<!DOCTYPE html>
    <!-- Version: 2024-01-27-Terrain-Update-v1.8-Build-Points-System -->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashes of the Covenant - Enhanced Strategic Dice Combat</title>
  <!-- Socket.IO Client Library -->
  <script src="/socket.io/socket.io.js"></script>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    
    /* Debug: visually highlight all grid zones */
    .zone {
      outline: 2px solid lime !important;
    }
    
    /* --- ZONE BATTLE SCREEN CURSOR FIXES --- */
    .zone,
    .zone *,
    .army-unit-card,
    .army-unit-card *,
    .army-selector,
    .army-selector *,
    .rename-zone,
    .rename-zone *,
    .battlefield,
    .battlefield *,
    .battlefield-section,
    .battlefield-section *,
    .army-selection-container,
    .army-selection-container *,
    .army-pool-container,
    .army-pool-container *,
    .artillery-panel,
    .artillery-panel *,
    .aerial-panel,
    .aerial-panel *,
    .bottom-panel,
    .bottom-panel *,
    .canvas-cursor,
    .canvas-cursor *,
    .mini-battlefield,
    .mini-battlefield *,
    .volume-slider,
    .volume-slider *,
    .grid-8,
    .grid-8 *,
    .grid-6,
    .grid-6 *,
    .grid-4,
    .grid-4 *,
    .grid-2,
    .grid-2 *,
    .deployment-grid,
    .deployment-grid *,
    .construction-grid,
    .construction-grid *,
    #mini-battlefield,
    #mini-battlefield *,
    .mini-battlefield.grid-8,
    .mini-battlefield.grid-8 *,
    .mini-battlefield.grid-6,
    .mini-battlefield.grid-6 *,
    .mini-battlefield.grid-4,
    .mini-battlefield.grid-4 *,
    .mini-battlefield.grid-2,
    .mini-battlefield.grid-2 * {
      cursor: none !important;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Cinzel', serif;
      overflow-x: hidden;
      overflow-y: auto;
      cursor: none;
      background: #000;
      min-height: 100vh;
      width: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    .screen {
      display: none;
      width: 100%;
      min-height: 100vh;
      position: relative;
      z-index: 1000;
      padding: 20px;
    }
    
   #summary { background: #000; /* display handled by .screen/.active; do not force visible */ align-items: flex-start; justify-content: center; }
    
    /* Player color custom properties */
    :root {
      --player1-color: #DC143C;
      --player2-color: #4169E1;
      --player1-color-rgb: 220, 20, 60;
      --player2-color-rgb: 65, 105, 225;
      --player-color: #DC143C;
      --enemy-color: #4169E1;
      --player-color-rgb: 220, 20, 60;
      --enemy-color-rgb: 65, 105, 225;
    }
    
    .screen.active {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Screen transition animations */
    .screen.fade-out {
      opacity: 0;
      transform: translateY(-20px);
    }
    
    .screen.fade-in {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Screen header styling */
    .screen-header {
      display: flex;
      align-items: center;
      margin-bottom: 30px;
      padding: 20px 0;
      border-bottom: 2px solid rgba(255,255,255,0.2);
    }
    
    .screen-header.center-header {
      justify-content: center;
    }
    
    /* Setup header styling */
    .setup-header {
      text-align: center;
      padding: 40px 20px;
      position: relative;
      z-index: 10;
      margin-bottom: 40px;
    }
    
    .setup-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 3rem;
      color: #cc2222;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, 
          #cc2222 0%, 
          #990000 50%, 
          #aa1111 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: titleEnergyPulse 4s ease-in-out infinite;
      margin-bottom: 10px;
      position: relative;
      z-index: 5;
    }
    
    .setup-title::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, 
          #cc2222 0%, 
          #990000 50%, 
          #aa1111 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: blur(4px);
      opacity: 0.3;
      z-index: -1;
    }
    
    .setup-subtitle {
      font-size: 1.2rem;
      color: #996666;
      letter-spacing: 1px;
      opacity: 0.9;
    }
    
    /* Demonic Background Symbols */
    .demonic-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
      overflow: hidden;
    }
    
    .demonic-star {
      position: absolute;
      width: 60px;
      height: 60px;
      background: 
          radial-gradient(circle at 50% 50%, 
              rgba(139, 0, 0, 0.8) 0%, 
              rgba(139, 0, 0, 0.4) 40%, 
              transparent 70%
          );
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: demonicPulse 4s ease-in-out infinite;
      opacity: 0.3;
      filter: drop-shadow(0 0 8px rgba(139, 0, 0, 0.6));
    }
    
    .demonic-star:nth-child(1) {
      top: 10%;
      left: 15%;
      animation-delay: 0s;
      transform: scale(0.8);
    }
    
    .demonic-star:nth-child(2) {
      top: 25%;
      right: 20%;
      animation-delay: 1s;
      transform: scale(1.2);
    }
    
    .demonic-star:nth-child(3) {
      bottom: 30%;
      left: 10%;
      animation-delay: 2s;
      transform: scale(0.6);
    }
    
    .demonic-star:nth-child(4) {
      bottom: 15%;
      right: 15%;
      animation-delay: 3s;
      transform: scale(1.1);
    }
    
    .demonic-star:nth-child(5) {
      top: 50%;
      left: 5%;
      animation-delay: 0.5s;
      transform: scale(0.9);
    }
    
    .demonic-star:nth-child(6) {
      top: 60%;
      right: 5%;
      animation-delay: 1.5s;
      transform: scale(0.7);
    }
    
    .demonic-pentagram {
      position: absolute;
      width: 80px;
      height: 80px;
      background: 
          radial-gradient(circle at 50% 50%, 
              rgba(139, 0, 0, 0.6) 0%, 
              rgba(139, 0, 0, 0.3) 50%, 
              transparent 80%
          );
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: demonicRotate 8s linear infinite;
      opacity: 0.2;
    }
    
    .demonic-pentagram:nth-child(7) {
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .demonic-pentagram:nth-child(8) {
      bottom: 25%;
      left: 50%;
      transform: translateX(-50%);
      animation-direction: reverse;
    }
    
    .demonic-circle {
      position: absolute;
      width: 100px;
      height: 100px;
      border: 2px solid rgba(139, 0, 0, 0.4);
      border-radius: 50%;
      animation: demonicGlow 6s ease-in-out infinite;
      opacity: 0.15;
    }
    
    .demonic-circle:nth-child(9) {
      top: 35%;
      right: 10%;
      animation-delay: 2s;
    }
    
    .demonic-circle:nth-child(10) {
      bottom: 40%;
      left: 20%;
      animation-delay: 4s;
    }
    
    .demonic-rune {
      position: absolute;
      width: 40px;
      height: 40px;
      background: 
          radial-gradient(circle at 50% 50%, 
              rgba(139, 0, 0, 0.7) 0%, 
              rgba(139, 0, 0, 0.3) 50%, 
              transparent 80%
          );
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
      animation: demonicFloat 6s ease-in-out infinite;
      opacity: 0.2;
      filter: drop-shadow(0 0 6px rgba(139, 0, 0, 0.5));
    }
    
    .demonic-rune:nth-child(11) {
      top: 15%;
      left: 25%;
      animation-delay: 1s;
      transform: scale(0.8);
    }
    
    .demonic-rune:nth-child(12) {
      top: 70%;
      right: 25%;
      animation-delay: 3s;
      transform: scale(1.1);
    }
    
    .demonic-rune:nth-child(13) {
      bottom: 20%;
      left: 35%;
      animation-delay: 2s;
      transform: scale(0.9);
    }
    
    .demonic-rune:nth-child(14) {
      top: 40%;
      right: 35%;
      animation-delay: 4s;
      transform: scale(0.7);
    }
    
    .demonic-eye {
      position: absolute;
      width: 50px;
      height: 30px;
      background: 
          radial-gradient(ellipse at 50% 50%, 
              rgba(139, 0, 0, 0.8) 0%, 
              rgba(139, 0, 0, 0.4) 60%, 
              transparent 100%
          );
      border-radius: 50%;
      animation: demonicBlink 8s ease-in-out infinite;
      opacity: 0.25;
      filter: drop-shadow(0 0 10px rgba(139, 0, 0, 0.6));
    }
    
    .demonic-eye:nth-child(15) {
      top: 30%;
      left: 8%;
      animation-delay: 0s;
    }
    
    .demonic-eye:nth-child(16) {
      bottom: 35%;
      right: 8%;
      animation-delay: 4s;
    }
    
    .demonic-eye:nth-child(17) {
      top: 80%;
      left: 45%;
      animation-delay: 2s;
    }
    
    .demonic-eye:nth-child(18) {
      top: 10%;
      right: 45%;
      animation-delay: 6s;
    }
    
    .demonic-triangle {
      position: absolute;
      width: 70px;
      height: 70px;
      background: 
          radial-gradient(circle at 50% 50%, 
              rgba(139, 0, 0, 0.6) 0%, 
              rgba(139, 0, 0, 0.2) 50%, 
              transparent 80%
          );
      clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
      animation: demonicRotate 10s linear infinite;
      opacity: 0.15;
      filter: drop-shadow(0 0 8px rgba(139, 0, 0, 0.4));
    }
    
    .demonic-triangle:nth-child(19) {
      top: 25%;
      left: 60%;
      animation-delay: 1s;
    }
    
    .demonic-triangle:nth-child(20) {
      bottom: 25%;
      right: 60%;
      animation-delay: 5s;
      animation-direction: reverse;
    }
    
    @keyframes demonicPulse {
      0%, 100% { 
        opacity: 0.3; 
        transform: scale(1) rotate(0deg);
        filter: drop-shadow(0 0 10px rgba(139, 0, 0, 0.5)) brightness(1);
      }
      50% { 
        opacity: 0.7; 
        transform: scale(1.2) rotate(180deg);
        filter: drop-shadow(0 0 25px rgba(139, 0, 0, 0.9)) brightness(1.3);
      }
    }
    
    @keyframes demonicRotate {
      0% { 
        transform: rotate(0deg) scale(1);
        opacity: 0.2;
      }
      50% { 
        transform: rotate(180deg) scale(1.1);
        opacity: 0.4;
      }
      100% { 
        transform: rotate(360deg) scale(1);
        opacity: 0.2;
      }
    }
    
    @keyframes demonicGlow {
      0%, 100% { 
        opacity: 0.15;
        box-shadow: 0 0 20px rgba(139, 0, 0, 0.3);
        border-color: rgba(139, 0, 0, 0.4);
      }
      50% { 
        opacity: 0.3;
        box-shadow: 0 0 40px rgba(139, 0, 0, 0.6);
        border-color: rgba(139, 0, 0, 0.7);
      }
    }
    
    @keyframes demonicFloat {
      0%, 100% { 
        opacity: 0.2;
        transform: translateY(0px) scale(1);
        filter: drop-shadow(0 0 6px rgba(139, 0, 0, 0.5));
      }
      50% { 
        opacity: 0.4;
        transform: translateY(-10px) scale(1.1);
        filter: drop-shadow(0 0 12px rgba(139, 0, 0, 0.7));
      }
    }
    
    @keyframes demonicBlink {
      0%, 90%, 100% { 
        opacity: 0.25;
        transform: scale(1);
        filter: drop-shadow(0 0 10px rgba(139, 0, 0, 0.6));
      }
      5%, 85% { 
        opacity: 0.5;
        transform: scale(1.2);
        filter: drop-shadow(0 0 15px rgba(139, 0, 0, 0.8));
      }
    }
    
    /* Custom Dropdown Styling */
    .custom-dropdown {
      position: relative;
      width: 100%;
      background: 
          linear-gradient(135deg, 
              rgba(40, 30, 50, 0.95) 0%, 
              rgba(30, 20, 40, 0.98) 50%, 
              rgba(35, 25, 45, 0.95) 100%
          );
      border: 1px solid rgba(80, 60, 100, 0.8);
      border-radius: 6px;
      cursor: none;
      transition: all 0.3s ease;
      box-shadow: 
          0 3px 10px rgba(0, 0, 0, 0.6),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(4px);
      z-index: 999998;
    }
    
    .custom-dropdown.open {
      z-index: 999999;
    }
    
    .dropdown-selected {
      padding: 12px 15px;
      color: #cc6666;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
    }
    
    .dropdown-arrow {
      color: #cc4444;
      font-size: 1.2rem;
      transition: transform 0.3s ease;
    }
    
    .custom-dropdown.open .dropdown-arrow {
      transform: rotate(180deg);
    }
    
    .dropdown-options {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: 
          linear-gradient(135deg, 
              rgba(25, 20, 30, 0.98) 0%, 
              rgba(20, 15, 25, 0.99) 50%, 
              rgba(15, 10, 20, 1) 100%
          );
      border: 1px solid rgba(80, 60, 100, 0.8);
      border-top: none;
      border-radius: 0 0 6px 6px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 999999;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s ease;
      box-shadow: 
          0 6px 20px rgba(0, 0, 0, 0.8),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(4px);
      /* Ensure dropdown can overflow parent containers */
      overflow: visible;
      max-width: 100vw;
    }
    
    .custom-dropdown.open .dropdown-options {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    .dropdown-option {
      padding: 10px 15px;
      color: #cc6666;
      font-family: 'Cinzel', serif;
      font-size: 0.95rem;
      cursor: none;
      transition: all 0.2s ease;
      border-bottom: 1px solid rgba(80, 60, 100, 0.3);
    }
    
    .dropdown-option:last-child {
      border-bottom: none;
    }
    
    .dropdown-option:hover {
      background: rgba(204, 68, 68, 0.1);
      color: #cc4444;
    }
    
    .dropdown-option.selected {
      background: rgba(204, 68, 68, 0.2);
      color: #cc2222;
      font-weight: 600;
    }
    
    .custom-dropdown:hover {
      border-color: rgba(204, 68, 68, 0.9);
      box-shadow: 
          0 0 20px rgba(204, 68, 68, 0.4),
          0 3px 10px rgba(0, 0, 0, 0.8),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    /* Specific styles for Unit Creator dropdowns to prevent conflicts */
    #unit-creator .custom-dropdown .dropdown-options {
      z-index: 999999 !important;
      background: 
          linear-gradient(135deg, 
              rgba(25, 20, 30, 0.98) 0%, 
              rgba(20, 15, 25, 0.99) 50%, 
              rgba(15, 10, 20, 1) 100%
          ) !important;
      border: 1px solid rgba(80, 60, 100, 0.8) !important;
      color: #cc6666 !important;
      /* Override the conflicting CSS rules */
      opacity: 0 !important;
      visibility: hidden !important;
      transform: translateY(-10px) !important;
    }
    
    #unit-creator .custom-dropdown.open .dropdown-options {
      opacity: 1 !important;
      visibility: visible !important;
      transform: translateY(0) !important;
      /* Ensure these properties are not overridden */
      display: block !important;
      pointer-events: auto !important;
    }
    
    #unit-creator .custom-dropdown .dropdown-option {
      color: #cc6666 !important;
      background: transparent !important;
    }
    
    #unit-creator .custom-dropdown .dropdown-option:hover {
      background: rgba(204, 68, 68, 0.1) !important;
      color: #cc4444 !important;
    }
    
    #unit-creator .custom-dropdown .dropdown-option.selected {
      background: rgba(204, 68, 68, 0.2) !important;
      color: #cc2222 !important;
    }
    
    .back-button {
      background: 
          linear-gradient(135deg, 
              rgba(40, 30, 50, 0.95) 0%, 
              rgba(30, 20, 40, 0.98) 50%, 
              rgba(35, 25, 45, 0.95) 100%
          );
      border: 1px solid rgba(100, 70, 120, 0.8);
      color: #cc4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: crosshair;
      margin-right: 20px;
      transition: all 0.3s ease;
      box-shadow: 
          0 3px 10px rgba(0, 0, 0, 0.6),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(4px);
    }
    
    .back-button:hover {
      background: 
          linear-gradient(135deg, 
              rgba(60, 45, 55, 0.98) 0%, 
              rgba(50, 35, 45, 1) 50%, 
              rgba(65, 50, 60, 0.98) 100%
          );
      color: #cc2222;
      border-color: rgba(204, 68, 68, 0.9);
      transform: translateX(-5px);
      box-shadow: 
          0 6px 20px rgba(200, 0, 0, 0.3),
          0 0 25px rgba(204, 68, 68, 0.25);
    }
    
    .screen-header h1 {
      margin: 0;
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 3rem;
      color: #cc2222;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, 
          #cc2222 0%, 
          #990000 50%, 
          #aa1111 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 12px rgba(204, 34, 34, 0.8));
      animation: titleEnergyPulse 4s ease-in-out infinite;
    }
    
    /* Dice Animation Overlay */
    .dice-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(10px);
    }
    
    /* 3D Dice Interface Styles */
    .dice-interface {
      background: 
        linear-gradient(135deg, 
          rgba(35, 35, 40, 0.95) 0%, 
          rgba(25, 25, 30, 0.97) 50%, 
          rgba(20, 20, 25, 0.98) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="metalTexture"><feTurbulence baseFrequency="0.8" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.03 0.08 0.12 0.01"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23metalTexture)" opacity="0.4"/></svg>');
      border: 2px solid rgba(110, 110, 120, 0.8);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(12px) saturate(1.3);
      box-shadow: 
        0 0 50px rgba(255, 0, 0, 0.15),
        0 0 100px rgba(0, 0, 0, 0.6),
        inset 0 2px 0 rgba(255, 255, 255, 0.1),
        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
      position: relative;
      text-align: center;
      min-width: 450px;
      max-width: 550px;
    }
    
    .dice-interface::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
        transparent 25%, 
        rgba(255, 0, 0, 0.1) 50%, 
        transparent 75%
      );
      border-radius: 15px;
      z-index: -1;
      animation: borderPulse 8s linear infinite;
    }
    
    .dice-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2.2rem;
      color: #ff4444;
      margin-bottom: 30px;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ff4444 0%, #cc0000 50%, #ff6666 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 10px rgba(255, 68, 68, 0.6));
      animation: titlePulse 4s ease-in-out infinite;
    }
    
    .dual-dice-arena {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 0 auto 20px;
      position: relative;
      width: 100%;
      max-width: 450px;
    }
    
    .dice-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    
    .dice-label {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      color: #ff6666;
      margin-bottom: 15px;
      text-shadow: 0 0 8px rgba(255, 102, 102, 0.6);
      letter-spacing: 1px;
    }
    
    .dice-display {
      position: relative;
      width: 120px;
      height: 120px;
      perspective: 1000px;
    }
    
    .dice-cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out;
    }
    
    .dice-face {
      position: absolute;
      width: 120px;
      height: 120px;
      background: 
        linear-gradient(135deg, 
          rgba(60, 40, 40, 0.95) 0%, 
          rgba(40, 25, 25, 0.98) 50%, 
          rgba(50, 30, 30, 0.95) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%232a1a1a" opacity="0.6"/><circle cx="20" cy="20" r="1" fill="%23444" opacity="0.4"/><circle cx="80" cy="30" r="1.5" fill="%23555" opacity="0.3"/><circle cx="60" cy="80" r="1" fill="%23666" opacity="0.4"/></svg>');
      border: 2px solid rgba(120, 80, 80, 0.8);
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(255, 0, 0, 0.2);
    }
    
    .dice-face.front { transform: rotateY(0deg) translateZ(60px); }
    .dice-face.back { transform: rotateY(180deg) translateZ(60px); }
    .dice-face.right { transform: rotateY(90deg) translateZ(60px); }
    .dice-face.left { transform: rotateY(-90deg) translateZ(60px); }
    .dice-face.top { transform: rotateX(90deg) translateZ(60px); }
    .dice-face.bottom { transform: rotateX(-90deg) translateZ(60px); }
    
    /* Dice face visibility classes */
    .dice-cube.show-face-1 .dice-face { visibility: hidden; }
    .dice-cube.show-face-1 .dice-face.front { visibility: visible; }
    
    .dice-cube.show-face-2 .dice-face { visibility: hidden; }
    .dice-cube.show-face-2 .dice-face.back { visibility: visible; }
    
    .dice-cube.show-face-3 .dice-face { visibility: hidden; }
    .dice-cube.show-face-3 .dice-face.right { visibility: visible; }
    
    .dice-cube.show-face-4 .dice-face { visibility: hidden; }
    .dice-cube.show-face-4 .dice-face.left { visibility: visible; }
    
    .dice-cube.show-face-5 .dice-face { visibility: hidden; }
    .dice-cube.show-face-5 .dice-face.top { visibility: visible; }
    
    .dice-cube.show-face-6 .dice-face { visibility: hidden; }
    .dice-cube.show-face-6 .dice-face.bottom { visibility: visible; }
    
    /* During rolling, show all faces */
    .dice-cube.rolling .dice-face { visibility: visible !important; }
    
    .dice-dot {
      width: 12px;
      height: 12px;
      background: 
        radial-gradient(circle, #ff4444 0%, #cc0000 70%);
      border-radius: 50%;
      box-shadow: 
        0 0 6px rgba(255, 68, 68, 0.8),
        inset 0 1px 2px rgba(255, 255, 255, 0.2);
      filter: drop-shadow(0 0 3px rgba(255, 68, 68, 0.6));
    }
    
    .vs-divider {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 1.2rem;
      color: #ff4444;
      text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(255, 68, 68, 0.6);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: vsGlow 2s ease-in-out infinite alternate;
      z-index: 10;
    }
    

    
    .battle-results {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
    }
    
    .dice-result {
      font-size: 1.4rem;
      color: #ff6666;
      text-shadow: 0 0 10px rgba(255, 102, 102, 0.7);
      min-width: 80px;
      text-align: center;
    }
    
    .winner-announcement {
      font-size: 1.1rem;
      color: #ffff44;
      text-shadow: 0 0 15px rgba(255, 255, 68, 0.8);
      font-weight: 900;
      text-align: center;
      margin: 0 20px;
      min-height: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .bonus-section {
      background: 
        linear-gradient(135deg, 
          rgba(25, 25, 30, 0.9) 0%, 
          rgba(20, 20, 25, 0.95) 100%
        );
      border: 1px solid rgba(255, 68, 68, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .bonus-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.1rem;
      color: #ffaa44;
      margin-bottom: 15px;
      text-align: center;
      text-shadow: 0 0 8px rgba(255, 170, 68, 0.6);
    }
    
    .bonus-controls {
      display: flex;
      justify-content: space-between;
      gap: 15px;
    }
    
    .bonus-group {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .bonus-label {
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      color: #cc9999;
      margin-bottom: 8px;
      text-align: center;
    }
    
    .bonus-value {
      background: rgba(40, 25, 25, 0.8);
      border: 1px solid rgba(255, 68, 68, 0.4);
      border-radius: 5px;
      color: #ff9999;
      font-family: 'Orbitron', monospace;
      font-size: 1rem;
      font-weight: 600;
      text-align: center;
      padding: 8px 12px;
      width: 80px;
      transition: all 0.3s ease;
    }
    
    .winner {
      animation: victoryGlow 1.5s ease-in-out 3;
    }
    
    .loser {
      opacity: 0.6;
      filter: grayscale(50%);
    }
    
    .rolling {
      animation: dualDiceRoll 2.5s ease-out forwards;
    }
    
    .rolling.left-dice {
      animation: leftDiceRoll 2.5s ease-out forwards;
    }
    
    .rolling.right-dice {
      animation: rightDiceRoll 2.5s ease-out forwards;
    }
    
    /* Dice Face Layouts */
    .dice-face.face-1 {
      justify-content: center;
      align-items: center;
    }
    
    .dice-face.face-2 {
      justify-content: space-between;
      align-items: stretch;
    }
    .dice-face.face-2 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .dice-face.face-2 .dice-dot:nth-child(2) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .dice-face.face-3 {
      justify-content: space-between;
      align-items: stretch;
    }
    .dice-face.face-3 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .dice-face.face-3 .dice-dot:nth-child(2) { 
      align-self: center;
      margin: auto;
    }
    .dice-face.face-3 .dice-dot:nth-child(3) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .dice-face.face-4 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .dice-face.face-4 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .dice-face.face-4 .dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .dice-face.face-4 .dice-dot:nth-child(3) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .dice-face.face-4 .dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .dice-face.face-5 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .dice-face.face-5 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .dice-face.face-5 .dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .dice-face.face-5 .dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: center;
      margin: auto;
    }
    .dice-face.face-5 .dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .dice-face.face-5 .dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .dice-face.face-6 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .dice-face.face-6 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .dice-face.face-6 .dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .dice-face.face-6 .dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: flex-start;
      margin-right: auto;
    }
    .dice-face.face-6 .dice-dot:nth-child(4) { 
      align-self: center;
      justify-self: flex-end;
      margin-left: auto;
    }
    .dice-face.face-6 .dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .dice-face.face-6 .dice-dot:nth-child(6) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    /* Animations */
    @keyframes borderPulse {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes titlePulse {
      0%, 100% { 
        filter: drop-shadow(0 0 10px rgba(255, 68, 68, 0.6)); 
        transform: scale(1);
      }
      50% { 
        filter: drop-shadow(0 0 20px rgba(255, 68, 68, 0.9)); 
        transform: scale(1.02);
      }
    }
    
    @keyframes vsGlow {
      0% { 
        box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        border-color: rgba(255, 68, 68, 0.6);
      }
      100% { 
        box-shadow: 0 0 40px rgba(255, 68, 68, 1);
        border-color: rgba(255, 68, 68, 1);
      }
    }
    
    @keyframes leftDiceRoll {
      0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) translateX(0); }
      25% { transform: rotateX(180deg) rotateY(180deg) rotateZ(90deg) scale(1.1) translateX(-10px); }
      50% { transform: rotateX(360deg) rotateY(360deg) rotateZ(180deg) scale(0.9) translateX(-5px); }
      75% { transform: rotateX(540deg) rotateY(540deg) rotateZ(270deg) scale(1.05) translateX(-15px); }
      100% { transform: rotateX(720deg) rotateY(720deg) rotateZ(360deg) scale(1) translateX(0); }
    }
    
    @keyframes rightDiceRoll {
      0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) translateX(0); }
      25% { transform: rotateX(-180deg) rotateY(-180deg) rotateZ(-90deg) scale(1.1) translateX(10px); }
      50% { transform: rotateX(-360deg) rotateY(-360deg) rotateZ(-180deg) scale(0.9) translateX(5px); }
      75% { transform: rotateX(-540deg) rotateY(-540deg) rotateZ(-270deg) scale(1.05) translateX(15px); }
      100% { transform: rotateX(-720deg) rotateY(-720deg) rotateZ(-360deg) scale(1) translateX(0); }
    }
    
    @keyframes victoryGlow {
      0%, 100% { 
        transform: scale(1);
        filter: brightness(1) drop-shadow(0 0 10px rgba(255, 255, 68, 0.6));
      }
      50% { 
        transform: scale(1.05);
        filter: brightness(1.2) drop-shadow(0 0 25px rgba(255, 255, 68, 1));
      }
    }
    
    .dice-click-prompt {
      font-size: 16px;
      color: #FFD700;
      margin-top: 20px;
      animation: pulse 2s infinite;
      cursor: pointer;
      padding: 10px 20px;
      border: 2px solid #FFD700;
      border-radius: 10px;
      background: rgba(255, 215, 0, 0.1);
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .dice-interface {
        padding: 25px 20px;
        min-width: 300px;
      }
      
      .dice-title {
        font-size: 1.6rem;
      }
      
      .dual-dice-arena {
        max-width: 280px;
      }
      
      .dice-display {
        width: 90px;
        height: 90px;
      }
      
      .dice-face {
        width: 90px;
        height: 90px;
        padding: 12px;
      }
      
      .dice-cube .dice-face.front { transform: rotateY(0deg) translateZ(45px); }
      .dice-cube .dice-face.back { transform: rotateY(180deg) translateZ(45px); }
      .dice-cube .dice-face.right { transform: rotateY(90deg) translateZ(45px); }
      .dice-cube .dice-face.left { transform: rotateY(-90deg) translateZ(45px); }
      .dice-cube .dice-face.top { transform: rotateX(90deg) translateZ(45px); }
      .dice-cube .dice-face.bottom { transform: rotateX(-90deg) translateZ(45px); }
      
      .vs-divider {
        width: 35px;
        height: 35px;
        font-size: 0.9rem;
      }
      
      .dice-result {
        font-size: 1.1rem;
      }
      
      .winner-announcement {
        font-size: 0.8rem;
        margin: 0 8px;
      }
      
      .bonus-controls {
        flex-direction: column;
        gap: 8px;
      }
      
      .bonus-value {
        width: 50px;
      }
      
      /* Morale interface responsive */
      .morale-interface {
        padding: 20px 15px;
        min-width: 280px;
      }
      
      .morale-title {
        font-size: 1.4rem;
      }
      
      .morale-dice-display {
        width: 90px;
        height: 90px;
      }
      
      .morale-dice-face {
        width: 90px;
        height: 90px;
        padding: 12px;
      }
      
      .morale-dice-cube .morale-dice-face.front { transform: rotateY(0deg) translateZ(45px); }
      .morale-dice-cube .morale-dice-face.back { transform: rotateY(180deg) translateZ(45px); }
      .morale-dice-cube .morale-dice-face.right { transform: rotateY(90deg) translateZ(45px); }
      .morale-dice-cube .morale-dice-face.left { transform: rotateY(-90deg) translateZ(45px); }
      .morale-dice-cube .morale-dice-face.top { transform: rotateX(90deg) translateZ(45px); }
      .morale-dice-cube .morale-dice-face.bottom { transform: rotateX(-90deg) translateZ(45px); }
      
      .morale-dice-dot {
        width: 10px;
        height: 10px;
      }
      
      .morale-result {
        font-size: 1rem;
      }
      
      .morale-target {
        font-size: 0.9rem;
      }
    }
    
    @keyframes pulse {
      0% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
      100% { opacity: 0.6; transform: scale(1); }
    }
    
    /* Morale Check Animation */
    .morale-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      backdrop-filter: blur(10px);
      pointer-events: auto;
    }
    
    .morale-interface {
      background: 
        linear-gradient(135deg, 
          rgba(35, 35, 40, 0.95) 0%, 
          rgba(25, 25, 30, 0.97) 50%, 
          rgba(20, 20, 25, 0.98) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="metalTexture"><feTurbulence baseFrequency="0.8" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.03 0.08 0.12 0.01"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23metalTexture)" opacity="0.4"/></svg>');
      border: 2px solid rgba(50, 205, 50, 0.8);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(12px) saturate(1.3);
      box-shadow: 
        0 0 50px rgba(50, 205, 50, 0.15),
        0 0 100px rgba(0, 0, 0, 0.6),
        inset 0 2px 0 rgba(255, 255, 255, 0.1),
        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
      position: relative;
      text-align: center;
      min-width: 400px;
      max-width: 500px;
      z-index: 10001;
    }
    
    .morale-interface::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
        transparent 25%, 
        rgba(50, 205, 50, 0.1) 50%, 
        transparent 75%
      );
      border-radius: 15px;
      z-index: -1;
      animation: borderPulse 8s linear infinite;
    }
    
    .morale-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2rem;
      color: #32CD32;
      margin-bottom: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #32CD32 0%, #228B22 50%, #32CD32 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 10px rgba(50, 205, 50, 0.6));
      animation: titlePulse 4s ease-in-out infinite;
    }
    
    .morale-unit-info {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #90EE90;
      margin-bottom: 25px;
      text-shadow: 0 0 8px rgba(144, 238, 144, 0.6);
      letter-spacing: 1px;
    }
    
    .morale-dice-arena {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 auto 25px;
      position: relative;
      width: 100%;
      max-width: 300px;
    }
    
    .morale-dice-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    
    .morale-dice-label {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      color: #90EE90;
      margin-bottom: 15px;
      text-shadow: 0 0 8px rgba(144, 238, 144, 0.6);
      letter-spacing: 1px;
    }
    
    .morale-dice-display {
      position: relative;
      width: 120px;
      height: 120px;
      perspective: 1000px;
    }
    
    .morale-dice-cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out;
    }
    
    .morale-dice-face {
      position: absolute;
      width: 120px;
      height: 120px;
      background: 
        linear-gradient(135deg, 
          rgba(40, 60, 40, 0.95) 0%, 
          rgba(25, 40, 25, 0.98) 50%, 
          rgba(30, 50, 30, 0.95) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%232a4a2a" opacity="0.6"/><circle cx="20" cy="20" r="1" fill="%23444" opacity="0.4"/><circle cx="80" cy="30" r="1.5" fill="%23555" opacity="0.3"/><circle cx="60" cy="80" r="1" fill="%23666" opacity="0.4"/></svg>');
      border: 2px solid rgba(50, 205, 50, 0.8);
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(50, 205, 50, 0.2);
    }
    
    .morale-dice-face.front { transform: rotateY(0deg) translateZ(60px); }
    .morale-dice-face.back { transform: rotateY(180deg) translateZ(60px); }
    .morale-dice-face.right { transform: rotateY(90deg) translateZ(60px); }
    .morale-dice-face.left { transform: rotateY(-90deg) translateZ(60px); }
    .morale-dice-face.top { transform: rotateX(90deg) translateZ(60px); }
    .morale-dice-face.bottom { transform: rotateX(-90deg) translateZ(60px); }
    
    /* Morale dice face visibility classes */
    .morale-dice-cube.show-face-1 .morale-dice-face { visibility: hidden; }
    .morale-dice-cube.show-face-1 .morale-dice-face.front { visibility: visible; }
    
    .morale-dice-cube.show-face-2 .morale-dice-face { visibility: hidden; }
    .morale-dice-cube.show-face-2 .morale-dice-face.back { visibility: visible; }
    
    .morale-dice-cube.show-face-3 .morale-dice-face { visibility: hidden; }
    .morale-dice-cube.show-face-3 .morale-dice-face.right { visibility: visible; }
    
    .morale-dice-cube.show-face-4 .morale-dice-face { visibility: hidden; }
    .morale-dice-cube.show-face-4 .morale-dice-face.left { visibility: visible; }
    
    .morale-dice-cube.show-face-5 .morale-dice-face { visibility: hidden; }
    .morale-dice-cube.show-face-5 .morale-dice-face.top { visibility: visible; }
    
    .morale-dice-cube.show-face-6 .morale-dice-face { visibility: hidden; }
    .morale-dice-cube.show-face-6 .morale-dice-face.bottom { visibility: visible; }
    
    /* During rolling, show all faces */
    .morale-dice-cube.rolling .morale-dice-face { visibility: visible !important; }
    
    .morale-dice-dot {
      width: 12px;
      height: 12px;
      background: 
        radial-gradient(circle, #32CD32 0%, #228B22 70%);
      border-radius: 50%;
      box-shadow: 
        0 0 6px rgba(50, 205, 50, 0.8),
        inset 0 1px 2px rgba(255, 255, 255, 0.2);
      filter: drop-shadow(0 0 3px rgba(50, 205, 50, 0.6));
    }
    
    .morale-results {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
    }
    
    .morale-result {
      font-size: 1.2rem;
      color: #90EE90;
      text-shadow: 0 0 10px rgba(144, 238, 144, 0.7);
      margin-bottom: 10px;
      min-height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .morale-target {
      font-size: 1rem;
      color: #FFD700;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
      font-weight: 600;
    }
    
    .morale-click-prompt {
      font-size: 16px;
      color: #FFD700;
      margin-top: 20px;
      animation: pulse 2s infinite;
      cursor: pointer;
      padding: 10px 20px;
      border: 2px solid #FFD700;
      border-radius: 10px;
      background: rgba(255, 215, 0, 0.1);
    }
    
    .morale-dice-cube.rolling {
      animation: moraleDiceRoll 2.5s ease-out forwards;
    }
    
    @keyframes moraleDiceRoll {
      0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) translateX(0); }
      25% { transform: rotateX(180deg) rotateY(180deg) rotateZ(90deg) scale(1.1) translateX(-10px); }
      50% { transform: rotateX(360deg) rotateY(360deg) rotateZ(180deg) scale(0.9) translateX(-5px); }
      75% { transform: rotateX(540deg) rotateY(540deg) rotateZ(270deg) scale(1.05) translateX(-15px); }
      100% { transform: rotateX(720deg) rotateY(720deg) rotateZ(360deg) scale(1) translateX(0); }
    }
    
    /* Morale Dice Face Layouts */
    .morale-dice-face.face-1 {
      justify-content: center;
      align-items: center;
    }
    
    .morale-dice-face.face-2 {
      justify-content: space-between;
      align-items: stretch;
    }
    .morale-dice-face.face-2 .morale-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .morale-dice-face.face-2 .morale-dice-dot:nth-child(2) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .morale-dice-face.face-3 {
      justify-content: space-between;
      align-items: stretch;
    }
    .morale-dice-face.face-3 .morale-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .morale-dice-face.face-3 .morale-dice-dot:nth-child(2) { 
      align-self: center;
      margin: auto;
    }
    .morale-dice-face.face-3 .morale-dice-dot:nth-child(3) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .morale-dice-face.face-4 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .morale-dice-face.face-4 .morale-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .morale-dice-face.face-4 .morale-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .morale-dice-face.face-4 .morale-dice-dot:nth-child(3) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .morale-dice-face.face-4 .morale-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .morale-dice-face.face-5 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .morale-dice-face.face-5 .morale-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .morale-dice-face.face-5 .morale-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .morale-dice-face.face-5 .morale-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: center;
      margin: auto;
    }
    .morale-dice-face.face-5 .morale-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .morale-dice-face.face-5 .morale-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .morale-dice-face.face-6 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .morale-dice-face.face-6 .morale-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .morale-dice-face.face-6 .morale-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .morale-dice-face.face-6 .morale-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: flex-start;
      margin-right: auto;
    }
    .morale-dice-face.face-6 .morale-dice-dot:nth-child(4) { 
      align-self: center;
      justify-self: flex-end;
      margin-left: auto;
    }
    .morale-dice-face.face-6 .morale-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .morale-dice-face.face-6 .morale-dice-dot:nth-child(6) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    /* Artillery Attack Animation */
    .artillery-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      backdrop-filter: blur(10px);
      pointer-events: auto;
    }
    
    .aerial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      backdrop-filter: blur(10px);
      pointer-events: auto;
    }
    
    .artillery-interface {
      background: 
        linear-gradient(135deg, 
          rgba(35, 35, 40, 0.95) 0%, 
          rgba(25, 25, 30, 0.97) 50%, 
          rgba(20, 20, 25, 0.98) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="metalTexture"><feTurbulence baseFrequency="0.8" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.03 0.08 0.12 0.01"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23metalTexture)" opacity="0.4"/></svg>');
      border: 2px solid rgba(255, 69, 0, 0.8);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(12px) saturate(1.3);
      box-shadow: 
        0 0 50px rgba(255, 69, 0, 0.15),
        0 0 100px rgba(0, 0, 0, 0.6),
        inset 0 2px 0 rgba(255, 255, 255, 0.1),
        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
      position: relative;
      text-align: center;
      min-width: 400px;
      max-width: 500px;
      z-index: 10001;
    }
    
    .artillery-interface::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
        transparent 25%, 
        rgba(255, 69, 0, 0.1) 50%, 
        transparent 75%
      );
      border-radius: 15px;
      z-index: -1;
      animation: borderPulse 8s linear infinite;
    }
    
    .artillery-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2rem;
      color: #FF4500;
      margin-bottom: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #FF4500 0%, #FF6347 50%, #FF4500 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 10px rgba(255, 69, 0, 0.6));
      animation: titlePulse 4s ease-in-out infinite;
    }
    
    .artillery-phase {
      margin-bottom: 30px;
      padding: 20px;
      border: 2px solid rgba(255, 69, 0, 0.3);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.3);
    }
    
    .artillery-phase-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.2rem;
      color: #FF4500;
      margin-bottom: 15px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(255, 69, 0, 0.6);
    }
    
    .artillery-phase:not(:last-child) {
      margin-bottom: 20px;
    }
    
    .aerial-title {
      font-size: 32px;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      color: #FF0000;
      font-weight: bold;
    }
    
    .aerial-container {
      background: 
        linear-gradient(135deg, 
          rgba(20, 20, 20, 0.95) 0%, 
          rgba(40, 40, 40, 0.97) 50%, 
          rgba(30, 30, 30, 0.98) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="darkTexture"><feTurbulence baseFrequency="0.8" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.03 0.08 0.12 0.01"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23darkTexture)" opacity="0.4"/></svg>');
      border: 2px solid rgba(255, 0, 0, 0.8);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(12px) saturate(1.3);
      box-shadow: 
        0 0 50px rgba(255, 0, 0, 0.15),
        0 0 100px rgba(0, 0, 0, 0.6),
        inset 0 2px 0 rgba(255, 255, 255, 0.1),
        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
      position: relative;
      text-align: center;
      min-width: 400px;
      max-width: 500px;
      z-index: 10001;
      color: white;
    }
    
    .aerial-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
        transparent 25%, 
        rgba(255, 0, 0, 0.1) 50%, 
        transparent 75%
      );
      border-radius: 15px;
      z-index: -1;
      animation: borderPulse 8s linear infinite;
    }
    
    .aerial-info {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #CCCCCC;
      margin-bottom: 25px;
      text-shadow: 0 0 8px rgba(204, 204, 204, 0.6);
      letter-spacing: 1px;
    }
    
    .aerial-target {
      font-family: 'Cinzel', serif;
      font-size: 1.2rem;
      color: #FF0000;
      margin-bottom: 20px;
      text-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
      letter-spacing: 1px;
      font-weight: bold;
    }
    
    .aerial-bonus {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      color: #FF6666;
      margin-bottom: 15px;
      text-shadow: 0 0 5px rgba(255, 102, 102, 0.6);
      letter-spacing: 1px;
    }
    
    .aerial-result {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #CCCCCC;
      margin-bottom: 25px;
      text-shadow: 0 0 8px rgba(204, 204, 204, 0.6);
      letter-spacing: 1px;
    }
    
    .aerial-click-prompt {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      color: #FF0000;
      cursor: pointer;
      padding: 10px 20px;
      border: 1px solid rgba(255, 0, 0, 0.5);
      border-radius: 5px;
      background: rgba(255, 0, 0, 0.1);
      transition: all 0.3s ease;
      text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
    }
    
    .aerial-click-prompt:hover {
      background: rgba(255, 0, 0, 0.2);
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    

    
    .artillery-info {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #FFA07A;
      margin-bottom: 25px;
      text-shadow: 0 0 8px rgba(255, 160, 122, 0.6);
      letter-spacing: 1px;
    }
    
    .artillery-dice-arena {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 auto 25px;
      position: relative;
      width: 100%;
      max-width: 300px;
    }
    
    .artillery-dice-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    
    .artillery-dice-label {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      color: #FFA07A;
      margin-bottom: 15px;
      text-shadow: 0 0 8px rgba(255, 160, 122, 0.6);
      letter-spacing: 1px;
    }
    
    .artillery-dice-display {
      position: relative;
      width: 120px;
      height: 120px;
      perspective: 1000px;
    }
    
    .artillery-dice-cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out;
    }
    
    /* Slot machine style for artillery hit chance */
    .artillery-slot-machine {
      width: 120px;
      height: 120px;
      background: 
        linear-gradient(135deg, 
          rgba(60, 40, 30, 0.95) 0%, 
          rgba(40, 25, 20, 0.98) 50%, 
          rgba(50, 30, 25, 0.95) 100%
        );
      border: 3px solid rgba(255, 69, 0, 0.8);
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(255, 69, 0, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    #artillery-target-tile {
      color: #FFD700;
      text-shadow: 0 0 10px #FFD700;
      font-weight: bold;
      font-size: 28px;
      margin-left: 10px;
    }
    
    .artillery-slot-machine.rolling {
      animation: slotMachineRoll 0.1s linear infinite;
    }
    
    .slot-number {
      font-size: 48px;
      font-weight: bold;
      color: #FF4500;
      text-shadow: 0 0 10px #FF4500, 2px 2px 4px #000;
      font-family: 'Courier New', monospace;
    }
    
    @keyframes slotMachineRoll {
      0% { transform: translateY(-10px); opacity: 0.7; }
      50% { transform: translateY(0px); opacity: 1; }
      100% { transform: translateY(10px); opacity: 0.7; }
    }
    
    .artillery-dice-face {
      position: absolute;
      width: 120px;
      height: 120px;
      background: 
        linear-gradient(135deg, 
          rgba(60, 40, 30, 0.95) 0%, 
          rgba(40, 25, 20, 0.98) 50%, 
          rgba(50, 30, 25, 0.95) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%232a1a15" opacity="0.6"/><circle cx="20" cy="20" r="1" fill="%23444" opacity="0.4"/><circle cx="80" cy="30" r="1.5" fill="%23555" opacity="0.3"/><circle cx="60" cy="80" r="1" fill="%23666" opacity="0.4"/></svg>');
      border: 2px solid rgba(255, 69, 0, 0.8);
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(255, 69, 0, 0.2);
    }
    
    .artillery-dice-face.front { transform: rotateY(0deg) translateZ(60px); }
    .artillery-dice-face.back { transform: rotateY(180deg) translateZ(60px); }
    .artillery-dice-face.right { transform: rotateY(90deg) translateZ(60px); }
    .artillery-dice-face.left { transform: rotateY(-90deg) translateZ(60px); }
    .artillery-dice-face.top { transform: rotateX(90deg) translateZ(60px); }
    .artillery-dice-face.bottom { transform: rotateX(-90deg) translateZ(60px); }
    
    /* Artillery dice face visibility classes */
    .artillery-dice-cube.show-face-1 .artillery-dice-face { visibility: hidden; }
    .artillery-dice-cube.show-face-1 .artillery-dice-face.front { visibility: visible; }
    
    .artillery-dice-cube.show-face-2 .artillery-dice-face { visibility: hidden; }
    .artillery-dice-cube.show-face-2 .artillery-dice-face.back { visibility: visible; }
    
    .artillery-dice-cube.show-face-3 .artillery-dice-face { visibility: hidden; }
    .artillery-dice-cube.show-face-3 .artillery-dice-face.right { visibility: visible; }
    
    .artillery-dice-cube.show-face-4 .artillery-dice-face { visibility: hidden; }
    .artillery-dice-cube.show-face-4 .artillery-dice-face.left { visibility: visible; }
    
    .artillery-dice-cube.show-face-5 .artillery-dice-face { visibility: hidden; }
    .artillery-dice-cube.show-face-5 .artillery-dice-face.top { visibility: visible; }
    
    .artillery-dice-cube.show-face-6 .artillery-dice-face { visibility: hidden; }
    .artillery-dice-cube.show-face-6 .artillery-dice-face.bottom { visibility: visible; }
    
    /* During rolling, show all faces */
    .artillery-dice-cube.rolling .artillery-dice-face { visibility: visible !important; }
    
    /* Gas Dice Styles */
    .gas-dice-display {
      position: relative;
      width: 120px;
      height: 120px;
      perspective: 1000px;
      margin: 20px auto;
    }
    
    .gas-dice-cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out;
    }
    
    .gas-dice-face {
      position: absolute;
      width: 120px;
      height: 120px;
      background: 
        linear-gradient(135deg, 
          rgba(40, 60, 40, 0.95) 0%, 
          rgba(25, 40, 25, 0.98) 50%, 
          rgba(30, 50, 30, 0.95) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%232a4a2a" opacity="0.6"/><circle cx="20" cy="20" r="1" fill="%23444" opacity="0.4"/><circle cx="80" cy="30" r="1.5" fill="%23555" opacity="0.3"/><circle cx="60" cy="80" r="1" fill="%23666" opacity="0.4"/></svg>');
      border: 2px solid rgba(0, 255, 0, 0.8);
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(0, 255, 0, 0.2);
    }
    
    .gas-dice-face.front { transform: rotateY(0deg) translateZ(60px); }
    .gas-dice-face.back { transform: rotateY(180deg) translateZ(60px); }
    .gas-dice-face.right { transform: rotateY(90deg) translateZ(60px); }
    .gas-dice-face.left { transform: rotateY(-90deg) translateZ(60px); }
    .gas-dice-face.top { transform: rotateX(90deg) translateZ(60px); }
    .gas-dice-face.bottom { transform: rotateX(-90deg) translateZ(60px); }
    
    .gas-dice-dot {
      width: 12px;
      height: 12px;
      background: 
        radial-gradient(circle, #00ff00 0%, #008000 70%);
      border-radius: 50%;
      box-shadow: 
        0 0 6px rgba(0, 255, 0, 0.8),
        inset 0 1px 2px rgba(255, 255, 255, 0.2);
      filter: drop-shadow(0 0 3px rgba(0, 255, 0, 0.6));
    }
    
    /* Gas dice face visibility classes */
    .gas-dice-cube.show-face-1 .gas-dice-face { visibility: hidden; }
    .gas-dice-cube.show-face-1 .gas-dice-face.front { visibility: visible; }
    
    .gas-dice-cube.show-face-2 .gas-dice-face { visibility: hidden; }
    .gas-dice-cube.show-face-2 .gas-dice-face.back { visibility: visible; }
    
    .gas-dice-cube.show-face-3 .gas-dice-face { visibility: hidden; }
    .gas-dice-cube.show-face-3 .gas-dice-face.right { visibility: visible; }
    
    .gas-dice-cube.show-face-4 .gas-dice-face { visibility: hidden; }
    .gas-dice-cube.show-face-4 .gas-dice-face.left { visibility: visible; }
    
    .gas-dice-cube.show-face-5 .gas-dice-face { visibility: hidden; }
    .gas-dice-cube.show-face-5 .gas-dice-face.top { visibility: visible; }
    
    .gas-dice-cube.show-face-6 .gas-dice-face { visibility: hidden; }
    .gas-dice-cube.show-face-6 .gas-dice-face.bottom { visibility: visible; }
    
    /* During rolling, show all faces */
    .gas-dice-cube.rolling .gas-dice-face { visibility: visible !important; }
    
    /* Gas Dice Face Layouts */
    .gas-dice-face.face-1 {
      justify-content: center;
      align-items: center;
    }
    
    .gas-dice-face.face-2 {
      justify-content: space-between;
      align-items: stretch;
    }
    .gas-dice-face.face-2 .gas-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .gas-dice-face.face-2 .gas-dice-dot:nth-child(2) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .gas-dice-face.face-3 {
      justify-content: space-between;
      align-items: stretch;
    }
    .gas-dice-face.face-3 .gas-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .gas-dice-face.face-3 .gas-dice-dot:nth-child(2) { 
      align-self: center;
      margin: auto;
    }
    .gas-dice-face.face-3 .gas-dice-dot:nth-child(3) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .gas-dice-face.face-4 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .gas-dice-face.face-4 .gas-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .gas-dice-face.face-4 .gas-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .gas-dice-face.face-4 .gas-dice-dot:nth-child(3) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .gas-dice-face.face-4 .gas-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .gas-dice-face.face-5 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .gas-dice-face.face-5 .gas-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .gas-dice-face.face-5 .gas-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .gas-dice-face.face-5 .gas-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: center;
      margin: auto;
    }
    .gas-dice-face.face-5 .gas-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .gas-dice-face.face-5 .gas-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .gas-dice-face.face-6 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .gas-dice-face.face-6 .gas-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .gas-dice-face.face-6 .gas-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .gas-dice-face.face-6 .gas-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: flex-start;
      margin-right: auto;
    }
    .gas-dice-face.face-6 .gas-dice-dot:nth-child(4) { 
      align-self: center;
      justify-self: flex-end;
      margin-left: auto;
    }
    .gas-dice-face.face-6 .gas-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .gas-dice-face.face-6 .gas-dice-dot:nth-child(6) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    /* Minefield Dice Styles */
    .minefield-dice-display {
      position: relative;
      width: 120px;
      height: 120px;
      perspective: 1000px;
      margin: 20px auto;
    }
    
    .minefield-dice-cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out;
    }
    
    .minefield-dice-face {
      position: absolute;
      width: 120px;
      height: 120px;
      background: 
        linear-gradient(135deg, 
          rgba(60, 60, 60, 0.95) 0%, 
          rgba(40, 40, 40, 0.98) 50%, 
          rgba(50, 50, 50, 0.95) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%233a3a3a" opacity="0.6"/><circle cx="20" cy="20" r="1" fill="%23444" opacity="0.4"/><circle cx="80" cy="30" r="1.5" fill="%23555" opacity="0.3"/><circle cx="60" cy="80" r="1" fill="%23666" opacity="0.4"/></svg>');
      border: 2px solid rgba(128, 128, 128, 0.8);
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(128, 128, 128, 0.2);
    }
    
    .minefield-dice-face.front { transform: rotateY(0deg) translateZ(60px); }
    .minefield-dice-face.back { transform: rotateY(180deg) translateZ(60px); }
    .minefield-dice-face.right { transform: rotateY(90deg) translateZ(60px); }
    .minefield-dice-face.left { transform: rotateY(-90deg) translateZ(60px); }
    .minefield-dice-face.top { transform: rotateX(90deg) translateZ(60px); }
    .minefield-dice-face.bottom { transform: rotateX(-90deg) translateZ(60px); }
    
    .minefield-dice-dot {
      width: 12px;
      height: 12px;
      background: 
        radial-gradient(circle, #808080 0%, #404040 70%);
      border-radius: 50%;
      box-shadow: 
        0 0 6px rgba(128, 128, 128, 0.8),
        inset 0 1px 2px rgba(255, 255, 255, 0.2);
      filter: drop-shadow(0 0 3px rgba(128, 128, 128, 0.6));
    }
    
    /* Minefield dice face visibility classes */
    .minefield-dice-cube.show-face-1 .minefield-dice-face { visibility: hidden; }
    .minefield-dice-cube.show-face-1 .minefield-dice-face.front { visibility: visible; }
    
    .minefield-dice-cube.show-face-2 .minefield-dice-face { visibility: hidden; }
    .minefield-dice-cube.show-face-2 .minefield-dice-face.back { visibility: visible; }
    
    .minefield-dice-cube.show-face-3 .minefield-dice-face { visibility: hidden; }
    .minefield-dice-cube.show-face-3 .minefield-dice-face.right { visibility: visible; }
    
    .minefield-dice-cube.show-face-4 .minefield-dice-face { visibility: hidden; }
    .minefield-dice-cube.show-face-4 .minefield-dice-face.left { visibility: visible; }
    
    .minefield-dice-cube.show-face-5 .minefield-dice-face { visibility: hidden; }
    .minefield-dice-cube.show-face-5 .minefield-dice-face.top { visibility: visible; }
    
    .minefield-dice-cube.show-face-6 .minefield-dice-face { visibility: hidden; }
    .minefield-dice-cube.show-face-6 .minefield-dice-face.bottom { visibility: visible; }
    
    /* During rolling, show all faces */
    .minefield-dice-cube.rolling .minefield-dice-face { visibility: visible !important; }
    
    /* Minefield Dice Face Layouts */
    .minefield-dice-face.face-1 {
      justify-content: center;
      align-items: center;
    }
    
    .minefield-dice-face.face-2 {
      justify-content: space-between;
      align-items: stretch;
    }
    .minefield-dice-face.face-2 .minefield-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .minefield-dice-face.face-2 .minefield-dice-dot:nth-child(2) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .minefield-dice-face.face-3 {
      justify-content: space-between;
      align-items: stretch;
    }
    .minefield-dice-face.face-3 .minefield-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .minefield-dice-face.face-3 .minefield-dice-dot:nth-child(2) { 
      align-self: center;
      margin: auto;
    }
    .minefield-dice-face.face-3 .minefield-dice-dot:nth-child(3) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .minefield-dice-face.face-4 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .minefield-dice-face.face-4 .minefield-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .minefield-dice-face.face-4 .minefield-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .minefield-dice-face.face-4 .minefield-dice-dot:nth-child(3) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .minefield-dice-face.face-4 .minefield-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .minefield-dice-face.face-5 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .minefield-dice-face.face-5 .minefield-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .minefield-dice-face.face-5 .minefield-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .minefield-dice-face.face-5 .minefield-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: center;
      margin: auto;
    }
    .minefield-dice-face.face-5 .minefield-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .minefield-dice-face.face-5 .minefield-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .minefield-dice-face.face-6 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .minefield-dice-face.face-6 .minefield-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .minefield-dice-face.face-6 .minefield-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .minefield-dice-face.face-6 .minefield-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: flex-start;
      margin-right: auto;
    }
    .minefield-dice-face.face-6 .minefield-dice-dot:nth-child(4) { 
      align-self: center;
      justify-self: flex-end;
      margin-left: auto;
    }
    .minefield-dice-face.face-6 .minefield-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .minefield-dice-face.face-6 .minefield-dice-dot:nth-child(6) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    /* Aerial Dice Styles - Updated to use grid battle dice styling */
    .aerial-container .dice-display {
      position: relative;
      width: 120px;
      height: 120px;
      perspective: 1000px;
      margin: 0 auto;
    }
    
    .aerial-container .dice-cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out;
    }
    
    .aerial-container .dice-face {
      position: absolute;
      width: 120px;
      height: 120px;
      background: 
        linear-gradient(135deg, 
          rgba(60, 40, 40, 0.95) 0%, 
          rgba(40, 25, 25, 0.98) 50%, 
          rgba(50, 30, 30, 0.95) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%232a1a1a" opacity="0.6"/><circle cx="20" cy="20" r="1" fill="%23444" opacity="0.4"/><circle cx="80" cy="30" r="1.5" fill="%23555" opacity="0.3"/><circle cx="60" cy="80" r="1" fill="%23666" opacity="0.4"/></svg>');
      border: 2px solid rgba(255, 0, 0, 0.8);
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(255, 0, 0, 0.2);
    }
    
    .aerial-container .dice-face.front { transform: rotateY(0deg) translateZ(60px); }
    .aerial-container .dice-face.back { transform: rotateY(180deg) translateZ(60px); }
    .aerial-container .dice-face.right { transform: rotateY(90deg) translateZ(60px); }
    .aerial-container .dice-face.left { transform: rotateY(-90deg) translateZ(60px); }
    .aerial-container .dice-face.top { transform: rotateX(90deg) translateZ(60px); }
    .aerial-container .dice-face.bottom { transform: rotateX(-90deg) translateZ(60px); }
    
    .aerial-container .dice-dot {
      width: 12px;
      height: 12px;
      background: 
        radial-gradient(circle, #ff4444 0%, #cc0000 70%);
      border-radius: 50%;
      box-shadow: 
        0 0 6px rgba(255, 68, 68, 0.8),
        inset 0 1px 2px rgba(255, 255, 255, 0.2);
      filter: drop-shadow(0 0 3px rgba(255, 68, 68, 0.6));
    }
    
    /* Aerial dice face visibility classes */
    .aerial-container .dice-cube.show-face-1 .dice-face { visibility: hidden; }
    .aerial-container .dice-cube.show-face-1 .dice-face.front { visibility: visible; }
    
    .aerial-container .dice-cube.show-face-2 .dice-face { visibility: hidden; }
    .aerial-container .dice-cube.show-face-2 .dice-face.back { visibility: visible; }
    
    .aerial-container .dice-cube.show-face-3 .dice-face { visibility: hidden; }
    .aerial-container .dice-cube.show-face-3 .dice-face.right { visibility: visible; }
    
    .aerial-container .dice-cube.show-face-4 .dice-face { visibility: hidden; }
    .aerial-container .dice-cube.show-face-4 .dice-face.left { visibility: visible; }
    
    .aerial-container .dice-cube.show-face-5 .dice-face { visibility: hidden; }
    .aerial-container .dice-cube.show-face-5 .dice-face.top { visibility: visible; }
    
    .aerial-container .dice-cube.show-face-6 .dice-face { visibility: hidden; }
    .aerial-container .dice-cube.show-face-6 .dice-face.bottom { visibility: visible; }
    
    /* During rolling, show all faces */
    .aerial-container .dice-cube.rolling .dice-face { visibility: visible !important; }
    
    /* Aerial Dice Face Layouts - Updated to use grid battle dice styling */
    .aerial-container .dice-face.face-1 {
      justify-content: center;
      align-items: center;
    }
    
    .aerial-container .dice-face.face-2 {
      justify-content: space-between;
      align-items: stretch;
    }
    .aerial-container .dice-face.face-2 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .aerial-container .dice-face.face-2 .dice-dot:nth-child(2) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .aerial-container .dice-face.face-3 {
      justify-content: space-between;
      align-items: stretch;
    }
    .aerial-container .dice-face.face-3 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .aerial-container .dice-face.face-3 .dice-dot:nth-child(2) { 
      align-self: center;
      margin: auto;
    }
    .aerial-container .dice-face.face-3 .dice-dot:nth-child(3) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .aerial-container .dice-face.face-4 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .aerial-container .dice-face.face-4 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .aerial-container .dice-face.face-4 .dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .aerial-container .dice-face.face-4 .dice-dot:nth-child(3) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .aerial-container .dice-face.face-4 .dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .aerial-container .dice-face.face-5 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .aerial-container .dice-face.face-5 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .aerial-container .dice-face.face-5 .dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .aerial-container .dice-face.face-5 .dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: center;
      margin: auto;
    }
    .aerial-container .dice-face.face-5 .dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .aerial-container .dice-face.face-5 .dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .aerial-container .dice-face.face-6 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .aerial-container .dice-face.face-6 .dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .aerial-container .dice-face.face-6 .dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .aerial-container .dice-face.face-6 .dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: flex-start;
      margin-right: auto;
    }
    .aerial-container .dice-face.face-6 .dice-dot:nth-child(4) { 
      align-self: center;
      justify-self: flex-end;
      margin-left: auto;
    }
    .aerial-container .dice-face.face-6 .dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .aerial-container .dice-face.face-6 .dice-dot:nth-child(6) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .artillery-dice-dot {
      width: 12px;
      height: 12px;
      background: 
        radial-gradient(circle, #FF4500 0%, #FF6347 70%);
      border-radius: 50%;
      box-shadow: 
        0 0 6px rgba(255, 69, 0, 0.8),
        inset 0 1px 2px rgba(255, 255, 255, 0.2);
      filter: drop-shadow(0 0 3px rgba(255, 69, 0, 0.6));
    }
    
    .artillery-results {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
    }
    
    .artillery-result {
      font-size: 1.2rem;
      color: #FFA07A;
      text-shadow: 0 0 10px rgba(255, 160, 122, 0.7);
      margin-bottom: 10px;
      min-height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .artillery-target {
      font-size: 1rem;
      color: #FFD700;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
      font-weight: 600;
    }
    
    .artillery-click-prompt {
      font-size: 16px;
      color: #FFD700;
      margin-top: 20px;
      animation: pulse 2s infinite;
      cursor: pointer;
      padding: 10px 20px;
      border: 2px solid #FFD700;
      border-radius: 10px;
      background: rgba(255, 215, 0, 0.1);
    }
    
    .artillery-dice-cube.rolling {
      animation: artilleryDiceRoll 2.5s ease-out forwards;
    }
    
    @keyframes artilleryDiceRoll {
      0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) translateX(0); }
      25% { transform: rotateX(180deg) rotateY(180deg) rotateZ(90deg) scale(1.1) translateX(-10px); }
      50% { transform: rotateX(360deg) rotateY(360deg) rotateZ(180deg) scale(0.9) translateX(-5px); }
      75% { transform: rotateX(540deg) rotateY(540deg) rotateZ(270deg) scale(1.05) translateX(-15px); }
      100% { transform: rotateX(720deg) rotateY(720deg) rotateZ(360deg) scale(1) translateX(0); }
    }
    
    /* Artillery Dice Face Layouts */
    .artillery-dice-face.face-1 {
      justify-content: center;
      align-items: center;
    }
    
    .artillery-dice-face.face-2 {
      justify-content: space-between;
      align-items: stretch;
    }
    .artillery-dice-face.face-2 .artillery-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .artillery-dice-face.face-2 .artillery-dice-dot:nth-child(2) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .artillery-dice-face.face-3 {
      justify-content: space-between;
      align-items: stretch;
    }
    .artillery-dice-face.face-3 .artillery-dice-dot:nth-child(1) { 
      align-self: flex-start;
      margin: auto;
    }
    .artillery-dice-face.face-3 .artillery-dice-dot:nth-child(2) { 
      align-self: center;
      margin: auto;
    }
    .artillery-dice-face.face-3 .artillery-dice-dot:nth-child(3) { 
      align-self: flex-end;
      margin: auto;
    }
    
    .artillery-dice-face.face-4 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .artillery-dice-face.face-4 .artillery-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .artillery-dice-face.face-4 .artillery-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .artillery-dice-face.face-4 .artillery-dice-dot:nth-child(3) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .artillery-dice-face.face-4 .artillery-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .artillery-dice-face.face-5 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .artillery-dice-face.face-5 .artillery-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .artillery-dice-face.face-5 .artillery-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .artillery-dice-face.face-5 .artillery-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: center;
      margin: auto;
    }
    .artillery-dice-face.face-5 .artillery-dice-dot:nth-child(4) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .artillery-dice-face.face-5 .artillery-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .artillery-dice-face.face-6 {
      justify-content: space-between;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .artillery-dice-face.face-6 .artillery-dice-dot:nth-child(1) { 
      align-self: flex-start;
      justify-self: flex-start;
      margin-right: auto;
    }
    .artillery-dice-face.face-6 .artillery-dice-dot:nth-child(2) { 
      align-self: flex-start;
      justify-self: flex-end;
      margin-left: auto;
    }
    .artillery-dice-face.face-6 .artillery-dice-dot:nth-child(3) { 
      align-self: center;
      justify-self: flex-start;
      margin-right: auto;
    }
    .artillery-dice-face.face-6 .artillery-dice-dot:nth-child(4) { 
      align-self: center;
      justify-self: flex-end;
      margin-left: auto;
    }
    .artillery-dice-face.face-6 .artillery-dice-dot:nth-child(5) { 
      align-self: flex-end;
      justify-self: flex-start;
      margin-right: auto;
    }
    .artillery-dice-face.face-6 .artillery-dice-dot:nth-child(6) { 
      align-self: flex-end;
      justify-self: flex-end;
      margin-left: auto;
    }
    
    .aerial-dice {
      width: 100px;
      height: 100px;
      background: linear-gradient(145deg, #87CEEB, #4169E1);
      border: 4px solid #FFD700;
      border-radius: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 48px;
      font-weight: bold;
      color: white;
      margin: 0 auto 30px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.4);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .aerial-dice.rolling {
      animation: aerialRoll 0.1s infinite;
    }
    
    @keyframes aerialRoll {
      0% { transform: rotate3d(1, 1, 1, 0deg) scale(1); }
      25% { transform: rotate3d(1, 1, 1, 90deg) scale(1.1); }
      50% { transform: rotate3d(1, 1, 1, 180deg) scale(1); }
      75% { transform: rotate3d(1, 1, 1, 270deg) scale(1.1); }
      100% { transform: rotate3d(1, 1, 1, 360deg) scale(1); }
    }
    
    .artillery-result {
      font-size: 20px;
      margin-bottom: 20px;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    .artillery-click-prompt {
      font-size: 18px;
      color: #FFD700;
      animation: pulse 2s infinite;
      cursor: pointer;
      padding: 15px 30px;
      border: 3px solid #FFD700;
      border-radius: 15px;
      background: rgba(255, 215, 0, 0.2);
      transition: all 0.3s ease;
    }
    
    .artillery-click-prompt:hover {
      background: rgba(255, 215, 0, 0.4);
      transform: scale(1.05);
    }
    
    /* Artillery Units Grid */
    .artillery-units-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin: 10px 0;
    }
    
    .artillery-unit-card {
      background: rgba(255, 69, 0, 0.2);
      border: 2px solid #FF4500;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
    
    .artillery-unit-card:hover {
      background: rgba(255, 69, 0, 0.4);
      transform: scale(1.05);
    }
    
    .artillery-unit-card.selected {
      background: rgba(255, 69, 0, 0.6);
      border-color: #FFD700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .artillery-unit-card.used {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .artillery-unit-name {
      font-weight: bold;
      color: #FF4500;
      margin-bottom: 5px;
    }
    
    .artillery-unit-stats {
      font-size: 12px;
      color: #ccc;
    }
    
    /* Aerial Panel Styles */
    .aerial-panel {
      background: rgba(var(--player-color-rgb, 135, 206, 235), 0.1);
      border: 2px solid var(--player-color, #87CEEB);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      transition: all 0.3s ease;
    }
    
    .aerial-panel.red-player {
      background: rgba(var(--player1-color-rgb, 220, 20, 60), 0.1);
      border: 2px solid var(--player1-color, #DC143C);
    }
    
    .aerial-panel.blue-player {
      background: rgba(var(--player2-color-rgb, 65, 105, 225), 0.1);
      border: 2px solid var(--player2-color, #4169E1);
    }
    
    .aerial-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .aerial-panel-header h3 {
      margin: 0;
      color: var(--player-color, #FF4500);
      font-size: 18px;
      transition: color 0.3s ease;
      text-align: center;
      width: 100%;
      text-shadow: 0 0 8px rgba(var(--player-color-rgb, 255, 68, 68), 0.6);
    }
    
    .aerial-panel.red-player .aerial-panel-header h3 {
      color: var(--player1-color, #DC143C);
    }
    
    .aerial-panel.blue-player .aerial-panel-header h3 {
      color: var(--player2-color, #4169E1);
    }
    
    .aerial-panel.red-player .aerial-panel-content {
      border-top-color: rgba(220, 20, 60, 0.3);
    }
    
    .aerial-panel.blue-player .aerial-panel-content {
      border-top-color: rgba(65, 105, 225, 0.3);
    }
    
    .aerial-status {
      font-size: 12px;
      color: #ccc;
      font-style: italic;
    }
    
    .aerial-panel-content {
      border-top: 1px solid rgba(var(--player-color-rgb, 135, 206, 235), 0.3);
      padding-top: 10px;
      transition: border-color 0.3s ease;
    }
    
    .aerial-panel.red-player .aerial-panel-content {
      border-top-color: rgba(var(--player1-color-rgb, 220, 20, 60), 0.3);
    }
    
    .aerial-panel.blue-player .aerial-panel-content {
      border-top-color: rgba(var(--player2-color-rgb, 65, 105, 225), 0.3);
    }
    
    .aerial-units-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 10px;
    }
    
    .aerial-section {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
    }
    
    .aerial-section h4 {
      margin: 0 0 10px 0;
      color: #FFD700;
      font-size: 14px;
      text-align: center;
    }
    
    .aerial-section .artillery-unit-card {
      margin-bottom: 8px;
    }
    
    .friendly-aerial {
      border-left: 3px solid var(--player-color, #32CD32);
    }
    
    .enemy-aerial {
      border-left: 3px solid var(--enemy-color, #DC143C);
      opacity: 0.8;
    }
    
    .aerial-unit-targetable {
      border: 3px solid #DC143C !important;
      box-shadow: 0 0 10px rgba(220, 20, 60, 0.6) !important;
      animation: targetPulse 1.5s ease-in-out infinite;
    }
    
    .anti-air-targetable {
      border: 3px solid #FFD700 !important;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.8) !important;
      animation: antiAirTargetPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes antiAirTargetPulse {
      0%, 100% { 
        border-color: #FFD700;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
      }
      50% { 
        border-color: #FFA500;
        box-shadow: 0 0 20px rgba(255, 165, 0, 1);
      }
    }
    
    .bomber-targetable {
      border: 3px solid #FF6B35 !important;
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8) !important;
      animation: bomberTargetPulse 2s ease-in-out infinite;
    }
    
    @keyframes bomberTargetPulse {
      0%, 100% { 
        border-color: #FF6B35;
        box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      }
      50% { 
        border-color: #FF8C42;
        box-shadow: 0 0 20px rgba(255, 140, 66, 1);
      }
    }
    
    @keyframes targetPulse {
      0%, 100% { 
        border-color: #DC143C;
        box-shadow: 0 0 10px rgba(220, 20, 60, 0.6);
      }
      50% { 
        border-color: #FF4444;
        box-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
      }
    }
    
    .aerial-attack-btn {
      background: #DC143C;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 5px;
      transition: all 0.3s ease;
    }
    
    .aerial-attack-btn:hover {
      background: #B22222;
      transform: scale(1.05);
    }
    
    .used-indicator {
      color: #FF6B6B;
      font-size: 12px;
      font-style: italic;
      margin-top: 5px;
    }
    
    .enemy-aerial:hover {
      opacity: 1;
    }
    
    .artillery-unit-card.selected {
      border: 2px solid #FFD700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      background: rgba(255, 215, 0, 0.1);
    }
    
    .artillery-unit-card.selected:hover {
      background: rgba(255, 215, 0, 0.2);
    }
    
    .aerial-instructions {
      font-size: 11px;
      color: #ccc;
      text-align: center;
      font-style: italic;
    }
    
    /* Artillery Panel Styles */
    .artillery-panel {
      background: rgba(var(--player-color-rgb, 255, 69, 0), 0.1);
      border: 2px solid var(--player-color, #FF4500);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      transition: all 0.3s ease;
    }
    
    .artillery-panel.red-player {
      background: rgba(var(--player1-color-rgb, 220, 20, 60), 0.1);
      border: 2px solid var(--player1-color, #DC143C);
    }
    
    .artillery-panel.blue-player {
      background: rgba(var(--player2-color-rgb, 65, 105, 225), 0.1);
      border: 2px solid var(--player2-color, #4169E1);
    }
    
    .artillery-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .artillery-panel-header h3 {
      margin: 0;
      color: var(--player-color, #FF4500);
      font-size: 18px;
      transition: color 0.3s ease;
      text-shadow: 0 0 8px rgba(var(--player-color-rgb, 255, 68, 68), 0.6);
    }
    
    .artillery-panel.red-player .artillery-panel-header h3 {
      color: var(--player1-color, #DC143C);
    }
    
    .artillery-panel.blue-player .artillery-panel-header h3 {
      color: var(--player2-color, #4169E1);
    }
    
    .artillery-status {
      font-size: 12px;
      color: #ccc;
      font-style: italic;
    }
    
    .artillery-panel-content {
      border-top: 1px solid rgba(var(--player-color-rgb, 255, 69, 0), 0.3);
      padding-top: 10px;
      transition: border-color 0.3s ease;
    }
    
    .artillery-panel.red-player .artillery-panel-content {
      border-top-color: rgba(var(--player1-color-rgb, 220, 20, 60), 0.3);
    }
    
    .artillery-panel.blue-player .artillery-panel-content {
      border-top-color: rgba(var(--player2-color-rgb, 65, 105, 225), 0.3);
    }
    
    .artillery-units-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 10px;
    }
    
    .artillery-section {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
    }
    
    .artillery-section h4 {
      margin: 0 0 10px 0;
      color: #FFD700;
      font-size: 14px;
      text-align: center;
    }
    
    .artillery-section .artillery-unit-card {
      margin-bottom: 8px;
    }
    
    .friendly-artillery {
      border-left: 3px solid var(--player-color, #32CD32);
    }
    
    .enemy-artillery {
      border-left: 3px solid var(--enemy-color, #DC143C);
      opacity: 0.8;
    }
    
    .artillery-instructions {
      font-size: 11px;
      color: #ccc;
      text-align: center;
      font-style: italic;
    }
    
    /* Construction Panel Styles */
    .construction-panel {
      background: rgba(139, 69, 19, 0.1);
      border: 2px solid #8B4513;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      transition: all 0.3s ease;
    }
    
    .construction-panel.red-player {
      background: rgba(220, 20, 60, 0.1);
      border: 2px solid #DC143C;
    }
    
    .construction-panel.blue-player {
      background: rgba(65, 105, 225, 0.1);
      border: 2px solid #4169E1;
    }
    
    .construction-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .construction-panel-header h3 {
      margin: 0;
      color: #8B4513;
      font-size: 18px;
      transition: color 0.3s ease;
    }
    
    .construction-panel.red-player .construction-panel-header h3 {
      color: #DC143C;
    }
    
    .construction-panel.blue-player .construction-panel-header h3 {
      color: #4169E1;
    }
    
    .construction-status {
      font-size: 12px;
      color: #ccc;
      font-style: italic;
    }
    
    .construction-panel-content {
      border-top: 1px solid rgba(139, 69, 19, 0.3);
      padding-top: 10px;
      transition: border-color 0.3s ease;
    }
    
    .construction-panel.red-player .construction-panel-content {
      border-top-color: rgba(220, 20, 60, 0.3);
    }
    
    .construction-panel.blue-player .construction-panel-content {
      border-top-color: rgba(65, 105, 225, 0.3);
    }
    
    .construction-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 6px;
      margin-bottom: 10px;
      max-height: 500px;
      min-height: 300px;
      overflow-y: auto;
      padding: 10px;
      background: rgba(40, 20, 10, 0.3);
      border-radius: 8px;
      border: 1px solid rgba(139, 69, 19, 0.4);
    }
    
    .construction-option {
      background: rgba(139, 69, 19, 0.2);
      border: 1px solid #8B4513;
      border-radius: 6px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 12px;
    }
    
    .construction-option:hover {
      background: rgba(139, 69, 19, 0.4);
      border-color: #D2691E;
      transform: translateY(-2px);
    }
    
    .construction-option.selected {
      background: rgba(139, 69, 19, 0.6);
      border-color: #D2691E;
      box-shadow: 0 0 10px rgba(139, 69, 19, 0.5);
    }
    
    .construction-option-name {
      font-weight: bold;
      color: #D2691E;
      margin-bottom: 4px;
    }
    
    .construction-option-cost {
      font-size: 10px;
      color: #ccc;
      margin-bottom: 2px;
    }
    
    .construction-option-duration {
      font-size: 10px;
      color: #aaa;
    }
    
    .construction-instructions {
      font-size: 11px;
      color: #ccc;
      text-align: center;
      font-style: italic;
    }
    
    /* Transparent scrollbar for construction options */
    .construction-options::-webkit-scrollbar {
      width: 6px;
    }
    
    .construction-options::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .construction-options::-webkit-scrollbar-thumb {
      background: rgba(139, 69, 19, 0.3);
      border-radius: 3px;
    }
    
    .construction-options::-webkit-scrollbar-thumb:hover {
      background: rgba(139, 69, 19, 0.5);
    }
    
    /* Weather and Day/Night Cycle Display Styles */
    .weather-display {
      background: 
        linear-gradient(135deg, 
          rgba(40, 60, 80, 0.9) 0%, 
          rgba(30, 45, 60, 0.95) 50%, 
          rgba(25, 40, 55, 0.98) 100%
        );
      border: 2px solid rgba(100, 150, 200, 0.6);
      border-radius: 8px;
      padding: 15px;
      margin: 15px auto;
      max-width: 400px;
      backdrop-filter: blur(4px);
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .weather-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .weather-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 0;
    }
    
    .weather-label {
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      color: #aaccff;
      font-weight: 600;
      text-shadow: 0 0 5px rgba(170, 204, 255, 0.5);
    }
    
    .weather-value {
      font-family: 'Orbitron', monospace;
      font-size: 0.85rem;
      color: #ffcc66;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(255, 204, 102, 0.6);
    }
    
    .weather-section {
      background: 
        linear-gradient(135deg, 
          rgba(40, 60, 80, 0.8) 0%, 
          rgba(30, 45, 60, 0.9) 50%, 
          rgba(25, 40, 55, 0.95) 100%
        );
      border: 1px solid rgba(100, 150, 200, 0.5);
      border-radius: 6px;
      padding: 12px;
      margin: 15px 0;
      backdrop-filter: blur(3px);
    }
    
    .weather-section strong {
      color: #aaccff;
      font-size: 0.9rem;
      margin-bottom: 8px;
      display: block;
      text-shadow: 0 0 5px rgba(170, 204, 255, 0.5);
    }
    
    .weather-display-controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .weather-display-controls .weather-item {
      padding: 3px 0;
    }
    
    .weather-display-controls .weather-label {
      font-size: 0.8rem;
      color: #88aaff;
    }
    
    .weather-display-controls .weather-value {
      font-size: 0.8rem;
      color: #ffdd88;
    }
    
    /* Transparent scrollbar for main page */
    ::-webkit-scrollbar {
      width: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(139, 0, 0, 0.3);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(139, 0, 0, 0.5);
    }
    
    /* Enhanced Main Menu Styles */
    #main-menu {
      font-family: 'Cinzel', serif;
      overflow: hidden;
      cursor: none; /* Hide default cursor */
      background: #000;
      position: relative;
    }
    

    
    .main-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: 
        radial-gradient(ellipse 120% 100% at center bottom, rgba(120, 40, 40, 0.3) 0%, transparent 60%),
        radial-gradient(ellipse 80% 120% at center top, rgba(20, 0, 0, 0.4) 0%, transparent 50%),
        linear-gradient(180deg, 
          rgba(35, 30, 40, 0.9) 0%, 
          rgba(45, 35, 40, 0.85) 20%,
          rgba(40, 30, 35, 0.87) 50%, 
          rgba(30, 25, 30, 0.92) 80%,
          rgba(25, 20, 25, 0.95) 100%
        );
      filter: contrast(1.2) brightness(0.85);
    }
    
    .battlefield-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 100"><defs><filter id="noise"><feTurbulence baseFrequency="0.9" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.1 0.15 0.2 0.05"/></feComponentTransfer></filter></defs><rect width="400" height="100" fill="%23000" opacity="0.3"/><path d="M0,70 Q100,65 200,70 T400,70 L400,100 L0,100 Z" fill="%234a3728" opacity="0.6"/><path d="M0,80 Q150,75 300,80 T400,80 L400,100 L0,100 Z" fill="%23362519" opacity="0.8"/><rect width="400" height="100" fill="url(%23noise)" opacity="0.4"/></svg>') repeat-x bottom,
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 50"><path d="M0,40 L30,35 L60,42 L90,38 L120,41 L150,37 L180,40 L200,39 L200,50 L0,50 Z" fill="%232d1810" opacity="0.7"/></svg>') repeat-x bottom;
      background-size: 800px 200px, 400px 100px;
      animation: battlefieldDrift 25s linear infinite;
    }
    
    .debris-field {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 200px;
      background: 
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 30"><rect x="10" y="20" width="3" height="8" fill="%23333" opacity="0.6" transform="rotate(15 11.5 24)"/><rect x="45" y="18" width="2" height="10" fill="%23444" opacity="0.5" transform="rotate(-20 46 23)"/><rect x="75" y="22" width="4" height="6" fill="%23555" opacity="0.4" transform="rotate(30 77 25)"/><circle cx="25" cy="25" r="1.5" fill="%23666" opacity="0.3"/><circle cx="60" cy="24" r="1" fill="%23555" opacity="0.4"/></svg>') repeat-x;
      opacity: 0.6;
      animation: debrisFloat 12s ease-in-out infinite;
    }
    
    .wire-system {
      position: absolute;
      bottom: 80px;
      left: 0;
      width: 100%;
      height: 60px;
      background: 
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><path d="M0,10 Q10,8 20,10 T40,10 Q50,12 60,10 T80,10 Q90,8 100,10" stroke="%23666" stroke-width="0.8" fill="none" opacity="0.8"/><path d="M0,15 Q15,13 30,15 T60,15 Q75,17 90,15 L100,15" stroke="%23555" stroke-width="0.6" fill="none" opacity="0.6"/><circle cx="20" cy="10" r="1.2" fill="%23777" opacity="0.7"/><circle cx="45" cy="10" r="1" fill="%23666" opacity="0.6"/><circle cx="70" cy="15" r="1.3" fill="%23888" opacity="0.5"/></svg>') repeat-x;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.6));
      animation: wireOscillation 6s ease-in-out infinite;
    }
    
    .atmospheric-smoke {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
    }
    
    .smoke-particle {
      position: absolute;
      background: radial-gradient(circle, rgba(180, 180, 180, 0.08) 0%, rgba(120, 120, 120, 0.04) 40%, transparent 70%);
      border-radius: 50%;
      filter: blur(1px);
    }
    
    .blood-mist {
      position: absolute;
      background: radial-gradient(ellipse, rgba(180, 0, 0, 0.15) 0%, rgba(120, 0, 0, 0.08) 30%, rgba(80, 0, 0, 0.04) 60%, transparent 80%);
      border-radius: 50%;
      filter: blur(2px);
      animation: bloodMistDrift 20s linear infinite;
    }
    
    .blood-mist.dense {
      background: radial-gradient(ellipse, rgba(200, 20, 20, 0.2) 0%, rgba(150, 10, 10, 0.12) 25%, rgba(100, 5, 5, 0.06) 50%, transparent 75%);
      filter: blur(3px);
    }
    
    .blood-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .blood-gradient {
      position: absolute;
      background: radial-gradient(ellipse at center, rgba(120, 0, 0, 0.25) 0%, rgba(80, 0, 0, 0.15) 30%, transparent 60%);
      filter: blur(3px);
    }
    
    .blood-gradient.corner-tl {
      top: -100px;
      left: -100px;
      width: 300px;
      height: 300px;
      transform: rotate(45deg);
    }
    
    .blood-gradient.corner-br {
      bottom: -100px;
      right: -100px;
      width: 350px;
      height: 350px;
      transform: rotate(-135deg);
    }
    
    .menu-system {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: 
        linear-gradient(135deg, 
          rgba(30, 10, 10, 0.98) 0%, 
          rgba(20, 5, 5, 0.99) 50%, 
          rgba(25, 8, 8, 0.98) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="metalNoise"><feTurbulence baseFrequency="0.9" numOctaves="3" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.05 0.1 0.15 0.02"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23metalNoise)" opacity="0.4"/></svg>');
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 50px 70px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
        0 0 60px rgba(255, 0, 0, 0.3),
        0 0 120px rgba(139, 0, 0, 0.4),
        0 0 200px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(255, 50, 50, 0.2),
        inset 0 -1px 0 rgba(0, 0, 0, 0.5);
      animation: menuLevitation 8s ease-in-out infinite, menuFlicker 12s ease-in-out infinite;
      position: relative;
      max-width: 600px;
      width: 90%;
    }
    
    .menu-system::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
        transparent 20%, 
        rgba(255, 0, 0, 0.3) 30%,
        rgba(139, 0, 0, 0.2) 50%, 
        rgba(255, 0, 0, 0.3) 70%,
        transparent 80%
      );
      border-radius: 12px;
      z-index: -1;
      animation: borderFlow 6s linear infinite, borderFlicker 8s ease-in-out infinite;
    }
    
    .game-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 3.2rem;
      color: #ff4444;
      text-align: center;
      margin-bottom: 40px;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ff0000 0%, #8b0000 30%, #ff3333 60%, #cc0000 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 12px rgba(255, 0, 0, 0.8)) drop-shadow(0 0 24px rgba(139, 0, 0, 0.6));
      animation: titleEnergyPulse 4s ease-in-out infinite, titleFlicker 8s ease-in-out infinite;
      position: relative;
    }
    
    .game-title::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #ff0000, #8b0000, #ff0000, transparent);
      animation: underlineGlow 3s ease-in-out infinite, underlinePulse 6s ease-in-out infinite;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
    }
    
    .menu-navigation {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      align-items: center;
      max-width: 500px;
      margin: 0 auto;
    }
    
    .menu-section {
      display: contents;
    }
    
    .section-title {
      grid-column: 1 / -1;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.1rem;
      color: #ff0000;
      text-align: center;
      margin: 15px 0 10px 0;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.9;
      position: relative;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
    }
    
    .section-title::before,
    .section-title::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 30px;
      height: 1px;
      background: linear-gradient(90deg, transparent, #ff0000, transparent);
      box-shadow: 0 0 5px rgba(255, 0, 0, 0.8);
    }
    
    .section-title::before {
      left: -40px;
    }
    
    .section-title::after {
      right: -40px;
    }
    
    /* CRITICAL: Preserve your existing button functionality */
    .menu-button {
      position: relative;
      background: 
        linear-gradient(135deg, 
          rgba(50, 15, 15, 0.95) 0%, 
          rgba(35, 10, 10, 0.98) 50%, 
          rgba(45, 12, 12, 0.95) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.1rem;
      padding: 15px 20px;
      cursor: crosshair;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 0 12px rgba(255, 68, 68, 0.6), 0 0 24px rgba(139, 0, 0, 0.4);
      letter-spacing: 1px;
      border-radius: 8px;
      box-shadow: 
        0 4px 20px rgba(139, 0, 0, 0.6),
        0 0 30px rgba(255, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 50, 50, 0.15),
        inset 0 -1px 0 rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      overflow: hidden;
      text-align: center;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .menu-button.primary {
      grid-column: 1 / -1;
      font-size: 1.3rem;
      padding: 18px 30px;
      background: 
        linear-gradient(135deg, 
          rgba(80, 20, 20, 0.98) 0%, 
          rgba(60, 15, 15, 0.99) 50%, 
          rgba(75, 18, 18, 0.98) 100%
        );
      border: 1px solid rgba(255, 0, 0, 0.9);
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8), 0 0 30px rgba(139, 0, 0, 0.6);
    }
    
    .menu-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 0, 0, 0.2) 30%, 
        rgba(255, 50, 50, 0.4) 50%, 
        rgba(255, 0, 0, 0.2) 70%, 
        transparent 100%
      );
      transition: left 0.6s ease;
      z-index: 1;
    }
    
    .menu-button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: radial-gradient(circle, rgba(255, 0, 0, 0.5) 0%, transparent 70%);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.4s ease;
      z-index: 0;
    }
    
    .menu-button span {
      position: relative;
      z-index: 2;
    }
    
    .menu-button:hover {
      background: 
        linear-gradient(135deg, 
          rgba(90, 25, 25, 0.98) 0%, 
          rgba(70, 20, 20, 0.99) 50%, 
          rgba(85, 22, 22, 0.98) 100%
        );
      color: #ff0000;
      border-color: rgba(255, 0, 0, 1);
      transform: translateY(-3px) scale(1.02);
      box-shadow: 
        0 8px 35px rgba(255, 0, 0, 0.4),
        0 0 50px rgba(255, 0, 0, 0.3),
        0 0 80px rgba(139, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 50, 50, 0.3);
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.9), 0 0 40px rgba(139, 0, 0, 0.7);
    }
    
    .menu-button:hover::before {
      left: 100%;
    }
    
    .menu-button:hover::after {
      width: 200px;
      height: 200px;
    }
    
    .menu-button:active {
      transform: translateY(-1px) scale(1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
    }
    
    .menu-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: rgba(100,100,100,0.3);
    }
    
    /* Specific styling for disabled "Unleash Hell" button */
    .menu-button.large-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: rgba(80, 0, 0, 0.3);
      border-color: rgba(139, 0, 0, 0.3);
      color: rgba(255, 255, 255, 0.5);
      transform: none;
      box-shadow: none;
      font-size: 0.75rem;
      line-height: 1.1;
      padding: 12px 20px;
      text-align: center;
      white-space: normal;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .menu-button.large-button:disabled:hover {
      transform: none;
      box-shadow: none;
      background: rgba(80, 0, 0, 0.3);
    }
    
    .sigil-container {
      position: absolute;
      top: 15%;
      right: 8%;
      width: 80px;
      height: 80px;
      animation: sigilLevitate 8s ease-in-out infinite;
    }
    
    .demonic-sigil {
      width: 100%;
      height: 100%;
      background: 
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="glow"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><circle cx="50" cy="50" r="35" stroke="%23cc0000" stroke-width="1.5" fill="none" opacity="0.8" filter="url(%23glow)"/><circle cx="50" cy="50" r="20" stroke="%23ff0000" stroke-width="1" fill="none" opacity="0.6"/><path d="M30,30 L70,70 M70,30 L30,70" stroke="%23ff0000" stroke-width="1.2" opacity="0.7" filter="url(%23glow)"/><path d="M50,15 L50,85 M15,50 L85,50" stroke="%23cc0000" stroke-width="0.8" opacity="0.5"/><polygon points="50,28 54,38 64,38 56,46 60,56 50,50 40,56 44,46 36,38 46,38" fill="%23ff0000" opacity="0.6" filter="url(%23glow)"/><circle cx="50" cy="50" r="3" fill="%23ff3333" opacity="0.8"/></svg>') 
        center/contain no-repeat;
      animation: sigilPulse 3s ease-in-out infinite;
      filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.4));
    }
    
    .environmental-effects {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 25% 75%, rgba(139, 0, 0, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 75% 25%, rgba(80, 0, 0, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(60, 0, 0, 0.12) 0%, transparent 60%);
      animation: environmentalShift 15s ease-in-out infinite;
      pointer-events: none;
    }
    
    .depth-vignette {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse 80% 60% at center, transparent 30%, rgba(0, 0, 0, 0.4) 70%, rgba(0, 0, 0, 0.8) 100%);
      pointer-events: none;
    }
    
    /* Setup Screen Styles */
    .setup-container {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      padding: 0 20px;
      overflow: hidden;
      box-sizing: border-box;
    }
    
    /* Responsive design for smaller screens */
    @media (max-width: 768px) {
      .setup-container {
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 0 10px;
      }
      
      .setup-title {
        font-size: 2rem;
      }
      
      .setup-section {
        padding: 20px;
      }
    }
    
    .setup-section {
      background: 
          linear-gradient(135deg, 
              rgba(5, 0, 10, 0.95) 0%, 
              rgba(0, 0, 5, 0.98) 50%, 
              rgba(0, 0, 0, 1) 100%
          ),
          url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="metalNoise"><feTurbulence baseFrequency="0.9" numOctaves="3" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.08 0.15 0.2 0.05"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23metalNoise)" opacity="0.4"/></svg>');
      border: 2px solid rgba(139, 0, 0, 0.8);
      border-radius: 12px;
      padding: 30px;
      backdrop-filter: blur(10px) saturate(1.3);
      box-shadow: 
          0 0 20px rgba(139, 0, 0, 0.3),
          0 0 40px rgba(0, 0, 0, 0.9),
          inset 0 1px 0 rgba(255, 255, 255, 0.02),
          inset 0 -1px 0 rgba(0, 0, 0, 0.8);
      position: relative;
      overflow: visible;
      animation: sectionLevitation 8s ease-in-out infinite;
      z-index: 1;
    }
    
    .setup-section::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
          transparent 30%, 
          rgba(139, 0, 0, 0.4) 50%, 
          transparent 70%
      );
      border-radius: 12px;
      z-index: -1;
      animation: borderFlow 8s linear infinite;
    }
    
    .setup-section h2 {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.8rem;
      color: #cc2222;
      text-align: center;
      margin-bottom: 25px;
      letter-spacing: 2px;
      text-transform: uppercase;
      position: relative;
      padding-bottom: 15px;
    }
    
    .setup-section h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #cc2222, transparent);
      animation: underlineGlow 3s ease-in-out infinite;
    }
    
    .form-group {
      margin-bottom: 25px;
      position: relative;
      overflow: visible;
    }
    
    .form-group label {
      display: block;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.1rem;
      color: #cc4444;
      margin-bottom: 12px;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(204, 68, 68, 0.5);
      position: relative;
      padding-left: 15px;
    }
    
    .form-group label::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #ff4444 0%, #cc2222 100%);
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
      animation: labelPulse 3s ease-in-out infinite;
    }
    
    @keyframes labelPulse {
      0%, 100% { 
        opacity: 0.7;
        transform: translateY(-50%) scale(1);
      }
      50% { 
        opacity: 1;
        transform: translateY(-50%) scale(1.2);
      }
    }
    
    .form-control {
      width: 100%;
      padding: 15px 18px;
      background: 
        linear-gradient(135deg, 
          rgba(40, 15, 15, 0.95) 0%, 
          rgba(30, 10, 10, 0.98) 100%
        ) !important;
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      color: #ff6666;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      transition: all 0.3s ease;
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(255, 0, 0, 0.1);
      backdrop-filter: blur(4px);
    }
    
    .form-control option {
      background: #1e3c72;
      color: white;
    }
    
    .form-control::placeholder {
      color: rgba(255, 100, 100, 0.5);
      font-style: italic;
    }

    /* Locked Setting Styles */
    .locked-setting {
      background: linear-gradient(135deg, 
        rgba(60, 20, 20, 0.9) 0%, 
        rgba(40, 15, 15, 0.95) 100%
      );
      border: 2px solid rgba(139, 0, 0, 0.7);
      border-radius: 8px;
      padding: 15px 18px;
      position: relative;
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(255, 0, 0, 0.1);
      backdrop-filter: blur(4px);
    }

    .locked-value {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      color: #ff6666;
      text-align: center;
      margin-bottom: 8px;
    }

    .locked-note {
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      color: rgba(255, 100, 100, 0.7);
      text-align: center;
      font-style: italic;
    }
    
    .form-control:focus {
      outline: none;
      border-color: rgba(255, 0, 0, 0.9);
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.4),
        0 0 30px rgba(255, 0, 0, 0.3),
        0 0 15px rgba(255, 0, 0, 0.5);
      background: 
        linear-gradient(135deg, 
          rgba(50, 20, 20, 0.98) 0%, 
          rgba(40, 15, 15, 0.99) 100%
        );
    }
    
    .color-picker-container {
  display: flex;
  align-items: center;
  gap: 15px;
  background: 
      linear-gradient(135deg, 
          rgba(50, 15, 15, 0.9) 0%, 
          rgba(35, 10, 10, 0.95) 50%, 
          rgba(45, 15, 15, 0.9) 100%
      );
  border: 1px solid rgba(180, 0, 0, 0.6);
  border-radius: 8px;
  padding: 12px 16px;
  box-shadow: 
      0 4px 12px rgba(0, 0, 0, 0.5),
      inset 0 1px 0 rgba(255, 255, 255, 0.05);
  position: relative;
}
    
    .color-input {
  width: 50px;
  height: 35px;
  border: 2px solid rgba(180, 0, 0, 0.8);
  border-radius: 6px;
  cursor: crosshair;
  transition: all 0.3s ease;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
  background: transparent;
  opacity: 0;
  position: absolute;
  z-index: 10;
}

    .color-display {
      width: 50px;
      height: 35px;
      border: 2px solid rgba(180, 0, 0, 0.8);
      border-radius: 6px;
      cursor: crosshair;
      transition: all 0.3s ease;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      background: var(--color-value, #cc0000);
      position: relative;
      z-index: 5;
      /* Button styling */
      padding: 0;
      margin: 0;
      font-family: inherit;
      font-size: inherit;
      line-height: 1;
      text-align: center;
      text-decoration: none;
      vertical-align: middle;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    
    .color-display::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
          transparent 30%, 
          rgba(204, 68, 68, 0.2) 50%, 
          transparent 70%
      );
      border-radius: 8px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: -1;
    }
    
    .color-picker-container:hover .color-display {
      border-color: rgba(204, 68, 68, 0.9);
      box-shadow: 0 0 20px rgba(204, 68, 68, 0.4);
      transform: scale(1.05);
    }
    
    .color-picker-container:hover .color-display::after {
      opacity: 1;
    }
    
    .color-picker-container span {
      color: #996666;
      font-style: italic;
      font-size: 0.95rem;
    }
    
    /* Custom Color Picker Overlay */
    .custom-color-picker-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999999;
      backdrop-filter: blur(5px);
      pointer-events: auto;
    }
    
    .custom-color-picker-overlay.active {
      display: flex;
      cursor: none !important;
    }
    
    .custom-color-picker-overlay.active * {
      cursor: none !important;
    }
    
    .custom-color-picker-overlay.active button,
    .custom-color-picker-overlay.active input,
    .custom-color-picker-overlay.active canvas {
      cursor: none !important;
    }
    
    .custom-color-picker-container {
      background: 
        linear-gradient(135deg, 
          rgba(40, 40, 45, 0.98) 0%, 
          rgba(30, 30, 35, 1) 50%, 
          rgba(25, 25, 30, 0.99) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="metalNoise"><feTurbulence baseFrequency="0.9" numOctaves="3" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.05 0.1 0.15 0.02"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23metalNoise)" opacity="0.3"/></svg>');
      border: 3px solid rgba(255, 68, 68, 0.8);
      border-radius: 15px;
      padding: 35px;
      max-width: 450px;
      width: 100%;
      box-shadow: 
        0 0 60px rgba(255, 68, 68, 0.3),
        0 10px 30px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      position: relative;
      animation: pickerSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .custom-color-picker-container::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(45deg, 
        rgba(255, 68, 68, 0.6) 0%, 
        rgba(255, 0, 0, 0.3) 25%,
        rgba(255, 68, 68, 0.6) 50%,
        rgba(255, 0, 0, 0.3) 75%,
        rgba(255, 68, 68, 0.6) 100%
      );
      border-radius: 15px;
      z-index: -1;
      animation: borderPulse 3s ease-in-out infinite;
    }
    
    .picker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid rgba(255, 68, 68, 0.3);
    }
    
    .picker-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.5rem;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
    }
    
    .close-btn {
      background: rgba(80, 40, 40, 0.8);
      border: 2px solid rgba(255, 68, 68, 0.6);
      color: #ff4444;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: none;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.2);
    }
    
    .close-btn:hover {
      background: rgba(100, 50, 50, 0.9);
      border-color: rgba(255, 34, 34, 0.8);
      color: #ff2222;
      transform: scale(1.1);
      box-shadow: 0 0 25px rgba(255, 34, 34, 0.4);
    }
    
    .color-selection-area {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 25px;
      margin-bottom: 25px;
    }
    
    .color-canvas-container {
      position: relative;
    }
    
    .color-canvas {
      width: 100%;
      height: 200px;
      border: 2px solid rgba(120, 120, 130, 0.6);
      border-radius: 8px;
      cursor: none;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }
    
    .color-canvas:hover {
      border-color: rgba(255, 102, 102, 0.8);
      box-shadow: 
        0 0 20px rgba(255, 102, 102, 0.3),
        0 4px 15px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }
    
    .hue-slider-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .hue-slider {
      width: 100%;
      height: 200px;
      background: linear-gradient(to bottom,
        #ff0000 0%,
        #ff8000 14.28%,
        #ffff00 28.57%,
        #80ff00 42.86%,
        #00ff00 57.14%,
        #00ff80 71.43%,
        #00ffff 85.71%,
        #0080ff 100%
      );
      border: 2px solid rgba(120, 120, 130, 0.6);
      border-radius: 8px;
      cursor: none;
      position: relative;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .hue-slider:hover {
      border-color: rgba(255, 102, 102, 0.8);
      box-shadow: 
        0 0 20px rgba(255, 102, 102, 0.3),
        0 4px 15px rgba(0, 0, 0, 0.6);
    }
    
    .slider-thumb {
      position: absolute;
      left: -5px;
      width: calc(100% + 10px);
      height: 8px;
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid rgba(0, 0, 0, 0.8);
      border-radius: 4px;
      cursor: none;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      transition: all 0.2s ease;
      top: 0%;
    }
    
    .slider-thumb:hover {
      background: rgba(255, 255, 255, 1);
      transform: scaleY(1.2);
    }
    
    .color-preview {
      width: 100%;
      height: 60px;
      border: 2px solid rgba(120, 120, 130, 0.6);
      border-radius: 8px;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      background-color: #ff0000;
    }
    
    .preset-colors {
      margin-bottom: 25px;
    }
    
    .preset-label {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.1rem;
      color: #ff6666;
      margin-bottom: 15px;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(255, 102, 102, 0.4);
    }
    
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 8px;
    }
    
    .preset-color {
      width: 35px;
      height: 35px;
      border: 2px solid rgba(120, 120, 130, 0.6);
      border-radius: 6px;
      cursor: crosshair;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      position: relative;
    }
    
    .preset-color:hover {
      border-color: rgba(255, 102, 102, 0.8);
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(255, 102, 102, 0.3);
    }
    
    .preset-color.selected {
      border-color: rgba(255, 68, 68, 1);
      box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
    }
    
    .preset-color.selected::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0.9);
      font-weight: bold;
      font-size: 1.2rem;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
    }
    
    .color-inputs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 25px;
    }
    
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .input-label {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 0.9rem;
      color: #ff8888;
      letter-spacing: 1px;
      text-align: center;
    }
    
    .color-input-field {
      background: rgba(60, 60, 70, 0.9);
      border: 1px solid rgba(120, 120, 130, 0.6);
      color: #ff8888;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      padding: 8px;
      border-radius: 4px;
      text-align: center;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }
    
    .color-input-field:focus {
      outline: none;
      border-color: rgba(255, 102, 102, 0.8);
      background: rgba(70, 60, 60, 0.95);
      box-shadow: 0 0 15px rgba(255, 102, 102, 0.3);
      color: #ff6666;
    }
    
    .action-buttons {
      display: flex;
      justify-content: space-between;
      gap: 15px;
    }
    
    .picker-btn {
      flex: 1;
      background: linear-gradient(135deg, 
        rgba(60, 60, 70, 0.9) 0%, 
        rgba(45, 45, 55, 0.95) 50%, 
        rgba(55, 55, 65, 0.9) 100%
      );
      border: 2px solid rgba(120, 120, 130, 0.6);
      color: #ff6666;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      padding: 12px 20px;
      cursor: none;
      border-radius: 6px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .picker-btn:hover {
      background: linear-gradient(135deg, 
        rgba(80, 70, 70, 0.95) 0%, 
        rgba(70, 60, 60, 0.98) 50%, 
        rgba(85, 75, 75, 0.95) 100%
      );
      color: #ff3333;
      border-color: rgba(255, 102, 102, 0.8);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.25);
    }
    
    .picker-btn-primary {
      background: linear-gradient(135deg, 
        rgba(80, 40, 40, 0.95) 0%, 
        rgba(70, 30, 30, 0.98) 50%, 
        rgba(90, 50, 50, 0.95) 100%
      );
      border-color: rgba(255, 68, 68, 0.8);
      color: #ff4444;
    }
    
    .picker-btn-primary:hover {
      background: linear-gradient(135deg, 
        rgba(100, 50, 50, 0.98) 0%, 
        rgba(90, 40, 40, 1) 50%, 
        rgba(110, 60, 60, 0.98) 100%
      );
      color: #ff2222;
      border-color: rgba(255, 34, 34, 1);
      box-shadow: 0 0 25px rgba(255, 34, 34, 0.4);
    }
    
    .canvas-cursor {
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
      transition: all 0.1s ease;
      display: none;
    }
    
    /* Animations */
    @keyframes pickerSlideIn {
      from { 
        opacity: 0; 
        transform: translateY(-50px) scale(0.9); 
      }
      to { 
        opacity: 1; 
        transform: translateY(0) scale(1); 
      }
    }
    
    @keyframes borderPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .custom-color-picker-container {
        padding: 25px;
        margin: 20px;
      }
      
      .color-selection-area {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .hue-slider {
        height: 40px;
        background: linear-gradient(to right,
          #ff0000 0%,
          #ff8000 14.28%,
          #ffff00 28.57%,
          #80ff00 42.86%,
          #00ff00 57.14%,
          #00ff80 71.43%,
          #00ffff 85.71%,
          #0080ff 100%
        );
      }
      
      .slider-thumb {
        top: -5px;
        left: 0;
        width: 8px;
        height: calc(100% + 10px);
      }
      
      .preset-grid {
        grid-template-columns: repeat(6, 1fr);
      }
      
      .color-inputs {
        grid-template-columns: 1fr;
      }
      
      .action-buttons {
        flex-direction: column;
      }
    }
    
    .slider-container {
      position: relative;
      margin: 15px 0;
      padding: 10px 15px;
      background: 
          linear-gradient(135deg, 
              rgba(25, 15, 20, 0.95) 0%, 
              rgba(20, 10, 15, 0.98) 50%, 
              rgba(30, 20, 25, 0.95) 100%
          );
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      box-shadow: 
          0 4px 15px rgba(0, 0, 0, 0.6),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(4px);
      transition: all 0.3s ease;
    }
    
    .slider-container:hover {
      border-color: rgba(204, 68, 68, 0.8);
      box-shadow: 
          0 6px 20px rgba(139, 0, 0, 0.4),
          0 0 25px rgba(204, 68, 68, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .slider-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, 
          transparent 30%, 
          rgba(139, 0, 0, 0.1) 50%, 
          transparent 70%
      );
      border-radius: 8px;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .slider-container:hover::before {
      opacity: 1;
    }
    
    .slider {
      width: 100%;
      height: 12px;
      background: 
          linear-gradient(to right, 
              rgba(0, 0, 0, 0.9) 0%, 
              rgba(20, 0, 0, 0.8) 25%, 
              rgba(139, 0, 0, 0.7) 50%, 
              rgba(180, 0, 0, 0.6) 75%,
              rgba(220, 20, 60, 0.5) 100%
          );
      border-radius: 6px;
      outline: none;
      border: 2px solid rgba(139, 0, 0, 0.7);
      box-shadow: 
          0 3px 10px rgba(0, 0, 0, 0.5),
          inset 0 2px 4px rgba(0, 0, 0, 0.4),
          0 0 15px rgba(139, 0, 0, 0.3);
      cursor: none;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .slider::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
          transparent 0%, 
          rgba(255, 255, 255, 0.1) 50%, 
          transparent 100%
      );
      animation: sliderShine 3s ease-in-out infinite;
      pointer-events: none;
    }
    
    @keyframes sliderShine {
      0%, 100% { transform: translateX(-100%); }
      50% { transform: translateX(100%); }
    }
    
    @keyframes sliderPulse {
      0%, 100% { 
        box-shadow: 
          0 3px 10px rgba(0, 0, 0, 0.5),
          inset 0 2px 4px rgba(0, 0, 0, 0.4),
          0 0 15px rgba(139, 0, 0, 0.3);
      }
      50% { 
        box-shadow: 
          0 3px 15px rgba(0, 0, 0, 0.6),
          inset 0 2px 4px rgba(0, 0, 0, 0.4),
          0 0 25px rgba(139, 0, 0, 0.5);
      }
    }
    
    .slider:hover {
      animation: sliderPulse 2s ease-in-out infinite;
    }
    
    .slider:focus {
      border-color: rgba(255, 0, 0, 0.9);
      box-shadow: 
          0 3px 15px rgba(0, 0, 0, 0.6),
          inset 0 2px 4px rgba(0, 0, 0, 0.4),
          0 0 25px rgba(255, 0, 0, 0.4);
    }
    
    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 28px;
      height: 28px;
      background: 
          radial-gradient(circle, 
              #000000 0%, 
              #1a0000 30%, 
              #330000 70%, 
              #660000 100%
          );
      border-radius: 50%;
      border: 3px solid rgba(255, 0, 0, 0.6);
      cursor: none;
      box-shadow: 
          0 0 20px rgba(255, 0, 0, 0.8),
          0 6px 12px rgba(0, 0, 0, 0.5),
          inset 0 2px 4px rgba(255, 0, 0, 0.3);
      transition: all 0.3s ease;
      position: relative;
    }
    
    .slider::-webkit-slider-thumb::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #ff0000 0%, rgba(255, 0, 0, 0.8) 100%);
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.9);
    }
    
    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 
          0 0 30px rgba(255, 0, 0, 1),
          0 8px 16px rgba(0, 0, 0, 0.6),
          inset 0 2px 4px rgba(255, 0, 0, 0.4);
      border-color: rgba(255, 0, 0, 0.8);
    }
    
    .slider::-webkit-slider-thumb:active {
      transform: scale(1.1);
      box-shadow: 
          0 0 25px rgba(255, 0, 0, 0.9),
          0 4px 8px rgba(0, 0, 0, 0.7),
          inset 0 1px 2px rgba(255, 0, 0, 0.5);
    }
    
    .slider::-moz-range-thumb {
      width: 28px;
      height: 28px;
      background: 
          radial-gradient(circle, 
              #000000 0%, 
              #1a0000 30%, 
              #330000 70%, 
              #660000 100%
          );
      border-radius: 50%;
      border: 3px solid rgba(255, 0, 0, 0.6);
      cursor: crosshair;
      box-shadow: 
          0 0 20px rgba(255, 0, 0, 0.8),
          0 6px 12px rgba(0, 0, 0, 0.5),
          inset 0 2px 4px rgba(255, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .slider::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 
          0 0 30px rgba(255, 0, 0, 1),
          0 8px 16px rgba(0, 0, 0, 0.6),
          inset 0 2px 4px rgba(255, 0, 0, 0.4);
      border-color: rgba(255, 0, 0, 0.8);
    }
    
    .slider::-moz-range-thumb:active {
      transform: scale(1.1);
      box-shadow: 
          0 0 25px rgba(255, 0, 0, 0.9),
          0 4px 8px rgba(0, 0, 0, 0.7),
          inset 0 1px 2px rgba(255, 0, 0, 0.5);
    }
    
    /* Enhanced slider track styling */
    .slider::-webkit-slider-track {
      background: transparent;
      border: none;
      height: 12px;
      border-radius: 6px;
    }
    
    .slider::-moz-range-track {
      background: transparent;
      border: none;
      height: 12px;
      border-radius: 6px;
    }
    
    /* Note: Removed old slider-container CSS - now using volume-control structure from music UI */

/* Force update for specific sliders */
#zone-count,
#starting-cp,
#mp-zone-count,
#mp-starting-cp,
#ai-cp,
#mp-player1-cp,
#mp-player2-cp,
#mp-build-points,
#mp-player1-build-points,
#mp-player2-build-points,
#attack-mod,
#defense-mod,
#morale-mod,
#range-mod,
#movement-mod,
#hit-chance-mod {
  width: 100% !important;
  height: 12px !important;
  background: 
      linear-gradient(to right, 
          rgba(0, 0, 0, 0.9) 0%, 
          rgba(20, 0, 0, 0.8) 25%, 
          rgba(139, 0, 0, 0.7) 50%, 
          rgba(180, 0, 0, 0.6) 75%,
          rgba(220, 20, 60, 0.5) 100%
      ) !important;
  border-radius: 6px !important;
  outline: none !important;
  border: 2px solid rgba(139, 0, 0, 0.7) !important;
  box-shadow: 
      0 3px 10px rgba(0, 0, 0, 0.5),
      inset 0 2px 4px rgba(0, 0, 0, 0.4),
      0 0 15px rgba(139, 0, 0, 0.3) !important;
  cursor: none !important;
  transition: all 0.3s ease !important;
}

#zone-count::-webkit-slider-thumb,
#starting-cp::-webkit-slider-thumb,
#mp-zone-count::-webkit-slider-thumb,
#mp-starting-cp::-webkit-slider-thumb,
#ai-cp::-webkit-slider-thumb,
#mp-player1-cp::-webkit-slider-thumb,
#mp-player2-cp::-webkit-slider-thumb,
#mp-build-points::-webkit-slider-thumb,
#mp-player1-build-points::-webkit-slider-thumb,
#mp-player2-build-points::-webkit-slider-thumb,
#attack-mod::-webkit-slider-thumb,
#defense-mod::-webkit-slider-thumb,
#morale-mod::-webkit-slider-thumb,
#range-mod::-webkit-slider-thumb,
#movement-mod::-webkit-slider-thumb,
#hit-chance-mod::-webkit-slider-thumb {
  appearance: none !important;
  width: 28px !important;
  height: 28px !important;
  background: 
      radial-gradient(circle, 
          #000000 0%, 
          #1a0000 30%, 
          #330000 70%, 
          #660000 100%
      ) !important;
  border-radius: 50% !important;
  border: 3px solid rgba(255, 0, 0, 0.6) !important;
  cursor: none !important;
  box-shadow: 
      0 0 20px rgba(255, 0, 0, 0.8),
      0 6px 12px rgba(0, 0, 0, 0.5),
      inset 0 2px 4px rgba(255, 0, 0, 0.3) !important;
  transition: all 0.3s ease !important;
  position: relative !important;
}

#zone-count::-webkit-slider-thumb::before,
#starting-cp::-webkit-slider-thumb::before,
#mp-zone-count::-webkit-slider-thumb::before,
#mp-starting-cp::-webkit-slider-thumb::before,
#ai-cp::-webkit-slider-thumb::before,
#mp-player1-cp::-webkit-slider-thumb::before,
#mp-player2-cp::-webkit-slider-thumb::before,
#mp-build-points::-webkit-slider-thumb::before,
#mp-player1-build-points::-webkit-slider-thumb::before,
#mp-player2-build-points::-webkit-slider-thumb::before,
#attack-mod::-webkit-slider-thumb::before,
#defense-mod::-webkit-slider-thumb::before,
#morale-mod::-webkit-slider-thumb::before,
#range-mod::-webkit-slider-thumb::before,
#movement-mod::-webkit-slider-thumb::before,
#hit-chance-mod::-webkit-slider-thumb::before {
  content: '' !important;
  position: absolute !important;
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  width: 12px !important;
  height: 12px !important;
  background: radial-gradient(circle, #ff0000 0%, rgba(255, 0, 0, 0.8) 100%) !important;
  border-radius: 50% !important;
  box-shadow: 0 0 12px rgba(255, 0, 0, 0.9) !important;
}

#zone-count::-webkit-slider-thumb:hover,
#starting-cp::-webkit-slider-thumb:hover,
#mp-zone-count::-webkit-slider-thumb:hover,
#mp-starting-cp::-webkit-slider-thumb:hover,
#ai-cp::-webkit-slider-thumb:hover,
#mp-player1-cp::-webkit-slider-thumb:hover,
#mp-player2-cp::-webkit-slider-thumb:hover,
#attack-mod::-webkit-slider-thumb:hover,
#defense-mod::-webkit-slider-thumb:hover,
#morale-mod::-webkit-slider-thumb:hover,
#range-mod::-webkit-slider-thumb:hover,
#movement-mod::-webkit-slider-thumb:hover,
#hit-chance-mod::-webkit-slider-thumb:hover {
  transform: scale(1.2) !important;
  box-shadow: 
      0 0 30px rgba(255, 0, 0, 1),
      0 8px 16px rgba(0, 0, 0, 0.6),
      inset 0 2px 4px rgba(255, 0, 0, 0.4) !important;
  border-color: rgba(255, 0, 0, 0.8) !important;
}

#zone-count::-moz-range-thumb,
#starting-cp::-moz-range-thumb,
#mp-zone-count::-moz-range-thumb,
#mp-starting-cp::-moz-range-thumb,
#ai-cp::-moz-range-thumb,
#mp-player1-cp::-moz-range-thumb,
#mp-player2-cp::-moz-range-thumb,
#mp-build-points::-moz-range-thumb,
#mp-player1-build-points::-moz-range-thumb,
#mp-player2-build-points::-moz-range-thumb,
#attack-mod::-moz-range-thumb,
#defense-mod::-moz-range-thumb,
#morale-mod::-moz-range-thumb,
#range-mod::-moz-range-thumb,
#movement-mod::-moz-range-thumb,
#hit-chance-mod::-moz-range-thumb {
  width: 28px !important;
  height: 28px !important;
  background: 
      radial-gradient(circle, 
          #000000 0%, 
          #1a0000 30%, 
          #330000 70%, 
          #660000 100%
      ) !important;
  border-radius: 50% !important;
  border: 3px solid rgba(255, 0, 0, 0.6) !important;
  cursor: crosshair !important;
  box-shadow: 
      0 0 20px rgba(255, 0, 0, 0.8),
      0 6px 12px rgba(0, 0, 0, 0.5),
      inset 0 2px 4px rgba(255, 0, 0, 0.3) !important;
  transition: all 0.3s ease !important;
}
    
    /* Unit Creator Enhanced Styles */
    #unit-creator {
      font-family: 'Cinzel', serif;
      overflow: hidden;
      cursor: none; /* hide default cursor - use skeletal cursor */
      background: #000;
      position: relative;
      color: #ff4444;
    }
    
    /* Ensure skeletal cursor everywhere in Unit Creator (hide native cursor) */
    #unit-creator .unit-creator-container,
    #unit-creator .unit-creator-container * {
      cursor: none !important;
    }
    
    /* Specifically enforce on selects and dropdown options */
    #unit-creator .unit-creator-container select,
    #unit-creator .unit-creator-container select *,
    #unit-creator .unit-creator-container .form-select,
    #unit-creator .unit-creator-container .form-select * {
      cursor: none !important;
      -webkit-appearance: none;
      appearance: none;
    }
    /* Sliders and their tracks/thumbs */
    #unit-creator .unit-creator-container input[type="range"],
    #unit-creator .unit-creator-container .slider,
    #unit-creator .unit-creator-container .slider *,
    #unit-creator .unit-creator-container .volume-slider,
    #unit-creator .unit-creator-container .volume-slider * {
      cursor: none !important; /* force skeletal cursor overlay only */
    }
    /* Hide platform-specific cursors on slider thumb/track */
    #unit-creator .unit-creator-container input[type="range"]::-webkit-slider-thumb,
    #unit-creator .unit-creator-container input[type="range"]::-webkit-slider-runnable-track,
    #unit-creator .unit-creator-container .volume-slider::-webkit-slider-thumb,
    #unit-creator .unit-creator-container .volume-slider::-webkit-slider-runnable-track {
      cursor: none !important;
    }
    #unit-creator .unit-creator-container input[type="range"]::-moz-range-thumb,
    #unit-creator .unit-creator-container input[type="range"]::-moz-range-track {
      cursor: none !important;
    }
    
    .unit-creator-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: 
          radial-gradient(ellipse 120% 100% at center bottom, rgba(139, 0, 0, 0.3) 0%, transparent 60%),
          radial-gradient(ellipse 80% 120% at center top, rgba(20, 0, 0, 0.4) 0%, transparent 50%),
          linear-gradient(180deg, 
              rgba(15, 5, 5, 0.95) 0%, 
              rgba(25, 10, 10, 0.9) 20%,
              rgba(35, 15, 15, 0.85) 50%, 
              rgba(20, 5, 5, 0.95) 80%,
              rgba(5, 0, 0, 1) 100%
          );
      filter: contrast(1.4) brightness(0.7);
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    
    .forge-header {
      text-align: center;
      margin-bottom: 30px;
      position: relative;
    }
    
    .forge-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2.5rem;
      color: #ff4444;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ff0000 0%, #8b0000 30%, #ff3333 60%, #cc0000 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 12px rgba(255, 0, 0, 0.8));
      animation: titleFlicker 8s ease-in-out infinite;
      margin-bottom: 10px;
    }
    
    .forge-subtitle {
      font-size: 1rem;
      color: #cc4444;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(204, 68, 68, 0.6);
    }
    
    .creation-grid {
      display: grid;
      grid-template-columns: 1fr 400px 1.2fr; /* allocate more space to Created Units */
      gap: 30px;
      max-width: 1400px;
      margin: 0 auto;
      min-height: calc(100vh - 200px);
    }
    
    /* Unit Configuration Panel */
    .unit-config-panel {
      background: 
          linear-gradient(135deg, 
              rgba(30, 10, 10, 0.98) 0%, 
              rgba(20, 5, 5, 0.99) 50%, 
              rgba(25, 8, 8, 0.98) 100%
          );
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 25px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
          0 0 40px rgba(255, 0, 0, 0.3),
          0 0 80px rgba(139, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 50, 50, 0.2),
          inset 0 -1px 0 rgba(0, 0, 0, 0.5);
      position: relative;
      animation: panelLevitation 8s ease-in-out infinite;
    }
    
    .unit-config-panel::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
          transparent 20%, 
          rgba(255, 0, 0, 0.3) 30%,
          rgba(139, 0, 0, 0.2) 50%, 
          rgba(255, 0, 0, 0.3) 70%,
          transparent 80%
      );
      border-radius: 12px;
      z-index: -1;
      animation: borderFlow 6s linear infinite;
    }
    
    .panel-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.5rem;
      color: #ff0000;
      text-align: center;
      margin-bottom: 25px;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
      position: relative;
    }
    
    .panel-title::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #ff0000, transparent);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
    }
    
    /* Form Controls */
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-label {
      display: block;
      font-weight: 600;
      font-size: 1rem;
      color: #ff4444;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }
    
    .form-input {
      width: 100%;
      background: rgba(20, 5, 5, 0.9);
      border: 1px solid rgba(139, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      padding: 12px 15px;
      border-radius: 6px;
      box-shadow: 
          0 0 20px rgba(139, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 50, 50, 0.1);
      transition: all 0.3s ease;
      box-sizing: border-box;
    }
    
    .form-input:focus {
      outline: none;
      border-color: rgba(255, 0, 0, 1);
      box-shadow: 
          0 0 30px rgba(255, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 50, 50, 0.2);
      text-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
    }
    
    .form-select {
      width: 100%;
      background: rgba(20, 5, 5, 0.9);
      border: 1px solid rgba(139, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      padding: 12px 15px;
      border-radius: 6px;
      cursor: crosshair;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }
    
    .form-select:focus {
      outline: none;
      border-color: rgba(255, 0, 0, 1);
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
    }
    
    .form-select option {
      background: rgba(20, 5, 5, 0.95);
      color: #ff4444;
    }
    
    /* Stat Controls Panel */
    .stat-controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 15px;
    }
    
    .stat-control {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 3, 3, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 8px 12px;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
      min-height: 40px;
    }
    
    .stat-label {
      font-weight: 600;
      font-size: 0.9rem;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 80px;
    }
    
    /* Enhanced volume control for unit creator */
    #unit-creator .volume-control {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      max-width: 350px;
      height: 32px;
      padding: 0 8px;
    }
    
    /* Army Builder Demonic Theme */
    #army-builder {
      font-family: 'Cinzel', serif;
      overflow: hidden;
      cursor: crosshair;
      background: #000;
      position: relative;
      color: #ff4444;
    }
    
    .army-builder-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: 
          radial-gradient(ellipse 120% 100% at center bottom, rgba(139, 0, 0, 0.3) 0%, transparent 60%),
          radial-gradient(ellipse 80% 120% at center top, rgba(20, 0, 0, 0.4) 0%, transparent 50%),
          linear-gradient(180deg, 
              rgba(15, 5, 5, 0.95) 0%, 
              rgba(25, 10, 10, 0.9) 20%,
              rgba(35, 15, 15, 0.85) 50%, 
              rgba(20, 5, 5, 0.95) 80%,
              rgba(5, 0, 0, 1) 100%
          );
      filter: contrast(1.4) brightness(0.7);
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    
    .war-council-header {
      text-align: center;
      margin-bottom: 30px;
      position: relative;
    }
    
    .war-council-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2.5rem;
      color: #ff4444;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ff0000 0%, #8b0000 30%, #ff3333 60%, #cc0000 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 12px rgba(255, 0, 0, 0.8));
      animation: titleFlicker 8s ease-in-out infinite;
      margin-bottom: 10px;
    }
    
    .war-council-subtitle {
      font-size: 1rem;
      color: #cc4444;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(204, 68, 68, 0.6);
    }
    
    .command-grid {
      display: grid;
      grid-template-columns: 400px 1fr 350px;
      gap: 30px;
      max-width: 1400px;
      margin: 0 auto;
      min-height: calc(100vh - 200px);
    }
    
    /* Army Configuration Panel */
    .army-config-panel {
      background: 
          linear-gradient(135deg, 
              rgba(30, 10, 10, 0.98) 0%, 
              rgba(20, 5, 5, 0.99) 50%, 
              rgba(25, 8, 8, 0.98) 100%
          );
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 25px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
          0 0 40px rgba(255, 0, 0, 0.3),
          0 0 80px rgba(139, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 50, 50, 0.2),
          inset 0 -1px 0 rgba(0, 0, 0, 0.5);
      position: relative;
      animation: panelLevitation 8s ease-in-out infinite;
    }
    
    .army-config-panel::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
          transparent 20%, 
          rgba(255, 0, 0, 0.3) 30%,
          rgba(139, 0, 0, 0.2) 50%, 
          rgba(255, 0, 0, 0.3) 70%,
          transparent 80%
      );
      border-radius: 12px;
      z-index: -1;
      animation: borderFlow 6s linear infinite;
    }
    
    .panel-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.5rem;
      color: #ff0000;
      text-align: center;
      margin-bottom: 25px;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
      position: relative;
    }
    
    .panel-title::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #ff0000, transparent);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
    }
    
    /* Unit Counter */
    .army-counter {
      background: rgba(15, 3, 3, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      margin-bottom: 20px;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }
    
    .counter-label {
      font-size: 0.9rem;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    
    .counter-value {
      font-family: 'Orbitron', monospace;
      font-size: 2rem;
      font-weight: 700;
      color: #ff0000;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
    }
    
    /* Current Army List */
    .current-army-list {
      max-height: 300px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(139, 0, 0, 0.8) rgba(20, 5, 5, 0.9);
      margin-bottom: 20px;
    }
    
    .current-army-list::-webkit-scrollbar {
      width: 8px;
    }
    
    .current-army-list::-webkit-scrollbar-track {
      background: rgba(20, 5, 5, 0.9);
      border-radius: 4px;
    }
    
    .current-army-list::-webkit-scrollbar-thumb {
      background: rgba(139, 0, 0, 0.8);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    
    .army-unit {
      background: rgba(15, 3, 3, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
    }
    
    .army-unit:hover {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
      transform: translateX(3px);
    }
    
    .unit-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .unit-icon {
      font-size: 1.5rem;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
    }
    
    .unit-details {
      display: flex;
      flex-direction: column;
    }
    
    .unit-name {
      font-weight: 600;
      color: #ff0000;
      text-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
      margin-bottom: 2px;
    }
    
    .unit-type {
      font-size: 0.8rem;
      color: #cc4444;
      opacity: 0.8;
      text-transform: uppercase;
    }
    
    .remove-unit-btn {
      background: rgba(80, 0, 0, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.8);
      color: #fff;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: crosshair;
      transition: all 0.3s ease;
    }
    
    .remove-unit-btn:hover {
      background: rgba(120, 0, 0, 0.8);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
      transform: scale(1.05);
    }
    
    /* Available Units Panel */
    .available-units-panel {
      background: 
          linear-gradient(135deg, 
              rgba(30, 10, 10, 0.98) 0%, 
              rgba(20, 5, 5, 0.99) 50%, 
              rgba(25, 8, 8, 0.98) 100%
          );
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 25px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
          0 0 40px rgba(255, 0, 0, 0.3),
          0 0 80px rgba(139, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 50, 50, 0.2);
      position: relative;
      animation: panelLevitation 8s ease-in-out infinite reverse;
    }
    
    /* Unit Tabs */
    .unit-tabs {
      display: flex;
      margin-bottom: 20px;
      gap: 10px;
    }
    
    .tab-button {
      flex: 1;
      background: rgba(20, 5, 5, 0.9);
      border: 1px solid rgba(139, 0, 0, 0.6);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: crosshair;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .tab-button:hover {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
    }
    
    .tab-button.active {
      background: rgba(60, 15, 15, 0.9);
      border-color: rgba(255, 0, 0, 1);
      color: #ff0000;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
    }
    
    /* Available Units Pool */
    .available-units-pool {
      max-height: 500px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(139, 0, 0, 0.8) rgba(20, 5, 5, 0.9);
    }
    
    .available-units-pool::-webkit-scrollbar {
      width: 8px;
    }
    
    .available-units-pool::-webkit-scrollbar-track {
      background: rgba(20, 5, 5, 0.9);
      border-radius: 4px;
    }
    
    .available-units-pool::-webkit-scrollbar-thumb {
      background: rgba(139, 0, 0, 0.8);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    
    .available-unit {
      background: rgba(15, 3, 3, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      transition: all 0.3s ease;
      cursor: none;
    }
    
    .available-unit:hover {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
      transform: translateX(5px);
    }
    
    .unit-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .unit-stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    
    .stat {
      background: rgba(139, 0, 0, 0.3);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 0.8rem;
      color: #ff4444;
    }
    
    .add-unit-btn {
      background: rgba(60, 15, 15, 0.8);
      border: 1px solid rgba(255, 0, 0, 0.8);
      color: #fff;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: crosshair;
      transition: all 0.3s ease;
      width: 100%;
    }
    
    .add-unit-btn:hover {
      background: rgba(100, 25, 25, 0.8);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
      transform: scale(1.02);
    }
    
    .add-unit-btn:disabled {
      background: rgba(40, 10, 10, 0.5);
      border-color: rgba(100, 0, 0, 0.5);
      color: rgba(255, 255, 255, 0.5);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Saved Armies Panel */
    .saved-armies-panel {
      background: 
          linear-gradient(135deg, 
              rgba(30, 10, 10, 0.98) 0%, 
              rgba(20, 5, 5, 0.99) 50%, 
              rgba(25, 8, 8, 0.98) 100%
          );
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 25px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
          0 0 40px rgba(255, 0, 0, 0.3),
          0 0 80px rgba(139, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 50, 50, 0.2);
      position: relative;
      animation: panelLevitation 8s ease-in-out infinite;
      animation-delay: -2s;
    }
    
    .saved-armies-list {
      max-height: 400px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(139, 0, 0, 0.8) rgba(20, 5, 5, 0.9);
    }
    
    .saved-armies-list::-webkit-scrollbar {
      width: 8px;
    }
    
    .saved-armies-list::-webkit-scrollbar-track {
      background: rgba(20, 5, 5, 0.9);
      border-radius: 4px;
    }
    
    .saved-armies-list::-webkit-scrollbar-thumb {
      background: rgba(139, 0, 0, 0.8);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    
    .saved-army {
      background: rgba(15, 3, 3, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      transition: all 0.3s ease;
    }
    
    .saved-army:hover {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
      transform: translateX(5px);
    }
    
    .army-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .army-name {
      font-weight: 700;
      font-size: 1.1rem;
      color: #ff0000;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
    }
    
    .army-count {
      font-size: 0.9rem;
      color: #cc4444;
      opacity: 0.8;
    }
    
    .army-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
    }
    
    .small-button {
      background: rgba(139, 0, 0, 0.8);
      border: 1px solid rgba(255, 0, 0, 0.8);
      color: #fff;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: crosshair;
      transition: all 0.3s ease;
    }
    
    .small-button:hover {
      background: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
      transform: scale(1.05);
    }
    
    .small-button.delete {
      background: rgba(80, 0, 0, 0.8);
    }
    
    /* Atmospheric Effects */
    .war-atmosphere {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: 
          radial-gradient(circle at 20% 80%, rgba(139, 0, 0, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(80, 0, 0, 0.08) 0%, transparent 50%);
      animation: atmosphereShift 12s ease-in-out infinite;
    }
    
    /* Animations */
    @keyframes titleFlicker {
      0%, 100% { opacity: 1; }
      2% { opacity: 0.8; }
      4% { opacity: 1; }
      15% { opacity: 0.9; }
      16% { opacity: 1; }
    }
    
    @keyframes panelLevitation {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    @keyframes borderFlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes atmosphereShift {
      0%, 100% { opacity: 0.6; }
      33% { opacity: 0.8; }
      66% { opacity: 0.4; }
    }
    
    /* Responsive Design */
    @media (max-width: 1200px) {
      .command-grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }
    }
    
    @media (max-width: 768px) {
      .army-builder-container {
        padding: 15px;
      }
      
      .war-council-title {
        font-size: 2rem;
      }
      
      .command-grid {
        gap: 15px;
      }
      
      .army-config-panel, 
      .available-units-panel, 
      .saved-armies-panel {
        padding: 20px;
      }
      
      .unit-tabs {
        flex-direction: column;
        gap: 5px;
      }
    }
    
    #unit-creator .volume-slider {
      flex: 1;
      height: 12px !important;
      background: 
          linear-gradient(90deg, 
              rgba(139, 0, 0, 0.8) 0%, 
              rgba(255, 0, 0, 0.6) 50%, 
              rgba(139, 0, 0, 0.8) 100%
          ) !important;
      border-radius: 6px !important;
      outline: none !important;
      cursor: crosshair !important;
      appearance: none !important;
      -webkit-appearance: none !important;
      border: 1px solid rgba(139, 0, 0, 0.9) !important;
      box-shadow: 
          0 0 15px rgba(255, 0, 0, 0.3),
          inset 0 0 10px rgba(0, 0, 0, 0.6) !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Force override for unit creator sliders with maximum specificity */
    #unit-creator input[type="range"].volume-slider {
      height: 12px !important;
      min-height: 12px !important;
      max-height: 12px !important;
    }
    
    #unit-creator input[type="range"].volume-slider::-webkit-slider-track {
      height: 12px !important;
    }
    
    #unit-creator input[type="range"].volume-slider::-moz-range-track {
      height: 12px !important;
    }
    
    #unit-creator .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none !important;
      width: 24px !important;
      height: 24px !important;
      background: 
          radial-gradient(circle, 
              rgba(255, 0, 0, 0.9) 0%, 
              rgba(139, 0, 0, 0.8) 70%, 
              rgba(80, 0, 0, 1) 100%
          ) !important;
      border: 2px solid rgba(255, 0, 0, 0.8) !important;
      border-radius: 50% !important;
      cursor: crosshair !important;
      box-shadow: 
          0 0 15px rgba(255, 0, 0, 0.6),
          0 0 25px rgba(139, 0, 0, 0.4) !important;
      transition: all 0.3s ease !important;
    }
    
    #unit-creator .volume-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 
          0 0 20px rgba(255, 0, 0, 0.8),
          0 0 35px rgba(139, 0, 0, 0.6);
    }
    
    #unit-creator .volume-slider::-moz-range-thumb {
      width: 24px !important;
      height: 24px !important;
      background: 
          radial-gradient(circle, 
              rgba(255, 0, 0, 0.9) 0%, 
              rgba(139, 0, 0, 0.8) 70%, 
              rgba(80, 0, 0, 1) 100%
          ) !important;
      border: 2px solid rgba(255, 0, 0, 0.8) !important;
      border-radius: 50% !important;
      cursor: none !important;
      box-shadow: 
          0 0 15px rgba(255, 0, 0, 0.6),
          0 0 25px rgba(139, 0, 0, 0.4) !important;
    }
    
    /* NEW: Unit Creator Sliders - Completely fresh styling */
    .unit-creator-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 16px;
      background: 
          linear-gradient(90deg, 
              rgba(20, 5, 5, 0.9) 0%, 
              rgba(139, 0, 0, 0.7) 25%, 
              rgba(255, 0, 0, 0.6) 50%, 
              rgba(139, 0, 0, 0.7) 75%, 
              rgba(20, 5, 5, 0.9) 100%
          );
      border-radius: 8px;
      outline: none;
      border: 2px solid rgba(139, 0, 0, 0.8);
      box-shadow: 
          0 0 20px rgba(255, 0, 0, 0.3),
          inset 0 2px 4px rgba(0, 0, 0, 0.6),
          0 2px 8px rgba(0, 0, 0, 0.4);
      cursor: none;
      transition: all 0.3s ease;
      margin: 0;
      padding: 0;
    }
    
    .unit-creator-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      background: 
          radial-gradient(circle, 
              rgba(255, 0, 0, 0.95) 0%, 
              rgba(200, 0, 0, 0.9) 30%, 
              rgba(139, 0, 0, 0.8) 70%, 
              rgba(80, 0, 0, 1) 100%
          );
      border: 3px solid rgba(255, 0, 0, 0.9);
      border-radius: 50%;
      cursor: none;
      box-shadow: 
          0 0 20px rgba(255, 0, 0, 0.8),
          0 0 40px rgba(139, 0, 0, 0.6),
          0 4px 12px rgba(0, 0, 0, 0.5),
          inset 0 2px 4px rgba(255, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .unit-creator-slider::-webkit-slider-thumb:hover {
      transform: scale(1.15);
      box-shadow: 
          0 0 30px rgba(255, 0, 0, 1),
          0 0 60px rgba(139, 0, 0, 0.8),
          0 6px 16px rgba(0, 0, 0, 0.6),
          inset 0 2px 4px rgba(255, 0, 0, 0.4);
      border-color: rgba(255, 0, 0, 1);
    }
    
    .unit-creator-slider::-webkit-slider-thumb:active {
      transform: scale(1.1);
      box-shadow: 
          0 0 25px rgba(255, 0, 0, 0.9),
          0 0 50px rgba(139, 0, 0, 0.7),
          0 3px 10px rgba(0, 0, 0, 0.7),
          inset 0 1px 2px rgba(255, 0, 0, 0.5);
    }
    
    .unit-creator-slider::-moz-range-thumb {
      width: 28px;
      height: 28px;
      background: 
          radial-gradient(circle, 
              rgba(255, 0, 0, 0.95) 0%, 
              rgba(200, 0, 0, 0.9) 30%, 
              rgba(139, 0, 0, 0.8) 70%, 
              rgba(80, 0, 0, 1) 100%
          );
      border: 3px solid rgba(255, 0, 0, 0.9);
      border-radius: 50%;
      cursor: none;
      box-shadow: 
          0 0 20px rgba(255, 0, 0, 0.8),
          0 0 40px rgba(139, 0, 0, 0.6),
          0 4px 12px rgba(0, 0, 0, 0.5),
          inset 0 2px 4px rgba(255, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .unit-creator-slider::-moz-range-thumb:hover {
      transform: scale(1.15);
      box-shadow: 
          0 0 30px rgba(255, 0, 0, 1),
          0 0 60px rgba(139, 0, 0, 0.8),
          0 6px 16px rgba(0, 0, 0, 0.6),
          inset 0 2px 4px rgba(255, 0, 0, 0.4);
      border-color: rgba(255, 0, 0, 1);
      cursor: none;
    }
    
    .unit-creator-slider::-webkit-slider-track {
      background: transparent;
      border: none;
      height: 16px;
      border-radius: 8px;
    }
    
    .unit-creator-slider::-moz-range-track {
      background: transparent;
      border: none;
      height: 16px;
      border-radius: 8px;
    }
    

    
    #unit-creator .volume-value {
      min-width: 35px;
      text-align: center;
      font-weight: 700;
      font-size: 1rem;
      color: #ff0000;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
      background: rgba(20, 5, 5, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 4px;
      padding: 6px 8px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Unit Preview Panel */
    .unit-preview-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: 
          linear-gradient(135deg, 
              rgba(30, 10, 10, 0.98) 0%, 
              rgba(20, 5, 5, 0.99) 50%, 
              rgba(25, 8, 8, 0.98) 100%
          );
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 25px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
          0 0 40px rgba(255, 0, 0, 0.3),
          0 0 80px rgba(139, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 50, 50, 0.2);
      position: relative;
      animation: panelLevitation 8s ease-in-out infinite reverse;
    }
    
    .unit-preview {
      width: 120px;
      height: 120px;
      background: 
          radial-gradient(circle, 
              rgba(139, 0, 0, 0.8) 0%, 
              rgba(80, 0, 0, 0.6) 50%, 
              rgba(40, 0, 0, 0.9) 100%
          );
      border: 3px solid rgba(255, 0, 0, 0.8);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      color: #ff0000;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      box-shadow: 
          0 0 30px rgba(255, 0, 0, 0.4),
          inset 0 0 30px rgba(0, 0, 0, 0.6);
      animation: unitPulse 3s ease-in-out infinite;
      margin-bottom: 20px;
    }
    
    .unit-name-display {
      font-size: 1.3rem;
      font-weight: 700;
      color: #ff0000;
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
      min-height: 30px;
    }
    
    .unit-type-display {
      font-size: 1rem;
      color: #cc4444;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 20px;
    }
    
    .unit-stats-display {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      width: 100%;
    }
    
    .stat-display {
      background: rgba(15, 3, 3, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 6px;
      padding: 8px 12px;
      text-align: center;
    }
    
    .stat-name {
      font-size: 0.8rem;
      color: #ff4444;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    .stat-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: #ff0000;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
    }
    
    .special-ability-display {
      background: rgba(15, 3, 3, 0.9);
      border: 2px solid rgba(139, 0, 0, 0.8);
      border-radius: 8px;
      padding: 12px;
      margin-top: 15px;
      text-align: center;
    }
    
    .special-ability-label {
      font-size: 0.9rem;
      color: #ff6666;
      text-transform: uppercase;
      margin-bottom: 6px;
      font-weight: 600;
    }
    
    .special-ability-value {
      font-size: 1rem;
      font-weight: 700;
      color: #ffaa00;
      text-shadow: 0 0 8px rgba(255, 170, 0, 0.6);
      min-height: 20px;
      cursor: help;
      position: relative;
    }
    
    .custom-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.95);
      color: #ffaa00;
      padding: 10px 15px;
      border-radius: 8px;
      border: 2px solid #ffaa00;
      font-size: 0.9rem;
      max-width: 300px;
      z-index: 10000;
      pointer-events: none;
      box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s ease;
      white-space: normal;
      line-height: 1.4;
    }
    
    .custom-tooltip.show {
      opacity: 1;
    }
    
    /* Unit List Panel */
    .unit-list-panel {
      background: 
          linear-gradient(135deg, 
              rgba(30, 10, 10, 0.98) 0%, 
              rgba(20, 5, 5, 0.99) 50%, 
              rgba(25, 8, 8, 0.98) 100%
          );
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 25px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
          0 0 40px rgba(255, 0, 0, 0.3),
          0 0 80px rgba(139, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 50, 50, 0.2);
      position: relative;
      animation: panelLevitation 8s ease-in-out infinite;
      animation-delay: -2s;
    }
    
    .unit-list {
      max-height: 650px; /* show more units */
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(139, 0, 0, 0.8) rgba(20, 5, 5, 0.9);
    }
    
    .unit-list::-webkit-scrollbar {
      width: 8px;
    }
    
    .unit-list::-webkit-scrollbar-track {
      background: rgba(20, 5, 5, 0.9);
      border-radius: 4px;
    }
    
    .unit-list::-webkit-scrollbar-thumb {
      background: rgba(139, 0, 0, 0.8);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    
    .unit-item {
      background: rgba(15, 3, 3, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      transition: all 0.3s ease;
    }
    
    .unit-item:hover {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
      transform: translateX(5px);
    }
    
    .unit-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .unit-item-name {
      font-weight: 700;
      font-size: 1.1rem;
      color: #ff0000;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
    }
    
    .unit-item-type {
      font-size: 0.9rem;
      color: #cc4444;
      opacity: 0.8;
      text-transform: uppercase;
    }
    
    .unit-stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    
    .stat {
      background: rgba(139, 0, 0, 0.3);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 0.8rem;
      color: #ff4444;
    }
    
    .unit-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    .small-button {
      background: rgba(139, 0, 0, 0.8);
      border: 1px solid rgba(255, 0, 0, 0.8);
      color: #fff;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: crosshair;
      transition: all 0.3s ease;
    }
    
    .small-button:hover {
      background: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
      transform: scale(1.05);
    }
    
    .small-button.delete {
      background: rgba(80, 0, 0, 0.8);
    }
    
    /* Action Buttons */
    .action-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 20px;
    }
    
    .action-button {
      background: 
          linear-gradient(135deg, 
              rgba(80, 20, 20, 0.98) 0%, 
              rgba(60, 15, 15, 0.99) 50%, 
              rgba(75, 18, 18, 0.98) 100%
          );
      border: 1px solid rgba(255, 0, 0, 0.9);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.1rem;
      padding: 15px 30px;
      cursor: crosshair;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 0 12px rgba(255, 68, 68, 0.6);
      letter-spacing: 1px;
      border-radius: 8px;
      box-shadow: 
          0 4px 20px rgba(139, 0, 0, 0.6),
          0 0 30px rgba(255, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 50, 50, 0.15),
          inset 0 -1px 0 rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      position: relative;
      overflow: hidden;
    }
    
    .action-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent 0%, 
          rgba(255, 0, 0, 0.2) 30%, 
          rgba(255, 50, 50, 0.4) 50%, 
          rgba(255, 0, 0, 0.2) 70%, 
          transparent 100%
      );
      transition: left 0.6s ease;
      z-index: 1;
    }
    
    .action-button span {
      position: relative;
      z-index: 2;
    }
    
    .action-button:hover {
      background: 
          linear-gradient(135deg, 
              rgba(120, 30, 30, 0.98) 0%, 
              rgba(90, 25, 25, 0.99) 50%, 
              rgba(110, 28, 28, 0.98) 100%
          );
      color: #ff0000;
      border-color: rgba(255, 0, 0, 1);
      transform: translateY(-3px) scale(1.02);
      box-shadow: 
          0 8px 35px rgba(255, 0, 0, 0.4),
          0 0 50px rgba(255, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 50, 50, 0.3);
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.9);
    }
    
    .action-button:hover::before {
      left: 100%;
    }
    
    .back-button {
      position: absolute;
      top: 30px;
      left: 30px;
      background: rgba(30, 10, 10, 0.9);
      border: 1px solid rgba(139, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      padding: 12px 20px;
      cursor: crosshair;
      transition: all 0.3s ease;
      border-radius: 6px;
      text-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
    }
    
    .back-button:hover {
      background: rgba(50, 15, 15, 0.9);
      border-color: rgba(255, 0, 0, 1);
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
      transform: translateY(-2px);
    }
    
    /* Atmospheric Effects */
    .forge-atmosphere {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: 
          radial-gradient(circle at 20% 80%, rgba(139, 0, 0, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(80, 0, 0, 0.08) 0%, transparent 50%);
      animation: atmosphereShift 12s ease-in-out infinite;
    }
    
    /* Animations */
    @keyframes titleFlicker {
      0%, 100% { opacity: 1; }
      2% { opacity: 0.8; }
      4% { opacity: 1; }
      15% { opacity: 0.9; }
      16% { opacity: 1; }
    }
    
    @keyframes panelLevitation {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    @keyframes borderFlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes unitPulse {
      0%, 100% { 
          box-shadow: 
              0 0 30px rgba(255, 0, 0, 0.4),
              inset 0 0 30px rgba(0, 0, 0, 0.6);
      }
      50% { 
          box-shadow: 
              0 0 50px rgba(255, 0, 0, 0.6),
              inset 0 0 30px rgba(0, 0, 0, 0.6);
      }
    }
    
    @keyframes atmosphereShift {
      0%, 100% { opacity: 0.6; }
      33% { opacity: 0.8; }
      66% { opacity: 0.4; }
    }
    
    @keyframes emberRise {
      0% {
          bottom: -10px;
          opacity: 0;
          transform: translateX(0) scale(0.3);
      }
      10% {
          opacity: 1;
      }
      90% {
          opacity: 0.6;
      }
      100% {
          bottom: 100vh;
          opacity: 0;
          transform: translateX(var(--random-x, 0px)) scale(0.1);
      }
    }
    
    /* Responsive Design */
    @media (max-width: 1200px) {
      .creation-grid {
          grid-template-columns: 1fr;
          gap: 20px;
      }
      
      .unit-preview-panel {
          order: -1;
      }
    }
    
    @media (max-width: 768px) {
      .unit-creator-container {
          padding: 15px;
      }
      
      .forge-title {
          font-size: 2rem;
      }
      
      .creation-grid {
          gap: 15px;
      }
      
      .unit-config-panel, 
      .unit-preview-panel, 
      .unit-list-panel {
          padding: 20px;
      }
      
      .unit-stats-display {
          grid-template-columns: 1fr;
      }
    }
    
    .small-button:disabled {
      background: #444;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    /* Zone Detail Screen - PHASE 1 ENHANCEMENT */
    .zone-detail-container {
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 30px;
      position: relative;
    }

    .zone-detail-container::before {
      content: '';
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background: 
        linear-gradient(135deg, 
          rgba(139, 0, 0, 0.1) 0%, 
          rgba(0, 0, 0, 0.3) 50%, 
          rgba(139, 0, 0, 0.1) 100%
        ),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="demonicNoise"><feTurbulence baseFrequency="0.8" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.02 0.05 0.08 0.03"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23demonicNoise)" opacity="0.3"/></svg>');
      border-radius: 15px;
      z-index: -1;
      animation: demonicPulse 8s ease-in-out infinite;
    }

    @keyframes demonicPulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.5; }
    }
    
    .zone-battlefield {
      background: 
        linear-gradient(135deg, 
          rgba(30, 10, 10, 0.95) 0%, 
          rgba(20, 5, 5, 0.98) 50%, 
          rgba(25, 8, 8, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.8);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(10px);
      box-shadow: 
        0 0 40px rgba(255, 0, 0, 0.2),
        0 0 80px rgba(139, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
      position: relative;
    }

    .zone-battlefield::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(ellipse at 20% 20%, rgba(255, 0, 0, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(139, 0, 0, 0.1) 0%, transparent 50%);
      border-radius: 15px;
      pointer-events: none;
      z-index: -1;
    }
    
    .mini-battlefield {
      display: grid;
      gap: 8px;
      margin-bottom: 30px;
      padding: 20px;
      background: 
        linear-gradient(135deg, 
          rgba(15, 5, 5, 0.9) 0%, 
          rgba(10, 3, 3, 0.95) 50%, 
          rgba(12, 4, 4, 0.9) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.6);
      border-radius: 12px;
      box-shadow: 
        0 0 30px rgba(255, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
      position: relative;
    }

    .mini-battlefield::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 30% 30%, rgba(255, 0, 0, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 70% 70%, rgba(139, 0, 0, 0.05) 0%, transparent 50%);
      border-radius: 12px;
      pointer-events: none;
      z-index: -1;
    }
    
    .mini-zone {
      background: 
        linear-gradient(135deg, 
          rgba(40, 15, 15, 0.8) 0%, 
          rgba(30, 10, 10, 0.9) 50%, 
          rgba(35, 12, 12, 0.8) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.4);
      border-radius: 8px;
      padding: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      position: relative;
      font-size: 11px;
      font-family: 'Cinzel', serif;
      color: #ff8888;
      box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
    }
    
    .mini-zone:hover {
      transform: scale(1.05);
      background: 
        linear-gradient(135deg, 
          rgba(60, 20, 20, 0.9) 0%, 
          rgba(45, 15, 15, 0.95) 50%, 
          rgba(50, 17, 17, 0.9) 100%
        );
      border-color: rgba(255, 0, 0, 0.6);
      box-shadow: 
        0 4px 15px rgba(255, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 100, 100, 0.2);
    }
    
    .mini-zone.has-unit {
      border-width: 3px;
      font-weight: bold;
      box-shadow: 
        0 4px 15px rgba(255, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 100, 100, 0.3);
    }
    
    .mini-zone.red-unit {
      border-color: #DC143C;
      background: 
        linear-gradient(135deg, 
          rgba(220, 20, 60, 0.4) 0%, 
          rgba(180, 15, 45, 0.5) 50%, 
          rgba(200, 18, 52, 0.4) 100%
        );
      color: #FFE4E1;
      box-shadow: 
        0 4px 15px rgba(220, 20, 60, 0.4),
        inset 0 1px 0 rgba(255, 100, 100, 0.3);
    }
    
    .mini-zone.blue-unit {
      border-color: #4169E1;
      background: 
        linear-gradient(135deg, 
          rgba(65, 105, 225, 0.4) 0%, 
          rgba(50, 80, 180, 0.5) 50%, 
          rgba(58, 92, 202, 0.4) 100%
        );
      color: #E6E6FA;
      box-shadow: 
        0 4px 15px rgba(65, 105, 225, 0.4),
        inset 0 1px 0 rgba(100, 150, 255, 0.3);
    }
    
    .mini-zone.has-construction {
      border-width: 3px;
      box-shadow: 
        0 4px 15px rgba(255, 215, 0, 0.3),
        inset 0 1px 0 rgba(255, 215, 0, 0.2);
    }
    
    .mini-zone.red-construction {
      border-color: #DC143C;
      background: 
        linear-gradient(135deg, 
          rgba(220, 20, 60, 0.3) 0%, 
          rgba(180, 15, 45, 0.4) 50%, 
          rgba(200, 18, 52, 0.3) 100%
        );
    }
    
    .mini-zone.blue-construction {
      border-color: #4169E1;
      background: 
        linear-gradient(135deg, 
          rgba(65, 105, 225, 0.3) 0%, 
          rgba(50, 80, 180, 0.4) 50%, 
          rgba(58, 92, 202, 0.3) 100%
        );
    }
    
    .construction-marker {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: white;
      font-weight: bold;
      font-family: 'Orbitron', monospace;
      box-shadow: 
        0 2px 6px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .construction-marker.completed {
      background: 
        linear-gradient(135deg, #FFD700 0%, #DAA520 50%, #FFD700 100%);
      border: 1px solid rgba(255, 215, 0, 0.6);
      box-shadow: 
        0 2px 6px rgba(255, 215, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      animation: constructionGlow 2s ease-in-out infinite;
    }

    @keyframes constructionGlow {
      0%, 100% { box-shadow: 0 2px 6px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3); }
      50% { box-shadow: 0 4px 12px rgba(255, 215, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.4); }
    }
    
    .construction-marker.building {
      background: 
        linear-gradient(135deg, #FF4500 0%, #8B0000 50%, #FF4500 100%);
      border: 1px dashed rgba(255, 255, 255, 0.5);
      animation: constructionBuild 2s infinite;
    }

    @keyframes constructionBuild {
      0%, 100% { transform: scale(1) rotate(0deg); }
      50% { transform: scale(1.1) rotate(180deg); }
    }
    
    .construction-progress {
      position: absolute;
      bottom: 4px;
      right: 4px;
      background: 
        linear-gradient(135deg, 
          rgba(0, 0, 0, 0.9) 0%, 
          rgba(20, 5, 5, 0.95) 50%, 
          rgba(0, 0, 0, 0.9) 100%
        );
      color: #FFD700;
      font-size: 9px;
      font-weight: bold;
      font-family: 'Orbitron', monospace;
      padding: 2px 4px;
      border-radius: 3px;
      border: 1px solid rgba(255, 215, 0, 0.4);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
    }

    /* ENHANCED UNIT MARKERS - PHASE 1 */
    .unit-marker {
      position: absolute;
      bottom: 4px;
      left: 4px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      color: white;
      font-family: 'Orbitron', monospace;
      text-transform: uppercase;
      box-shadow: 
        0 2px 6px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      animation: unitPulse 3s ease-in-out infinite;
    }

    @keyframes unitPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .unit-marker.red-unit {
      background: 
        linear-gradient(135deg, #DC143C 0%, #B22222 50%, #DC143C 100%);
      box-shadow: 
        0 2px 6px rgba(220, 20, 60, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    .unit-marker.blue-unit {
      background: 
        linear-gradient(135deg, #4169E1 0%, #2E4B8F 50%, #4169E1 100%);
      box-shadow: 
        0 2px 6px rgba(65, 105, 225, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    /* ENHANCED INFO BUTTON - PHASE 1 */
    .unit-info-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 14px;
      height: 14px;
      background: 
        linear-gradient(135deg, 
          rgba(255, 0, 0, 0.8) 0%, 
          rgba(139, 0, 0, 0.9) 50%, 
          rgba(255, 0, 0, 0.8) 100%
        );
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-weight: bold;
      font-family: 'Orbitron', monospace;
      cursor: help;
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 
        0 2px 4px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
      z-index: 10;
    }

    .unit-info-button:hover {
      transform: translate(-50%, -50%) scale(1.2);
      background: 
        linear-gradient(135deg, 
          rgba(255, 0, 0, 1) 0%, 
          rgba(139, 0, 0, 1) 50%, 
          rgba(255, 0, 0, 1) 100%
        );
      box-shadow: 
        0 4px 8px rgba(255, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    /* ENHANCED MOVEMENT INDICATOR - PHASE 1 */
    .movement-indicator {
      position: absolute;
      top: 2px;
      left: 2px;
      background: 
        linear-gradient(135deg, 
          rgba(0, 255, 0, 0.8) 0%, 
          rgba(0, 128, 0, 0.9) 50%, 
          rgba(0, 255, 0, 0.8) 100%
        );
      color: white;
      font-size: 8px;
      font-weight: bold;
      font-family: 'Orbitron', monospace;
      padding: 2px 4px;
      border-radius: 3px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      animation: movementPulse 2s ease-in-out infinite;
    }

    @keyframes movementPulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    /* ENHANCED VOLCANIC DAMAGE INDICATOR - PHASE 1 */
    .volcanic-damage-indicator {
      position: absolute;
      bottom: 2px;
      left: 2px;
      font-size: 10px;
      animation: volcanicBurn 1s ease-in-out infinite;
    }

    @keyframes volcanicBurn {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.2); opacity: 1; }
    }
    
    @keyframes pulse-construction {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .mini-zone.selectable {
      border-color: #FFD700;
      background: rgba(255, 215, 0, 0.2);
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .mini-zone.air-defense-target {
      border-color: #FF4500;
      background: rgba(255, 69, 0, 0.3);
      box-shadow: 0 0 15px rgba(255, 69, 0, 0.7);
      animation: air-defense-pulse 1s infinite;
    }
    
    @keyframes air-defense-pulse {
      0% { box-shadow: 0 0 15px rgba(255, 69, 0, 0.7); }
      50% { box-shadow: 0 0 25px rgba(255, 69, 0, 0.9); }
      100% { box-shadow: 0 0 15px rgba(255, 69, 0, 0.7); }
    }
    
    .mini-zone.deployment-zone {
      border-color: #32CD32;
      background: rgba(50, 205, 50, 0.2);
    }
    
    .mini-zone.attacker-zone {
      /* Dynamic color will be set via JavaScript */
      background: rgba(220, 20, 60, 0.15);
    }
    
    .mini-zone.defender-zone {
      /* Dynamic color will be set via JavaScript */
      background: rgba(65, 105, 225, 0.15);
    }
    
    .mini-zone.movement-zone {
      border-color: #9C27B0;
      background: rgba(156, 39, 176, 0.2);
      box-shadow: 0 0 10px rgba(156, 39, 176, 0.5);
      animation: pulse-move 1.5s infinite;
    }
    
    @keyframes pulse-move {
      0% { box-shadow: 0 0 0 0 rgba(156, 39, 176, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(156, 39, 176, 0); }
      100% { box-shadow: 0 0 0 0 rgba(156, 39, 176, 0); }
    }
    
    /* ENHANCED TERRAIN STYLES - PHASE 1 */
    .terrain-plains {
      background: 
        linear-gradient(135deg, 
          rgba(139, 69, 19, 0.3) 0%, 
          rgba(160, 82, 45, 0.4) 50%, 
          rgba(139, 69, 19, 0.3) 100%
        );
    }

    .terrain-forest {
      background: 
        linear-gradient(135deg, 
          rgba(34, 139, 34, 0.3) 0%, 
          rgba(0, 100, 0, 0.4) 50%, 
          rgba(34, 139, 34, 0.3) 100%
        );
    }

    .terrain-mountain {
      background: 
        linear-gradient(135deg, 
          rgba(105, 105, 105, 0.3) 0%, 
          rgba(47, 79, 79, 0.4) 50%, 
          rgba(105, 105, 105, 0.3) 100%
        );
    }

    .terrain-swamp {
      background: 
        linear-gradient(135deg, 
          rgba(85, 107, 47, 0.3) 0%, 
          rgba(107, 142, 35, 0.4) 50%, 
          rgba(85, 107, 47, 0.3) 100%
        );
    }

    .terrain-river {
      background: 
        linear-gradient(135deg, 
          rgba(70, 130, 180, 0.3) 0%, 
          rgba(100, 149, 237, 0.4) 50%, 
          rgba(70, 130, 180, 0.3) 100%
        );
      animation: riverFlow 3s ease-in-out infinite;
    }

    .terrain-ruins {
      background: 
        linear-gradient(135deg, 
          rgba(139, 69, 19, 0.3) 0%, 
          rgba(160, 82, 45, 0.4) 50%, 
          rgba(139, 69, 19, 0.3) 100%
        );
    }

    .terrain-volcanic {
      background: 
        linear-gradient(135deg, 
          rgba(255, 69, 0, 0.3) 0%, 
          rgba(139, 0, 0, 0.4) 50%, 
          rgba(255, 69, 0, 0.3) 100%
        );
      animation: volcanicGlow 3s ease-in-out infinite;
    }

    @keyframes volcanicGlow {
      0%, 100% { box-shadow: 0 2px 8px rgba(255, 69, 0, 0.2); }
      50% { box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4); }
    }
    
    @keyframes riverFlow {
      0% { background-position-x: 0%; }
      100% { background-position-x: 100%; }
    }

    /* PHASE 2: ENHANCED INTERACTIVITY & ANIMATIONS */
    
    /* Enhanced Hover Effects & Transitions */
    .mini-zone {
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      transform-origin: center;
    }

    .mini-zone:hover {
      transform: scale(1.08) translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(255, 0, 0, 0.4),
        0 4px 15px rgba(139, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 100, 100, 0.3);
      z-index: 10;
    }

    .mini-zone:active {
      transform: scale(1.05) translateY(-1px);
      transition: all 0.1s ease;
    }

    /* Enhanced Unit Marker Animations */
    .unit-marker {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .mini-zone:hover .unit-marker {
      transform: scale(1.2);
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    .unit-marker.red-unit {
      animation: unitPulse 3s ease-in-out infinite;
    }

    .unit-marker.blue-unit {
      animation: unitPulse 3s ease-in-out infinite;
    }

    /* Removed heavy glow animations for performance */

    /* Enhanced Construction Animations */
    .construction-marker.completed {
      animation: constructionGlow 2s ease-in-out infinite;
    }

    .construction-marker.building {
      animation: constructionBuild 2s infinite;
    }

    /* Removed heavy float and pulse animations for performance */

    /* Enhanced Info Button Interactions */
    .unit-info-button {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 0.7;
    }

    .mini-zone:hover .unit-info-button {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.3);
    }

    .unit-info-button:hover {
      transform: translate(-50%, -50%) scale(1.4);
      background: 
        linear-gradient(135deg, 
          rgba(255, 0, 0, 1) 0%, 
          rgba(139, 0, 0, 1) 50%, 
          rgba(255, 0, 0, 1) 100%
        );
      box-shadow: 
        0 6px 15px rgba(255, 0, 0, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    /* Enhanced Movement Indicator */
    .movement-indicator {
      animation: movementPulse 2s ease-in-out infinite, movementFloat 2.5s ease-in-out infinite;
    }

    @keyframes movementFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-1px); }
    }

    /* Optimized Selectable Position Effects - Reduced Lag */
    .mini-zone.selectable {
      animation: selectableGlow 3s ease-in-out infinite;
      border-color: #FFD700;
      background: rgba(255, 215, 0, 0.3);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      will-change: box-shadow, transform;
    }

    @keyframes selectableGlow {
      0%, 100% { 
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        transform: scale(1);
      }
      50% { 
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        transform: scale(1.02);
      }
    }

    .mini-zone.selectable:hover {
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
    }

    /* Enhanced Movement Zone Effects - Brighter Visibility */
    .mini-zone.movement-zone {
      animation: movementZonePulse 2.5s ease-in-out infinite;
      border-color: #9C27B0;
      border-width: 3px;
      background: rgba(156, 39, 176, 0.5);
      box-shadow: 0 0 25px rgba(156, 39, 176, 0.8), 0 0 40px rgba(156, 39, 176, 0.4);
      will-change: box-shadow, transform;
    }

    @keyframes movementZonePulse {
      0%, 100% { 
        box-shadow: 0 0 25px rgba(156, 39, 176, 0.8), 0 0 40px rgba(156, 39, 176, 0.4);
        transform: scale(1);
        opacity: 0.9;
      }
      50% { 
        box-shadow: 0 0 35px rgba(156, 39, 176, 1.0), 0 0 50px rgba(156, 39, 176, 0.6);
        transform: scale(1.03);
        opacity: 1;
      }
    }

    /* Enhanced Deployment Zone Effects - Brighter Visibility */
    .mini-zone.deployment-zone {
      animation: deploymentGlow 3s ease-in-out infinite;
      border-color: var(--player-color, #32CD32);
      border-width: 3px;
      background: rgba(50, 205, 50, 0.5);
      box-shadow: 0 0 25px rgba(50, 205, 50, 0.8), 0 0 40px rgba(50, 205, 50, 0.4);
      will-change: box-shadow, transform;
    }

    @keyframes deploymentGlow {
      0%, 100% { 
        box-shadow: 0 0 25px rgba(var(--player-color-rgb, 50, 205, 50), 0.8), 0 0 40px rgba(var(--player-color-rgb, 50, 205, 50), 0.4);
        transform: scale(1);
        opacity: 0.9;
      }
      50% { 
        box-shadow: 0 0 35px rgba(var(--player-color-rgb, 50, 205, 50), 1.0), 0 0 50px rgba(var(--player-color-rgb, 50, 205, 50), 0.6);
        transform: scale(1.03);
        opacity: 1;
      }
    }

    /* Enhanced Attacker/Defender Zone Effects - Brighter Visibility */
    .mini-zone.attacker-zone {
      animation: attackerGlow 3s ease-in-out infinite;
      border-color: var(--player-color, #DC143C);
      border-width: 3px;
      background: rgba(var(--player-color-rgb, 220, 20, 60), 0.4);
      box-shadow: 0 0 25px rgba(var(--player-color-rgb, 220, 20, 60), 0.8), 0 0 40px rgba(var(--player-color-rgb, 220, 20, 60), 0.4);
    }

    @keyframes attackerGlow {
      0%, 100% { 
        box-shadow: 0 0 25px rgba(var(--player-color-rgb, 220, 20, 60), 0.8), 0 0 40px rgba(var(--player-color-rgb, 220, 20, 60), 0.4);
        opacity: 0.9;
        transform: scale(1);
      }
      50% { 
        box-shadow: 0 0 35px rgba(var(--player-color-rgb, 220, 20, 60), 1.0), 0 0 50px rgba(var(--player-color-rgb, 220, 20, 60), 0.6);
        opacity: 1;
        transform: scale(1.03);
      }
    }

    .mini-zone.defender-zone {
      animation: defenderGlow 3s ease-in-out infinite;
      border-color: var(--enemy-color, #4169E1);
      border-width: 3px;
      background: rgba(var(--enemy-color-rgb, 65, 105, 225), 0.4);
      box-shadow: 0 0 25px rgba(var(--enemy-color-rgb, 65, 105, 225), 0.8), 0 0 40px rgba(var(--enemy-color-rgb, 65, 105, 225), 0.4);
    }

    @keyframes defenderGlow {
      0%, 100% { 
        box-shadow: 0 0 25px rgba(var(--enemy-color-rgb, 65, 105, 225), 0.8), 0 0 40px rgba(var(--enemy-color-rgb, 65, 105, 225), 0.4);
        opacity: 0.9;
        transform: scale(1);
      }
      50% { 
        box-shadow: 0 0 35px rgba(var(--enemy-color-rgb, 65, 105, 225), 1.0), 0 0 50px rgba(var(--enemy-color-rgb, 65, 105, 225), 0.6);
        opacity: 1;
        transform: scale(1.03);
      }
    }

    /* Optimized Tooltip System - Reduced Lag */
    .unit-tooltip {
      position: fixed;
      background: rgba(20, 5, 5, 0.95);
      color: #ff8888;
      padding: 15px 20px;
      border-radius: 8px;
      border: 2px solid rgba(139, 0, 0, 0.8);
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      max-width: 350px;
      min-width: 250px;
      min-height: 250px;
      z-index: 10000;
      pointer-events: none;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
      opacity: 0;
      transform: translateY(10px) scale(0.95);
      transition: all 0.3s ease;

    }

    .unit-tooltip.show {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .unit-tooltip strong {
      color: #ff4444;
      font-weight: 700;
    }

    .unit-tooltip br {
      margin-bottom: 5px;
    }

    /* Enhanced Control Buttons */
    .control-button {
      background: 
        linear-gradient(135deg, 
          rgba(50, 15, 15, 0.9) 0%, 
          rgba(35, 10, 10, 0.95) 50%, 
          rgba(45, 12, 12, 0.9) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.6);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
    }

    .control-button:hover {
      background: 
        linear-gradient(135deg, 
          rgba(70, 20, 20, 0.95) 0%, 
          rgba(50, 15, 15, 0.98) 50%, 
          rgba(60, 17, 17, 0.95) 100%
        );
      border-color: rgba(255, 0, 0, 0.8);
      color: #ff6666;
      transform: translateY(-2px);
      box-shadow: 
        0 4px 15px rgba(255, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 100, 100, 0.2);
    }

    .control-button.active {
      background: 
        linear-gradient(135deg, 
          rgba(139, 0, 0, 0.8) 0%, 
          rgba(100, 0, 0, 0.9) 50%, 
          rgba(139, 0, 0, 0.8) 100%
        );
      border-color: rgba(255, 215, 0, 0.8);
      color: #FFD700;
      box-shadow: 
        0 0 20px rgba(255, 215, 0, 0.4),
        inset 0 1px 0 rgba(255, 215, 0, 0.3);
      animation: activeButtonGlow 2s ease-in-out infinite;
    }

    @keyframes activeButtonGlow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 215, 0, 0.3); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6), inset 0 1px 0 rgba(255, 215, 0, 0.5); }
    }

    /* Enhanced Menu Button */
    .menu-button {
      background: 
        linear-gradient(135deg, 
          rgba(50, 15, 15, 0.9) 0%, 
          rgba(35, 10, 10, 0.95) 50%, 
          rgba(45, 12, 12, 0.9) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      padding: 12px 25px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
    }

    .menu-button:hover {
      background: 
        linear-gradient(135deg, 
          rgba(70, 20, 20, 0.95) 0%, 
          rgba(50, 15, 15, 0.98) 50%, 
          rgba(60, 17, 17, 0.95) 100%
        );
      border-color: rgba(255, 0, 0, 0.8);
      color: #ff6666;
      transform: translateY(-3px);
      box-shadow: 
        0 6px 20px rgba(255, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 100, 100, 0.2);
    }

    /* Enhanced Status Panels */
    .deployment-area, .movement-info, .selected-unit-info {
      background: 
        linear-gradient(135deg, 
          rgba(25, 8, 8, 0.9) 0%, 
          rgba(20, 5, 5, 0.95) 50%, 
          rgba(22, 6, 6, 0.9) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      box-shadow: 
        0 2px 10px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
      transition: all 0.3s ease;
    }

    .deployment-area:hover, .movement-info:hover, .selected-unit-info:hover {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 
        0 4px 15px rgba(255, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 100, 100, 0.2);
    }

    /* Enhanced Role Indicator */
    .role-indicator {
      background: 
        linear-gradient(135deg, 
          rgba(139, 0, 0, 0.8) 0%, 
          rgba(100, 0, 0, 0.9) 50%, 
          rgba(139, 0, 0, 0.8) 100%
        );
      border: 2px solid rgba(255, 0, 0, 0.6);
      border-radius: 8px;
      padding: 12px 15px;
      margin-bottom: 15px;
      text-align: center;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 
        0 0 20px rgba(255, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 100, 100, 0.2);
      animation: roleIndicatorPulse 4s ease-in-out infinite;
    }

    @keyframes roleIndicatorPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.3), inset 0 1px 0 rgba(255, 100, 100, 0.2); }
      50% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.5), inset 0 1px 0 rgba(255, 100, 100, 0.4); }
    }

    /* Enhanced Command Points & Build Points */
    .command-points, .build-points {
      background: 
        linear-gradient(135deg, 
          rgba(25, 8, 8, 0.9) 0%, 
          rgba(20, 5, 5, 0.95) 50%, 
          rgba(22, 6, 6, 0.9) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 12px 15px;
      margin-bottom: 15px;
      box-shadow: 
        0 2px 10px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
      transition: all 0.3s ease;
    }

    .command-points:hover, .build-points:hover {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 
        0 4px 15px rgba(255, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 100, 100, 0.2);
    }

    .command-points strong, .build-points strong {
      color: #ff4444;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
    }

    /* Enhanced Terrain Animations */
    .terrain-volcanic {
      animation: volcanicGlow 3s ease-in-out infinite, volcanicRumble 4s ease-in-out infinite;
    }

    @keyframes volcanicRumble {
      0%, 100% { transform: translateX(0px); }
      25% { transform: translateX(-1px); }
      75% { transform: translateX(1px); }
    }

    .terrain-river {
      animation: riverFlow 3s ease-in-out infinite, riverShimmer 2s ease-in-out infinite;
    }

    @keyframes riverShimmer {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    /* Enhanced Loading States */
    .mini-zone.loading {
      animation: loadingPulse 1.5s ease-in-out infinite;
    }

    @keyframes loadingPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    /* Enhanced Error States */
    .mini-zone.error {
      animation: errorShake 0.5s ease-in-out;
      border-color: #ff0000;
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
    }

    @keyframes errorShake {
      0%, 100% { transform: translateX(0px); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }

    /* Enhanced Success States */
    .mini-zone.success {
      animation: successGlow 1s ease-in-out;
      border-color: var(--player-color, #32CD32);
      box-shadow: 0 0 20px rgba(var(--player-color-rgb, 50, 205, 50), 0.6);
    }

    @keyframes successGlow {
      0% { box-shadow: 0 0 20px rgba(var(--player-color-rgb, 50, 205, 50), 0.6); }
      50% { box-shadow: 0 0 30px rgba(var(--player-color-rgb, 50, 205, 50), 0.8); }
      100% { box-shadow: 0 0 20px rgba(var(--player-color-rgb, 50, 205, 50), 0.6); }
    }

    /* PHASE 2: ENHANCED VISUAL FEEDBACK FUNCTIONS */
    
    /* Enhanced Unit Placement Animation */
    .mini-zone.unit-placed {
      animation: unitPlacedEffect 0.8s ease-out;
    }

    @keyframes unitPlacedEffect {
      0% { 
        transform: scale(0.8);
        opacity: 0.5;
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
      }
      50% { 
        transform: scale(1.1);
        opacity: 1;
        box-shadow: 0 0 40px rgba(255, 215, 0, 1);
      }
      100% { 
        transform: scale(1);
        opacity: 1;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      }
    }

    /* Enhanced Attack Animation */
    .mini-zone.attack-effect {
      animation: attackEffect 0.6s ease-out;
    }

    @keyframes attackEffect {
      0% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
      }
      25% { 
        transform: scale(1.15);
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
      }
      50% { 
        transform: scale(0.9);
        box-shadow: 0 0 40px rgba(255, 0, 0, 1);
      }
      100% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
      }
    }

    /* Enhanced Movement Animation */
    .mini-zone.movement-effect {
      animation: movementEffect 0.5s ease-out;
    }

    @keyframes movementEffect {
      0% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(156, 39, 176, 0.6);
      }
      50% { 
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(156, 39, 176, 0.8);
      }
      100% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(156, 39, 176, 0.6);
      }
    }

    /* Enhanced Construction Animation */
    .mini-zone.construction-effect {
      animation: constructionEffect 1s ease-out;
    }

    @keyframes constructionEffect {
      0% { 
        transform: scale(0.9);
        opacity: 0.7;
        box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
      }
      50% { 
        transform: scale(1.05);
        opacity: 1;
        box-shadow: 0 0 35px rgba(255, 69, 0, 0.9);
      }
      100% { 
        transform: scale(1);
        opacity: 1;
        box-shadow: 0 0 20px rgba(255, 69, 0, 0.6);
      }
    }

    /* Enhanced Selection Animation */
    .mini-zone.selection-effect {
      animation: selectionEffect 0.4s ease-out;
    }

    @keyframes selectionEffect {
      0% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      }
      50% { 
        transform: scale(1.08);
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
      }
      100% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      }
    }

    /* Disembark Position Highlighting */
    .mini-zone.disembark-target {
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
      border: 2px solid #ffff00;
      animation: disembarkGlow 1.5s ease-in-out infinite alternate;
    }

    @keyframes disembarkGlow {
      from {
        box-shadow: 0 0 20px rgba(255, 255, 0, 0.6);
        border-color: rgba(255, 255, 0, 0.6);
      }
      to {
        box-shadow: 0 0 30px rgba(255, 255, 0, 1.0);
        border-color: rgba(255, 255, 0, 1.0);
      }
    }

    /* Enhanced Damage Animation */
    .mini-zone.damage-effect {
      animation: damageEffect 0.8s ease-out;
    }

    @keyframes damageEffect {
      0% { 
        transform: scale(1) rotate(0deg);
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
      }
      25% { 
        transform: scale(1.1) rotate(-2deg);
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
      }
      50% { 
        transform: scale(0.95) rotate(2deg);
        box-shadow: 0 0 35px rgba(255, 0, 0, 1);
      }
      75% { 
        transform: scale(1.05) rotate(-1deg);
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
      }
      100% { 
        transform: scale(1) rotate(0deg);
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
      }
    }

    /* Enhanced Victory Animation */
    .mini-zone.victory-effect {
      animation: victoryEffect 1.2s ease-out;
    }

    @keyframes victoryEffect {
      0% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      }
      25% { 
        transform: scale(1.2);
        box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
      }
      50% { 
        transform: scale(1.1);
        box-shadow: 0 0 50px rgba(255, 215, 0, 1);
      }
      75% { 
        transform: scale(1.15);
        box-shadow: 0 0 45px rgba(255, 215, 0, 0.9);
      }
      100% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      }
    }
    
    .volcanic-damage-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      color: #FF4500;
      text-shadow: 0 0 4px rgba(255, 69, 0, 0.6);
      pointer-events: none;
      z-index: 10;
    }
    
    .mini-zone.volcanic-damage {
      border: 2px solid #FF4500;
      box-shadow: 0 0 15px rgba(255, 69, 0, 0.7);
    }
    
    .unit-marker {
      position: absolute;
      bottom: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .unit-info-button {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(0,0,0,0.7);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      cursor: help;
    }
    
    
    .deployment-area {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .deployment-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .control-button {
      padding: 8px 16px;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .control-button:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .control-button.active {
      border-color: #FFD700;
      background: rgba(255,215,0,0.2);
    }
    
    .phase-indicator {
      background: rgba(255,215,0,0.2);
      border: 2px solid #FFD700;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
    }
    
    .selected-unit-info {
      background: rgba(255,215,0,0.2);
      border: 2px solid #FFD700;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
    }
    
    /* Army pool styles */
    .army-pool-container {
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      cursor: crosshair;
    }
    
    .army-pool-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .army-pool-title {
      font-weight: bold;
      font-size: 16px;
      color: #fff;
    }
    
    .army-pool-count {
      background: #007acc;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 14px;
    }
    
    .army-pool-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px;
      max-height: 400px;
      overflow-y: auto;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }
    
    .army-unit-card {
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      padding: 8px;
      cursor: crosshair;
      transition: all 0.2s;
      border: 1px solid rgba(255,255,255,0.2);
      min-height: 80px;
    }
    
    .army-unit-card:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .army-unit-card.selected {
      border: 2px solid #FFD700;
      background: rgba(255, 215, 0, 0.2);
    }
    
    .army-unit-card.disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: rgba(100, 100, 100, 0.3);
      border-color: #666;
    }
    
    .army-unit-card.disabled:hover {
      background: rgba(100, 100, 100, 0.4);
      transform: none;
    }
    
    .deployed-indicator {
      background: #DC143C;
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-top: 5px;
      text-align: center;
      font-weight: bold;
    }
    
    .army-deployed-indicator {
      position: absolute;
      top: 5px;
      right: 5px;
      font-size: 14px;
      color: #FFD700;
    }
    
    .army-available-indicator {
      position: absolute;
      top: 5px;
      left: 5px;
      font-size: 14px;
      color: #32CD32;
    }
    
    .army-unit-name {
      font-weight: bold;
      margin-bottom: 4px;
      font-size: 13px;
      color: #fff;
      text-align: center;
      padding: 2px 0;
      background: rgba(0,0,0,0.2);
      border-radius: 3px;
    }
    
    .army-unit-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
      font-size: 11px;
      margin-top: 4px;
    }
    
    .army-unit-stats .stat {
      background: rgba(0,0,0,0.3);
      padding: 2px 4px;
      border-radius: 3px;
      text-align: center;
      font-weight: bold;
    }
    
    .army-unit-stats .stat.attack { color: #FF6B6B; }
    .army-unit-stats .stat.defend { color: #4ECDC4; }
    .army-unit-stats .stat.morale { color: #FFE66D; }
    .army-unit-stats .stat.range { color: #A8E6CF; }
    .army-unit-stats .stat.movement { color: #FF8B94; }
    .army-unit-stats .stat.hit-chance { color: #FF4500; }
    
    /* Game Screen Styles */
    .game-container {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
    }
    
    .battlefield-section, .controls-section {
      background: rgba(255,255,255,0.1);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
    }
    
    .battlefield {
      display: grid;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .battlefield.grid-4 { grid-template-columns: repeat(2, 1fr); }
    .battlefield.grid-6 { grid-template-columns: repeat(3, 1fr); }
    .battlefield.grid-9 { grid-template-columns: repeat(3, 1fr); }
    .battlefield.grid-12 { grid-template-columns: repeat(4, 1fr); }
    
    .zone {
      background: rgba(255,255,255,0.2);
      border: 2px solid #333;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
    }
    
    .zone:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }
    
    .zone.contested { border-color: #FFD700; background: rgba(255, 215, 0, 0.2); }
    .zone.neutral { border-color: #888; }
    .zone.locked { border: 3px dashed #FF4500; }
    
    .zone-header {
      font-weight: bold;
      font-size: 18px;
      margin-bottom: 10px;
    }
    
    .zone-units {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
    }
    
    .zone-conditions {
      font-size: 12px;
      color: #FFD700;
      margin-top: 5px;
    }
    
    .zone-lock-indicator {
      position: absolute;
      top: 5px;
      right: 5px;
      background: #FF4500;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
    }
    
    .zone-status-indicator {
      position: absolute;
      top: 5px;
      left: 5px;
      background: rgba(0,0,0,0.8);
      color: #FFD700;
      padding: 2px 6px;
    }
    
    .intelligence-entry {
      color: #87CEEB;
      font-style: italic;
      border-left: 2px solid #87CEEB;
      padding-left: 8px;
      margin: 2px 0;
    }
    


    /* Victory Confirmation Overlay Styles */
    .victory-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }

    .victory-overlay-content {
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid #ffd700;
      border-radius: 15px;
      padding: 40px;
      max-width: 500px;
      width: 90%;
      text-align: center;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
    }

    .victory-overlay-content h2 {
      color: #ffd700;
      font-size: 2em;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .victory-overlay-content p {
      color: #ffffff;
      font-size: 1.2em;
      margin-bottom: 30px;
      line-height: 1.5;
    }

    .victory-overlay-buttons {
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    .victory-overlay-buttons .menu-button {
      padding: 15px 30px;
      font-size: 1.1em;
      min-width: 150px;
    }

    .player-status-indicators {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .player-status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
    }

    .player-status:last-child {
      margin-bottom: 0;
    }

    .player-name {
      color: #ffffff;
      font-weight: bold;
      font-size: 1.1em;
    }

    .status-indicator {
      font-weight: bold;
      font-size: 1em;
    }

    .status-indicator.waiting {
      color: #ffa500;
    }

    .status-indicator.accepted {
      color: #4CAF50;
    }

    #accept-victory-btn {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      border-color: #4CAF50;
    }

    #accept-victory-btn:hover {
      background: linear-gradient(45deg, #45a049, #4CAF50);
    }

    #accept-defeat-btn {
      background: linear-gradient(45deg, #f44336, #d32f2f);
      border-color: #f44336;
    }

    #accept-defeat-btn:hover {
      background: linear-gradient(45deg, #d32f2f, #f44336);
    }
    
    /* Summary Screen Styles */
    .summary-container { max-width: 1000px; margin: 80px auto; padding: 40px 20px; background: rgba(20, 10, 10, 0.95); border-radius: 20px; backdrop-filter: blur(15px); box-shadow: 0 20px 40px rgba(0,0,0,0.8), 0 0 100px rgba(139, 0, 0, 0.3), inset 0 1px 0 rgba(255, 50, 50, 0.2); border: 2px solid rgba(139, 0, 0, 0.6); position: relative; z-index: 10; }
    

    
    .summary-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 20%, rgba(139, 0, 0, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(139, 0, 0, 0.1) 0%, transparent 50%);
      border-radius: 20px;
      pointer-events: none;
      z-index: -1;
    }
    
    .summary-header {
      text-align: center;
      margin-bottom: 40px;
      position: relative;
    }
    
    .summary-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2.8rem;
      color: #cc2222;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, 
          #cc2222 0%, 
          #990000 50%, 
          #aa1111 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: titleEnergyPulse 4s ease-in-out infinite;
      margin-bottom: 15px;
      position: relative;
      z-index: 5;
    }
    
    .summary-title::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, 
          #cc2222 0%, 
          #990000 50%, 
          #aa1111 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: blur(4px);
      opacity: 0.3;
      z-index: -1;
    }
    
    .summary-result {
      font-size: 2.2em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #FFD700;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      font-family: 'Cinzel', serif;
      letter-spacing: 2px;
    }
    
    .summary-subtitle {
      font-size: 1.3em;
      color: #996666;
      margin-bottom: 20px;
      letter-spacing: 1px;
      font-family: 'Cinzel', serif;
    }
    
    .summary-stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 40px;
    }
    
    .player-summary {
      background: rgba(30, 15, 15, 0.9);
      border-radius: 15px;
      padding: 25px;
      border: 2px solid transparent;
      position: relative;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .player1-summary {
      border-color: var(--player1-color);
      box-shadow: 0 0 20px rgba(var(--player1-color), 0.3);
    }
    
    .player2-summary {
      border-color: var(--player2-color);
      box-shadow: 0 0 20px rgba(var(--player2-color), 0.3);
    }
    
    .player1-detailed {
      border-color: var(--player1-color);
      box-shadow: 0 0 20px rgba(var(--player1-color), 0.3);
    }
    
    .player2-detailed {
      border-color: var(--player2-color);
      box-shadow: 0 0 20px rgba(var(--player2-color), 0.3);
    }
    
    .player-summary::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, 
        rgba(139, 0, 0, 0.1) 0%, 
        transparent 50%, 
        rgba(139, 0, 0, 0.1) 100%);
      border-radius: 15px;
      pointer-events: none;
    }
    
    .player-summary.red-player {
      border-color: #DC143C;
      box-shadow: 
        0 10px 30px rgba(220, 20, 60, 0.3),
        0 0 50px rgba(220, 20, 60, 0.1);
    }
    
    .player-summary.blue-player {
      border-color: #4169E1;
      box-shadow: 
        0 10px 30px rgba(65, 105, 225, 0.3),
        0 0 50px rgba(65, 105, 225, 0.1);
    }
    
    .player-summary:hover {
      transform: translateY(-5px);
      box-shadow: 
        0 15px 40px rgba(139, 0, 0, 0.4),
        0 0 60px rgba(139, 0, 0, 0.2);
    }
    
    .player-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      position: relative;
      z-index: 2;
    }
    
    .player-summary h3 {
      margin: 0;
      font-size: 1.4em;
      color: #FFD700;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      letter-spacing: 1px;
    }
    
    .player-badge {
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 0.8em;
      font-weight: bold;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .red-badge {
      background: rgba(var(--player1-color), 0.8);
      color: #fff;
      border: 1px solid rgba(var(--player1-color), 0.9);
    }
    
    .blue-badge {
      background: rgba(var(--player2-color), 0.8);
      color: #fff;
      border: 1px solid rgba(var(--player2-color), 0.9);
    }
    
    .player-stats {
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      z-index: 2;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .stat-row:hover {
      background: rgba(255,255,255,0.05);
      border-radius: 5px;
      padding-left: 10px;
      padding-right: 10px;
    }
    
    .stat-row:last-child {
      border-bottom: none;
    }
    
    .stat-label {
      color: #ccc;
      font-size: 0.95em;
      font-family: 'Cinzel', serif;
    }
    
    .stat-value {
      color: #FFD700;
      font-weight: bold;
      font-size: 1.1em;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .casualty-count {
      color: #FF6B6B !important;
      text-shadow: 0 0 10px rgba(255, 107, 107, 0.7) !important;
    }
    
    .campaign-info-panel {
      background: rgba(30, 15, 15, 0.9);
      border-radius: 15px;
      padding: 25px;
      border: 2px solid rgba(139, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      position: relative;
    }
    
    .campaign-info-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, 
        rgba(139, 0, 0, 0.1) 0%, 
        transparent 50%, 
        rgba(139, 0, 0, 0.1) 100%);
      border-radius: 15px;
      pointer-events: none;
    }
    
    .panel-title {
      margin: 0 0 20px 0;
      font-size: 1.4em;
      color: #FFD700;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      text-align: center;
      letter-spacing: 1px;
      position: relative;
      z-index: 2;
    }
    
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      position: relative;
      z-index: 2;
    }
    
    .info-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .info-item:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(255, 215, 0, 0.3);
      transform: translateY(-2px);
    }
    
    .info-label {
      color: #ccc;
      font-size: 0.95em;
      font-family: 'Cinzel', serif;
    }
    
    .info-value {
      color: #FFD700;
      font-weight: bold;
      font-size: 1.1em;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .victor-name {
      color: #4ECDC4 !important;
      text-shadow: 0 0 15px rgba(78, 205, 196, 0.8) !important;
    }
    
    .summary-actions {
      text-align: center;
      display: flex;
      gap: 30px;
      justify-content: center;
      margin-top: 40px;
    }
    
    .summary-actions .menu-button {
      min-width: 180px;
      font-size: 1.1em;
    }
    
    /* Summary Tabs */
    .summary-tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 40px;
      gap: 15px;
    }
    
    .tab-button {
      background: rgba(30, 15, 15, 0.9);
      border: 2px solid rgba(139, 0, 0, 0.6);
      border-radius: 12px;
      padding: 15px 30px;
      color: #ccc;
      cursor: crosshair;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 16px;
      font-weight: bold;
      font-family: 'Cinzel', serif;
      letter-spacing: 1px;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
    }
    
    .tab-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 0, 0, 0.2) 30%, 
        rgba(255, 50, 50, 0.4) 50%, 
        rgba(255, 0, 0, 0.2) 70%, 
        transparent 100%
      );
      transition: left 0.6s ease;
      z-index: 1;
    }
    
    .tab-button span {
      position: relative;
      z-index: 2;
    }
    
    .tab-button:hover {
      background: rgba(50, 25, 25, 0.95);
      border-color: rgba(255, 0, 0, 0.8);
      transform: translateY(-3px);
      box-shadow: 
        0 8px 25px rgba(255, 0, 0, 0.3),
        0 0 40px rgba(139, 0, 0, 0.2);
    }
    
    .tab-button:hover::before {
      left: 100%;
    }
    
    .tab-button.active {
      background: rgba(139, 0, 0, 0.3);
      border-color: #FFD700;
      color: #FFD700;
      box-shadow: 
        0 0 30px rgba(255, 215, 0, 0.3),
        inset 0 1px 0 rgba(255, 215, 0, 0.2);
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    }
    
    .summary-tab-content {
      display: none;
    }
    
    .summary-tab-content.active {
      display: block;
    }
    
    /* Detailed View Styles */
    .detailed-stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
    }
    
    .player-detailed {
      background: rgba(30, 15, 15, 0.9);
      border-radius: 15px;
      padding: 25px;
      border: 2px solid transparent;
      position: relative;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .player-detailed::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, 
        rgba(139, 0, 0, 0.1) 0%, 
        transparent 50%, 
        rgba(139, 0, 0, 0.1) 100%);
      border-radius: 15px;
      pointer-events: none;
    }
    
    .player-detailed.red-player {
      border-color: #DC143C;
      box-shadow: 
        0 10px 30px rgba(220, 20, 60, 0.3),
        0 0 50px rgba(220, 20, 60, 0.1);
    }
    
    .player-detailed.blue-player {
      border-color: #4169E1;
      box-shadow: 
        0 10px 30px rgba(65, 105, 225, 0.3),
        0 0 50px rgba(65, 105, 225, 0.1);
    }
    
    .player-detailed:hover {
      transform: translateY(-5px);
      box-shadow: 
        0 15px 40px rgba(139, 0, 0, 0.4),
        0 0 60px rgba(139, 0, 0, 0.2);
    }
    
    .detailed-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      position: relative;
      z-index: 2;
    }
    
    .player-detailed h3 {
      margin: 0;
      font-size: 1.3em;
      color: #FFD700;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      letter-spacing: 1px;
    }
    
    .casualty-icon {
      font-size: 1.5em;
      opacity: 0.8;
    }
    
    .units-lost-section {
      position: relative;
      z-index: 2;
    }
    
    .section-title {
      margin: 0 0 15px 0;
      color: #FF6B6B;
      font-size: 1.1em;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .units-lost-list {
      max-height: 250px;
      overflow-y: auto;
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      padding: 15px;
      border: 1px solid rgba(255,255,255,0.1);
      scrollbar-width: thin;
      scrollbar-color: rgba(139, 0, 0, 0.6) rgba(0, 0, 0, 0.3);
    }
    
    .units-lost-list::-webkit-scrollbar {
      width: 8px;
    }
    
    .units-lost-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }
    
    .units-lost-list::-webkit-scrollbar-thumb {
      background: rgba(139, 0, 0, 0.6);
      border-radius: 4px;
    }
    
    .units-lost-list::-webkit-scrollbar-thumb:hover {
      background: rgba(139, 0, 0, 0.8);
    }
    
    .unit-lost-item {
      padding: 12px 15px;
      margin: 8px 0;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      border-left: 4px solid #FF6B6B;
      font-size: 14px;
      color: #ccc;
      font-family: 'Cinzel', serif;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .unit-lost-item::before { content: ''; }
    
    .unit-lost-item:hover {
      background: rgba(255,255,255,0.1);
      border-left-color: #FF4444;
      transform: translateX(5px);
      color: #fff;
    }
    
    .unit-lost-item:first-child {
      margin-top: 0;
    }
    
    .unit-lost-item:last-child {
      margin-bottom: 0;
    }
    
    .zone-unit-list {
      font-size: 12px;
      margin-top: 5px;
      max-height: 60px;
      overflow-y: auto;
      text-align: left;
      padding: 5px;
      background: rgba(0,0,0,0.2);
      border-radius: 5px;
    }
    
    .zone-unit-item {
      margin: 2px 0;
      padding: 2px;
      border-left: 2px solid;
    }
    
    .zone-unit-item.red {
      border-left-color: var(--player1-color, #DC143C);
    }
    
    .zone-unit-item.blue {
      border-left-color: var(--player2-color, #4169E1);
    }
    
    .current-player {
      background: rgba(255,215,0,0.2);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
      font-weight: bold;
    }
    
    /* AI Turn Indicator */
    .ai-turn-indicator {
      background: rgba(255, 0, 0, 0.2);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
      border: 2px solid rgba(255, 0, 0, 0.5);
      animation: aiPulse 2s infinite;
    }
    
    .ai-thinking {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      font-weight: bold;
      color: #FF6B6B;
    }
    
    .ai-spinner {
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 107, 107, 0.3);
      border-top: 3px solid #FF6B6B;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
             @keyframes aiPulse {
           0% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.3); }
           50% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.6); }
           100% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.3); }
         }

         /* AI Personality Display */
         .ai-personality {
           margin-top: 10px;
           padding: 10px;
           background: rgba(0, 0, 0, 0.3);
           border-radius: 5px;
           border-left: 3px solid #FFD700;
         }

         .personality-info {
           display: flex;
           justify-content: space-between;
           margin-bottom: 8px;
           font-weight: bold;
         }

         .personality-type {
           color: #FFD700;
         }

         .personality-mood {
           color: #FF6B6B;
         }

         .personality-stats {
           font-size: 12px;
         }

         .stat-bar {
           display: flex;
           align-items: center;
           margin-bottom: 4px;
         }

         .stat-bar span {
           width: 80px;
           margin-right: 8px;
         }

         .bar {
           flex: 1;
           height: 8px;
           background: rgba(255, 255, 255, 0.2);
           border-radius: 4px;
           overflow: hidden;
         }

         .fill {
           height: 100%;
           background: linear-gradient(90deg, #FF6B6B, #FFD700);
           transition: width 0.3s ease;
         }
    
    .command-points {
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    
    .log {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid #FFD700;
      padding-left: 10px;
      font-size: 14px;
    }
    
    .log-combat { border-left-color: #DC143C; }
    .log-morale { border-left-color: #32CD32; }
    .log-system { border-left-color: #4169E1; }
    .log-artillery { border-left-color: #FF8C00; }
    .log-aerial { border-left-color: #4169E1; }
    .log-strategy { border-left-color: #32CD32; }
    .log-movement { border-left-color: #9C27B0; }
    
    .role-indicator {
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .attacker { border-left: 4px solid var(--player1-color, #DC143C); }
    .defender { border-left: 4px solid var(--player2-color, #4169E1); }
    
    /* AI turn indicator removed */
    
    /* Terrain info panel */
    .terrain-info {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .terrain-info h3 {
      margin-bottom: 10px;
      color: #FFD700;
    }
    
    .terrain-entry {
      margin-bottom: 8px;
      font-size: 13px;
    }
    
    .terrain-name {
      font-weight: bold;
      color: #FFD700;
    }
    
    /* Rename zone button */
    .rename-zone {
      position: absolute;
      top: 5px;
      left: 5px;
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .rename-zone:hover {
      background: rgba(0,0,0,0.7);
    }
    
    /* Grid size controls */
    .grid-size-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .grid-size-btn {
      background: 
          linear-gradient(135deg, 
              rgba(60, 20, 20, 0.95) 0%, 
              rgba(40, 15, 15, 0.98) 50%, 
              rgba(50, 18, 18, 0.95) 100%
          );
      border: 1px solid rgba(180, 0, 0, 0.8);
      color: #cc4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      padding: 12px;
      cursor: crosshair;
      border-radius: 6px;
      transition: all 0.3s ease;
      box-shadow: 
          0 3px 10px rgba(0, 0, 0, 0.5),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      position: relative;
      overflow: hidden;
      text-align: center;
    }
    
    .grid-size-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent 0%, 
          rgba(204, 68, 68, 0.15) 30%, 
          rgba(204, 68, 68, 0.25) 50%, 
          rgba(204, 68, 68, 0.15) 70%, 
          transparent 100%
      );
      transition: left 0.6s ease;
      z-index: 1;
    }
    
    .grid-size-btn span {
      position: relative;
      z-index: 2;
    }
    
    .grid-size-btn:hover {
      background: 
          linear-gradient(135deg, 
              rgba(80, 25, 25, 0.98) 0%, 
              rgba(60, 20, 20, 1) 50%, 
              rgba(70, 25, 25, 0.98) 100%
          );
      color: #cc2222;
      border-color: rgba(204, 68, 68, 0.9);
      transform: translateY(-2px);
      box-shadow: 
          0 6px 20px rgba(200, 0, 0, 0.3),
          0 0 25px rgba(204, 68, 68, 0.25);
    }
    
    .grid-size-btn:hover::before {
      left: 100%;
    }
    
    .grid-size-btn.active {
      background: 
          linear-gradient(135deg, 
              rgba(60, 30, 30, 0.98) 0%, 
              rgba(50, 20, 20, 1) 50%, 
              rgba(70, 40, 40, 0.98) 100%
          );
      color: #cc2222;
      border-color: rgba(204, 34, 34, 1);
      box-shadow: 
          0 0 25px rgba(204, 34, 34, 0.5),
          0 3px 10px rgba(0, 0, 0, 0.8),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    /* Movement indicators */
    .movement-indicator {
      position: absolute;
      bottom: 2px;
      left: 2px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(156, 39, 176, 0.8);
      font-size: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    
    .movement-points {
      position: absolute;
      top: 18px;
      right: 2px;
      background: rgba(0, 0, 0, 0.7);
      color: #9C27B0;
      font-size: 9px;
      padding: 1px 4px;
      border-radius: 4px;
    }
    
    /* Movement info panel */
    .movement-info {
      background: rgba(156, 39, 176, 0.2);
      border: 1px solid #9C27B0;
      border-radius: 8px;
      padding: 10px;
      margin-top: 10px;
      font-size: 14px;
    }
    
    /* Multi-army selection styles */
    .selected-armies-list {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
      min-height: 60px;
    }
    
    .no-armies-message {
      text-align: center;
      color: #996666;
      font-style: italic;
    }
    
    .selected-army-item {
      background: rgba(40, 25, 35, 0.9);
      border: 1px solid rgba(204, 34, 34, 0.5);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #cc6666;
    }
    
    .selected-army-info {
      flex: 1;
    }
    
    .selected-army-name {
      font-weight: bold;
      margin-bottom: 3px;
      color: #cc4444;
    }
    
    .armies-container {
  max-height: 120px;
  overflow-y: auto;
  border: 1px solid rgba(180, 0, 0, 0.6);
  border-radius: 6px;
  padding: 8px;
  background: rgba(25, 10, 10, 0.9);
  margin-top: 8px;
}
    
    .armies-container::-webkit-scrollbar {
      width: 6px;
    }
    
    .armies-container::-webkit-scrollbar-track {
      background: rgba(30, 20, 40, 0.7);
      border-radius: 3px;
    }
    
    .armies-container::-webkit-scrollbar-thumb {
      background: rgba(204, 34, 34, 0.8);
      border-radius: 3px;
    }
    
    .selected-army {
  background: rgba(50, 20, 20, 0.9);
  border: 1px solid rgba(204, 34, 34, 0.5);
  border-radius: 4px;
  padding: 8px 12px;
  margin: 4px 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: #cc6666;
  font-size: 0.9rem;
}
    
    .remove-army {
      background: 
          linear-gradient(135deg, 
              rgba(100, 20, 20, 0.8) 0%, 
              rgba(80, 10, 10, 0.9) 50%, 
              rgba(120, 30, 30, 0.8) 100%
          );
      border: 1px solid rgba(204, 34, 34, 0.8);
      color: #cc2222;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: crosshair;
      font-size: 0.8rem;
      transition: all 0.2s ease;
      font-family: 'Cinzel', serif;
      font-weight: 600;
    }
    
    .remove-army:hover {
      background: 
          linear-gradient(135deg, 
              rgba(120, 30, 30, 0.9) 0%, 
              rgba(100, 20, 20, 1) 50%, 
              rgba(140, 40, 40, 0.9) 100%
          );
      color: #cc1111;
      transform: scale(1.05);
      box-shadow: 0 0 10px rgba(204, 17, 17, 0.5);
    }
    
    .selected-army-composition {
      font-size: 12px;
      color: #ccc;
    }
    
    .army-limit-indicator {
      font-size: 12px;
      color: #FFD700;
      margin-top: 5px;
      text-align: center;
    }
    
    /* Army selection in zone detail */
    .army-selection-container {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .army-selector {
      margin-top: 15px;
    }
    
    .army-selector select {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: 2px solid #444;
      border-radius: 6px;
      background: #2a2a2a;
      color: #fff;
      cursor: pointer;
    }
    
    .army-selector select:focus {
      outline: none;
      border-color: #007acc;
    }
    
    .selected-army-info {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0, 122, 204, 0.1);
      border: 1px solid #007acc;
      border-radius: 6px;
    }
    
    .army-info-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .army-info-header span {
      font-size: 18px;
      font-weight: bold;
      color: #007acc;
    }
    
    .change-army-btn {
      padding: 6px 12px;
      background: #444;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .change-army-btn:hover {
      background: #555;
    }
    
    .army-info-stats {
      color: #ccc;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    
    .combat-ready-section {
      text-align: center;
    }
    
    .combat-ready-label {
      font-weight: bold;
      color: #FFD700;
      margin-bottom: 2px;
      font-size: 12px;
    }
    
    .combat-ready-count {
      font-size: 16px;
      color: #fff;
      font-weight: bold;
    }
    
    .legion-selection-section {
      text-align: right;
    }
    
    .difficulty-description {
      margin-top: 8px;
      font-size: 12px;
      color: #FFD700;
      font-style: italic;
      text-align: center;
    }
    
    .army-cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .army-card {
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      position: relative;
    }
    
    .army-card:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-2px);
    }
    
    .army-card.available {
      border-color: #32CD32;
      background: rgba(50, 205, 50, 0.1);
    }
    
    .army-card.partially-used {
      border-color: #FFD700;
      background: rgba(255, 215, 0, 0.1);
    }
    
    .army-card.exhausted {
      border-color: #DC143C;
      background: rgba(220, 20, 60, 0.1);
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .army-card-name {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 8px;
    }
    
    .army-card-stats {
      font-size: 14px;
      color: #ccc;
      margin-bottom: 5px;
    }
    
    .army-card-status {
      font-size: 12px;
      font-weight: bold;
      padding: 4px 8px;
      border-radius: 4px;
      margin-top: 8px;
    }
    
    .army-card-status.available {
      background: #32CD32;
      color: white;
    }
    
    .army-card-status.partially-used {
      background: #FFD700;
      color: black;
    }
    
    .army-card-status.exhausted {
      background: #DC143C;
      color: white;
    }
    
    .back-to-armies-btn {
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-bottom: 15px;
    }
    
    .back-to-armies-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .setup-container {
        grid-template-columns: 1fr;
      }
      
      .zone-detail-container {
        grid-template-columns: 1fr;
      }
      
      .game-container {
        grid-template-columns: 1fr;
      }
      
      .army-cards-grid {
        grid-template-columns: 1fr;
      }
      
      .army-pool-grid {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        max-height: 300px;
      }
      
      .army-unit-stats {
        grid-template-columns: repeat(2, 1fr);
        font-size: 10px;
      }
    }
    
    /* Enhanced Main Menu Animations */
    @keyframes battlefieldDrift {
      0% { background-position-x: 0, 0; }
      100% { background-position-x: 800px, 400px; }
    }
    
    @keyframes debrisFloat {
      0%, 100% { transform: translateY(0) translateX(0); }
      33% { transform: translateY(-8px) translateX(5px); }
      66% { transform: translateY(-3px) translateX(-3px); }
    }
    
    @keyframes wireOscillation {
      0%, 100% { transform: translateY(0) scaleY(1); }
      50% { transform: translateY(-4px) scaleY(0.98); }
    }
    
    @keyframes menuLevitation {
      0%, 100% { transform: translate(-50%, -50%) translateY(0); }
      50% { transform: translate(-50%, -50%) translateY(-8px); }
    }
    
    @keyframes borderFlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes titleEnergyPulse {
      0%, 100% { 
        filter: drop-shadow(0 0 8px rgba(255, 68, 68, 0.6)); 
        transform: scale(1);
      }
      50% { 
        filter: drop-shadow(0 0 20px rgba(255, 68, 68, 0.9)); 
        transform: scale(1.02);
      }
    }
    
    @keyframes titleFlicker {
      0%, 100% { opacity: 1; }
      2% { opacity: 0.8; }
      4% { opacity: 1; }
      15% { opacity: 0.9; }
      16% { opacity: 1; }
      17% { opacity: 0.7; }
      18% { opacity: 1; }
      40% { opacity: 0.85; }
      42% { opacity: 1; }
      85% { opacity: 0.9; }
      87% { opacity: 1; }
    }
    
    @keyframes underlineGlow {
      0%, 100% { opacity: 0.5; transform: translateX(-50%) scaleX(0.8); }
      50% { opacity: 1; transform: translateX(-50%) scaleX(1.1); }
    }
    
    @keyframes underlinePulse {
      0%, 100% { height: 2px; }
      50% { height: 3px; }
    }
    
    @keyframes menuFlicker {
      0%, 100% { opacity: 1; }
      3% { opacity: 0.95; }
      6% { opacity: 1; }
      25% { opacity: 0.98; }
      27% { opacity: 1; }
      70% { opacity: 0.97; }
      72% { opacity: 1; }
    }
    
    @keyframes borderFlicker {
      0%, 100% { opacity: 1; }
      5% { opacity: 0.7; }
      10% { opacity: 1; }
      30% { opacity: 0.9; }
      35% { opacity: 1; }
      80% { opacity: 0.8; }
      85% { opacity: 1; }
    }
    
    @keyframes sigilLevitate {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-8px) rotate(2deg); }
      50% { transform: translateY(-5px) rotate(0deg); }
      75% { transform: translateY(-12px) rotate(-2deg); }
    }
    
    @keyframes sigilPulse {
      0%, 100% { 
        opacity: 0.6; 
        filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.4)); 
      }
      50% { 
        opacity: 0.9; 
        filter: drop-shadow(0 0 25px rgba(255, 0, 0, 0.8)); 
      }
    }
    
    @keyframes environmentalShift {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
    }
    
    @keyframes smokeRise {
      0% {
        bottom: -150px;
        opacity: 0;
        transform: translateX(0) scale(0.3) rotate(0deg);
      }
      15% {
        opacity: 0.6;
      }
      85% {
        opacity: 0.1;
      }
      100% {
        bottom: 120vh;
        opacity: 0;
        transform: translateX(150px) scale(2) rotate(180deg);
      }
    }
    
    @keyframes bloodMistDrift {
      0% {
        bottom: -100px;
        opacity: 0;
        transform: translateX(0) scale(0.5) rotate(0deg);
      }
      10% {
        opacity: 0.7;
      }
      20% {
        opacity: 0.9;
        transform: translateX(30px) scale(0.8) rotate(45deg);
      }
      50% {
        opacity: 0.6;
        transform: translateX(-20px) scale(1.2) rotate(90deg);
      }
      80% {
        opacity: 0.3;
        transform: translateX(50px) scale(1.5) rotate(135deg);
      }
      100% {
        bottom: 110vh;
        opacity: 0;
        transform: translateX(-30px) scale(2) rotate(180deg);
      }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    

    
    /* Demonic Skeletal Hand Cursor System */
    * {
      cursor: none !important;
    }

    body {
      cursor: none !important;
      margin: 0;
      padding: 0;
    }

    .cursor {
      position: fixed;
      pointer-events: none;
      z-index: 9999999;
      transition: transform 0.15s ease;
      filter: drop-shadow(0 0 8px rgba(255, 100, 0, 0.4));
    }

    .skeletal-hand {
      width: 40px;
      height: 60px;
      position: relative;
      transform-origin: center bottom;
      background: none;
      border: none;
    }

    /* Main hand structure */
    .hand-base {
      width: 24px;
      height: 36px;
      background: linear-gradient(135deg, 
          #3a3a3a 0%, 
          #2a2a2a 30%, 
          #1a1a1a 70%, 
          #0a0a0a 100%);
      border-radius: 8px 8px 4px 4px;
      position: relative;
      border: 1px solid #444;
      box-shadow: 
          inset 0 0 8px rgba(0, 0, 0, 0.8),
          0 0 15px rgba(255, 100, 0, 0.2);
    }

    /* Bone texture cracks */
    .hand-base::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
          45deg,
          transparent 0px,
          rgba(100, 50, 50, 0.3) 1px,
          transparent 2px,
          transparent 8px
      );
      border-radius: inherit;
    }

    /* Crimson veins */
    .crimson-veins {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(
          ellipse at 50% 30%,
          rgba(139, 0, 0, 0.6) 0%,
          transparent 40%
      ),
      linear-gradient(
          90deg,
          transparent 30%,
          rgba(139, 0, 0, 0.4) 50%,
          transparent 70%
      );
      border-radius: inherit;
      animation: pulse-veins 3s ease-in-out infinite;
    }

    @keyframes pulse-veins {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }

    /* Demonic eye in palm */
    .demonic-eye {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 12px;
      height: 8px;
      background: radial-gradient(
          ellipse,
          #ff6600 0%,
          #cc4400 50%,
          #8b0000 100%
      );
      border-radius: 50%;
      border: 1px solid #ff4400;
      box-shadow: 
          inset 0 0 4px rgba(0, 0, 0, 0.8),
          0 0 8px rgba(255, 100, 0, 0.8);
      animation: eye-track 4s ease-in-out infinite;
    }

    .demonic-eye::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 6px;
      background: #000;
      border-radius: 50%;
      animation: pupil-dilate 2s ease-in-out infinite alternate;
    }

    @keyframes eye-track {
      0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
      25% { transform: translate(-50%, -50%) rotate(-5deg); }
      75% { transform: translate(-50%, -50%) rotate(5deg); }
    }

    @keyframes pupil-dilate {
      0% { transform: translate(-50%, -50%) scale(0.8); }
      100% { transform: translate(-50%, -50%) scale(1.2); }
    }

    /* Skeletal fingers */
    .finger {
      position: absolute;
      background: linear-gradient(
          to bottom,
          #4a4a4a 0%,
          #2a2a2a 50%,
          #1a1a1a 100%
      );
      border-radius: 2px;
      border: 1px solid #333;
    }

    .finger1 {
      width: 3px;
      height: 20px;
      top: -18px;
      left: 2px;
      transform: rotate(-15deg);
    }

    .finger2 {
      width: 3px;
      height: 24px;
      top: -22px;
      left: 7px;
      transform: rotate(-5deg);
    }

    .finger3 {
      width: 3px;
      height: 22px;
      top: -20px;
      left: 12px;
      transform: rotate(5deg);
    }

    .finger4 {
      width: 3px;
      height: 18px;
      top: -16px;
      left: 17px;
      transform: rotate(15deg);
    }

    .thumb {
      width: 3px;
      height: 16px;
      top: 8px;
      left: -4px;
      transform: rotate(-45deg);
    }

    /* Iron claws */
    .claw {
      position: absolute;
      width: 2px;
      height: 8px;
      background: linear-gradient(
          to bottom,
          #8b4513 0%,
          #654321 50%,
          #2f1b14 100%
      );
      border-radius: 0 0 50% 50%;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      box-shadow: 0 0 3px rgba(139, 69, 19, 0.6);
    }

    /* Hover state */
    .cursor.hovering .demonic-eye {
      transform: translate(-50%, -50%) scale(1.3);
      animation: eye-focus 0.5s ease-in-out;
    }

    @keyframes eye-focus {
      0% { box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 100, 0, 0.8); }
      100% { box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.9), 0 0 15px rgba(255, 100, 0, 1); }
    }

    /* Click state */
    .cursor.clicking .demonic-eye {
      transform: translate(-50%, -50%) scaleY(0.1);
      animation: none;
    }

    .cursor.clicking .skeletal-hand {
      transform: scale(0.9);
      animation: grab-motion 0.3s ease-out;
    }

    .cursor.clicking .finger1 {
      transform: rotate(-35deg);
      transition: transform 0.2s ease-out;
    }
    
    .cursor.clicking .finger2 {
      transform: rotate(-25deg);
      transition: transform 0.2s ease-out;
    }
    
    .cursor.clicking .finger3 {
      transform: rotate(-5deg);
      transition: transform 0.2s ease-out;
    }
    
    .cursor.clicking .finger4 {
      transform: rotate(-5deg);
      transition: transform 0.2s ease-out;
    }
    
    .cursor.clicking .thumb {
      transform: rotate(-65deg);
      transition: transform 0.2s ease-out;
    }

    @keyframes grab-motion {
      0% { transform: scale(1); }
      50% { transform: scale(0.85) rotate(-5deg); }
      100% { transform: scale(0.9); }
    }

    /* Blood spray effect */
    .blood-spray {
      position: fixed;
      pointer-events: none;
      z-index: 9998;
    }

    .blood-particle {
      position: absolute;
      width: 5px;
      height: 7px;
      background: linear-gradient(
          to bottom,
          #ff0000 0%,
          #cc0000 30%,
          #8b0000 70%,
          #660000 100%
      );
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      box-shadow: 
          0 0 8px rgba(255, 0, 0, 0.8),
          inset 0 0 3px rgba(139, 0, 0, 0.9);
      animation: blood-splatter 1.2s ease-out forwards;
    }

    @keyframes blood-splatter {
      0% {
          opacity: 1;
          transform: scale(1) rotate(0deg);
          box-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
      }
      50% {
          opacity: 0.9;
          box-shadow: 0 0 12px rgba(255, 0, 0, 1);
      }
      100% {
          opacity: 0;
          transform: scale(0.4) rotate(180deg);
          box-shadow: 0 0 4px rgba(255, 0, 0, 0.4);
      }
    }

    /* Pentagram effect */
    .pentagram {
      position: fixed;
      pointer-events: none;
      z-index: 9997;
      width: 30px;
      height: 30px;
      opacity: 0;
      animation: pentagram-flash 1s ease-out forwards;
    }

    .pentagram svg {
      width: 100%;
      height: 100%;
      filter: drop-shadow(0 0 5px rgba(139, 0, 0, 0.8));
    }

    @keyframes pentagram-flash {
      0% { opacity: 0; transform: scale(0.5) rotate(0deg); }
      30% { opacity: 1; transform: scale(1) rotate(18deg); }
      100% { opacity: 0; transform: scale(1.2) rotate(36deg); }
    }

    /* Blood drip trail */
    .blood-drip {
      position: fixed;
      width: 4px;
      height: 12px;
      background: linear-gradient(
          to bottom,
          #ff0000 0%,
          #cc0000 30%,
          #8b0000 70%,
          #660000 100%
      );
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      pointer-events: none;
      z-index: 9996;
      box-shadow: 
          0 0 6px rgba(255, 0, 0, 0.9),
          inset 0 0 2px rgba(139, 0, 0, 0.8);
      animation: drip-fall 2s ease-in forwards;
    }

    @keyframes drip-fall {
      0% {
          opacity: 1;
          transform: translateY(0) scale(1);
          box-shadow: 0 0 6px rgba(255, 0, 0, 0.9);
      }
      50% {
          opacity: 0.8;
          box-shadow: 0 0 8px rgba(255, 0, 0, 1);
      }
      100% {
          opacity: 0;
          transform: translateY(80px) scale(0.6);
          box-shadow: 0 0 3px rgba(255, 0, 0, 0.3);
      }
    }

    /* Enhanced Settings Screen Styles */
    #settings {
      font-family: 'Cinzel', serif;
      overflow: hidden;
      cursor: crosshair;
      background: #000;
      position: relative;
      margin: 0;
      padding: 0;
      border: none;
      outline: none;
    }
    
    /* Remove any white borders */
    html, body {
      margin: 0;
      padding: 0;
      border: 0;
      outline: 0;
      background: #000;
    }
    
    * {
      box-sizing: border-box;
    }
    
    .settings-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: 
          radial-gradient(ellipse 120% 100% at center bottom, rgba(139, 0, 0, 0.35) 0%, transparent 60%),
          radial-gradient(ellipse 80% 120% at center top, rgba(40, 0, 0, 0.4) 0%, transparent 50%),
          linear-gradient(180deg, 
              rgba(20, 5, 5, 0.95) 0%, 
              rgba(35, 10, 10, 0.9) 20%,
              rgba(45, 15, 15, 0.85) 50%, 
              rgba(30, 5, 5, 0.95) 80%,
              rgba(8, 0, 0, 1) 100%
          );
      filter: contrast(1.5) brightness(0.75);
    }
    
    .ritual-chamber-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
          url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 100"><defs><filter id="chamberNoise"><feTurbulence baseFrequency="0.8" numOctaves="5" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.08 0.12 0.18 0.04"/></feComponentTransfer></filter></defs><rect width="400" height="100" fill="%23000" opacity="0.4"/><path d="M0,65 Q120,60 240,65 T400,65 L400,100 L0,100 Z" fill="%235a2828" opacity="0.7"/><path d="M0,78 Q180,73 360,78 T400,78 L400,100 L0,100 Z" fill="%23442020" opacity="0.8"/><rect width="400" height="100" fill="url(%23chamberNoise)" opacity="0.5"/></svg>') repeat-x bottom,
          url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 50"><path d="M0,35 L40,30 L80,37 L120,33 L160,36 L200,34 L200,50 L0,50 Z" fill="%23331515" opacity="0.8"/></svg>') repeat-x bottom;
      background-size: 800px 200px, 400px 100px;
      animation: chamberPulse 30s linear infinite;
    }
    
    .ritual-circles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .ritual-circle {
      position: absolute;
      border-radius: 50%;
      border: 1px solid rgba(139, 0, 0, 0.4);
      background: radial-gradient(circle, transparent 70%, rgba(139, 0, 0, 0.1) 85%, transparent 100%);
      animation: ritualRotation 45s linear infinite;
    }
    
    .ritual-circle.large {
      width: 400px;
      height: 400px;
      top: 10%;
      left: -100px;
      border-width: 2px;
      animation: ritualRotation 60s linear infinite reverse;
    }
    
    .ritual-circle.medium {
      width: 250px;
      height: 250px;
      bottom: 15%;
      right: -80px;
      border-color: rgba(180, 0, 0, 0.3);
      animation: ritualRotation 40s linear infinite;
    }
    
    .ritual-circle.small {
      width: 150px;
      height: 150px;
      top: 60%;
      left: 15%;
      border-color: rgba(200, 20, 20, 0.2);
      animation: ritualRotation 25s linear infinite reverse;
    }
    
    .demonic-sigils {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .floating-sigil {
      position: absolute;
      width: 60px;
      height: 60px;
      opacity: 0.6;
      filter: drop-shadow(0 0 12px rgba(255, 0, 0, 0.4));
      animation: sigilFloat 12s ease-in-out infinite;
    }
    
    .floating-sigil.pentagram {
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="pentagramGlow"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><circle cx="50" cy="50" r="35" stroke="%23cc0000" stroke-width="2" fill="none" opacity="0.6" filter="url(%23pentagramGlow)"/><polygon points="50,20 59,42 83,42 65,58 74,80 50,64 26,80 35,58 17,42 41,42" stroke="%23ff0000" stroke-width="2.5" fill="rgba(180,0,0,0.1)" opacity="0.8" filter="url(%23pentagramGlow)"/><circle cx="50" cy="50" r="6" fill="%23ff3333" opacity="0.9"/></svg>') center/contain no-repeat;
      top: 20%;
      right: 15%;
      animation-delay: -2s;
    }
    
    .floating-sigil.goat-head {
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="goatGlow"><feGaussianBlur stdDeviation="1.5" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><circle cx="50" cy="50" r="30" stroke="%23cc0000" stroke-width="1.5" fill="none" opacity="0.5" filter="url(%23goatGlow)"/><path d="M35,35 Q50,25 65,35 Q60,45 50,50 Q40,45 35,35" fill="%23aa0000" opacity="0.7" filter="url(%23goatGlow)"/><path d="M32,30 L38,25 M62,25 L68,30" stroke="%23ff0000" stroke-width="2.5" opacity="0.8" filter="url(%23goatGlow)"/><circle cx="44" cy="38" r="2" fill="%23ff3333" opacity="0.9"/><circle cx="56" cy="38" r="2" fill="%23ff3333" opacity="0.9"/><path d="M48,45 Q50,48 52,45" stroke="%23ff0000" stroke-width="1.5" fill="none" opacity="0.8"/><path d="M45,55 Q50,65 55,55" stroke="%23cc0000" stroke-width="2" fill="none" opacity="0.7" filter="url(%23goatGlow)"/></svg>') center/contain no-repeat;
      bottom: 25%;
      left: 10%;
      animation-delay: -5s;
    }
    
    .floating-sigil.triangle {
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="triangleGlow"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><polygon points="50,20 80,70 20,70" stroke="%23dd0000" stroke-width="2.5" fill="none" opacity="0.7" filter="url(%23triangleGlow)"/><polygon points="50,35 65,58 35,58" stroke="%23ff0000" stroke-width="1.5" fill="none" opacity="0.5" transform="rotate(180 50 50)"/><circle cx="50" cy="50" r="4" fill="%23ff3333" opacity="0.8"/></svg>') center/contain no-repeat;
      top: 65%;
      right: 20%;
      animation-delay: -8s;
    }
    
    .blood-orbs {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .blood-orb {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 100, 100, 0.4) 0%, rgba(180, 0, 0, 0.3) 40%, rgba(100, 0, 0, 0.2) 70%, transparent 100%);
      filter: blur(1px);
      animation: orbFloat 15s ease-in-out infinite;
    }
    
    .blood-orb.small {
      width: 30px;
      height: 30px;
      top: 30%;
      left: 8%;
      animation-delay: -3s;
    }
    
    .blood-orb.medium {
      width: 50px;
      height: 50px;
      top: 15%;
      right: 25%;
      animation-delay: -7s;
    }
    
    .blood-orb.large {
      width: 80px;
      height: 80px;
      bottom: 20%;
      right: 8%;
      animation-delay: -12s;
    }
    
    .settings-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: 
          linear-gradient(135deg, 
              rgba(40, 15, 15, 0.98) 0%, 
              rgba(25, 8, 8, 0.99) 30%,
              rgba(35, 12, 12, 0.98) 70%,
              rgba(30, 10, 10, 0.99) 100%
          ),
          url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="settingsNoise"><feTurbulence baseFrequency="0.9" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.03 0.08 0.12 0.02"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23settingsNoise)" opacity="0.5"/></svg>');
      border: 2px solid rgba(180, 0, 0, 0.9);
      border-radius: 15px;
      padding: 60px 80px;
      backdrop-filter: blur(12px) saturate(1.3);
      box-shadow: 
          0 0 80px rgba(255, 0, 0, 0.4),
          0 0 150px rgba(139, 0, 0, 0.5),
          0 0 250px rgba(0, 0, 0, 0.8),
          inset 0 2px 0 rgba(255, 60, 60, 0.3),
          inset 0 -2px 0 rgba(0, 0, 0, 0.6);
      animation: settingsLevitation 10s ease-in-out infinite, settingsPulse 8s ease-in-out infinite;
      max-width: 700px;
      width: 90%;
      min-height: 500px;
    }
    
    .settings-panel::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(45deg, 
          transparent 15%, 
          rgba(255, 0, 0, 0.4) 25%,
          rgba(180, 0, 0, 0.3) 50%, 
          rgba(255, 0, 0, 0.4) 75%,
          transparent 85%
      );
      border-radius: 15px;
      z-index: -1;
      animation: settingsBorderFlow 8s linear infinite, settingsBorderFlicker 10s ease-in-out infinite;
    }
    
    .settings-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 3rem;
      color: #ff4444;
      text-align: center;
      margin-bottom: 50px;
      letter-spacing: 4px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ff0000 0%, #8b0000 25%, #ff3333 50%, #cc0000 75%, #ff0000 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.8)) drop-shadow(0 0 30px rgba(139, 0, 0, 0.6));
      animation: titleBloodPulse 5s ease-in-out infinite;
      position: relative;
    }
    
    .settings-title::after {
      content: '';
      position: absolute;
      bottom: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: 70%;
      height: 3px;
      background: linear-gradient(90deg, transparent, #ff0000, #8b0000, #ff0000, transparent);
      animation: titleUnderlineFlow 4s ease-in-out infinite;
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
    }
    
    .settings-content {
      display: flex;
      flex-direction: column;
      gap: 40px;
    }
    
    .settings-section {
      background: 
          linear-gradient(135deg, 
              rgba(60, 20, 20, 0.8) 0%, 
              rgba(40, 15, 15, 0.9) 50%, 
              rgba(55, 18, 18, 0.8) 100%
          );
      border: 1px solid rgba(180, 0, 0, 0.6);
      border-radius: 12px;
      padding: 30px;
      backdrop-filter: blur(6px);
      box-shadow: 
          0 8px 32px rgba(139, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 50, 50, 0.2),
          inset 0 -1px 0 rgba(0, 0, 0, 0.4);
      position: relative;
      overflow: hidden;
    }
    
    .settings-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent 0%, 
          rgba(255, 0, 0, 0.1) 50%, 
          transparent 100%
      );
      animation: sectionSweep 12s ease-in-out infinite;
    }
    
    .section-label {
      font-family: 'Cinzel', serif;
      font-weight: 700;
      font-size: 1.4rem;
      color: #ff0000;
      margin-bottom: 25px;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 12px rgba(255, 0, 0, 0.6);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .section-label::before,
    .section-label::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 50px;
      height: 2px;
      background: linear-gradient(90deg, transparent, #ff0000, transparent);
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
    }
    
    .section-label::before {
      left: -70px;
    }
    
    .section-label::after {
      right: -70px;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      padding: 15px 0;
      border-bottom: 1px solid rgba(139, 0, 0, 0.3);
    }
    
    .control-group:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .control-label {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.1rem;
      color: #ff6666;
      text-shadow: 0 0 8px rgba(255, 102, 102, 0.4);
      min-width: 150px;
    }
    
    .music-selector {
      position: relative;
      flex: 1;
      max-width: 300px;
      margin: 0 20px;
    }
    
    .custom-dropdown {
      position: relative;
      width: 100%;
    }
    
    .dropdown-selected {
      appearance: none;
      background: 
          linear-gradient(135deg, 
              rgba(80, 25, 25, 0.95) 0%, 
              rgba(60, 20, 20, 0.98) 50%, 
              rgba(75, 22, 22, 0.95) 100%
          );
      border: 1px solid rgba(180, 0, 0, 0.7);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      padding: 12px 40px 12px 15px;
      border-radius: 8px;
      width: 100%;
      cursor: none;
      transition: all 0.3s ease;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.4);
      box-shadow: 
          0 4px 16px rgba(139, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 50, 50, 0.15);
      user-select: none;
    }
    
    .dropdown-selected:hover {
      background: 
          linear-gradient(135deg, 
              rgba(100, 30, 30, 0.98) 0%, 
              rgba(80, 25, 25, 0.99) 50%, 
              rgba(95, 27, 27, 0.98) 100%
          );
      border-color: rgba(255, 0, 0, 0.9);
      box-shadow: 
          0 6px 24px rgba(255, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 50, 50, 0.25);
      transform: translateY(-2px);
    }
    
    .dropdown-arrow {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: #ff4444;
      font-size: 1.2rem;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
      transition: transform 0.3s ease;
    }
    
    .dropdown-options {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: 
          linear-gradient(135deg, 
              rgba(60, 20, 20, 0.98) 0%, 
              rgba(40, 15, 15, 0.99) 50%, 
              rgba(55, 18, 18, 0.98) 100%
          );
      border: 1px solid rgba(180, 0, 0, 0.8);
      border-top: none;
      border-radius: 0 0 8px 8px;
      backdrop-filter: blur(8px);
      box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.8),
          0 4px 16px rgba(139, 0, 0, 0.6);
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s ease;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .custom-dropdown.open .dropdown-options {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    /* Custom Scrollbar for Dropdown */
    .dropdown-options::-webkit-scrollbar {
      width: 8px;
    }
    
    .dropdown-options::-webkit-scrollbar-track {
      background: rgba(20, 5, 5, 0.8);
      border-radius: 0 4px 4px 0;
    }
    
    .dropdown-options::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, 
          rgba(180, 0, 0, 0.8) 0%, 
          rgba(139, 0, 0, 0.9) 50%, 
          rgba(100, 0, 0, 0.8) 100%
      );
      border-radius: 4px;
      border: 1px solid rgba(255, 0, 0, 0.3);
      box-shadow: 
          0 0 8px rgba(255, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 50, 50, 0.2);
    }
    
    .dropdown-options::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, 
          rgba(220, 20, 20, 0.9) 0%, 
          rgba(180, 0, 0, 1) 50%, 
          rgba(140, 0, 0, 0.9) 100%
      );
      box-shadow: 
          0 0 12px rgba(255, 0, 0, 0.6),
          inset 0 1px 0 rgba(255, 50, 50, 0.3);
    }
    
    .dropdown-options::-webkit-scrollbar-thumb:active {
      background: linear-gradient(180deg, 
          rgba(255, 40, 40, 1) 0%, 
          rgba(200, 0, 0, 1) 50%, 
          rgba(160, 0, 0, 1) 100%
      );
    }
    
    /* Firefox Scrollbar */
    .dropdown-options {
      scrollbar-width: thin;
      scrollbar-color: rgba(180, 0, 0, 0.8) rgba(20, 5, 5, 0.8);
    }
    
    .dropdown-option {
      padding: 12px 15px;
      color: #ff6666;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      cursor: none;
      transition: all 0.2s ease;
      text-shadow: 0 0 6px rgba(255, 102, 102, 0.3);
      border-bottom: 1px solid rgba(139, 0, 0, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .dropdown-option:last-child {
      border-bottom: none;
    }
    
    .dropdown-option::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent 0%, 
          rgba(255, 0, 0, 0.2) 50%, 
          transparent 100%
      );
      transition: left 0.4s ease;
    }
    
    .dropdown-option:hover {
      background: 
          linear-gradient(135deg, 
              rgba(100, 30, 30, 0.8) 0%, 
              rgba(80, 25, 25, 0.9) 50%, 
              rgba(90, 28, 28, 0.8) 100%
          );
      color: #ff0000;
      text-shadow: 0 0 12px rgba(255, 0, 0, 0.8);
      transform: translateX(5px);
    }
    
    .dropdown-option:hover::before {
      left: 100%;
    }
    
    .dropdown-option.selected {
      background: 
          linear-gradient(135deg, 
              rgba(120, 35, 35, 0.9) 0%, 
              rgba(90, 25, 25, 0.95) 50%, 
              rgba(110, 30, 30, 0.9) 100%
          );
      color: #ff0000;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
    }
    
    .custom-dropdown.open .dropdown-selected {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-color: rgba(255, 0, 0, 0.9);
    }
    
    .custom-dropdown.open .dropdown-arrow {
      transform: translateY(-50%) rotate(180deg);
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      max-width: 350px;
      height: 32px;
      padding: 0 8px;
    }
    
    /* Larger sliders for singleplayer game setup */
    #game-setup .volume-control {
      max-width: 400px;
    }
    /* Match slider width in multiplayer setup */
    #multiplayer-game-setup .volume-control {
      max-width: 400px;
    }
    
    /* Bottom action buttons for game setup */
    .bottom-action-buttons {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-top: 50px;
      padding: 20px 0;
      grid-column: 1 / -1;
    }
    
    .large-button {
      font-size: 1.5rem !important;
      padding: 25px 50px !important;
      min-width: 250px !important;
      text-transform: uppercase;
      letter-spacing: 3px;
      box-shadow: 
          0 8px 30px rgba(139, 0, 0, 0.7),
          0 0 50px rgba(255, 0, 0, 0.4),
          inset 0 2px 0 rgba(255, 50, 50, 0.3),
          inset 0 -2px 0 rgba(0, 0, 0, 0.6) !important;
    }
    
    .large-button:hover {
      transform: translateY(-6px) scale(1.05) !important;
      box-shadow: 
          0 15px 50px rgba(255, 0, 0, 0.6),
          0 0 80px rgba(255, 0, 0, 0.5),
          0 0 120px rgba(139, 0, 0, 0.4),
          inset 0 2px 0 rgba(255, 50, 50, 0.5),
          inset 0 -2px 0 rgba(0, 0, 0, 0.7) !important;
    }
    
    .volume-slider {
      appearance: none !important;
      background: linear-gradient(to right, 
          rgba(0, 0, 0, 0.9) 0%, 
          rgba(20, 0, 0, 0.8) 25%, 
          rgba(139, 0, 0, 0.7) 50%, 
          rgba(180, 0, 0, 0.6) 75%,
          rgba(220, 20, 60, 0.5) 100%
      ) !important;
      height: 12px !important;
      border-radius: 6px !important;
      outline: none !important;
      flex: 1 !important;
      cursor: none !important;
      border: 1px solid rgba(139, 0, 0, 0.5) !important;
      box-shadow: 
          0 2px 8px rgba(0, 0, 0, 0.4),
          inset 0 1px 2px rgba(0, 0, 0, 0.3) !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* DEBUG: Force cursor none on all volume-slider elements and their children */
    .volume-slider,
    .volume-slider *,
    .volume-slider:hover,
    .volume-slider:active,
    .volume-slider:focus,
    .volume-slider::-webkit-slider-thumb,
    .volume-slider::-webkit-slider-thumb:hover,
    .volume-slider::-webkit-slider-thumb:active,
    .volume-slider::-moz-range-thumb,
    .volume-slider::-moz-range-thumb:hover,
    .volume-slider::-moz-range-thumb:active,
    .volume-slider::-webkit-slider-track,
    .volume-slider::-moz-range-track {
      cursor: none !important;
    }
    
    /* DEBUG: Specific targeting for Death Zones slider */
    #zone-count,
    #zone-count *,
    #zone-count:hover,
    #zone-count:active,
    #zone-count:focus,
    #zone-count::-webkit-slider-thumb,
    #zone-count::-webkit-slider-thumb:hover,
    #zone-count::-webkit-slider-thumb:active,
    #zone-count::-moz-range-thumb,
    #zone-count::-moz-range-thumb:hover,
    #zone-count::-moz-range-thumb:active,
    #zone-count::-webkit-slider-track,
    #zone-count::-moz-range-track {
      cursor: none !important;
    }
    
    /* DEBUG: Ultra-aggressive cursor override for all range inputs */
    input[type="range"],
    input[type="range"] *,
    input[type="range"]:hover,
    input[type="range"]:active,
    input[type="range"]:focus,
    input[type="range"]::-webkit-slider-thumb,
    input[type="range"]::-webkit-slider-thumb:hover,
    input[type="range"]::-webkit-slider-thumb:active,
    input[type="range"]::-webkit-slider-thumb:focus,
    input[type="range"]::-moz-range-thumb,
    input[type="range"]::-moz-range-thumb:hover,
    input[type="range"]::-moz-range-thumb:active,
    input[type="range"]::-moz-range-thumb:focus,
    input[type="range"]::-webkit-slider-track,
    input[type="range"]::-webkit-slider-track:hover,
    input[type="range"]::-webkit-slider-track:active,
    input[type="range"]::-moz-range-track,
    input[type="range"]::-moz-range-track:hover,
    input[type="range"]::-moz-range-track:active {
      cursor: none !important;
    }

    /* FINAL: ID-specific override to beat earlier ID rules that set crosshair on thumbs/tracks */
    /* Zone/CP sliders */
    /* Ensure base inputs themselves also never show crosshair, beating earlier ID rules */
    #zone-count,
    #zone-count:hover,
    #zone-count:active,
    #zone-count:focus,
    #starting-cp,
    #starting-cp:hover,
    #starting-cp:active,
    #starting-cp:focus,
    #mp-zone-count,
    #mp-zone-count:hover,
    #mp-zone-count:active,
    #mp-zone-count:focus,
    #mp-starting-cp,
    #mp-starting-cp:hover,
    #mp-starting-cp:active,
    #mp-starting-cp:focus,
    #ai-cp,
    #ai-cp:hover,
    #ai-cp:active,
    #ai-cp:focus,
    #mp-player1-cp,
    #mp-player1-cp:hover,
    #mp-player1-cp:active,
    #mp-player1-cp:focus,
    #mp-player2-cp,
    #mp-player2-cp:hover,
    #mp-player2-cp:active,
    #mp-player2-cp:focus,
    #mp-build-points,
    #mp-build-points:hover,
    #mp-build-points:active,
    #mp-build-points:focus,
    #mp-player1-build-points,
    #mp-player1-build-points:hover,
    #mp-player1-build-points:active,
    #mp-player1-build-points:focus,
    #mp-player2-build-points,
    #mp-player2-build-points:hover,
    #mp-player2-build-points:active,
    #mp-player2-build-points:focus,
    #attack-mod,
    #attack-mod:hover,
    #attack-mod:active,
    #attack-mod:focus,
    #defense-mod,
    #defense-mod:hover,
    #defense-mod:active,
    #defense-mod:focus,
    #morale-mod,
    #morale-mod:hover,
    #morale-mod:active,
    #morale-mod:focus,
    #range-mod,
    #range-mod:hover,
    #range-mod:active,
    #range-mod:focus,
    #movement-mod,
    #movement-mod:hover,
    #movement-mod:active,
    #movement-mod:focus,
    #hit-chance-mod,
    #hit-chance-mod:hover,
    #hit-chance-mod:active,
    #hit-chance-mod:focus {
      cursor: none !important;
    }

    #zone-count::-webkit-slider-thumb,
    #zone-count::-webkit-slider-thumb:hover,
    #zone-count::-webkit-slider-thumb:active,
    #zone-count::-webkit-slider-runnable-track,
    #zone-count::-moz-range-thumb,
    #zone-count::-moz-range-thumb:hover,
    #zone-count::-moz-range-thumb:active,
    #zone-count::-moz-range-track,
    #starting-cp::-webkit-slider-thumb,
    #starting-cp::-webkit-slider-thumb:hover,
    #starting-cp::-webkit-slider-thumb:active,
    #starting-cp::-webkit-slider-runnable-track,
    #starting-cp::-moz-range-thumb,
    #starting-cp::-moz-range-thumb:hover,
    #starting-cp::-moz-range-thumb:active,
    #starting-cp::-moz-range-track,
    #mp-zone-count::-webkit-slider-thumb,
    #mp-zone-count::-webkit-slider-thumb:hover,
    #mp-zone-count::-webkit-slider-thumb:active,
    #mp-zone-count::-webkit-slider-runnable-track,
    #mp-zone-count::-moz-range-thumb,
    #mp-zone-count::-moz-range-thumb:hover,
    #mp-zone-count::-moz-range-thumb:active,
    #mp-zone-count::-moz-range-track,
    #mp-starting-cp::-webkit-slider-thumb,
    #mp-starting-cp::-webkit-slider-thumb:hover,
    #mp-starting-cp::-webkit-slider-thumb:active,
    #mp-starting-cp::-webkit-slider-runnable-track,
    #mp-starting-cp::-moz-range-thumb,
    #mp-starting-cp::-moz-range-thumb:hover,
    #mp-starting-cp::-moz-range-thumb:active,
    #mp-starting-cp::-moz-range-track,
    #ai-cp::-webkit-slider-thumb,
    #ai-cp::-webkit-slider-thumb:hover,
    #ai-cp::-webkit-slider-thumb:active,
    #ai-cp::-webkit-slider-runnable-track,
    #ai-cp::-moz-range-thumb,
    #ai-cp::-moz-range-thumb:hover,
    #ai-cp::-moz-range-thumb:active,
    #ai-cp::-moz-range-track,
    #mp-player1-cp::-webkit-slider-thumb,
    #mp-player1-cp::-webkit-slider-thumb:hover,
    #mp-player1-cp::-webkit-slider-thumb:active,
    #mp-player1-cp::-webkit-slider-runnable-track,
    #mp-player1-cp::-moz-range-thumb,
    #mp-player1-cp::-moz-range-thumb:hover,
    #mp-player1-cp::-moz-range-thumb:active,
    #mp-player1-cp::-moz-range-track,
    #mp-player2-cp::-webkit-slider-thumb,
    #mp-player2-cp::-webkit-slider-thumb:hover,
    #mp-player2-cp::-webkit-slider-thumb:active,
    #mp-player2-cp::-webkit-slider-runnable-track,
    #mp-player2-cp::-moz-range-thumb,
    #mp-player2-cp::-moz-range-thumb:hover,
    #mp-player2-cp::-moz-range-thumb:active,
    #mp-player2-cp::-moz-range-track,
    #mp-build-points::-webkit-slider-thumb,
    #mp-build-points::-webkit-slider-thumb:hover,
    #mp-build-points::-webkit-slider-thumb:active,
    #mp-build-points::-webkit-slider-runnable-track,
    #mp-build-points::-moz-range-thumb,
    #mp-build-points::-moz-range-thumb:hover,
    #mp-build-points::-moz-range-thumb:active,
    #mp-build-points::-moz-range-track,
    #mp-player1-build-points::-webkit-slider-thumb,
    #mp-player1-build-points::-webkit-slider-thumb:hover,
    #mp-player1-build-points::-webkit-slider-thumb:active,
    #mp-player1-build-points::-webkit-slider-runnable-track,
    #mp-player1-build-points::-moz-range-thumb,
    #mp-player1-build-points::-moz-range-thumb:hover,
    #mp-player1-build-points::-moz-range-thumb:active,
    #mp-player1-build-points::-moz-range-track,
    #mp-player2-build-points::-webkit-slider-thumb,
    #mp-player2-build-points::-webkit-slider-thumb:hover,
    #mp-player2-build-points::-webkit-slider-thumb:active,
    #mp-player2-build-points::-webkit-slider-runnable-track,
    #mp-player2-build-points::-moz-range-thumb,
    #mp-player2-build-points::-moz-range-thumb:hover,
    #mp-player2-build-points::-moz-range-thumb:active,
    #mp-player2-build-points::-moz-range-track,
    /* Mod sliders */
    #attack-mod::-webkit-slider-thumb,
    #attack-mod::-webkit-slider-thumb:hover,
    #attack-mod::-webkit-slider-thumb:active,
    #attack-mod::-webkit-slider-runnable-track,
    #attack-mod::-moz-range-thumb,
    #attack-mod::-moz-range-thumb:hover,
    #attack-mod::-moz-range-thumb:active,
    #attack-mod::-moz-range-track,
    #defense-mod::-webkit-slider-thumb,
    #defense-mod::-webkit-slider-thumb:hover,
    #defense-mod::-webkit-slider-thumb:active,
    #defense-mod::-webkit-slider-runnable-track,
    #defense-mod::-moz-range-thumb,
    #defense-mod::-moz-range-thumb:hover,
    #defense-mod::-moz-range-thumb:active,
    #defense-mod::-moz-range-track,
    #morale-mod::-webkit-slider-thumb,
    #morale-mod::-webkit-slider-thumb:hover,
    #morale-mod::-webkit-slider-thumb:active,
    #morale-mod::-webkit-slider-runnable-track,
    #morale-mod::-moz-range-thumb,
    #morale-mod::-moz-range-thumb:hover,
    #morale-mod::-moz-range-thumb:active,
    #morale-mod::-moz-range-track,
    #range-mod::-webkit-slider-thumb,
    #range-mod::-webkit-slider-thumb:hover,
    #range-mod::-webkit-slider-thumb:active,
    #range-mod::-webkit-slider-runnable-track,
    #range-mod::-moz-range-thumb,
    #range-mod::-moz-range-thumb:hover,
    #range-mod::-moz-range-thumb:active,
    #range-mod::-moz-range-track,
    #movement-mod::-webkit-slider-thumb,
    #movement-mod::-webkit-slider-thumb:hover,
    #movement-mod::-webkit-slider-thumb:active,
    #movement-mod::-webkit-slider-runnable-track,
    #movement-mod::-moz-range-thumb,
    #movement-mod::-moz-range-thumb:hover,
    #movement-mod::-moz-range-thumb:active,
    #movement-mod::-moz-range-track,
    #hit-chance-mod::-webkit-slider-thumb,
    #hit-chance-mod::-webkit-slider-thumb:hover,
    #hit-chance-mod::-webkit-slider-thumb:active,
    #hit-chance-mod::-webkit-slider-runnable-track,
    #hit-chance-mod::-moz-range-thumb,
    #hit-chance-mod::-moz-range-thumb:hover,
    #hit-chance-mod::-moz-range-thumb:active,
    #hit-chance-mod::-moz-range-track {
      cursor: none !important;
    }
    
    /* DEBUG: Ultra-aggressive cursor override for dropdown and its options */
    #army-selector-dropdown,
    #army-selector-dropdown *,
    #army-selector-dropdown:hover,
    #army-selector-dropdown:active,
    #army-selector-dropdown:focus,
    #army-selector-dropdown option,
    #army-selector-dropdown option:hover,
    #army-selector-dropdown option:active,
    #army-selector-dropdown option:focus,
    select,
    select *,
    select:hover,
    select:active,
    select:focus,
    select option,
    select option:hover,
    select option:active,
    select option:focus {
      cursor: none !important;
    }
    
    .volume-slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      background: 
          radial-gradient(circle, 
              #000000 0%, 
              #1a0000 30%, 
              #330000 70%, 
              #660000 100%
          );
      border-radius: 50%;
      border: 2px solid rgba(255, 0, 0, 0.6);
      cursor: none;
      box-shadow: 
          0 0 12px rgba(255, 0, 0, 0.6),
          0 4px 8px rgba(0, 0, 0, 0.4);
      transition: all 0.2s ease;
    }
    
    .volume-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 
          0 0 16px rgba(255, 0, 0, 0.8),
          0 6px 12px rgba(0, 0, 0, 0.5);
      cursor: none;
    }
    
    .volume-value {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      color: #ff4444;
      font-size: 1rem;
      min-width: 40px;
      text-align: center;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
      background: rgba(139, 0, 0, 0.2);
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid rgba(139, 0, 0, 0.4);
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .return-button {
      margin-top: 40px;
      padding: 0;
      background: none;
      border: none;
      display: flex;
      justify-content: center;
    }
    
    .return-button .menu-button {
      position: relative;
      background: 
          linear-gradient(135deg, 
              rgba(70, 20, 20, 0.95) 0%, 
              rgba(50, 15, 15, 0.98) 50%, 
              rgba(65, 18, 18, 0.95) 100%
          );
      border: 2px solid rgba(180, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      font-size: 1.3rem;
      padding: 20px 40px;
      cursor: none;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 0 15px rgba(255, 68, 68, 0.6), 0 0 30px rgba(139, 0, 0, 0.4);
      letter-spacing: 2px;
      border-radius: 10px;
      box-shadow: 
          0 6px 25px rgba(139, 0, 0, 0.6),
          0 0 40px rgba(255, 0, 0, 0.3),
          inset 0 2px 0 rgba(255, 50, 50, 0.2),
          inset 0 -2px 0 rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(6px);
      overflow: hidden;
      text-transform: uppercase;
      min-width: 200px;
    }
    
    .return-button .menu-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent 0%, 
          rgba(255, 0, 0, 0.3) 30%, 
          rgba(255, 50, 50, 0.5) 50%, 
          rgba(255, 0, 0, 0.3) 70%, 
          transparent 100%
      );
      transition: left 0.6s ease;
      z-index: 1;
    }
    
    .return-button .menu-button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: radial-gradient(circle, rgba(255, 0, 0, 0.6) 0%, transparent 70%);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.4s ease;
      z-index: 0;
    }
    
    .return-button .menu-button span {
      position: relative;
      z-index: 2;
    }
    
    .return-button .menu-button:hover {
      background: 
          linear-gradient(135deg, 
              rgba(120, 35, 35, 0.98) 0%, 
              rgba(90, 25, 25, 0.99) 50%, 
              rgba(110, 30, 30, 0.98) 100%
          );
      color: #ff0000;
      border-color: rgba(255, 0, 0, 1);
      transform: translateY(-4px) scale(1.03);
      box-shadow: 
          0 12px 40px rgba(255, 0, 0, 0.5),
          0 0 60px rgba(255, 0, 0, 0.4),
          0 0 100px rgba(139, 0, 0, 0.3),
          inset 0 2px 0 rgba(255, 50, 50, 0.4);
      text-shadow: 0 0 25px rgba(255, 0, 0, 0.9), 0 0 50px rgba(139, 0, 0, 0.7);
    }
    
    .return-button .menu-button:hover::before {
      left: 100%;
    }
    
    .return-button .menu-button:hover::after {
      width: 250px;
      height: 250px;
    }
    
    .return-button .menu-button:active {
      transform: translateY(-2px) scale(1);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
    }
    
    /* Settings Animations */
    @keyframes chamberPulse {
      0% { background-position-x: 0, 0; }
      100% { background-position-x: 800px, 400px; }
    }
    
    @keyframes ritualRotation {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.05); }
      100% { transform: rotate(360deg) scale(1); }
    }
    
    @keyframes sigilFloat {
      0%, 100% { 
          transform: translateY(0) rotate(0deg); 
          opacity: 0.6; 
      }
      25% { 
          transform: translateY(-15px) rotate(5deg); 
          opacity: 0.8; 
      }
      50% { 
          transform: translateY(-8px) rotate(0deg); 
          opacity: 0.9; 
      }
      75% { 
          transform: translateY(-18px) rotate(-5deg); 
          opacity: 0.7; 
      }
    }
    
    @keyframes orbFloat {
      0%, 100% { 
          transform: translateY(0) translateX(0) scale(1); 
          opacity: 0.6; 
      }
      33% { 
          transform: translateY(-20px) translateX(10px) scale(1.1); 
          opacity: 0.8; 
      }
      66% { 
          transform: translateY(-10px) translateX(-8px) scale(0.95); 
          opacity: 0.9; 
      }
    }
    
    @keyframes settingsLevitation {
      0%, 100% { transform: translate(-50%, -50%) translateY(0); }
      50% { transform: translate(-50%, -50%) translateY(-10px); }
    }
    
    @keyframes settingsPulse {
      0%, 100% { 
          box-shadow: 
              0 0 80px rgba(255, 0, 0, 0.4),
              0 0 150px rgba(139, 0, 0, 0.5),
              0 0 250px rgba(0, 0, 0, 0.8);
      }
      50% { 
          box-shadow: 
              0 0 100px rgba(255, 0, 0, 0.6),
              0 0 180px rgba(139, 0, 0, 0.7),
              0 0 280px rgba(0, 0, 0, 0.9);
      }
    }
    
    @keyframes settingsBorderFlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes settingsBorderFlicker {
      0%, 100% { opacity: 1; }
      5% { opacity: 0.7; }
      10% { opacity: 1; }
      35% { opacity: 0.9; }
      40% { opacity: 1; }
      75% { opacity: 0.8; }
      80% { opacity: 1; }
    }
    
    @keyframes titleBloodPulse {
      0%, 100% { 
          filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.8)) drop-shadow(0 0 30px rgba(139, 0, 0, 0.6));
          transform: scale(1);
      }
      50% { 
          filter: drop-shadow(0 0 25px rgba(255, 0, 0, 1)) drop-shadow(0 0 50px rgba(139, 0, 0, 0.8));
          transform: scale(1.02);
      }
    }
    
    @keyframes titleUnderlineFlow {
      0%, 100% { 
          opacity: 0.6; 
          transform: translateX(-50%) scaleX(0.7); 
      }
      50% { 
          opacity: 1; 
          transform: translateX(-50%) scaleX(1.2); 
      }
    }
    
    @keyframes sectionSweep {
      0% { left: -100%; }
      20% { left: 100%; }
      100% { left: 100%; }
    }
    
    /* Responsive Design for Enhanced Main Menu */
    @media (max-width: 1024px) {
      .menu-system {
        padding: 40px 50px;
      }
      
      .game-title {
        font-size: 2.8rem;
      }
      
      .menu-button {
        font-size: 1rem;
        padding: 12px 18px;
      }
      
      .menu-button.primary {
        font-size: 1.2rem;
      }
    }
    
    @media (max-width: 768px) {
      .menu-system {
        padding: 30px 40px;
      }
      
      .game-title {
        font-size: 2.2rem;
        letter-spacing: 2px;
      }
      
      .menu-navigation {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .menu-button {
        font-size: 1rem;
        padding: 14px 20px;
      }
      
      .menu-button.primary {
        font-size: 1.1rem;
      }
    }
    
    @media (max-width: 480px) {
      .menu-system {
        padding: 25px 30px;
      }
      
      .game-title {
        font-size: 1.8rem;
        margin-bottom: 30px;
      }
      
      .menu-button {
        font-size: 0.9rem;
        padding: 12px 16px;
      }
    }
    
    /* ===== ENHANCED MULTIPLAYER LOBBY STYLES ===== */
    
    /* Multiplayer Screen Base */
    /* #multiplayer follows default .screen visibility controlled by showScreen() */
    
    .mp-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: 
        radial-gradient(ellipse 120% 100% at center bottom, rgba(139, 0, 0, 0.25) 0%, transparent 60%),
        radial-gradient(ellipse 80% 120% at center top, rgba(20, 0, 0, 0.4) 0%, transparent 50%),
        linear-gradient(180deg, 
          rgba(15, 5, 5, 0.95) 0%, 
          rgba(25, 10, 10, 0.9) 20%,
          rgba(35, 15, 15, 0.85) 50%, 
          rgba(20, 5, 5, 0.95) 80%,
          rgba(5, 0, 0, 1) 100%
        );
      filter: contrast(1.4) brightness(0.7);
    }
    
    /* Background Elements */
    .battlefield-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(to bottom, transparent 60%, rgba(74, 55, 40, 0.6) 70%, rgba(54, 37, 25, 0.8) 80%, rgba(45, 30, 20, 0.9) 100%);
      animation: battlefieldDrift 25s linear infinite;
    }
    
    .battlefield-layer::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 200px;
      background: 
        repeating-linear-gradient(
          90deg,
          transparent 0px,
          rgba(100, 80, 60, 0.1) 50px,
          transparent 100px
        );
      opacity: 0.3;
    }
    
            .wire-system {
          position: absolute;
          bottom: 80px;
          left: 0;
          width: 100%;
          height: 60px;
          background: 
            repeating-linear-gradient(
              90deg,
              transparent 0px,
              rgba(102, 102, 102, 0.3) 1px,
              transparent 2px,
              transparent 100px
            ),
            repeating-linear-gradient(
              90deg,
              transparent 0px,
              rgba(85, 85, 85, 0.2) 1px,
              transparent 2px,
              transparent 150px
            );
          filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
          animation: wireOscillation 6s ease-in-out infinite;
          opacity: 0.4;
        }
    
    .atmospheric-smoke {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      background: 
        radial-gradient(circle at 20% 80%, rgba(180, 180, 180, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(160, 160, 160, 0.02) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(140, 140, 140, 0.04) 0%, transparent 60%);
      animation: smokeFlow 20s ease-in-out infinite;
    }
    
    .blood-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .blood-gradient {
      position: absolute;
      background: radial-gradient(ellipse at center, rgba(120, 0, 0, 0.25) 0%, rgba(80, 0, 0, 0.15) 30%, transparent 60%);
      filter: blur(3px);
    }
    
    .blood-gradient.corner-tl {
      top: -100px;
      left: -100px;
      width: 300px;
      height: 300px;
      transform: rotate(45deg);
    }
    
    .blood-gradient.corner-br {
      bottom: -100px;
      right: -100px;
      width: 350px;
      height: 350px;
      transform: rotate(-135deg);
    }
    
    /* Back Button */
    .back-button {
      position: absolute;
      top: 30px;
      left: 30px;
      background: 
        linear-gradient(135deg, 
          rgba(50, 15, 15, 0.95) 0%, 
          rgba(35, 10, 10, 0.98) 50%, 
          rgba(45, 12, 12, 0.95) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      padding: 12px 20px;
      cursor: crosshair;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 0 12px rgba(255, 68, 68, 0.6);
      letter-spacing: 1px;
      border-radius: 8px;
      box-shadow: 
        0 4px 20px rgba(139, 0, 0, 0.6),
        0 0 30px rgba(255, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 50, 50, 0.15);
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    
    .back-button:hover {
      background: 
        linear-gradient(135deg, 
          rgba(90, 25, 25, 0.98) 0%, 
          rgba(70, 20, 20, 0.99) 50%, 
          rgba(85, 22, 22, 0.98) 100%
        );
      color: #ff0000;
      transform: translateY(-2px);
      box-shadow: 
        0 6px 25px rgba(255, 0, 0, 0.4),
        0 0 40px rgba(255, 0, 0, 0.3);
    }
    
    /* Main Content Area */
    .mp-content {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 60px 20px 20px;
      position: relative;
      z-index: 5;
    }
    
    /* Multiplayer Sections */
    .mp-section {
      background: 
        linear-gradient(135deg, 
          rgba(30, 10, 10, 0.98) 0%, 
          rgba(20, 5, 5, 0.99) 50%, 
          rgba(25, 8, 8, 0.98) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 40px;
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 
        0 0 60px rgba(255, 0, 0, 0.3),
        0 0 120px rgba(139, 0, 0, 0.4),
        0 0 200px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(255, 50, 50, 0.2),
        inset 0 -1px 0 rgba(0, 0, 0, 0.5);
      animation: sectionLevitation 8s ease-in-out infinite;
      position: relative;
      max-width: 600px;
      width: 100%;
    }
    
    .mp-section::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
        transparent 20%, 
        rgba(255, 0, 0, 0.3) 30%,
        rgba(139, 0, 0, 0.2) 50%, 
        rgba(255, 0, 0, 0.3) 70%,
        transparent 80%
      );
      border-radius: 12px;
      z-index: -1;
      animation: borderFlow 6s linear infinite;
    }
    
    .mp-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2.5rem;
      color: #ff4444;
      text-align: center;
      margin-bottom: 30px;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ff0000 0%, #8b0000 30%, #ff3333 60%, #cc0000 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 12px rgba(255, 0, 0, 0.8));
      animation: titlePulse 4s ease-in-out infinite;
    }
    
    .mp-subtitle {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #ff6666;
      text-align: center;
      margin-bottom: 40px;
      opacity: 0.9;
      text-shadow: 0 0 8px rgba(255, 100, 100, 0.5);
      letter-spacing: 1px;
    }
    
    /* Form Elements */
    .form-group {
      margin-bottom: 25px;
    }
    
    .form-label {
      display: block;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      color: #ff4444;
      margin-bottom: 8px;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
      letter-spacing: 0.5px;
    }
    
    .form-input {
      width: 100%;
      padding: 15px 18px;
      background: 
        linear-gradient(135deg, 
          rgba(40, 15, 15, 0.95) 0%, 
          rgba(30, 10, 10, 0.98) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      color: #ff6666;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      transition: all 0.3s ease;
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(255, 0, 0, 0.1);
      backdrop-filter: blur(4px);
    }
    
    .form-input::placeholder {
      color: rgba(255, 100, 100, 0.5);
      font-style: italic;
    }
    
    .form-input:focus {
      outline: none;
      border-color: rgba(255, 0, 0, 0.9);
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.4),
        0 0 30px rgba(255, 0, 0, 0.3),
        0 0 15px rgba(255, 0, 0, 0.5);
      background: 
        linear-gradient(135deg, 
          rgba(50, 20, 20, 0.98) 0%, 
          rgba(40, 15, 15, 0.99) 100%
        );
    }
    
    /* Action Buttons */
    .action-button {
      width: 100%;
      padding: 18px 25px;
      background: 
        linear-gradient(135deg, 
          rgba(60, 20, 20, 0.98) 0%, 
          rgba(45, 15, 15, 0.99) 50%, 
          rgba(55, 18, 18, 0.98) 100%
        );
      border: 1px solid rgba(255, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.2rem;
      cursor: crosshair;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 0 12px rgba(255, 68, 68, 0.6);
      letter-spacing: 1px;
      border-radius: 8px;
      box-shadow: 
        0 4px 20px rgba(139, 0, 0, 0.6),
        0 0 30px rgba(255, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 50, 50, 0.15);
      backdrop-filter: blur(4px);
      margin-bottom: 15px;
      position: relative;
      overflow: hidden;
    }
    
    .action-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 0, 0, 0.2) 30%, 
        rgba(255, 50, 50, 0.4) 50%, 
        rgba(255, 0, 0, 0.2) 70%, 
        transparent 100%
      );
      transition: left 0.6s ease;
      z-index: 1;
    }
    
    .action-button span {
      position: relative;
      z-index: 2;
    }
    
    .action-button:hover {
      background: 
        linear-gradient(135deg, 
          rgba(100, 30, 30, 0.98) 0%, 
          rgba(80, 25, 25, 0.99) 50%, 
          rgba(95, 28, 28, 0.98) 100%
        );
      color: #ff0000;
      transform: translateY(-3px) scale(1.02);
      box-shadow: 
        0 8px 35px rgba(255, 0, 0, 0.4),
        0 0 50px rgba(255, 0, 0, 0.3);
    }
    
    .action-button:hover::before {
      left: 100%;
    }
    
    .action-button.secondary {
      background: 
        linear-gradient(135deg, 
          rgba(40, 15, 15, 0.95) 0%, 
          rgba(30, 10, 10, 0.98) 50%, 
          rgba(35, 12, 12, 0.95) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.6);
      font-size: 1rem;
      padding: 15px 20px;
    }
    
    /* Divider */
    .form-divider {
      display: flex;
      align-items: center;
      margin: 30px 0;
      text-align: center;
    }
    
    .form-divider::before,
    .form-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.5), transparent);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    
    .form-divider span {
      padding: 0 20px;
      font-family: 'Cinzel', serif;
      color: #ff6666;
      font-weight: 600;
      text-shadow: 0 0 8px rgba(255, 100, 100, 0.5);
      letter-spacing: 1px;
    }
    
    /* Current Lobby Section */
    .current-lobby-section {
      text-align: center;
    }
    
    .lobby-info {
      background: 
        linear-gradient(135deg, 
          rgba(20, 5, 5, 0.95) 0%, 
          rgba(30, 10, 10, 0.9) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.7);
      border-radius: 8px;
      padding: 25px;
      margin-bottom: 30px;
      backdrop-filter: blur(4px);
      box-shadow: 
        inset 0 1px 0 rgba(255, 50, 50, 0.1),
        0 0 20px rgba(255, 0, 0, 0.1);
    }
    
    .lobby-code-section {
      margin-bottom: 20px;
    }
    
    .lobby-code-label {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #ff4444;
      margin-bottom: 10px;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }
    
    .lobby-code-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .code-value {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 2rem;
      color: #ff0000;
      background: 
        linear-gradient(135deg, 
          rgba(40, 15, 15, 0.95) 0%, 
          rgba(30, 10, 10, 0.98) 100%
        );
      border: 1px solid rgba(255, 0, 0, 0.8);
      padding: 15px 25px;
      border-radius: 8px;
      letter-spacing: 3px;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
      box-shadow: 
        0 0 30px rgba(255, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 50, 50, 0.2);
      animation: codeGlow 3s ease-in-out infinite;
    }
    
    .copy-button {
      background: 
        linear-gradient(135deg, 
          rgba(50, 15, 15, 0.95) 0%, 
          rgba(35, 10, 10, 0.98) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.8);
      color: #ff4444;
      font-family: 'Cinzel', serif;
      padding: 12px 18px;
      border-radius: 6px;
      cursor: crosshair;
      transition: all 0.3s ease;
      font-size: 0.9rem;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }
    
    .copy-button:hover {
      background: 
        linear-gradient(135deg, 
          rgba(80, 25, 25, 0.98) 0%, 
          rgba(60, 20, 20, 0.99) 100%
        );
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3);
    }
    
    /* Player List */
    .player-list-section {
      margin-bottom: 25px;
    }
    
    .player-list-title {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.2rem;
      color: #ff4444;
      margin-bottom: 15px;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }
    
    .player-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .player-item {
      background: 
        linear-gradient(135deg, 
          rgba(40, 15, 15, 0.9) 0%, 
          rgba(30, 10, 10, 0.95) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.5);
      border-radius: 6px;
      padding: 15px 20px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(2px);
      transition: all 0.3s ease;
    }
    
    .player-item:hover {
      border-color: rgba(255, 0, 0, 0.7);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.2);
    }
    
    .player-name {
      font-family: 'Cinzel', serif;
      color: #ff6666;
      font-weight: 600;
      text-shadow: 0 0 8px rgba(255, 100, 100, 0.5);
    }
    
    .player-status {
      font-family: 'Orbitron', monospace;
      font-size: 0.9rem;
      font-weight: 600;
      padding: 5px 12px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .player-status.ready {
      background: rgba(0, 100, 0, 0.3);
      color: #66ff66;
      border: 1px solid rgba(0, 255, 0, 0.5);
      text-shadow: 0 0 8px rgba(0, 255, 0, 0.6);
    }
    
    .player-status.not-ready {
      background: rgba(100, 100, 0, 0.3);
      color: #ffff66;
      border: 1px solid rgba(255, 255, 0, 0.5);
      text-shadow: 0 0 8px rgba(255, 255, 0, 0.6);
    }
    
    /* Ready Button */
    .ready-button {
      width: 100%;
      padding: 18px 25px;
      margin-bottom: 15px;
      font-size: 1.3rem;
      font-weight: 700;
      background: 
        linear-gradient(135deg, 
          rgba(80, 20, 20, 0.98) 0%, 
          rgba(60, 15, 15, 0.99) 50%, 
          rgba(75, 18, 18, 0.98) 100%
        );
      border: 1px solid rgba(255, 0, 0, 0.9);
      color: #ff0000;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
      animation: readyPulse 2s ease-in-out infinite;
    }
    
    .ready-button.ready-state {
      background: 
        linear-gradient(135deg, 
          rgba(20, 80, 20, 0.98) 0%, 
          rgba(15, 60, 15, 0.99) 50%, 
          rgba(18, 75, 18, 0.98) 100%
        );
      border: 1px solid rgba(0, 255, 0, 0.9);
      color: #00ff00;
      text-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
    }
    
    /* Waiting Message */
    .waiting-message {
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      color: #ff6666;
      text-align: center;
      margin: 20px 0;
      padding: 15px;
      background: 
        linear-gradient(135deg, 
          rgba(30, 10, 10, 0.8) 0%, 
          rgba(20, 5, 5, 0.9) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.5);
      border-radius: 6px;
      text-shadow: 0 0 8px rgba(255, 100, 100, 0.5);
      animation: messageFlicker 4s ease-in-out infinite;
    }
    
    /* Multiplayer Animations */
    @keyframes battlefieldDrift {
      0% { background-position-x: 0; }
      100% { background-position-x: 800px; }
    }
    
    @keyframes wireOscillation {
      0%, 100% { transform: translateY(0) scaleY(1); }
      50% { transform: translateY(-4px) scaleY(0.98); }
    }
    
    @keyframes smokeFlow {
      0%, 100% { opacity: 1; transform: translateX(0); }
      50% { opacity: 0.7; transform: translateX(20px); }
    }
    
    @keyframes sectionLevitation {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    @keyframes borderFlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes titlePulse {
      0%, 100% { 
        filter: drop-shadow(0 0 12px rgba(255, 0, 0, 0.8)); 
        transform: scale(1);
      }
      50% { 
        filter: drop-shadow(0 0 20px rgba(255, 0, 0, 1)); 
        transform: scale(1.02);
      }
    }
    
    @keyframes codeGlow {
      0%, 100% { 
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), inset 0 1px 0 rgba(255, 50, 50, 0.2); 
      }
      50% { 
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.5), inset 0 1px 0 rgba(255, 50, 50, 0.3); 
      }
    }
    
    @keyframes readyPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    
    @keyframes messageFlicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
    
    /* Responsive Design for Multiplayer */
    @media (max-width: 1024px) {
      .mp-section {
        padding: 30px;
        max-width: 90%;
      }
      
      .mp-title {
        font-size: 2.2rem;
      }
      
      .code-value {
        font-size: 1.8rem;
        padding: 12px 20px;
      }
    }
    
    @media (max-width: 768px) {
      .back-button {
        top: 20px;
        left: 20px;
        padding: 10px 16px;
        font-size: 0.9rem;
      }
      
      .mp-content {
        padding: 80px 15px 15px;
      }
      
      .mp-section {
        padding: 25px;
      }
      
      .mp-title {
        font-size: 1.8rem;
        margin-bottom: 25px;
      }
      
      .mp-subtitle {
        font-size: 1rem;
        margin-bottom: 30px;
      }
      
      .lobby-code-display {
        flex-direction: column;
        gap: 10px;
      }
      
      .code-value {
        font-size: 1.5rem;
        padding: 10px 15px;
      }
    }
    
    @media (max-width: 480px) {
      .mp-section {
        padding: 20px;
      }
      
      .mp-title {
        font-size: 1.5rem;
        letter-spacing: 1px;
      }
      
      .action-button {
        font-size: 1rem;
        padding: 15px 20px;
      }
      
      .ready-button {
        font-size: 1.1rem;
        padding: 15px 20px;
      }
    }

    /* New Strategic Battlefield UI Styles */
    .main-container {
        min-height: 100vh;
        position: relative;
        background: 
            radial-gradient(ellipse 120% 100% at center bottom, rgba(139, 69, 19, 0.15) 0%, transparent 60%),
            linear-gradient(180deg, 
                rgba(25, 25, 35, 0.9) 0%, 
                rgba(45, 35, 25, 0.8) 20%,
                rgba(35, 25, 15, 0.85) 50%, 
                rgba(20, 15, 10, 0.95) 80%,
                rgba(10, 8, 5, 1) 100%
            );
        filter: contrast(1.3) brightness(0.8);
    }
    
    .battlefield-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 100"><defs><filter id="noise"><feTurbulence baseFrequency="0.9" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.1 0.15 0.2 0.05"/></feComponentTransfer></filter></defs><rect width="400" height="100" fill="%23000" opacity="0.3"/><path d="M0,70 Q100,65 200,70 T400,70 L400,100 L0,100 Z" fill="%234a3728" opacity="0.6"/><path d="M0,80 Q150,75 300,80 T400,80 L400,100 L0,100 Z" fill="%23362519" opacity="0.8"/><rect width="400" height="100" fill="url(%23noise)" opacity="0.4"/></svg>') repeat-x bottom;
        background-size: 800px 200px;
        animation: battlefieldDrift 25s linear infinite;
        z-index: -1;
        opacity: 0.6;
    }
    
    .blood-effects {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }
    
    .blood-gradient {
        position: absolute;
        background: radial-gradient(ellipse at center, rgba(120, 0, 0, 0.25) 0%, rgba(80, 0, 0, 0.15) 30%, transparent 60%);
        filter: blur(3px);
    }
    
    .blood-gradient.corner-tl {
        top: -100px;
        left: -100px;
        width: 300px;
        height: 300px;
        transform: rotate(45deg);
    }
    
    .blood-gradient.corner-br {
        bottom: -100px;
        right: -100px;
        width: 350px;
        height: 350px;
        transform: rotate(-135deg);
    }
    
    .environmental-effects {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            radial-gradient(circle at 25% 75%, rgba(139, 0, 0, 0.06) 0%, transparent 50%),
            radial-gradient(circle at 75% 25%, rgba(0, 0, 139, 0.03) 0%, transparent 50%);
        animation: environmentalShift 12s ease-in-out infinite;
        pointer-events: none;
        z-index: 1;
    }
    
    .depth-vignette {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            radial-gradient(ellipse 70% 50% at center, transparent 20%, rgba(0, 0, 0, 0.3) 60%, rgba(0, 0, 0, 0.7) 100%);
        pointer-events: none;
        z-index: 2;
    }
    
    .game-container {
        display: flex;
        min-height: 100vh;
        gap: 20px;
        padding: 20px;
    }
    
    .battlefield-section {
        flex: 2;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    
    .battlefield-section h2 {
        font-family: 'Orbitron', monospace;
        font-weight: 900;
        font-size: 2.2rem;
        color: #ff4444;
        text-align: center;
        letter-spacing: 3px;
        text-transform: uppercase;
        background: linear-gradient(135deg, #ff4444 0%, #cc0000 50%, #ff6666 100%);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        filter: drop-shadow(0 0 12px rgba(255, 68, 68, 0.8));
        animation: titlePulse 3s ease-in-out infinite;
        margin-bottom: 20px;
        position: relative;
    }
    
    .battlefield-section h2::after {
        content: '';
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 80%;
        height: 2px;
        background: linear-gradient(90deg, transparent, #ff4444, transparent);
        animation: underlineGlow 2.5s ease-in-out infinite;
    }
    
    .battlefield {
        background: 
            linear-gradient(135deg, 
                rgba(40, 30, 25, 0.95) 0%, 
                rgba(30, 25, 20, 0.98) 50%, 
                rgba(35, 30, 25, 0.95) 100%
            ),
            url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="battleNoise"><feTurbulence baseFrequency="0.8" numOctaves="4" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.03 0.08 0.12 0.02"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23battleNoise)" opacity="0.4"/></svg>');
        border: 3px solid rgba(120, 80, 60, 0.8);
        border-radius: 15px;
        padding: 25px;
        box-shadow: 
            0 0 50px rgba(255, 0, 0, 0.2),
            0 0 100px rgba(0, 0, 0, 0.8),
            inset 0 2px 0 rgba(255, 255, 255, 0.1),
            inset 0 -2px 0 rgba(0, 0, 0, 0.4);
        position: relative;
        backdrop-filter: blur(5px);
        animation: battlefieldBreathing 6s ease-in-out infinite;
    }
    
    .battlefield::before {
        content: '';
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        background: linear-gradient(45deg, 
            transparent 30%, 
            rgba(255, 68, 68, 0.15) 50%, 
            transparent 70%
        );
        border-radius: 15px;
        z-index: -1;
        animation: borderPulse 4s linear infinite;
    }
    
    .grid-6 {
        display: grid;
        gap: 0px;
        height: auto;
        min-height: auto;
        align-items: start;
        justify-items: stretch;
        grid-auto-rows: min-content;
    }
    
    /* Special styling for 5-column layouts (10 zones) */
    .battlefield[style*="grid-template-columns: repeat(5, 1fr)"] {
        max-width: 1200px;
        margin: 0 auto;
    }
    

    
    .zone {
        background: 
            linear-gradient(135deg, 
                rgba(60, 50, 45, 0.9) 0%, 
                rgba(45, 40, 35, 0.95) 50%, 
                rgba(55, 45, 40, 0.9) 100%
            );
        border: 2px solid rgba(100, 80, 70, 0.7);
        border-radius: 0px;
        padding: 8px;
        cursor: none;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-height: 120px;
        height: 140px;
        flex-shrink: 0;
        box-shadow: 
            0 2px 8px rgba(0, 0, 0, 0.5),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .zone::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            radial-gradient(circle at 30% 30%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 70% 70%, rgba(80, 40, 20, 0.08) 0%, transparent 50%);
        border-radius: 6px;
        pointer-events: none;
    }
    
    .zone:hover {
        transform: translateY(-3px) scale(1.02);
        border-color: rgba(255, 102, 102, 0.8);
        box-shadow: 
            0 8px 25px rgba(255, 0, 0, 0.3),
            0 0 30px rgba(255, 102, 102, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
        background: 
            linear-gradient(135deg, 
                rgba(80, 60, 55, 0.95) 0%, 
                rgba(65, 55, 50, 0.98) 50%, 
                rgba(75, 60, 55, 0.95) 100%
            );
    }
    
    .zone.red {
        border-color: rgba(255, 0, 0, 0.8);
        background: 
            linear-gradient(135deg, 
                rgba(80, 40, 40, 0.9) 0%, 
                rgba(70, 30, 30, 0.95) 50%, 
                rgba(90, 50, 50, 0.9) 100%
            );
        box-shadow: 
            0 0 20px rgba(255, 0, 0, 0.3),
            0 2px 8px rgba(0, 0, 0, 0.6);
    }
    
    .zone.blue {
        border-color: rgba(0, 100, 255, 0.8);
        background: 
            linear-gradient(135deg, 
                rgba(40, 50, 80, 0.9) 0%, 
                rgba(30, 40, 70, 0.95) 50%, 
                rgba(50, 60, 90, 0.9) 100%
            );
        box-shadow: 
            0 0 20px rgba(0, 100, 255, 0.3),
            0 2px 8px rgba(0, 0, 0, 0.6);
    }
    
    .zone.neutral {
        border-color: rgba(150, 150, 150, 0.6);
        background: 
            linear-gradient(135deg, 
                rgba(60, 60, 60, 0.8) 0%, 
                rgba(50, 50, 50, 0.9) 50%, 
                rgba(70, 70, 70, 0.8) 100%
            );
    }
    
    .zone.locked {
        opacity: 0.6;
        cursor: not-allowed;
        filter: grayscale(0.5);
    }
    
    .zone .rename-zone {
        position: absolute !important;
        bottom: 4px !important;
        right: 4px !important;
        top: auto !important;
        left: auto !important;
        background: rgba(255, 68, 68, 0.2);
        border: 1px solid rgba(255, 68, 68, 0.5);
        color: #ff6666;
        border-radius: 3px;
        padding: 2px 6px;
        font-size: 8px;
        cursor: none;
        transition: all 0.2s ease;
        z-index: 100;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        pointer-events: auto;
    }
    
    .rename-zone:hover {
        background: rgba(255, 68, 68, 0.4);
        color: #ff4444;
        transform: scale(1.1);
    }
    
    .zone-header {
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 0.9rem;
        color: #ff8888;
        text-align: center;
        margin-bottom: 4px;
        text-shadow: 0 0 5px rgba(255, 136, 136, 0.3);
        position: relative;
        z-index: 5;
    }
    
    .zone-units {
        display: flex;
        flex-direction: column;
        gap: 2px;
        font-size: 0.8rem;
        font-weight: 600;
        position: relative;
        z-index: 5;
    }
    
    .zone-units span {
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
    }
    
    .current-player {
        background: 
            linear-gradient(135deg, 
                rgba(80, 40, 40, 0.95) 0%, 
                rgba(70, 30, 30, 0.98) 50%, 
                rgba(90, 50, 50, 0.95) 100%
            );
        border: 2px solid rgba(255, 68, 68, 0.8);
        border-radius: 10px;
        padding: 15px 20px;
        text-align: center;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 1.2rem;
        color: #ff4444;
        letter-spacing: 1px;
        box-shadow: 
            0 0 25px rgba(255, 68, 68, 0.4),
            0 2px 10px rgba(0, 0, 0, 0.5);
        animation: playerIndicatorPulse 2s ease-in-out infinite;
    }
    
    .demonic-effects-section {
        background: 
            linear-gradient(135deg, 
                rgba(40, 20, 20, 0.9) 0%, 
                rgba(30, 15, 15, 0.95) 50%, 
                rgba(50, 25, 25, 0.9) 100%
            );
        border: 2px solid rgba(139, 0, 0, 0.6);
        border-radius: 8px;
        padding: 20px;
        margin-top: 15px;
        position: relative;
        overflow: hidden;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        box-shadow: 
            0 0 20px rgba(139, 0, 0, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .demonic-effects-section::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            radial-gradient(circle at 30% 30%, rgba(139, 0, 0, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 70% 70%, rgba(80, 0, 0, 0.08) 0%, transparent 50%);
        pointer-events: none;
    }
    
    .demonic-symbols {
        display: flex;
        justify-content: space-around;
        width: 100%;
        margin-bottom: 15px;
        position: relative;
        z-index: 2;
    }
    
    .symbol {
        font-size: 1.5rem;
        color: #ff4444;
        text-shadow: 0 0 10px rgba(255, 68, 68, 0.8);
        animation: symbolFloat 3s ease-in-out infinite;
        opacity: 0.8;
    }
    
    .symbol-1 { animation-delay: 0s; }
    .symbol-2 { animation-delay: 0.5s; }
    .symbol-3 { animation-delay: 1s; }
    .symbol-4 { animation-delay: 1.5s; }
    .symbol-5 { animation-delay: 2s; }
    .symbol-6 { animation-delay: 2.5s; }
    
    .demonic-text {
        display: flex;
        justify-content: space-around;
        width: 100%;
        margin-bottom: 15px;
        position: relative;
        z-index: 2;
    }
    
    .demonic-word {
        font-family: 'Orbitron', monospace;
        font-weight: 900;
        font-size: 0.8rem;
        color: #cc6666;
        text-shadow: 0 0 5px rgba(204, 102, 102, 0.5);
        letter-spacing: 2px;
        animation: wordGlow 4s ease-in-out infinite;
        opacity: 0.7;
    }
    
    .demonic-word:nth-child(1) { animation-delay: 0s; }
    .demonic-word:nth-child(2) { animation-delay: 1s; }
    .demonic-word:nth-child(3) { animation-delay: 2s; }
    .demonic-word:nth-child(4) { animation-delay: 3s; }
    
    .demonic-pentagram {
        position: relative;
        width: 60px;
        height: 60px;
        position: relative;
        z-index: 2;
    }
    
    .pentagram-inner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 40px;
        height: 40px;
        background: 
            radial-gradient(circle at 50% 50%, 
                rgba(139, 0, 0, 0.8) 0%, 
                rgba(139, 0, 0, 0.4) 40%, 
                transparent 70%
            );
        clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
        animation: pentagramPulse 2s ease-in-out infinite;
    }
    
    .pentagram-outer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        border: 2px solid rgba(139, 0, 0, 0.6);
        border-radius: 50%;
        animation: pentagramRotate 8s linear infinite;
    }
    
    .controls-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
        min-width: 350px;
    }
    
    .control-panel {
        background: 
            linear-gradient(135deg, 
                rgba(40, 40, 45, 0.95) 0%, 
                rgba(30, 30, 35, 0.98) 50%, 
                rgba(25, 25, 30, 0.99) 100%
            ),
            url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="controlNoise"><feTurbulence baseFrequency="0.7" numOctaves="3" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/><feComponentTransfer><feFuncA type="discrete" tableValues="0.05 0.1 0.15 0.02"/></feComponentTransfer></filter></defs><rect width="100" height="100" fill="url(%23controlNoise)" opacity="0.3"/></svg>');
        border: 2px solid rgba(100, 100, 110, 0.8);
        border-radius: 12px;
        padding: 20px;
        backdrop-filter: blur(8px) saturate(1.2);
        box-shadow: 
            0 0 30px rgba(255, 0, 0, 0.1),
            0 0 60px rgba(0, 0, 0, 0.6),
            inset 0 1px 0 rgba(255, 255, 255, 0.1),
            inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        position: relative;
    }
    
    .control-panel::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, 
            transparent 30%, 
            rgba(255, 0, 0, 0.08) 50%, 
            transparent 70%
        );
        border-radius: 12px;
        z-index: -1;
        animation: controlPanelGlow 5s linear infinite;
    }
    
    .command-points {
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 1.3rem;
        color: #ff6666;
        text-align: center;
        padding: 15px;
        background: 
            linear-gradient(135deg, 
                rgba(60, 30, 30, 0.9) 0%, 
                rgba(50, 25, 25, 0.95) 50%, 
                rgba(70, 35, 35, 0.9) 100%
            );
        border: 2px solid rgba(255, 102, 102, 0.6);
        border-radius: 8px;
        letter-spacing: 2px;
        text-shadow: 0 0 8px rgba(255, 102, 102, 0.5);
        box-shadow: 
            0 0 15px rgba(255, 102, 102, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .artillery-section {
        background: 
            linear-gradient(135deg, 
                rgba(60, 45, 30, 0.9) 0%, 
                rgba(50, 35, 25, 0.95) 50%, 
                rgba(70, 50, 35, 0.9) 100%
            );
        border: 2px solid rgba(139, 102, 69, 0.8);
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        color: #cc8866;
        letter-spacing: 1px;
        box-shadow: 
            0 0 15px rgba(139, 102, 69, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .ai-turn-indicator {
        background: 
            linear-gradient(135deg, 
                rgba(40, 50, 80, 0.9) 0%, 
                rgba(30, 40, 70, 0.95) 50%, 
                rgba(50, 60, 90, 0.9) 100%
            );
        border: 2px solid rgba(0, 100, 255, 0.8);
        border-radius: 10px;
        padding: 20px;
        text-align: center;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        color: #6699ff;
        animation: aiProcessing 1.5s ease-in-out infinite;
    }
    
    .menu-button {
        background: 
            linear-gradient(135deg, 
                rgba(60, 50, 45, 0.9) 0%, 
                rgba(45, 40, 35, 0.95) 50%, 
                rgba(55, 45, 40, 0.9) 100%
            );
        border: 2px solid rgba(120, 100, 90, 0.8);
        color: #ff8888;
        font-family: 'Cinzel', serif;
        font-weight: 600;
        font-size: 1rem;
        padding: 12px 20px;
        cursor: crosshair;
        border-radius: 8px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 
            0 2px 8px rgba(0, 0, 0, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
        margin: 5px 0;
    }
    
    .menu-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(255, 136, 136, 0.1) 30%, 
            rgba(255, 136, 136, 0.2) 50%, 
            rgba(255, 136, 136, 0.1) 70%, 
            transparent 100%
        );
        transition: left 0.6s ease;
        z-index: 1;
    }
    
    .menu-button span {
        position: relative;
        z-index: 2;
    }
    
    .menu-button:hover {
        background: 
            linear-gradient(135deg, 
                rgba(80, 60, 55, 0.95) 0%, 
                rgba(65, 55, 50, 0.98) 50%, 
                rgba(75, 60, 55, 0.95) 100%
            );
        color: #ff6666;
        border-color: rgba(255, 136, 136, 0.9);
        transform: translateY(-2px);
        box-shadow: 
            0 4px 15px rgba(255, 0, 0, 0.2),
            0 0 20px rgba(255, 136, 136, 0.15);
    }
    
    .menu-button:hover::before {
        left: 100%;
    }
    
    .log {
        background: 
            linear-gradient(135deg, 
                rgba(25, 25, 30, 0.95) 0%, 
                rgba(20, 20, 25, 0.98) 50%, 
                rgba(30, 30, 35, 0.95) 100%
            );
        border: 2px solid rgba(80, 80, 90, 0.6);
        border-radius: 8px;
        padding: 15px;
        height: 200px;
        overflow-y: auto;
        font-family: 'Cinzel', serif;
        font-size: 0.9rem;
        color: #cc9999;
        line-height: 1.4;
        box-shadow: 
            inset 0 2px 8px rgba(0, 0, 0, 0.6),
            0 0 15px rgba(0, 0, 0, 0.3);
    }
    
    .log::-webkit-scrollbar {
        width: 8px;
    }
    
    .log::-webkit-scrollbar-track {
        background: rgba(40, 40, 50, 0.5);
        border-radius: 4px;
    }
    
    .log::-webkit-scrollbar-thumb {
        background: rgba(255, 68, 68, 0.6);
        border-radius: 4px;
    }
    
    .log::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 68, 68, 0.8);
    }
    
    /* Animations */
    @keyframes battlefieldDrift {
        0% { background-position-x: 0; }
        100% { background-position-x: 800px; }
    }
    
    @keyframes titlePulse {
        0%, 100% { 
            filter: drop-shadow(0 0 12px rgba(255, 68, 68, 0.8)); 
            transform: scale(1);
        }
        50% { 
            filter: drop-shadow(0 0 25px rgba(255, 68, 68, 1.2)); 
            transform: scale(1.01);
        }
    }
    
    @keyframes underlineGlow {
        0%, 100% { opacity: 0.6; transform: translateX(-50%) scaleX(0.9); }
        50% { opacity: 1; transform: translateX(-50%) scaleX(1.2); }
    }
    
    @keyframes battlefieldBreathing {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.005); }
    }
    
    @keyframes borderPulse {
        0% { transform: rotate(0deg); opacity: 0.3; }
        50% { opacity: 0.6; }
        100% { transform: rotate(360deg); opacity: 0.3; }
    }
    
    @keyframes playerIndicatorPulse {
        0%, 100% { 
            box-shadow: 
                0 0 25px rgba(255, 68, 68, 0.4),
                0 2px 10px rgba(0, 0, 0, 0.5);
        }
        50% { 
            box-shadow: 
                0 0 40px rgba(255, 68, 68, 0.6),
                0 2px 10px rgba(0, 0, 0, 0.5);
        }
    }
    
    @keyframes controlPanelGlow {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    @keyframes aiProcessing {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
    }
    
    @keyframes environmentalShift {
        0%, 100% { opacity: 0.4; }
        33% { opacity: 0.6; }
        66% { opacity: 0.3; }
    }
    
    @keyframes symbolFloat {
        0%, 100% { transform: translateY(0px) scale(1); opacity: 0.8; }
        50% { transform: translateY(-5px) scale(1.1); opacity: 1; }
    }
    
    @keyframes wordGlow {
        0%, 100% { 
            text-shadow: 0 0 5px rgba(204, 102, 102, 0.5);
            opacity: 0.7;
        }
        50% { 
            text-shadow: 0 0 15px rgba(204, 102, 102, 0.8);
            opacity: 1;
        }
    }
    
    @keyframes pentagramPulse {
        0%, 100% { 
            opacity: 0.8;
            transform: translate(-50%, -50%) scale(1);
        }
        50% { 
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }
    }
    
    @keyframes pentagramRotate {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    /* Responsive Design */
    @media (max-width: 1200px) {
        .game-container {
            flex-direction: column;
        }
        
        .controls-section {
            min-width: auto;
        }
        
        .grid-6 {
            min-height: 400px;
        }
    }
    
    @media (max-width: 768px) {
        .game-container {
            padding: 10px;
            gap: 15px;
        }
        
        .battlefield-section h2 {
            font-size: 1.8rem;
        }
        
        .grid-6 {
            grid-template-columns: repeat(3, 1fr);
            min-height: 300px;
        }
        
        .zone {
            min-height: 80px;
            height: 100px;
            padding: 6px;
        }
        
        .zone-header {
            font-size: 0.8rem;
        }
        
        .zone-units {
            font-size: 0.7rem;
        }
    }
    
    @media (max-width: 480px) {
        .battlefield {
            padding: 15px;
        }
        
        .control-panel {
            padding: 15px;
        }
        
        .menu-button {
            padding: 10px 15px;
            font-size: 0.9rem;
      }
    }

    /* PHASE 4: ENHANCED ZONE BATTLE LAYOUT - HELLISH THEME */
    
    /* Remove Glow Effects for Performance */
    .unit-marker.red-unit {
      animation: unitPulse 3s ease-in-out infinite;
    }

    .unit-marker.blue-unit {
      animation: unitPulse 3s ease-in-out infinite;
    }

    /* Global reset for zone detail */
    #zone-detail * {
      box-sizing: border-box;
    }
    
    /* Zone Detail Screen - Hellish Battlefield Theme */
    #zone-detail {
      position: relative;
      width: 100%;
      height: 100vh;
      background: #000;
      cursor: crosshair;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
      /* Debug: Add border to see container bounds */
      /* border: 2px solid red; */
    }



    /* Dark Void Background with Hell Burst */
    #zone-detail .zone-battle-container {
      position: relative;
      width: 100%;
      height: auto;
      background: 
        radial-gradient(ellipse 80% 60% at center center, 
          rgba(139, 0, 0, 0.8) 0%, 
          rgba(80, 0, 0, 0.6) 30%, 
          rgba(40, 0, 0, 0.4) 60%, 
          rgba(0, 0, 0, 0.9) 80%, 
          #000000 100%),
        radial-gradient(ellipse 120% 40% at center bottom, 
          rgba(255, 50, 0, 0.3) 0%, 
          rgba(139, 0, 0, 0.2) 40%, 
          transparent 70%),
        linear-gradient(180deg, 
          rgba(0, 0, 0, 1) 0%, 
          rgba(20, 0, 0, 0.95) 20%,
          rgba(40, 5, 5, 0.8) 50%, 
          rgba(20, 0, 0, 0.95) 80%,
          rgba(0, 0, 0, 1) 100%);
      animation: hellPulse 8s ease-in-out infinite alternate;
      padding-bottom: 120px; /* Add padding to prevent scroll past bottom */
      /* Debug: Ensure proper height calculation */
      min-height: calc(100vh - 120px);
      max-height: calc(100vh - 120px);
    }

    @keyframes hellPulse {
      0% { filter: brightness(0.9) contrast(1.1); }
      100% { filter: brightness(1.1) contrast(1.3); }
    }

    /* Floating Hell Particles */
    #zone-detail .battlefield-atmosphere {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    #zone-detail .battlefield-atmosphere::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(2px 2px at 20% 10%, rgba(255, 0, 0, 0.4), transparent),
        radial-gradient(1px 1px at 80% 20%, rgba(255, 100, 0, 0.3), transparent),
        radial-gradient(1px 1px at 10% 80%, rgba(139, 0, 0, 0.4), transparent),
        radial-gradient(2px 2px at 90% 90%, rgba(200, 0, 0, 0.3), transparent);
      animation: hellParticles 12s linear infinite;
    }

    @keyframes hellParticles {
      0% { transform: translateY(0px) rotate(0deg); opacity: 0.6; }
      50% { opacity: 0.8; }
      100% { transform: translateY(-20px) rotate(360deg); opacity: 0.4; }
    }

    /* Main UI Layout - Better Proportions */
    #zone-detail .zone-ui-wrapper {
      position: relative;
      z-index: 10;
      height: auto;
      display: grid;
      grid-template-areas: 
        "header header header"
        "left center right"
        "bottom bottom bottom";
      grid-template-rows: 90px 1fr 100px;
      grid-template-columns: 280px 1fr 320px;
      gap: 15px;
      padding: 15px;
      width: 100%;
      max-width: 100%;
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* Enhanced Top Header */
    #zone-detail .zone-header {
      grid-area: header;
      background: 
        linear-gradient(135deg, 
          rgba(60, 15, 15, 0.95) 0%, 
          rgba(40, 8, 8, 0.98) 30%, 
          rgba(80, 20, 20, 0.92) 70%, 
          rgba(50, 12, 12, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.8);
      border-radius: 8px;
      padding: 12px 25px;
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      align-items: center;
      box-shadow: 
        0 0 30px rgba(255, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 80, 80, 0.3),
        inset 0 -1px 0 rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      position: relative;
      overflow: hidden;
      height: 90px;
    }

    #zone-detail .zone-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.1), transparent);
      animation: headerSweep 6s linear infinite;
    }

    @keyframes headerSweep {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    #zone-detail .zone-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 1.5rem;
      color: #ff0000;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 
        0 0 15px rgba(255, 0, 0, 0.9),
        0 0 30px rgba(139, 0, 0, 0.7),
        3px 3px 6px rgba(0, 0, 0, 0.8);
      position: relative;
      z-index: 2;
      text-align: center;
      grid-column: 2;
      line-height: 1.1;
      margin: auto 0;
      transform: translateY(0);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #zone-detail .zone-status {
      grid-column: 3;
      display: flex;
      flex-direction: row;
      gap: 12px;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      position: relative;
      z-index: 2;
    }

    #zone-detail .zone-status-left {
      grid-column: 1;
      display: flex;
      flex-direction: row;
      gap: 12px;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      position: relative;
      z-index: 2;
      padding-top: 15px;
    }

    #zone-detail .phase-indicator {
      grid-column: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      position: relative;
      z-index: 2;
    }

    #zone-detail .status-item {
      padding: 6px 12px;
      border-radius: 6px;
      background: 
        linear-gradient(135deg, 
          rgba(100, 25, 25, 0.9), 
          rgba(70, 18, 18, 0.95)
        );
      border: 2px solid rgba(255, 50, 50, 0.8);
      color: #ff8888;
      font-weight: 700;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(255, 136, 136, 0.7);
      font-family: 'Orbitron', monospace;
      font-size: 0.8rem;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      box-shadow: 
        0 0 15px rgba(255, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 100, 100, 0.3);
    }

    #zone-detail .status-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 50, 50, 0.3), transparent);
      animation: statusGlow 3s linear infinite;
    }

    @keyframes statusGlow {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    #zone-detail .status-item span {
      color: #ff4444;
      font-weight: 900;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
    }

    /* Expanded Center Battlefield */
    #zone-detail .battlefield-center {
      grid-area: center;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 15px;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      margin-top: 0;
      flex-direction: column;
    }

    #zone-detail .battlefield-frame {
      width: 100%;
      height: 100%;
      max-width: 100%;
      background: 
        linear-gradient(135deg, 
          rgba(80, 20, 20, 0.95) 0%, 
          rgba(50, 12, 12, 0.98) 25%, 
          rgba(100, 25, 25, 0.92) 50%,
          rgba(60, 15, 15, 0.96) 75%,
          rgba(90, 22, 22, 0.94) 100%
        );
      border: 3px solid rgba(139, 0, 0, 0.9);
      border-radius: 12px;
      padding: 0;
      position: relative;
      box-shadow: 
        0 0 60px rgba(255, 0, 0, 0.5),
        0 0 120px rgba(139, 0, 0, 0.3),
        inset 0 2px 0 rgba(255, 80, 80, 0.3),
        inset 0 -2px 0 rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(6px);
      overflow: hidden;
    }

    /* Demonic Decorations Below Battle Grid */
    #zone-detail .demonic-decorations {
      width: 100%;
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      position: relative;
      z-index: 5;
    }

    #zone-detail .demonic-decorations::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 0, 0, 0.8) 20%, 
        rgba(139, 0, 0, 0.9) 50%, 
        rgba(255, 0, 0, 0.8) 80%, 
        transparent 100%
      );
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
    }

    #zone-detail .demonic-symbol {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, 
        rgba(139, 0, 0, 0.9) 0%, 
        rgba(80, 0, 0, 0.8) 50%, 
        rgba(40, 0, 0, 0.9) 100%
      );
      border: 2px solid rgba(255, 0, 0, 0.8);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #ff0000;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
      box-shadow: 
        0 0 30px rgba(255, 0, 0, 0.5),
        inset 0 0 20px rgba(0, 0, 0, 0.7);
      animation: demonicPulse 4s ease-in-out infinite alternate;
      position: relative;
      z-index: 2;
    }

    #zone-detail .demonic-symbol::before {
      content: '';
      position: absolute;
      top: -5px;
      left: -5px;
      right: -5px;
      bottom: -5px;
      border: 1px solid rgba(255, 0, 0, 0.3);
      border-radius: 50%;
      animation: demonicRotate 8s linear infinite;
    }

    @keyframes demonicPulse {
      0% { 
        transform: scale(1) rotate(0deg);
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.7);
      }
      100% { 
        transform: scale(1.1) rotate(5deg);
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.8), inset 0 0 30px rgba(0, 0, 0, 0.9);
      }
    }

    @keyframes demonicRotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #zone-detail .demonic-symbol:nth-child(1)::after { content: ''; }
    #zone-detail .demonic-symbol:nth-child(2)::after { content: ''; }
    #zone-detail .demonic-symbol:nth-child(3)::after { content: ''; }
    #zone-detail .demonic-symbol:nth-child(4)::after { content: ''; }
    #zone-detail .demonic-symbol:nth-child(5)::after { content: ''; }

    #zone-detail .mini-battlefield {
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse 60% 40% at center center, 
          rgba(60, 15, 15, 0.6) 0%, 
          rgba(30, 8, 8, 0.8) 50%, 
          rgba(10, 3, 3, 0.9) 100%
        );
      border: 2px solid rgba(80, 20, 20, 0.8);
      border-radius: 8px;
      position: relative;
      cursor: none !important;
      display: grid;
      gap: 0;
      padding: 0;
      align-content: stretch;
      justify-content: stretch;
      /* Ensure cells fill available space */
      grid-auto-rows: 1fr;
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* Dynamic grid sizing for different battlefield sizes */
    #zone-detail .mini-battlefield.grid-6 {
      grid-template-columns: repeat(6, minmax(0, 1fr));
      grid-template-rows: repeat(6, minmax(0, 1fr));
      grid-auto-rows: 1fr;
    }

    #zone-detail .mini-battlefield.grid-8 {
      grid-template-columns: repeat(8, minmax(0, 1fr));
      grid-template-rows: repeat(8, minmax(0, 1fr));
      grid-auto-rows: 1fr;
    }

    #zone-detail .mini-battlefield.grid-10 {
      grid-template-columns: repeat(10, minmax(0, 1fr));
      grid-template-rows: repeat(10, minmax(0, 1fr));
      grid-auto-rows: 1fr;
    }

    #zone-detail .mini-battlefield.grid-12 {
      grid-template-columns: repeat(12, minmax(0, 1fr));
      grid-template-rows: repeat(12, minmax(0, 1fr));
      grid-auto-rows: 1fr;
    }

    /* Mini zone positioning styles */
    #zone-detail .mini-zone {
      position: relative;
      border: 1px solid rgba(139, 0, 0, 0.4);
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      color: #ff9999;
      cursor: none;
      transition: all 0.2s ease;
      /* Fill available grid track completely */
      width: 100%;
      height: 100%;
      min-width: 0;
      min-height: 0;
      aspect-ratio: auto;
      justify-self: stretch;
      align-self: stretch;
    }

    #zone-detail .mini-zone:hover {
      border-color: rgba(255, 50, 50, 0.8);
      transform: scale(1.05);
      box-shadow: 
        0 8px 25px rgba(255, 0, 0, 0.4),
        0 4px 15px rgba(139, 0, 0, 0.3);
    }
    
    #zone-detail .mini-zone.air-defense-target {
      border-color: #FF4500;
      background: rgba(255, 69, 0, 0.3);
      box-shadow: 0 0 15px rgba(255, 69, 0, 0.7);
      animation: air-defense-pulse 1s infinite;
    }

    /* Responsive font sizing for different grid sizes */
    #zone-detail .mini-battlefield.grid-6 .mini-zone { font-size: 1.1rem; min-height: 0; min-width: 0; }

    #zone-detail .mini-battlefield.grid-8 .mini-zone { font-size: 1rem; min-height: 0; min-width: 0; }

    #zone-detail .mini-battlefield.grid-10 .mini-zone { font-size: 0.9rem; min-height: 0; min-width: 0; }

    #zone-detail .mini-battlefield.grid-12 .mini-zone { font-size: 0.8rem; min-height: 0; min-width: 0; }

    /* Zone Detail Terrain Colors - Override default backgrounds with terrain colors */
    #zone-detail .mini-zone.terrain-plains {
      background: #6B8E23 !important;
      background-color: #6B8E23 !important;
    }

    #zone-detail .mini-zone.terrain-forest {
      background: #006400 !important;
      background-color: #006400 !important;
    }

    #zone-detail .mini-zone.terrain-river {
      background: #4169E1 !important;
      background-color: #4169E1 !important;
      animation: riverFlow 3s ease-in-out infinite;
    }

    #zone-detail .mini-zone.terrain-hills {
      background: #654321 !important;
      background-color: #654321 !important;
    }

    #zone-detail .mini-zone.terrain-mountains {
      background: #2F4F4F !important;
      background-color: #2F4F4F !important;
    }

    #zone-detail .mini-zone.terrain-swamp {
      background: #006400 !important;
      background-color: #006400 !important;
    }

    #zone-detail .mini-zone.terrain-jungle {
      background: #32CD32 !important;
      background-color: #32CD32 !important;
    }

    #zone-detail .mini-zone.terrain-desert {
      background: #D2B48C !important;
      background-color: #D2B48C !important;
    }

    #zone-detail .mini-zone.terrain-ruins {
      background: #A0A0A0 !important;
      background-color: #A0A0A0 !important;
    }

    #zone-detail .mini-zone.terrain-road {
      background: #696969 !important;
      background-color: #696969 !important;
    }

    #zone-detail .mini-zone.terrain-infrastructure {
      background: #696969 !important;
      background-color: #696969 !important;
    }

    #zone-detail .mini-zone.terrain-snow {
      background: #E6F3FF !important;
      background-color: #E6F3FF !important;
    }

    #zone-detail .mini-zone.terrain-volcanic {
      background: #8B0000 !important;
      background-color: #8B0000 !important;
      animation: volcanicGlow 3s ease-in-out infinite;
    }

    #zone-detail .mini-zone.terrain-beach {
      background: #DEB887 !important;
      background-color: #DEB887 !important;
    }

    /* Compact Left Panel */
    #zone-detail .left-panel {
      grid-area: left;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #zone-detail .construction-panel {
      background: 
        linear-gradient(135deg, 
          rgba(60, 15, 15, 0.95) 0%, 
          rgba(40, 10, 10, 0.98) 50%, 
          rgba(55, 14, 14, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.7);
      border-radius: 8px;
      padding: 12px;
      backdrop-filter: blur(4px);
      flex: 1;
    }

    #zone-detail .construction-panel h3 {
      font-family: 'Orbitron', monospace;
      color: #ff4444;
      text-align: center;
      margin-bottom: 12px;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }

    #zone-detail .construction-status {
      color: #cc6666;
      font-size: 0.9rem;
      text-align: center;
      margin-bottom: 10px;
      font-style: italic;
    }

    /* Compact Battle Log */
    #zone-detail .chat-panel {
      background: 
        linear-gradient(135deg, 
          rgba(60, 15, 15, 0.95) 0%, 
          rgba(40, 10, 10, 0.98) 50%, 
          rgba(55, 14, 14, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.7);
      border-radius: 8px;
      padding: 12px;
      backdrop-filter: blur(4px);
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 160px;
    }

    #zone-detail .chat-panel h3 {
      font-family: 'Orbitron', monospace;
      color: #ff4444;
      text-align: center;
      margin-bottom: 8px;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }

    #zone-detail .chat-messages {
      flex: 1;
      overflow-y: auto;
      background: rgba(20, 5, 5, 0.9);
      border: 1px solid rgba(139, 0, 0, 0.4);
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 8px;
      font-size: 0.8rem;
      color: #ff9999;
      min-height: 80px;
    }

    /* Custom Scrollbar for Intelligence Reports */
    #zone-detail .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    #zone-detail .chat-messages::-webkit-scrollbar-track {
      background: rgba(40, 10, 10, 0.8);
      border-radius: 4px;
      border: 1px solid rgba(80, 20, 20, 0.6);
    }

    #zone-detail .chat-messages::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, 
        rgba(139, 0, 0, 0.9) 0%, 
        rgba(100, 0, 0, 0.95) 50%, 
        rgba(80, 0, 0, 0.9) 100%
      );
      border-radius: 4px;
      border: 1px solid rgba(255, 50, 50, 0.4);
      box-shadow: 0 0 6px rgba(255, 0, 0, 0.3);
    }

    #zone-detail .chat-messages::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, 
        rgba(200, 0, 0, 0.95) 0%, 
        rgba(160, 0, 0, 0.98) 50%, 
        rgba(120, 0, 0, 0.95) 100%
      );
      border-color: rgba(255, 80, 80, 0.6);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
    }

    #zone-detail .chat-messages::-webkit-scrollbar-corner {
      background: rgba(40, 10, 10, 0.8);
    }

    #zone-detail .log-entry {
      margin-bottom: 4px;
      padding: 2px 0;
      border-bottom: 1px solid rgba(139, 0, 0, 0.2);
    }

    #zone-detail .chat-input {
      background: rgba(30, 8, 8, 0.9);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 4px;
      padding: 6px 10px;
      color: #ff9999;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
    }

    #zone-detail .chat-input::placeholder {
      color: rgba(255, 153, 153, 0.5);
    }

    /* Enhanced Right Panel */
    #zone-detail .right-panel {
      grid-area: right;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #zone-detail .units-panel,
    #zone-detail .artillery-panel,
    #zone-detail .airplanes-panel {
      background: 
        linear-gradient(135deg, 
          rgba(60, 15, 15, 0.95) 0%, 
          rgba(40, 10, 10, 0.98) 50%, 
          rgba(55, 14, 14, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.7);
      border-radius: 8px;
      padding: 15px;
      backdrop-filter: blur(4px);
    }

    #zone-detail .units-panel {
      flex: 2;
    }

    #zone-detail .artillery-panel,
    #zone-detail .airplanes-panel {
      flex: 1;
    }

    #zone-detail .units-panel h3,
    #zone-detail .artillery-panel h3,
    #zone-detail .airplanes-panel h3 {
      font-family: 'Orbitron', monospace;
      color: #ff4444;
      text-align: center;
      margin-bottom: 12px;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
            text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }

    /* Deployment Controls */
    #zone-detail .deployment-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
    }

    #zone-detail .deployment-controls .action-button {
      flex: 1;
      padding: 8px 6px;
      font-size: 0.8rem;
      margin-bottom: 0;
      min-height: 35px;
    }

    #zone-detail .deployment-controls .action-button.active {
      background: 
        linear-gradient(135deg, 
          rgba(120, 30, 30, 0.98) 0%, 
          rgba(90, 23, 23, 0.99) 50%, 
          rgba(110, 28, 28, 0.98) 100%
        );
      color: #ff3333;
      border-color: rgba(255, 50, 50, 1);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4);
    }

    #zone-detail .deployment-controls .primary-controls {
      display: flex;
      gap: 5px;
      margin-bottom: 8px;
    }

    #zone-detail .deployment-controls .carrier-controls {
      display: flex;
      gap: 5px;
    }

    #zone-detail .deployment-controls .primary-controls .action-button,
    #zone-detail .deployment-controls .carrier-controls .action-button {
      flex: 1;
      padding: 8px 6px;
      font-size: 0.75rem;
      margin-bottom: 0;
      min-height: 35px;
    }

    /* Carrier System Styles */
    .carrier-target {
      background-color: rgba(0, 255, 0, 0.3) !important;
      border: 2px solid #00ff00 !important;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5) !important;
    }

    .disembark-target {
      background-color: rgba(255, 165, 0, 0.3) !important;
      border: 2px solid #ffa500 !important;
      box-shadow: 0 0 10px rgba(255, 165, 0, 0.5) !important;
    }

    .gas-target {
      background-color: rgba(0, 255, 0, 0.3) !important;
      border: 2px solid #00ff00 !important;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.7) !important;
      animation: gasGlow 1.5s ease-in-out infinite alternate;
    }

    @keyframes gasGlow {
      0% { box-shadow: 0 0 15px rgba(0, 255, 0, 0.7); }
      100% { box-shadow: 0 0 25px rgba(0, 255, 0, 1); }
    }

    .gas-cloud {
      position: relative;
    }

    .gas-cloud::after {
      content: '';
      position: absolute;
      top: calc(50% - 10px);
      right: 2px;
      transform: translateY(-50%);
      font-size: 14px;
      z-index: 10;
      color: #00ff00;
      text-shadow: 0 0 4px rgba(0, 255, 0, 1);
      animation: gasCloudPulse 2s ease-in-out infinite alternate;
    }

    .gas-cloud {
      background: linear-gradient(45deg, 
        rgba(0, 255, 0, 0.15) 0%, 
        rgba(50, 255, 50, 0.25) 50%, 
        rgba(0, 255, 0, 0.15) 100%) !important;
      border: 1px solid rgba(0, 255, 0, 0.6) !important;
    }

    @keyframes gasCloudPulse {
      0% { opacity: 0.6; transform: scale(0.9); }
      100% { opacity: 1; transform: scale(1.1); }
    }

    @keyframes gasDiceRoll {
      0% { transform: rotate(0deg) scale(1); }
      25% { transform: rotate(90deg) scale(1.2); }
      50% { transform: rotate(180deg) scale(1); }
      75% { transform: rotate(270deg) scale(1.2); }
      100% { transform: rotate(360deg) scale(1); }
    }

    @keyframes minefieldDiceRoll {
      0% { transform: rotate(0deg) scale(1); }
      25% { transform: rotate(90deg) scale(1.2); }
      50% { transform: rotate(180deg) scale(1); }
      75% { transform: rotate(270deg) scale(1.2); }
      100% { transform: rotate(360deg) scale(1); }
    }

    .transported-units-panel {
      background: linear-gradient(135deg, 
        rgba(40, 10, 10, 0.95) 0%, 
        rgba(60, 15, 15, 0.98) 100%
      );
      border: 2px solid rgba(139, 0, 0, 0.8);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(6px);
      color: #ffffff;
      font-family: 'Cinzel', serif;
    }

    .transported-units-panel h3 {
      margin: 0 0 15px 0;
      color: #ff6666;
      font-size: 1.1rem;
      text-align: center;
      border-bottom: 1px solid rgba(139, 0, 0, 0.5);
      padding-bottom: 8px;
    }

    .transported-units-menu {
      background: linear-gradient(135deg, 
        rgba(40, 10, 10, 0.95) 0%, 
        rgba(60, 15, 15, 0.98) 100%
      );
      border: 2px solid rgba(139, 0, 0, 0.8);
      border-radius: 8px;
      padding: 15px;
      min-width: 250px;
      max-width: 300px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(6px);
      color: #ffffff;
      font-family: 'Cinzel', serif;
    }

    .transported-units-menu .menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(139, 0, 0, 0.5);
    }

    .transported-units-menu .menu-header h4 {
      margin: 0;
      color: #ff6666;
      font-size: 1rem;
    }

    .transported-units-menu .close-btn {
      background: rgba(139, 0, 0, 0.8);
      border: 1px solid #ff3333;
      color: #ffffff;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1;
    }

    .transported-units-menu .close-btn:hover {
      background: rgba(139, 0, 0, 1);
      box-shadow: 0 2px 8px rgba(255, 0, 0, 0.4);
    }

    .transported-units-menu .units-list,
    .transported-units-panel .units-list {
      margin-bottom: 10px;
    }

    .transported-unit-item {
      background: rgba(80, 20, 20, 0.6);
      border: 1px solid rgba(139, 0, 0, 0.6);
      border-radius: 4px;
      padding: 8px 12px;
      margin-bottom: 5px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .transported-unit-item:hover {
      background: rgba(139, 0, 0, 0.8);
      border-color: #ff3333;
      box-shadow: 0 2px 8px rgba(255, 0, 0, 0.3);
    }

    .transported-unit-item.selected {
      background: rgba(139, 0, 0, 0.9);
      border-color: #ff6666;
      box-shadow: 0 0 12px rgba(255, 0, 0, 0.5);
    }

    .transported-unit-item .unit-name {
      font-weight: bold;
      color: #ffffff;
    }

    .transported-unit-item .unit-stats {
      font-size: 0.85rem;
      color: #cccccc;
    }

    .transported-units-menu .menu-instructions {
      font-size: 0.8rem;
      color: #cccccc;
      text-align: center;
      font-style: italic;
      padding-top: 8px;
      border-top: 1px solid rgba(139, 0, 0, 0.3);
    }

    .carrier-indicator {
      position: absolute;
      top: 50%;
      left: 2px;
      transform: translateY(-50%);
      background: rgba(255, 165, 0, 0.9);
      color: #000;
      font-size: 8px;
      font-weight: bold;
      padding: 1px 3px;
      border-radius: 3px;
      border: 1px solid #ff8c00;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

    /* Enhanced Bottom Panel */
    #zone-detail .bottom-panel {
      grid-area: bottom;
      background: 
        linear-gradient(135deg, 
          rgba(60, 15, 15, 0.95) 0%, 
          rgba(40, 10, 10, 0.98) 30%, 
          rgba(80, 20, 20, 0.92) 70%, 
          rgba(50, 12, 12, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.8);
      border-radius: 8px;
      padding: 25px 35px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(6px);
      position: relative;
      overflow: hidden;
      min-height: 100px;
    }

    #zone-detail .bottom-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        repeating-linear-gradient(90deg,
          transparent 0px,
          rgba(139, 0, 0, 0.1) 50px,
          transparent 100px
        );
      animation: bottomSweep 8s linear infinite;
    }

    @keyframes bottomSweep {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    #zone-detail .decoration-left {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      align-items: center;
      color: #cc5555;
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 2px;
      font-family: 'Orbitron', monospace;
      position: relative;
      z-index: 2;
    }

    #zone-detail .decoration-center {
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      z-index: 2;
    }

    #zone-detail .decoration-right {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      align-items: center;
      color: #cc5555;
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 2px;
      font-family: 'Orbitron', monospace;
      position: relative;
      z-index: 2;
    }

    #zone-detail .decoration-left span,
    #zone-detail .decoration-right span {
      position: relative;
      padding: 12px 18px;
      border-radius: 8px;
      background: 
        linear-gradient(135deg, 
          rgba(80, 20, 20, 0.8), 
          rgba(60, 15, 15, 0.9)
        );
      border: 2px solid rgba(139, 0, 0, 0.7);
      text-shadow: 0 0 12px rgba(204, 85, 85, 0.8);
      font-size: 1.5rem;
      text-align: center;
      box-shadow: 
        0 0 20px rgba(255, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 80, 80, 0.2);
      transition: all 0.3s ease;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #zone-detail .decoration-left span:hover,
    #zone-detail .decoration-right span:hover {
      background: 
        linear-gradient(135deg, 
          rgba(120, 30, 30, 0.9), 
          rgba(90, 22, 22, 0.95)
        );
      border-color: rgba(255, 50, 50, 0.9);
      transform: translateY(-2px);
      box-shadow: 
        0 4px 25px rgba(255, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 100, 100, 0.3);
    }

    #zone-detail .decoration-center .action-button {
      background: 
        linear-gradient(135deg, 
          rgba(100, 25, 25, 0.95) 0%, 
          rgba(80, 20, 20, 0.98) 50%, 
          rgba(95, 24, 24, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.9);
      color: #ff4444;
      padding: 15px 30px;
      font-size: 1.2rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 0;
      min-height: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Additional button styles for zone detail */
    #zone-detail .change-army-btn,
    #zone-detail .back-to-armies-btn {
      background: 
        linear-gradient(135deg, 
          rgba(80, 20, 20, 0.95) 0%, 
          rgba(60, 15, 15, 0.98) 50%, 
          rgba(75, 18, 18, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.8);
      color: #ff6666;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1rem;
      padding: 10px 16px;
      cursor: crosshair;
      border-radius: 6px;
      transition: all 0.3s ease;
      text-shadow: 0 0 6px rgba(255, 102, 102, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #zone-detail .change-army-btn:hover,
    #zone-detail .back-to-armies-btn:hover {
      background: 
        linear-gradient(135deg, 
          rgba(120, 30, 30, 0.98) 0%, 
          rgba(90, 23, 23, 0.99) 50%, 
          rgba(110, 28, 28, 0.98) 100%
        );
      color: #ff3333;
      border-color: rgba(255, 50, 50, 1);
      transform: translateY(-1px);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4);
    }

    /* Action Buttons */
    #zone-detail .action-button {
      background: 
        linear-gradient(135deg, 
          rgba(80, 20, 20, 0.95) 0%, 
          rgba(60, 15, 15, 0.98) 50%, 
          rgba(75, 18, 18, 0.95) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.8);
      color: #ff6666;
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 1.1rem;
      padding: 12px 18px;
      margin-bottom: 8px;
      cursor: crosshair;
      border-radius: 6px;
      transition: all 0.3s ease;
      text-shadow: 0 0 6px rgba(255, 102, 102, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      min-height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #zone-detail .action-button:hover {
      background: 
        linear-gradient(135deg, 
          rgba(120, 30, 30, 0.98) 0%, 
          rgba(90, 23, 23, 0.99) 50%, 
          rgba(110, 28, 28, 0.98) 100%
        );
      color: #ff3333;
      border-color: rgba(255, 50, 50, 1);
      transform: translateY(-1px);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4);
    }

    #zone-detail .action-button.active {
      background: 
        linear-gradient(135deg, 
          rgba(150, 40, 40, 0.98) 0%, 
          rgba(120, 30, 30, 0.99) 50%, 
          rgba(140, 35, 35, 0.98) 100%
        );
      border-color: rgba(255, 80, 80, 1);
      color: #ff0000;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
    }

    /* Status and Info Text Updates */
    #zone-detail .artillery-status,
    #zone-detail .aerial-status {
      color: #aa5555;
      font-size: 0.85rem;
      text-align: center;
      font-style: italic;
      margin-bottom: 8px;
    }

    #zone-detail .movement-info,
    #zone-detail .selected-unit-info {
      background: rgba(40, 10, 10, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.5);
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 10px;
      font-size: 0.8rem;
      color: #cc7777;
    }

    /* Army Selection Styling */
    #zone-detail .army-selection-container {
      margin-bottom: 15px;
      cursor: crosshair;
    }

    #zone-detail .army-selection-container h3 {
      font-family: 'Orbitron', monospace;
      color: #ff4444;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      text-align: center;
    }

    #zone-detail #army-selector-dropdown {
      width: 100%;
      background: rgba(40, 10, 10, 0.9);
      border: 1px solid rgba(139, 0, 0, 0.7);
      color: #ff8888;
      padding: 8px;
      border-radius: 4px;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      cursor: crosshair;
      /* Ensure dropdown can overflow parent containers */
      position: relative;
      z-index: 999999;
    }
    
    /* Ensure the themed dropdown has proper z-index and positioning */
    #zone-detail .themed-dropdown {
      position: relative;
      z-index: 9999999;
    }
    
    #zone-detail .themed-dropdown-options {
      position: fixed !important;
      background: linear-gradient(135deg, #1a0505 0%, #0a0202 100%);
      border: 2px solid #8B0000;
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 20px rgba(139, 0, 0, 0.6);
      max-height: 300px;
      overflow-y: auto;
      z-index: 10000000 !important;
      display: none;
      min-width: 300px;
    }

    #zone-detail .themed-dropdown.open .themed-dropdown-options {
      display: block;
    }
    
    /* Screen expansion when dropdown is open */
    #zone-detail.dropdown-open {
      min-height: 1200px !important;
      height: auto !important;
      overflow-y: auto !important;
    }
    
    #zone-detail.dropdown-open .zone-detail-content {
      min-height: 1200px !important;
      height: auto !important;
    }
    
    #zone-detail.dropdown-open .zone-ui-wrapper {
      min-height: 1200px !important;
      height: auto !important;
    }
    
    /* Legion box expansion when dropdown is open */
    #zone-detail.dropdown-open .army-selection-container {
      min-height: 400px !important;
      height: auto !important;
      padding: 20px !important;
      transition: all 0.3s ease !important;
      box-shadow: 0 8px 32px rgba(139, 0, 0, 0.4) !important;
      border: 2px solid #B22222 !important;
      display: flex !important;
      flex-direction: column !important;
      justify-content: flex-start !important;
      align-items: center !important;
    }
    
    #zone-detail.dropdown-open .army-selector {
      min-height: 300px !important;
      height: auto !important;
      width: 100% !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
    }
    
    #zone-detail.dropdown-open .themed-dropdown {
      min-height: 50px !important;
      height: auto !important;
      transition: all 0.3s ease !important;
      transform: scale(1.02) !important;
      width: 100% !important;
      max-width: 400px !important;
    }
    
    #zone-detail.dropdown-open .themed-dropdown-options {
      position: relative !important;
      top: auto !important;
      left: auto !important;
      right: auto !important;
      max-height: none !important;
      min-height: auto !important;
      height: auto !important;
      width: 100% !important;
      margin-top: 10px !important;
      display: flex !important;
      flex-direction: column !important;
      gap: 5px !important;
    }
    
    #zone-detail.dropdown-open .themed-dropdown-option {
      margin: 2px 0 !important;
      padding: 12px 16px !important;
      border-radius: 6px !important;
      background: linear-gradient(135deg, #2a0a0a 0%, #1a0505 100%) !important;
      border: 1px solid #8B0000 !important;
      transition: all 0.2s ease !important;
    }
    
    #zone-detail.dropdown-open .themed-dropdown-option:hover {
      background: linear-gradient(135deg, #3a0f0f 0%, #2a0a0a 100%) !important;
      border-color: #B22222 !important;
      transform: translateY(-1px) !important;
    }
    
    #zone-detail #army-selector-dropdown .dropdown-options {
      /* Ensure dropdown options can overflow all parent containers */
      position: fixed;
      z-index: 999998;
      max-height: 300px !important;
      overflow: visible;
      /* Force the dropdown to be positioned relative to viewport */
      transform: none !important;
    }
    
    /* Ensure parent containers don't clip the dropdown */
    #zone-detail .army-selection-container {
      overflow: visible !important;
    }
    
    #zone-detail .army-selector {
      overflow: visible !important;
    }
    
    #zone-detail .zone-ui-wrapper {
      overflow: visible !important;
    }
    
    #zone-detail .units-panel {
      overflow: visible !important;
    }
    
    #zone-detail .right-panel {
      overflow: visible !important;
    }
    
    /* New Themed Dropdown Styles */
    .themed-dropdown {
      position: relative;
      width: 100%;
      max-width: 300px;
      z-index: 1000;
    }

    .themed-dropdown-button {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: linear-gradient(135deg, #2a0a0a 0%, #1a0505 100%);
      border: 2px solid #8B0000;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(139, 0, 0, 0.3);
      min-height: 48px;
    }

    .themed-dropdown-button:hover {
      background: linear-gradient(135deg, #3a0f0f 0%, #2a0a0a 100%);
      border-color: #B22222;
      box-shadow: 0 4px 15px rgba(139, 0, 0, 0.5);
      transform: translateY(-1px);
    }

    .themed-dropdown-button:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(139, 0, 0, 0.4);
    }

    .themed-dropdown-text {
      color: #FFD700;
      font-weight: 600;
      font-size: 14px;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
      flex: 1;
    }

    .themed-dropdown-icon {
      color: #8B0000;
      font-size: 16px;
      margin-left: 8px;
      transition: transform 0.3s ease;
    }

    .themed-dropdown.open .themed-dropdown-icon {
      transform: rotate(180deg);
    }

    .themed-dropdown-options {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #1a0505 0%, #0a0202 100%);
      border: 2px solid #8B0000;
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 20px rgba(139, 0, 0, 0.6);
      max-height: 300px;
      overflow-y: auto;
      z-index: 1001;
      display: none;
    }

    .themed-dropdown.open .themed-dropdown-options {
      display: block;
    }

    .themed-dropdown-option {
      padding: 12px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      border-bottom: 1px solid rgba(139, 0, 0, 0.3);
    }

    .themed-dropdown-option:last-child {
      border-bottom: none;
    }

    .themed-dropdown-option:hover {
      background: linear-gradient(135deg, #3a0f0f 0%, #2a0a0a 100%);
    }

    .army-option-name {
      color: #FFD700;
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .army-option-composition {
      color: #ff8888;
      font-size: 12px;
      opacity: 0.8;
    }

    .themed-dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #1a0505 0%, #0a0202 100%);
      border: 2px solid #8B0000;
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 20px rgba(139, 0, 0, 0.8);
      max-height: 200px;
      overflow-y: auto;
      z-index: 1001;
      display: none;
      margin-top: 2px;
    }

    .themed-dropdown.open .themed-dropdown-menu {
      display: block;
    }

    .themed-dropdown-option {
      padding: 12px 16px;
      color: #FFD700;
      cursor: pointer;
      transition: all 0.2s ease;
      border-bottom: 1px solid rgba(139, 0, 0, 0.3);
      font-size: 14px;
      font-weight: 500;
    }

    .themed-dropdown-option:last-child {
      border-bottom: none;
    }

    .themed-dropdown-option:hover {
      background: linear-gradient(135deg, #3a0f0f 0%, #2a0a0a 100%);
      color: #FFF;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
    }

    .themed-dropdown-option.selected {
      background: linear-gradient(135deg, #8B0000 0%, #660000 100%);
      color: #FFF;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
    }

    /* Scrollbar styling for dropdown menu */
    .themed-dropdown-menu::-webkit-scrollbar {
      width: 6px;
    }

    .themed-dropdown-menu::-webkit-scrollbar-track {
      background: #1a0505;
    }

    .themed-dropdown-menu::-webkit-scrollbar-thumb {
      background: #8B0000;
      border-radius: 3px;
    }

    .themed-dropdown-menu::-webkit-scrollbar-thumb:hover {
      background: #B22222;
    }
    

    


    /* Responsive Design */
    @media (max-width: 1400px) {
      #zone-detail .zone-ui-wrapper {
        grid-template-columns: 260px 1fr 280px;
      }
    }

    @media (max-width: 1200px) {
      #zone-detail .zone-ui-wrapper {
        grid-template-columns: 240px 1fr 260px;
        gap: 12px;
      }
      
      #zone-detail .zone-title {
        font-size: 1.5rem;
      }
    }

    @media (max-width: 1024px) {
      #zone-detail .zone-ui-wrapper {
        grid-template-areas: 
          "header header"
          "left center"
          "right center"
          "bottom bottom";
        grid-template-columns: 240px 1fr;
        grid-template-rows: 70px 1fr 1fr 60px;
        min-height: 100vh;
      }
    }

    @media (max-width: 768px) {
      #zone-detail .zone-ui-wrapper {
        grid-template-areas: 
          "header"
          "center"
          "left"
          "right"
          "bottom";
        grid-template-columns: 1fr;
        grid-template-rows: 70px 1fr auto auto 60px;
        gap: 10px;
        min-height: 100vh;
      }
    }

    .combat-overlay.active {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      animation: combatOverlayFade 0.5s ease-out;
    }

    @keyframes combatOverlayFade {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    /* Combat Scene Container */
    .combat-scene {
      background: 
        linear-gradient(135deg, 
          rgba(20, 5, 5, 0.95) 0%, 
          rgba(15, 3, 3, 0.98) 50%, 
          rgba(18, 4, 4, 0.95) 100%
        );
      border: 3px solid rgba(255, 0, 0, 0.6);
      border-radius: 15px;
      padding: 40px;
      max-width: 800px;
      width: 90%;
      text-align: center;
      box-shadow: 
        0 0 50px rgba(255, 0, 0, 0.3),
        0 0 100px rgba(139, 0, 0, 0.4);
      position: relative;
    }

    .combat-scene::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: 
        linear-gradient(45deg, 
          transparent 20%, 
          rgba(255, 0, 0, 0.3) 30%,
          rgba(139, 0, 0, 0.2) 50%, 
          rgba(255, 0, 0, 0.3) 70%,
          transparent 80%
        );
      border-radius: 15px;
      z-index: -1;
      animation: borderFlow 6s linear infinite;
    }

    /* Combat Title */
    .combat-title {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2.5rem;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-bottom: 30px;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      animation: titlePulse 2s ease-in-out infinite;
    }

    @keyframes titlePulse {
      0%, 100% { text-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
      50% { text-shadow: 0 0 30px rgba(255, 0, 0, 1); }
    }

    /* Combat Participants */
    .combat-participants {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 30px 0;
      gap: 40px;
    }

    .combatant {
      flex: 1;
      background: 
        linear-gradient(135deg, 
          rgba(30, 10, 10, 0.9) 0%, 
          rgba(20, 5, 5, 0.95) 50%, 
          rgba(25, 8, 8, 0.9) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.6);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .combatant.attacker {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 25px rgba(255, 0, 0, 0.3);
    }

    .combatant.defender {
      border-color: rgba(65, 105, 225, 0.8);
      box-shadow: 0 0 25px rgba(65, 105, 225, 0.3);
    }

    .combatant-name {
      font-family: 'Cinzel', serif;
      font-weight: 700;
      font-size: 1.2rem;
      color: #ff8888;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .combatant-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 0.9rem;
      color: #ccc;
    }

    .stat-label {
      color: #ff6666;
      font-weight: 600;
    }

    /* Combat Dice */
    .combat-dice-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
    }

    .combat-dice {
      width: 80px;
      height: 80px;
      background: 
        linear-gradient(135deg, 
          rgba(255, 0, 0, 0.9) 0%, 
          rgba(139, 0, 0, 1) 50%, 
          rgba(255, 0, 0, 0.9) 100%
        );
      border: 3px solid #FFD700;
      border-radius: 15px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
      font-weight: bold;
      color: white;
      font-family: 'Orbitron', monospace;
      box-shadow: 
        0 0 20px rgba(255, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    .combat-dice.rolling {
      animation: diceRoll 0.2s infinite;
    }

    @keyframes diceRoll {
      0% { transform: rotate3d(1, 1, 1, 0deg) scale(1); }
      25% { transform: rotate3d(1, 1, 1, 90deg) scale(1.1); }
      50% { transform: rotate3d(1, 1, 1, 180deg) scale(1); }
      75% { transform: rotate3d(1, 1, 1, 270deg) scale(1.1); }
      100% { transform: rotate3d(1, 1, 1, 360deg) scale(1); }
    }

    /* Combat Result */
    .combat-result {
      background: 
        linear-gradient(135deg, 
          rgba(25, 8, 8, 0.9) 0%, 
          rgba(20, 5, 5, 0.95) 50%, 
          rgba(22, 6, 6, 0.9) 100%
        );
      border: 2px solid rgba(255, 215, 0, 0.6);
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }

    .combat-result.victory {
      border-color: rgba(50, 205, 50, 0.8);
      box-shadow: 0 0 25px rgba(50, 205, 50, 0.4);
    }

    .combat-result.defeat {
      border-color: rgba(255, 0, 0, 0.8);
      box-shadow: 0 0 25px rgba(255, 0, 0, 0.4);
    }

    .result-text {
      font-family: 'Cinzel', serif;
      font-weight: 700;
      font-size: 1.3rem;
      color: #ff8888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .result-text.victory {
      color: #32CD32;
    }

    .result-text.defeat {
      color: #ff4444;
    }

    /* Strategic Overlay */
    .strategic-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(135deg, 
          rgba(0, 0, 0, 0.7) 0%, 
          rgba(20, 5, 5, 0.8) 50%, 
          rgba(0, 0, 0, 0.7) 100%
        );
      z-index: 3000;
      display: none;
      backdrop-filter: blur(3px);
    }

    .strategic-overlay.active {
      display: block;
      animation: strategicFade 0.3s ease-out;
    }

    @keyframes strategicFade {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    /* Strategic Grid */
    .strategic-grid {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: grid;
      gap: 2px;
      background: rgba(139, 0, 0, 0.3);
      border: 2px solid rgba(255, 0, 0, 0.6);
      border-radius: 10px;
      padding: 10px;
    }

    .strategic-cell {
      width: 60px;
      height: 60px;
      background: 
        linear-gradient(135deg, 
          rgba(40, 15, 15, 0.8) 0%, 
          rgba(30, 10, 10, 0.9) 50%, 
          rgba(35, 12, 12, 0.8) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.4);
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      color: #ff8888;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .strategic-cell:hover {
      background: 
        linear-gradient(135deg, 
          rgba(60, 20, 20, 0.9) 0%, 
          rgba(45, 15, 15, 0.95) 50%, 
          rgba(50, 17, 17, 0.9) 100%
        );
      border-color: rgba(255, 0, 0, 0.6);
      transform: scale(1.05);
    }

    .strategic-cell.selected {
      background: 
        linear-gradient(135deg, 
          rgba(255, 215, 0, 0.3) 0%, 
          rgba(218, 165, 32, 0.4) 50%, 
          rgba(255, 215, 0, 0.3) 100%
        );
      border-color: rgba(255, 215, 0, 0.8);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }

    /* Enhanced HUD Elements */
    .hud-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .hud-panel {
      background: 
        linear-gradient(135deg, 
          rgba(20, 5, 5, 0.9) 0%, 
          rgba(15, 3, 3, 0.95) 50%, 
          rgba(18, 4, 4, 0.9) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      min-width: 200px;
      box-shadow: 
        0 0 20px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
    }

    .hud-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 0.9rem;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      text-align: center;
    }

    .hud-content {
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      color: #ff8888;
      line-height: 1.4;
    }

    /* Turn Indicator */
    .turn-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: 
        linear-gradient(135deg, 
          rgba(139, 0, 0, 0.9) 0%, 
          rgba(100, 0, 0, 0.95) 50%, 
          rgba(139, 0, 0, 0.9) 100%
        );
      border: 2px solid rgba(255, 0, 0, 0.6);
      border-radius: 10px;
      padding: 15px 30px;
      z-index: 2000;
      box-shadow: 
        0 0 30px rgba(255, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 100, 100, 0.2);
    }

    .turn-indicator.red-turn {
      border-color: rgba(220, 20, 60, 0.8);
      box-shadow: 
        0 0 30px rgba(220, 20, 60, 0.4),
        inset 0 1px 0 rgba(255, 100, 100, 0.3);
    }

    .turn-indicator.blue-turn {
      border-color: rgba(65, 105, 225, 0.8);
      box-shadow: 
        0 0 30px rgba(65, 105, 225, 0.4),
        inset 0 1px 0 rgba(100, 150, 255, 0.3);
    }

    .turn-text {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 1.1rem;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    .turn-text.red-turn {
      color: #DC143C;
    }

    .turn-text.blue-turn {
      color: #4169E1;
    }

    /* Action Log */
    .action-log {
      position: fixed;
      bottom: 20px;
      left: 20px;
      max-width: 400px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 2000;
    }

    .log-entry {
      background: 
        linear-gradient(135deg, 
          rgba(20, 5, 5, 0.9) 0%, 
          rgba(15, 3, 3, 0.95) 50%, 
          rgba(18, 4, 4, 0.9) 100%
        );
      border: 1px solid rgba(139, 0, 0, 0.4);
      border-radius: 5px;
      padding: 8px 12px;
      margin-bottom: 5px;
      font-family: 'Cinzel', serif;
      font-size: 0.8rem;
      color: #ff8888;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      animation: logEntrySlide 0.3s ease-out;
    }

    @keyframes logEntrySlide {
      0% { 
        opacity: 0;
        transform: translateX(-20px);
      }
      100% { 
        opacity: 1;
        transform: translateX(0);
      }
    }

    .log-entry.combat {
      border-color: rgba(255, 0, 0, 0.6);
      background: 
        linear-gradient(135deg, 
          rgba(139, 0, 0, 0.3) 0%, 
          rgba(100, 0, 0, 0.4) 50%, 
          rgba(139, 0, 0, 0.3) 100%
        );
    }

    .log-entry.movement {
      border-color: rgba(156, 39, 176, 0.6);
      background: 
        linear-gradient(135deg, 
          rgba(156, 39, 176, 0.3) 0%, 
          rgba(123, 31, 162, 0.4) 50%, 
          rgba(156, 39, 176, 0.3) 100%
        );
    }

    .log-entry.construction {
      border-color: rgba(255, 69, 0, 0.6);
      background: 
        linear-gradient(135deg, 
          rgba(255, 69, 0, 0.3) 0%, 
          rgba(139, 0, 0, 0.4) 50%, 
          rgba(255, 69, 0, 0.3) 100%
        );
    }

    /* Minimap */
    .minimap {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 150px;
      background: 
        linear-gradient(135deg, 
          rgba(20, 5, 5, 0.9) 0%, 
          rgba(15, 3, 3, 0.95) 50%, 
          rgba(18, 4, 4, 0.9) 100%
        );
      border: 2px solid rgba(139, 0, 0, 0.6);
      border-radius: 8px;
      z-index: 2000;
      box-shadow: 
        0 0 20px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 50, 50, 0.1);
      overflow: hidden;
    }

    .minimap-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 0.8rem;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
      padding: 8px;
      border-bottom: 1px solid rgba(139, 0, 0, 0.4);
    }

    .minimap-content {
      padding: 10px;
      display: grid;
      gap: 2px;
      grid-template-columns: repeat(6, 1fr);
    }

    .minimap-zone {
      width: 25px;
      height: 20px;
      background: rgba(40, 15, 15, 0.8);
      border: 1px solid rgba(139, 0, 0, 0.4);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6rem;
      color: #ff8888;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .minimap-zone:hover {
      background: rgba(60, 20, 20, 0.9);
      border-color: rgba(255, 0, 0, 0.6);
      transform: scale(1.1);
    }

    .minimap-zone.active {
      background: rgba(255, 215, 0, 0.3);
      border-color: rgba(255, 215, 0, 0.8);
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
    }

    .minimap-zone.has-units {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.6);
    }
  </style>
</head>
<body>
  <!-- Dice Animation Overlay -->
  <div id="dice-overlay" class="dice-overlay" style="display: none;">
    <div class="dice-interface">
      <h1 class="dice-title">No Man's Land</h1>
      
      <div class="dual-dice-arena">
        <!-- Left Dice -->
        <div class="dice-section">
          <div class="dice-label">Offensive Forces</div>
          <div class="dice-display">
            <div class="dice-cube" id="leftDiceCube">
              <div class="dice-face front face-1">
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face back face-2">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face right face-3">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face left face-4">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face top face-5">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face bottom face-6">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- VS Divider -->
        <div class="vs-divider">VS</div>
        
        <!-- Right Dice -->
        <div class="dice-section">
          <div class="dice-label">Defensive Forces</div>
          <div class="dice-display">
            <div class="dice-cube" id="rightDiceCube">
              <div class="dice-face front face-1">
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face back face-2">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face right face-3">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face left face-4">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face top face-5">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face bottom face-6">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="battle-results">
        <div class="dice-result" id="leftResult">-</div>
        <div class="winner-announcement" id="winnerText"></div>
        <div class="dice-result" id="rightResult">-</div>
      </div>
      
      <div class="bonus-section">
        <div class="bonus-title">Combat Bonuses</div>
        <div class="bonus-controls">
          <div class="bonus-group">
            <div class="bonus-label">Offensive Bonus</div>
            <div class="bonus-value" id="leftBonus">0</div>
          </div>
          <div class="bonus-group">
            <div class="bonus-label">Defensive Bonus</div>
            <div class="bonus-value" id="rightBonus">0</div>
          </div>
        </div>
      </div>
      
      <div class="dice-click-prompt" id="dice-click-prompt" style="display: none;" onclick="closeDiceAnimations()">
        Click to Continue
      </div>
    </div>
  </div>

  <!-- Morale Check Animation Overlay -->
  <div id="morale-overlay" class="morale-overlay" style="display: none;">
    <div class="morale-interface">
      <h1 class="morale-title">MORALE CHECK</h1>
      
      <div class="morale-unit-info" id="morale-unit-info">
        Unit testing morale...
      </div>
      
      <div class="morale-dice-arena">
        <div class="morale-dice-section">
          <div class="morale-dice-label">Unit Morale</div>
          <div class="morale-dice-display">
            <div class="morale-dice-cube" id="moraleDiceCube">
              <div class="morale-dice-face front face-1">
                <div class="morale-dice-dot"></div>
              </div>
              <div class="morale-dice-face back face-2">
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
              </div>
              <div class="morale-dice-face right face-3">
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
              </div>
              <div class="morale-dice-face left face-4">
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
              </div>
              <div class="morale-dice-face top face-5">
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
              </div>
              <div class="morale-dice-face bottom face-6">
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
                <div class="morale-dice-dot"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="morale-results">
        <div class="morale-result" id="morale-result">
          <div>Rolling for morale...</div>
        </div>
        <div class="morale-target" id="morale-target">Target: 4</div>
      </div>
      
      <div class="morale-click-prompt" id="morale-click-prompt" style="display: none;" onclick="closeMoraleAnimation()">
        Click to Continue
      </div>
    </div>
  </div>

  <!-- Artillery Attack Animation Overlay -->
  <div id="artillery-overlay" class="artillery-overlay" style="display: none;">
    <div class="artillery-interface">
      <h1 class="artillery-title">THE RAINS OF HELL</h1>
      
      <div class="artillery-info" id="artillery-info">
        Artillery preparing to fire...
      </div>
      
      <!-- Phase 1: Hit Chance Roll -->
      <div class="artillery-phase" id="artillery-hit-phase">
        <div class="artillery-phase-title">Phase 1: Hit Chance Roll - Tile <span id="artillery-target-tile"></span></div>
      <div class="artillery-dice-arena">
        <div class="artillery-dice-section">
          <div class="artillery-dice-label">Hit Roll</div>
          <div class="artillery-dice-display">
            <div class="artillery-slot-machine" id="artilleryHitDiceCube">
              <span class="slot-number">1</span>
            </div>
          </div>
        </div>
      </div>
      
      <div class="artillery-results">
          <div class="artillery-result" id="artillery-hit-result">
          <div>Rolling for hit...</div>
        </div>
          <div class="artillery-target" id="artillery-hit-target">Target: 7+</div>
        </div>
      </div>
      
      <!-- Phase 2: Combat Roll (only shown if hit chance succeeds) -->
      <div class="artillery-phase" id="artillery-combat-phase" style="display: none;">
        <div class="artillery-phase-title">Phase 2: The Rains of Hell</div>
        <div class="dual-dice-arena">
          <!-- Artillery Dice Section -->
          <div class="dice-section">
            <div class="dice-label" id="artillery-attacker-label">Artillery</div>
            <div class="dice-display">
              <div class="dice-cube" id="artilleryAttackerDiceCube">
                <div class="dice-face front face-1">
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face back face-2">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face right face-3">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face left face-4">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face top face-5">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face bottom face-6">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
              </div>
            </div>
            <div class="dice-result" id="artillery-attacker-result">-</div>
          </div>
          
          <!-- VS Divider -->
          <div class="vs-divider">VS</div>
          
          <!-- Defender Dice Section -->
          <div class="dice-section">
            <div class="dice-label" id="artillery-defender-label">Defender</div>
            <div class="dice-display">
              <div class="dice-cube" id="artilleryDefenderDiceCube">
                <div class="dice-face front face-1">
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face back face-2">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face right face-3">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face left face-4">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face top face-5">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
                <div class="dice-face bottom face-6">
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                  <div class="dice-dot"></div>
                </div>
              </div>
            </div>
            <div class="dice-result" id="artillery-defender-result">-</div>
          </div>
        </div>
        
        <!-- Bonus Section -->
        <div class="bonus-section">
          <div class="bonus-title">Combat Modifiers</div>
          <div class="bonus-controls">
            <div class="bonus-group">
              <div class="bonus-label">Attack Bonus</div>
              <div class="bonus-value" id="artillery-attack-bonus">+0</div>
            </div>
            <div class="bonus-group">
              <div class="bonus-label">Defense Bonus</div>
              <div class="bonus-value" id="artillery-defense-bonus">+0</div>
            </div>
          </div>
        </div>
        
        <div class="artillery-results">
          <div class="artillery-result" id="artillery-combat-result">
            <div>Combat resolution...</div>
          </div>
        </div>
      </div>
      
      <div class="artillery-click-prompt" id="artillery-click-prompt" style="display: none;" onclick="closeArtilleryAnimation()">
        Click to Continue
      </div>
    </div>
  </div>
  
  <!-- Aerial Combat Animation Overlay -->
  <div id="aerial-overlay" class="aerial-overlay" style="display: none;">
    <div class="aerial-container">
      <div class="aerial-title">THE HELL ABOVE</div>
      <div class="aerial-info" id="aerial-info">
        Aerial units engaging...
      </div>
      
      <!-- Dual Dice Arena - Mirroring Grid Battle System -->
      <div class="dual-dice-arena">
        <!-- Attacker Dice Section -->
        <div class="dice-section">
          <div class="dice-label" id="aerial-attacker-label">Attacker</div>
          <div class="dice-display">
            <div class="dice-cube" id="aerialAttackerDiceCube">
              <div class="dice-face front face-1">
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face back face-2">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face right face-3">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face left face-4">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face top face-5">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face bottom face-6">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
            </div>
          </div>
          <div class="dice-result" id="aerial-attacker-result">-</div>
        </div>
        
        <!-- VS Divider -->
        <div class="vs-divider">VS</div>
        
        <!-- Defender Dice Section -->
        <div class="dice-section">
          <div class="dice-label" id="aerial-defender-label">Defender</div>
          <div class="dice-display">
            <div class="dice-cube" id="aerialDefenderDiceCube">
              <div class="dice-face front face-1">
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face back face-2">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face right face-3">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face left face-4">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face top face-5">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
              <div class="dice-face bottom face-6">
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
                <div class="dice-dot"></div>
              </div>
            </div>
          </div>
          <div class="dice-result" id="aerial-defender-result">-</div>
        </div>
      </div>
      
      <!-- Bonus Section -->
      <div class="bonus-section">
        <div class="bonus-title">Combat Modifiers</div>
        <div class="bonus-controls">
          <div class="bonus-group">
            <div class="bonus-label">Attack Bonus</div>
            <div class="bonus-value" id="aerial-attack-bonus">+0</div>
          </div>
          <div class="bonus-group">
            <div class="bonus-label">Defense Bonus</div>
            <div class="bonus-value" id="aerial-defense-bonus">+0</div>
          </div>
        </div>
      </div>
      
      <!-- Winner Announcement -->
      <div class="winner-announcement" id="aerial-winner-announcement"></div>
      
      <div class="aerial-click-prompt" id="aerial-click-prompt" style="display: none;" onclick="closeAerialAnimation()">
        Click to Continue
      </div>
    </div>
  </div>



  <!-- Demonic Skeletal Hand Cursor -->
  <div class="cursor" id="cursor">
    <div class="skeletal-hand">
      <div class="hand-base">
        <div class="crimson-veins"></div>
        <div class="demonic-eye"></div>
      </div>
      
      <div class="finger finger1"><div class="claw"></div></div>
      <div class="finger finger2"><div class="claw"></div></div>
      <div class="finger finger3"><div class="claw"></div></div>
      <div class="finger finger4"><div class="claw"></div></div>
      <div class="finger thumb"><div class="claw"></div></div>
    </div>
  </div>

  <!-- Enhanced Main Menu Screen -->
  <div id="main-menu" class="screen active">
    <div class="main-container">
      <!-- Enhanced Background Layers -->
      <div class="battlefield-layer"></div>
      <div class="debris-field"></div>
      <div class="wire-system"></div>
      
      <!-- Atmospheric Smoke System -->
      <div class="atmospheric-smoke" id="smokeSystem"></div>
      
      <!-- Enhanced Demonic Sigil -->
      <div class="sigil-container">
        <div class="demonic-sigil"></div>
      </div>
      <div class="blood-layer">
        <div class="blood-gradient corner-tl"></div>
        <div class="blood-gradient corner-br"></div>
      </div>
      
      <!-- Premium Menu System -->
      <div class="menu-system">
        <h1 class="game-title">Ashes of the Covenant</h1>
        <nav class="menu-navigation">
          <!-- Primary Game Modes Section -->
          <div class="menu-section">
            <div class="section-title">Battle</div>
            
            <!-- CRITICAL: Keep these exact onclick handlers -->
            <button class="menu-button primary" onclick="showScreen('game-setup')">
              <span>Single Player</span>
            </button>
            
            <button class="menu-button primary" onclick="showScreen('multiplayer')">
              <span>Multiplayer</span>
            </button>
          </div>
          
          <!-- Game Tools Section -->
          <div class="menu-section">
            <div class="section-title">Command Center</div>
            
            <button class="menu-button" onclick="showScreen('unit-creator')">
              <span>Unit Creator</span>
            </button>
            
            <button class="menu-button" onclick="showScreen('army-builder')">
              <span>Army Builder</span>
            </button>
          </div>
          
          <!-- Settings Section -->
          <div class="menu-section">
            <div class="section-title">Operations</div>
            
            <button class="menu-button" onclick="showScreen('settings')">
              <span>Settings</span>
            </button>
            
            <!-- Add this if you have a help screen -->
            <button class="menu-button" onclick="showScreen('help')" style="opacity: 0.7;">
              <span>Help</span>
            </button>
          </div>
        </nav>
      </div>
      
      <!-- Environmental Effects -->
      <div class="environmental-effects"></div>
      <div class="depth-vignette"></div>
    </div>
  </div>

  <!-- Multiplayer Lobby Screen -->
  <div id="multiplayer" class="screen">
    <div class="mp-container">
      <!-- Background Elements -->
      <div class="battlefield-layer"></div>
      <div class="wire-system"></div>
      
      <!-- Atmospheric Smoke System -->
      <div class="atmospheric-smoke" id="mpSmokeSystem"></div>
      
      <div class="blood-layer">
        <div class="blood-gradient corner-tl"></div>
        <div class="blood-gradient corner-br"></div>
      </div>
      
      <!-- Back Button -->
      <button class="back-button" onclick="showScreen('main-menu')">
         Back to Command
      </button>
      
      <!-- Main Content -->
      <div class="mp-content">
        <!-- Lobby Actions Section (Create/Join) -->
        <div class="mp-section lobby-section" id="lobby-actions-section">
          <h1 class="mp-title">Multiplayer Command</h1>
          <p class="mp-subtitle">Coordinate with Allied Forces</p>
          
          <!-- Shared Player Name Input -->
          <div class="form-group">
            <label class="form-label" for="display-name">Your Call Sign</label>
            <input 
              type="text" 
              id="display-name" 
              class="form-input" 
              placeholder="Enter your battlefield alias..."
              maxlength="20"
            >
          </div>
          
          <!-- Create Lobby Form -->
          <button class="action-button" onclick="createLobby()">
            <span>Create New Operation</span>
          </button>
          
          <div class="form-divider">
            <span>OR</span>
          </div>
          
          <!-- Join Lobby Form -->
          <div class="form-group">
            <label class="form-label" for="lobby-code">Operation Code</label>
            <input 
              type="text" 
              id="lobby-code" 
              class="form-input" 
              placeholder="Enter 6-digit operation code..."
              maxlength="6"
              pattern="[0-9]{6}"
            >
          </div>
          
          <button class="action-button secondary" onclick="joinLobby()">
            <span>Join Operation</span>
          </button>
        </div>
        
        <!-- Current Lobby Section (When in lobby) -->
        <div class="mp-section current-lobby-section" id="current-lobby-section" style="display: none;">
          <h1 class="mp-title">Operation Active</h1>
          <p class="mp-subtitle">Battlefield Command Center</p>
          
          <!-- Lobby Information -->
          <div class="lobby-info">
            <div class="lobby-code-section">
              <div class="lobby-code-label">Operation Code</div>
              <div class="lobby-code-display">
                <span class="code-value" id="lobby-code-display">123456</span>
                <button class="copy-button" onclick="copyLobbyCode()">Copy</button>
              </div>
              <div style="font-size: 0.9rem; color: #ff6666; opacity: 0.8; text-align: center;">
                Share this code with your ally
              </div>
            </div>
          </div>
          
          <!-- Player List Section -->
          <div class="player-list-section">
            <div class="player-list-title">Allied Forces</div>
            <ul class="player-list" id="lobby-player-list">
              <!-- Example players for demo -->
              <li class="player-item">
                <span class="player-name">CommanderAlpha</span>
                <span class="player-status ready">Ready</span>
              </li>
              <li class="player-item">
                <span class="player-name">Waiting for ally...</span>
                <span class="player-status not-ready">Not Ready</span>
              </li>
            </ul>
          </div>
          
          <!-- Ready System -->
          <button class="action-button ready-button" id="ready-button" onclick="toggleReady()">
            <span>Ready for Battle</span>
          </button>
          
          <!-- Waiting Message -->
          <div id="lobby-waiting-message" class="waiting-message">
            Waiting for allied forces to join the operation...
          </div>
          
          <!-- Leave Lobby -->
          <button class="action-button secondary" onclick="leaveLobby()">
            <span> Abandon Operation</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Setup Screen -->
  <div id="game-setup" class="screen">
    <!-- Demonic Background Symbols -->
    <div class="demonic-background">
      <div class="demonic-star"></div>
      <div class="demonic-star"></div>
      <div class="demonic-star"></div>
      <div class="demonic-star"></div>
      <div class="demonic-star"></div>
      <div class="demonic-star"></div>
      <div class="demonic-pentagram"></div>
      <div class="demonic-pentagram"></div>
      <div class="demonic-circle"></div>
      <div class="demonic-circle"></div>
      <div class="demonic-rune"></div>
      <div class="demonic-rune"></div>
      <div class="demonic-rune"></div>
      <div class="demonic-rune"></div>
      <div class="demonic-eye"></div>
      <div class="demonic-eye"></div>
      <div class="demonic-eye"></div>
      <div class="demonic-eye"></div>
      <div class="demonic-triangle"></div>
      <div class="demonic-triangle"></div>
    </div>
    
    <div class="setup-header">
      <h1 class="setup-title" data-text="War Configuration">War Configuration</h1>
      <p class="setup-subtitle">Prepare for Carnage</p>
    </div>
    <div class="setup-container">
      <div class="setup-section">
        <h2>Warlord Configuration</h2>
        
        <div class="form-group">
          <label for="player1-name">Warlord 1 Designation</label>
          <input type="text" id="player1-name" class="form-control" placeholder="Enter warlord designation" value="Red Commander">
        </div>
        
        <div class="form-group">
          <label for="player1-color">Warlord 1 War Banner</label>
          <div class="color-picker-container">
            <button type="button" class="color-display" id="player1-color-display" style="--color-value: #DC143C;" onclick="openCustomColorPicker('player1-color')"></button>
            <span>Choose blood colors</span>
          </div>
        </div>
        
        <div class="form-group">
          <label for="opponent-type">Enemy Type</label>
          <div class="locked-setting">
            <div class="locked-value">Human Adversary (Locked)</div>
            <div class="locked-note">AI is currently in testing</div>
          </div>
        </div>
        
        <div class="form-group" id="ai-settings" style="display: none;">
          <label for="ai-cp">AI War Machine Power</label>
          <div class="volume-control">
            <input type="range" 
                   class="volume-slider" 
                   id="ai-cp" 
                   min="3" 
                   max="10" 
                   value="4" 
                   step="1" 
                   oninput="updateAICPDisplay()">
            <div class="volume-value" id="ai-cp-display">4</div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="player2-name">Warlord 2 Designation</label>
          <input type="text" id="player2-name" class="form-control" placeholder="Enter warlord designation" value="Blue Commander">
        </div>
        
        <div class="form-group">
          <label for="player2-color">Warlord 2 War Banner</label>
          <div class="color-picker-container">
            <button type="button" class="color-display" id="player2-color-display" style="--color-value: #4169E1;" onclick="openCustomColorPicker('player2-color')"></button>
            <span>Choose blood colors</span>
          </div>
        </div>
        
        <div class="form-group">
          <label for="player1-army-select">Warlord 1 Legion</label>
          <div class="custom-dropdown" id="player1ArmyDropdown">
            <div class="dropdown-selected" id="player1ArmySelected">
              Select Legion Type
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="player1ArmyOptions">
              <div class="dropdown-option" data-value="">Select Legion Type</div>
              <div class="dropdown-option" data-value="default">Default Army</div>
            </div>
          </div>
          <button type="button" onclick="addArmyToPlayer('player1')" class="grid-size-btn" style="margin-top: 8px; width: 100%;">
            <span>Conscript Legion</span>
          </button>
        </div>
        
        <div class="form-group">
          <label>Warlord 1 Assembled Forces</label>
          <div id="player1-armies-container" class="armies-container">
            <div id="player1-selected-armies" class="selected-armies-list">
              <div class="no-armies-message">No armies selected. Click "Conscript Legion" to select armies for battle.</div>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="player2-army-select">Warlord 2 Legion</label>
          <div class="custom-dropdown" id="player2ArmyDropdown">
            <div class="dropdown-selected" id="player2ArmySelected">
              Select Legion Type
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="player2ArmyOptions">
              <div class="dropdown-option" data-value="">Select Legion Type</div>
              <div class="dropdown-option" data-value="default">Default Army</div>
            </div>
          </div>
          <button type="button" onclick="addArmyToPlayer('player2')" class="grid-size-btn" style="margin-top: 8px; width: 100%;">
            <span>Conscript Legion</span>
          </button>
        </div>
        
        <div class="form-group">
          <label>Warlord 2 Assembled Forces</label>
          <div id="player2-armies-container" class="armies-container">
            <div id="player2-selected-armies" class="selected-armies-list">
              <div class="no-armies-message">No armies selected. Click "Conscript Legion" to select armies for battle.</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="setup-section">
        <h2>War Parameters</h2>
        
        <div class="form-group">
          <label for="grid-size">Killing Ground Dimensions</label>
          <div class="grid-size-container">
            <button class="grid-size-btn active" data-size="6">66</button>
            <button class="grid-size-btn" data-size="8">88</button>
            <button class="grid-size-btn" data-size="10">1010</button>
            <button class="grid-size-btn" data-size="12">1212</button>
          </div>
        </div>
        
        <div class="form-group">
          <label for="zone-count">Death Zones</label>
          <div class="volume-control">
            <input type="range" 
                   class="volume-slider" 
                   id="zone-count" 
                   min="4" 
                   max="12" 
                   value="6" 
                   step="2" 
                   oninput="updateZoneDisplay()"
                   onmouseenter="debugCursor('zone-count', 'mouseenter')"
                   onmouseleave="debugCursor('zone-count', 'mouseleave')"
                   onmousemove="debugCursor('zone-count', 'mousemove')">
            <div class="volume-value" id="zone-display">6</div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="win-condition">Victory Condition</label>
          <div class="custom-dropdown" id="winConditionDropdown">
            <div class="dropdown-selected" id="winConditionSelected">
              Strategic Dominance (Control majority of zones)
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="winConditionOptions">
              <div class="dropdown-option selected" data-value="dominance">Strategic Dominance (Control majority of zones)</div>
              <div class="dropdown-option" data-value="elimination">Total Elimination (Destroy all enemy units)</div>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="terrain-type">Killing Ground Terrain</label>
          <div class="custom-dropdown" id="terrainDropdown">
            <div class="dropdown-selected" id="terrainSelected">
              Random Mix
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="terrainOptions">
              <div class="dropdown-option selected" data-value="random">Random Mix</div>
              <div class="dropdown-option" data-value="plains">The Scorched Expanse</div>
              <div class="dropdown-option" data-value="forest">The Withered Thicket</div>
              <div class="dropdown-option" data-value="desert">Ashblight Expanse</div>
              <div class="dropdown-option" data-value="ruins">Relics Of The Forsaken</div>
              <div class="dropdown-option" data-value="snow">The Frozen Grasp</div>
              <div class="dropdown-option" data-value="mountainous">Crags Of The Damned</div>
              <div class="dropdown-option" data-value="hilly">Bloodridge Heights</div>
              <div class="dropdown-option" data-value="swamp">Wailing Marshes</div>
              <div class="dropdown-option" data-value="jungle">Veil Of Rot</div>
              <div class="dropdown-option" data-value="volcanic">Hells Mouth</div>
              <div class="dropdown-option" data-value="urban">Wretched Society</div>
              <div class="dropdown-option" data-value="naval">Shore Of The Damned</div>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="player1-cp">Player 1 Command Points</label>
          <div class="volume-control">
            <input type="range" 
                   class="volume-slider" 
                   id="player1-cp" 
                   min="1" 
                   max="10" 
                   value="3" 
                   oninput="updatePlayer1CPDisplay()">
            <div class="volume-value" id="player1-cp-display">3</div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="player2-cp">Player 2 Command Points</label>
          <div class="volume-control">
            <input type="range" 
                   class="volume-slider" 
                   id="player2-cp" 
                   min="1" 
                   max="10" 
                   value="3" 
                   oninput="updatePlayer2CPDisplay()">
            <div class="volume-value" id="player2-cp-display">3</div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="player1-build-points">Player 1 Build Points</label>
          <div class="volume-control">
            <input type="range" 
                   class="volume-slider" 
                   id="player1-build-points" 
                   min="0" 
                   max="30" 
                   value="10" 
                   oninput="updatePlayer1BuildPointsDisplay()">
            <div class="volume-value" id="player1-build-points-display">10</div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="player2-build-points">Player 2 Build Points</label>
          <div class="volume-control">
            <input type="range" 
                   class="volume-slider"
                   id="player2-build-points" 
                   min="0" 
                   max="30" 
                   value="10" 
                   oninput="updatePlayer2BuildPointsDisplay()">
            <div class="volume-value" id="player2-build-points-display">10</div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="day-night-cycle">Day and Night Cycle</label>
          <div class="custom-dropdown" id="dayNightDropdown">
            <div class="dropdown-selected" id="dayNightSelected">
              Day
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="dayNightOptions">
              <div class="dropdown-option selected" data-value="day">Day</div>
              <div class="dropdown-option" data-value="night">Night</div>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="weather-cycle">Weather Cycle</label>
          <div class="custom-dropdown" id="weatherDropdown">
            <div class="dropdown-selected" id="weatherSelected">
              Clear Skies
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="weatherOptions">
              <div class="dropdown-option selected" data-value="clear">Clear Skies</div>
              <div class="dropdown-option" data-value="heavy-rain">Heavy Rain</div>
              <div class="dropdown-option" data-value="monsoon">Monsoon</div>
              <div class="dropdown-option" data-value="foggy">Foggy</div>
              <div class="dropdown-option" data-value="light-snow">Light Snowfall</div>
              <div class="dropdown-option" data-value="blizzard">Blizzard</div>
              <div class="dropdown-option" data-value="dust-storm">Dust Storm</div>
              <div class="dropdown-option" data-value="ash-storm">Ash Storm</div>
              <div class="dropdown-option" data-value="tornado">Tornado</div>
            </div>
          </div>
        </div>
        
        <!-- Removed old single build points slider - now separate for each player -->
        
        </div>
      </div>
      
      <!-- Bottom Action Buttons -->
      <div class="bottom-action-buttons">
        <button class="menu-button large-button" onclick="startGame()">Unleash Hell</button>
        <button class="menu-button large-button" onclick="resetSingleplayerBuildPoints(); showScreen('main-menu')">Back to Menu</button>
      </div>
    </div>
  </div>

  <!-- Multiplayer Game Setup Screen -->
  <div id="multiplayer-game-setup" class="screen">
    <div class="screen-header center-header">
      <h1> Multiplayer Game Setup</h1>
    </div>
    <div class="setup-container">
      <div class="setup-section">
        <h2>Warlord Configuration</h2>
        
        <!-- Multiplayer Status -->
        <div id="multiplayer-status" class="form-group">
          <div style="background: rgba(255, 215, 0, 0.2); padding: 10px; border-radius: 8px; border: 2px solid #FFD700;">
            <strong> Multiplayer Mode</strong><br>
            <span id="player-role-display">You are Player 1 (Host)</span>
          </div>
        </div>
        
        <div class="form-group">
          <label>Warlord 1 Name:</label>
          <input type="text" id="mp-player1-name" class="form-control" placeholder="Enter player 1 name" value="Red Commander">
        </div>
        
        <div class="form-group">
          <label>Warlord 1 Color:</label>
          <div class="color-picker-container">
            <button type="button" class="color-display" id="mp-player1-color-display" style="--color-value: #DC143C;" onclick="openCustomColorPicker('mp-player1-color')"></button>
            <span>Choose blood colors</span>
          </div>
        </div>
        
        <div class="form-group">
          <label>Warlord 2 Name:</label>
          <input type="text" id="mp-player2-name" class="form-control" placeholder="Enter player 2 name" value="Blue Commander">
        </div>
        
        <div class="form-group">
          <label>Warlord 2 Color:</label>
          <div class="color-picker-container">
            <button type="button" class="color-display" id="mp-player2-color-display" style="--color-value: #4169E1;" onclick="openCustomColorPicker('mp-player2-color')"></button>
            <span>Choose blood colors</span>
          </div>
        </div>
        
        <!-- Player 1 Armies (only visible to Player 1) -->
        <div class="form-group" id="mp-player1-armies-section">
          <label>Your Armies (up to 5):</label>
          <div id="mp-player1-armies-container">
            <div id="mp-player1-selected-armies" class="selected-armies-list">
              <div class="no-armies-message">No armies selected. Click "Add Army" to select armies for battle.</div>
            </div>
            <div style="margin-top: 10px;">
              <div class="custom-dropdown" id="mpPlayer1ArmyDropdown">
                <div class="dropdown-selected" id="mpPlayer1ArmySelected">Select Legion Type</div>
                <div class="dropdown-arrow"></div>
                <div class="dropdown-options" id="mpPlayer1ArmyOptions">
                  <div class="dropdown-option" data-value="">Select Legion Type</div>
                  <div class="dropdown-option" data-value="default">Default Army</div>
                </div>
              </div>
              <button type="button" class="grid-size-btn" style="margin-top: 8px; width: 100%;" onclick="addArmyToPlayerMultiplayer('player1')">Add Army</button>
            </div>
          </div>
        </div>
        
        <!-- Player 2 Armies (only visible to Player 2) -->
        <div class="form-group" id="mp-player2-armies-section" style="display: none;">
          <label>Your Armies (up to 5):</label>
          <div id="mp-player2-armies-container">
            <div id="mp-player2-selected-armies" class="selected-armies-list">
              <div class="no-armies-message">No armies selected. Click "Add Army" to select armies for battle.</div>
            </div>
            <div style="margin-top: 10px;">
              <div class="custom-dropdown" id="mpPlayer2ArmyDropdown">
                <div class="dropdown-selected" id="mpPlayer2ArmySelected">Select Legion Type</div>
                <div class="dropdown-arrow"></div>
                <div class="dropdown-options" id="mpPlayer2ArmyOptions">
                  <div class="dropdown-option" data-value="">Select Legion Type</div>
                  <div class="dropdown-option" data-value="default">Default Army</div>
                </div>
              </div>
              <button type="button" class="grid-size-btn" style="margin-top: 8px; width: 100%;" onclick="addArmyToPlayerMultiplayer('player2')">Add Army</button>
            </div>
          </div>
        </div>
        
        <!-- Opponent armies display (read-only) -->
        <div class="form-group" id="mp-opponent-armies-section">
          <label>Opponent's Armies:</label>
          <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.3);">
            <div id="mp-opponent-armies-display">Waiting for opponent to select armies...</div>
          </div>
        </div>
      </div>
      
      <!-- Game Configuration (only visible to Player 1/Host) -->
      <div class="setup-section" id="mp-game-config-section">
        <h2>War Parameters</h2>
        
        <div class="form-group">
          <label>Death Zones</label>
          <div class="volume-control">
            <input type="range" id="mp-zone-count" class="volume-slider" min="4" max="12" value="6" step="2" oninput="updateMPZoneDisplay()">
            <div class="volume-value" id="mp-zone-display">6</div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Tactical Grid Size:</label>
          <div class="grid-size-container">
            <button class="grid-size-btn active" data-size="6">66</button>
            <button class="grid-size-btn" data-size="8">88</button>
            <button class="grid-size-btn" data-size="10">1010</button>
            <button class="grid-size-btn" data-size="12">1212</button>
          </div>
        </div>

        <div class="form-group">
          <label for="mp-day-night-cycle">Day and Night Cycle</label>
          <div class="custom-dropdown" id="mpDayNightDropdown">
            <div class="dropdown-selected" id="mpDayNightSelected">Day</div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="mpDayNightOptions">
              <div class="dropdown-option selected" data-value="day">Day</div>
              <div class="dropdown-option" data-value="night">Night</div>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label for="mp-weather-cycle">Weather Cycle</label>
          <div class="custom-dropdown" id="mpWeatherDropdown">
            <div class="dropdown-selected" id="mpWeatherSelected">Clear Skies</div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="mpWeatherOptions">
              <div class="dropdown-option selected" data-value="clear">Clear Skies</div>
              <div class="dropdown-option" data-value="heavy-rain">Heavy Rain</div>
              <div class="dropdown-option" data-value="monsoon">Monsoon</div>
              <div class="dropdown-option" data-value="foggy">Foggy</div>
              <div class="dropdown-option" data-value="light-snow">Light Snowfall</div>
              <div class="dropdown-option" data-value="blizzard">Blizzard</div>
              <div class="dropdown-option" data-value="dust-storm">Dust Storm</div>
              <div class="dropdown-option" data-value="ash-storm">Ash Storm</div>
              <div class="dropdown-option" data-value="tornado">Tornado</div>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Win Condition:</label>
          <div class="custom-dropdown" id="mpWinConditionDropdown" data-dropdown-type="mp-win-condition">
            <div class="dropdown-selected" id="mpWinConditionSelected">
              Strategic Dominance (Control majority of zones)
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="mpWinConditionOptions">
              <div class="dropdown-option selected" data-value="dominance">Strategic Dominance (Control majority of zones)</div>
              <div class="dropdown-option" data-value="elimination">Total Elimination (Destroy all enemy units)</div>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Battlefield Terrain:</label>
          <div class="custom-dropdown" id="mpTerrainDropdown" data-dropdown-type="mp-terrain">
            <div class="dropdown-selected" id="mpTerrainSelected">
              Random Mix
            </div>
            <div class="dropdown-arrow"></div>
            <div class="dropdown-options" id="mpTerrainOptions">
              <div class="dropdown-option selected" data-value="random">Random Mix</div>
              <div class="dropdown-option" data-value="plains">The Scorched Expanse</div>
              <div class="dropdown-option" data-value="forest">The Withered Thicket</div>
              <div class="dropdown-option" data-value="desert">Ashblight Expanse</div>
              <div class="dropdown-option" data-value="ruins">Relics Of The Forsaken</div>
              <div class="dropdown-option" data-value="snow">The Frozen Grasp</div>
              <div class="dropdown-option" data-value="mountainous">Crags Of The Damned</div>
              <div class="dropdown-option" data-value="hilly">Bloodridge Heights</div>
              <div class="dropdown-option" data-value="swamp">Wailing Marshes</div>
              <div class="dropdown-option" data-value="jungle">Veil Of Rot</div>
              <div class="dropdown-option" data-value="volcanic">Hells Mouth</div>
              <div class="dropdown-option" data-value="urban">Wretched Society</div>
              <div class="dropdown-option" data-value="naval">Shore Of The Damned</div>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Player 1 Command Points</label>
          <div class="volume-control">
            <input type="range" id="mp-player1-cp" class="volume-slider" min="1" max="10" value="3" oninput="document.getElementById('mp-player1-cp-display').textContent=this.value">
            <div class="volume-value" id="mp-player1-cp-display">3</div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Player 2 Command Points</label>
          <div class="volume-control">
            <input type="range" id="mp-player2-cp" class="volume-slider" min="1" max="10" value="3" oninput="document.getElementById('mp-player2-cp-display').textContent=this.value">
            <div class="volume-value" id="mp-player2-cp-display">3</div>
          </div>
        </div>
        
        
        
        <div class="form-group">
          <label>Player 1 Build Points:</label>
          <div class="volume-control">
            <input type="range" id="mp-player1-build-points" class="volume-slider" min="0" max="30" value="10" oninput="document.getElementById('mp-player1-build-points-display').textContent=this.value">
            <div class="volume-value" id="mp-player1-build-points-display">10</div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Player 2 Build Points:</label>
          <div class="volume-control">
            <input type="range" id="mp-player2-build-points" class="volume-slider" min="0" max="30" value="10" oninput="document.getElementById('mp-player2-build-points-display').textContent=this.value">
            <div class="volume-value" id="mp-player2-build-points-display">10</div>
          </div>
        </div>
      </div>
      

      
      <div class="bottom-action-buttons">
        <button class="menu-button large-button" id="mp-start-game-btn" onclick="startMultiplayerGame()" disabled>Start Battle (Waiting for both players to select armies)</button>
      </div>
    </div>
  </div>

  <!-- Unit Creator Screen -->
  <div id="unit-creator" class="screen">
    <div class="unit-creator-container">
      <!-- Atmospheric Effects -->
      <div class="forge-atmosphere"></div>
      
      <!-- Back Button -->
      <button class="back-button" onclick="showScreen('main-menu')">
        <span> Return to Command</span>
      </button>
      
      <!-- Header -->
      <div class="forge-header">
        <h1 class="forge-title">Unit Forge</h1>
        <p class="forge-subtitle">Craft Your War Machines</p>
      </div>
      
      <!-- Main Creation Grid -->
      <div class="creation-grid">
        <!-- Unit Configuration Panel -->
        <div class="unit-config-panel">
          <h2 class="panel-title">Configuration</h2>
          
          <!-- Basic Unit Info -->
          <div class="form-group">
            <label class="form-label" for="unit-name">Unit Name</label>
            <input type="text" id="unit-name" class="form-input" placeholder="Enter unit name..." maxlength="20">
          </div>
          
          <div class="form-group">
            <label class="form-label" for="unit-type">Unit Type</label>
            <div class="custom-dropdown" id="unit-type-dropdown">
                        <div class="dropdown-selected" id="unit-type-selected" data-value="infantry">
            Infantry
          </div>
              <div class="dropdown-arrow"></div>
              <div class="dropdown-options" id="unit-type-options">
                <div class="dropdown-option" data-value="infantry">Infantry</div>
                <div class="dropdown-option" data-value="vehicle">Vehicle</div>
                <div class="dropdown-option" data-value="tank">Tank</div>
                <div class="dropdown-option" data-value="mech">Mech</div>
                <div class="dropdown-option" data-value="support">Support</div>
                <div class="dropdown-option" data-value="cavalry">Cavalry</div>
                <div class="dropdown-option" data-value="field_gun">Field Guns</div>
                <div class="dropdown-option" data-value="artillery">Artillery</div>
                <div class="dropdown-option" data-value="fighter">Fighter</div>
                <div class="dropdown-option" data-value="bomber">Bomber</div>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="unit-select">Select Unit to Edit</label>
            <div class="custom-dropdown" id="unit-select-dropdown">
                        <div class="dropdown-selected" id="unit-select-selected" data-value="">
            Create New Unit
          </div>
              <div class="dropdown-arrow"></div>
              <div class="dropdown-options" id="unit-select-options">
                <div class="dropdown-option" data-value="">Create New Unit</div>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="special-ability">Special Ability</label>
            <div class="custom-dropdown" id="special-ability-dropdown">
                        <div class="dropdown-selected" id="special-ability-selected" data-value="none">
            None
          </div>
              <div class="dropdown-arrow"></div>
              <div class="dropdown-options" id="special-ability-options">
                <div class="dropdown-option" data-value="none">None</div>
              </div>
            </div>
          </div>
          
          <!-- Stat Controls -->
          <div class="stat-controls">
            <div class="stat-control">
              <span class="stat-label">Attack</span>
              <div class="volume-control">
                <input type="range" class="volume-slider" id="attack-mod" min="-3" max="5" value="0" oninput="updateStatDisplays()">
                <div class="volume-value" id="attack-display">0</div>
              </div>
            </div>
            
            <div class="stat-control" id="defense-group">
              <span class="stat-label">Defense</span>
              <div class="volume-control">
                <input type="range" class="volume-slider" id="defense-mod" min="-3" max="5" value="0" oninput="updateStatDisplays()">
                <div class="volume-value" id="defense-display">0</div>
              </div>
            </div>
            
            <div class="stat-control" id="morale-group">
              <span class="stat-label">Morale</span>
              <div class="volume-control">
                <input type="range" class="volume-slider" id="morale-mod" min="2" max="6" value="4" oninput="updateStatDisplays()">
                <div class="volume-value" id="morale-display">4</div>
              </div>
            </div>
            
            <div class="stat-control" id="range-group">
              <span class="stat-label">Range</span>
              <div class="volume-control">
                <input type="range" class="volume-slider" id="range-mod" min="1" max="5" value="1" oninput="updateStatDisplays()">
                <div class="volume-value" id="range-display">1</div>
              </div>
            </div>
            
            <div class="stat-control" id="movement-group">
              <span class="stat-label">Movement</span>
              <div class="volume-control">
                <input type="range" class="volume-slider" id="movement-mod" min="1" max="3" value="1" oninput="updateStatDisplays()">
                <div class="volume-value" id="movement-display">1</div>
              </div>
            </div>
            
            <div class="stat-control" id="armour-group" style="display: none;">
              <span class="stat-label">Armour</span>
              <div class="volume-control">
                <input type="range" class="volume-slider" id="armour-mod" min="0" max="10" value="0" oninput="updateStatDisplays()">
                <div class="volume-value" id="armour-display">0</div>
              </div>
            </div>
            
            <div class="stat-control" id="hit-chance-group" style="display: none;">
              <span class="stat-label">Hit Chance</span>
              <div class="volume-control">
                <input type="range" class="volume-slider" id="hit-chance-mod" min="6" max="10" value="9" oninput="updateStatDisplays()">
                <div class="volume-value" id="hit-chance-display">9</div>
              </div>
            </div>
          </div>
          
          <!-- Create Button -->
          <div class="action-buttons">
            <button class="action-button" onclick="createUnit()" id="forge-button">
              <span>Forge Unit</span>
            </button>
          </div>
        </div>
        
        <!-- Unit Preview Panel -->
        <div class="unit-preview-panel">
          <h2 class="panel-title">Preview</h2>
          
          <div class="unit-preview" id="unit-preview-icon"></div>
          <div class="unit-name-display" id="preview-name">Unnamed Unit</div>
          <div class="unit-type-display" id="preview-type">Infantry</div>
          
          <div class="unit-stats-display">
            <div class="stat-display">
              <div class="stat-name">Attack</div>
              <div class="stat-value" id="preview-attack">0</div>
            </div>
            
            <div class="stat-display">
              <div class="stat-name">Defense</div>
              <div class="stat-value" id="preview-defense">0</div>
            </div>
            
            <div class="stat-display">
              <div class="stat-name">Morale</div>
              <div class="stat-value" id="preview-morale">4</div>
            </div>
            
            <div class="stat-display">
              <div class="stat-name">Range</div>
              <div class="stat-value" id="preview-range">1</div>
            </div>
            
            <div class="stat-display">
              <div class="stat-name">Movement</div>
              <div class="stat-value" id="preview-movement">1</div>
            </div>
            
            <div class="stat-display" id="preview-armour-display" style="display: none;">
              <div class="stat-name">Armour</div>
              <div class="stat-value" id="preview-armour">0</div>
            </div>
            
            <div class="stat-display">
              <div class="stat-name">Hit Chance</div>
              <div class="stat-value" id="preview-hit-chance">9</div>
            </div>
          </div>
          
          <div class="special-ability-display">
            <div class="special-ability-label">Special Ability</div>
            <div class="special-ability-value" id="preview-special-ability" onmouseover="showSpecialAbilityTooltip(event)" onmouseout="hideSpecialAbilityTooltip()">None</div>
          </div>
        </div>
        
        <!-- Unit List Panel -->
        <div class="unit-list-panel">
          <h2 class="panel-title">Created Units</h2>
          
          <div class="unit-list" id="custom-units-list">
            <!-- Custom units will be dynamically populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Army Builder Screen -->
  <div id="army-builder" class="screen">
    <div class="army-builder-container">
      <!-- Atmospheric Effects -->
      <div class="war-atmosphere"></div>
      
      <!-- Back Button -->
      <button class="back-button" onclick="showScreen('main-menu')">
        <span> Return to Command</span>
      </button>
      
      <!-- Header -->
      <div class="war-council-header">
        <h1 class="war-council-title">War Council</h1>
        <p class="war-council-subtitle">Assemble Your Legion of Darkness</p>
      </div>
      
      <!-- Main Command Grid -->
      <div class="command-grid">
        <!-- Army Configuration Panel -->
        <div class="army-config-panel">
          <h2 class="panel-title">Army Command</h2>
          
          <!-- Army Name Input -->
          <div class="form-group">
            <label class="form-label" for="army-name">Legion Name</label>
            <input type="text" id="army-name" class="form-control" placeholder="Name your dark legion..." maxlength="25" oninput="updateSaveButton()">
          </div>
          
          <!-- Unit Counter -->
          <div class="army-counter">
            <div class="counter-label">Forces Assembled</div>
            <div class="counter-value" id="army-unit-count">0/10</div>
          </div>
          
          <!-- Current Army List -->
          <div class="form-group">
            <label class="form-label">Current Legion</label>
            <div class="current-army-list" id="current-army-list">
              <div style="text-align: center; color: #cc4444; opacity: 0.7; padding: 20px; font-style: italic;">
                No forces assembled yet...
              </div>
            </div>
          </div>
          
          <!-- Action Buttons -->
          <div class="action-buttons">
            <button class="menu-button" id="save-army-btn" onclick="saveArmy()" disabled>
              <span>Save Legion</span>
            </button>
            <button class="menu-button" onclick="clearArmy()">
              <span>Disband All</span>
            </button>
          </div>
        </div>
        
        <!-- Available Units Panel -->
        <div class="available-units-panel">
          <h2 class="panel-title">Available Forces</h2>
          
          <!-- Unit Tabs -->
          <div class="unit-tabs">
            <button class="tab-button active" id="regular-tab" onclick="switchUnitTab('regular')">
              <span>Ground Forces</span>
            </button>
            <button class="tab-button" id="aerial-tab" onclick="switchUnitTab('aerial')">
              <span>Air Forces</span>
            </button>
          </div>
          
          <!-- Available Units Pool -->
          <div class="available-units-pool" id="available-units-pool">
            <!-- Units will be dynamically populated here -->
          </div>
        </div>
        
        <!-- Saved Armies Panel -->
        <div class="saved-armies-panel">
          <h2 class="panel-title">Saved Legions</h2>
          
          <div class="saved-armies-list" id="saved-armies-list">
            <div style="text-align: center; color: #cc4444; opacity: 0.7; padding: 20px; font-style: italic;">
              No legions saved yet...
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Enhanced Settings Screen -->
  <div id="settings" class="screen">
    <div class="settings-container">
      <!-- Enhanced Background Layers -->
      <div class="ritual-chamber-layer"></div>
      
      <!-- Ritual Circles -->
      <div class="ritual-circles">
        <div class="ritual-circle large"></div>
        <div class="ritual-circle medium"></div>
        <div class="ritual-circle small"></div>
      </div>
      
      <!-- Floating Demonic Sigils -->
      <div class="demonic-sigils">
        <div class="floating-sigil pentagram"></div>
        <div class="floating-sigil goat-head"></div>
        <div class="floating-sigil triangle"></div>
      </div>
      
      <!-- Blood Orbs -->
      <div class="blood-orbs">
        <div class="blood-orb small"></div>
        <div class="blood-orb medium"></div>
        <div class="blood-orb large"></div>
      </div>
      
      <!-- Settings Panel -->
      <div class="settings-panel">
        <h1 class="settings-title">Configuration</h1>
        
        <div class="settings-content">
          <!-- Audio Settings Section -->
          <div class="settings-section">
            <div class="section-label">Audio Control</div>
            
            <div class="control-group">
              <label class="control-label">Music Track</label>
              <div class="music-selector">
                <div class="custom-dropdown" id="musicDropdown">
                  <div class="dropdown-selected" id="dropdownSelected">
                    No Music
                  </div>
                  <div class="dropdown-arrow"></div>
                                                      <div class="dropdown-options" id="dropdownOptions">
                                        <div class="dropdown-option selected" data-value="none">No Music</div>
                                        <div class="dropdown-option" data-value="the-devil">The Devil</div>
                                        <div class="dropdown-option" data-value="girei">Girei</div>
                                        <div class="dropdown-option" data-value="libera-me">Libera Me</div>
                                        <div class="dropdown-option" data-value="lucifers-hymn">Lucifer's Hymn</div>
                                        <div class="dropdown-option" data-value="night-of-the-wolf">Night Of The Wolf</div>
                                        <div class="dropdown-option" data-value="requiem">Requiem of the Fallen</div>
                                        <div class="dropdown-option" data-value="trench-march">Trench March</div>
                                        <div class="dropdown-option" data-value="blood-oath">Blood Oath</div>
                                        <div class="dropdown-option" data-value="demons-lament">Demon's Lament</div>
                                    </div>
                </div>
              </div>
            </div>
            
            <div class="control-group">
              <label class="control-label">Volume</label>
              <div class="volume-control">
                <input type="range" 
                       class="volume-slider" 
                       id="volumeSlider" 
                       min="0" 
                       max="100" 
                       value="50">
                <div class="volume-value" id="volumeValue">50%</div>
              </div>
            </div>
            
            
          </div>
          
          <!-- Navigation Section -->
          <div class="return-button">
            <button class="menu-button" onclick="showScreen('main-menu')">
              <span>Return to Main Menu</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Zone Detail Screen -->
  <div id="zone-detail" class="screen">
    <div class="zone-battle-container">
      <!-- Hellish Atmosphere -->
      <div class="battlefield-atmosphere"></div>
      
      <!-- Main UI Layout -->
      <div class="zone-ui-wrapper">
        <!-- Top Header -->
        <div class="zone-header">
          <div class="zone-status-left">
            <div class="status-item" id="phase-indicator">Fortification Phase</div>
          </div>
          <h1 class="zone-title" id="zone-detail-title">Zone Asmodeus</h1>
          <div class="zone-status">
            <div class="status-item">Command Points: <span id="zone-command-points">3</span></div>
            <div class="status-item">Build Points: <span id="zone-build-points">10</span></div>
          </div>
        </div>
        
        <!-- Left Panel - Engineering & Intelligence -->
        <div class="left-panel">
          <div class="construction-panel">
            <h3>Field Engineering</h3>
            <div class="construction-status" id="construction-status">Awaiting construction orders</div>
            <div class="construction-panel-content" id="construction-panel-content" style="display: none;">
              <div class="construction-options" id="construction-options">
                <!-- Construction options will be populated here -->
              </div>
              <div class="construction-instructions" id="construction-instructions">
                Select fortification type, then designate placement coordinates
              </div>
            </div>
          </div>
          
          <div class="transported-units-panel" id="transported-units-panel" style="display: none;">
            <h3>Transported Units</h3>
            <div id="transported-units-container">
              <!-- Transported units will be shown here -->
            </div>
          </div>
          
          <div class="chat-panel">
            <h3>Intelligence Reports</h3>
            <div class="chat-messages" id="zone-log">
              <div class="log-entry">Demonic reinforcements deploying...</div>
              <div class="log-entry">Hellfire artillery primed and ready</div>
              <div class="log-entry">Shadow reconnaissance initiated</div>
            </div>
            <input type="text" class="chat-input" placeholder="Type intelligence report..." id="chat-input" onkeypress="handleIntelligenceInput(event)">
          </div>
        </div>
        
        <!-- Center Battlefield -->
        <div class="battlefield-center">
          <div class="battlefield-frame">
            <div class="mini-battlefield" id="mini-battlefield">
              <!-- Tactical positions will be generated here -->
            </div>
          </div>
          
          <!-- Demonic Decorations Below Battle Grid -->
          <div class="demonic-decorations">
            <div class="demonic-symbol"></div>
            <div class="demonic-symbol"></div>
            <div class="demonic-symbol"></div>
            <div class="demonic-symbol"></div>
            <div class="demonic-symbol"></div>
          </div>
        </div>
        
        
        
        <!-- Right Panel - Forces, Artillery, Aerial -->
        <div class="right-panel">
          <div class="units-panel">
            <h3>Infernal Legion</h3>
            <div class="deployment-area" id="deployment-area">
              <div class="deployment-controls" id="deployment-controls">
              <div class="primary-controls">
                <button class="action-button active" onclick="setDeploymentMode('place')">Deploy</button>
                <button class="action-button" onclick="setDeploymentMode('attack')">Assault</button>
                <button class="action-button" onclick="setDeploymentMode('move')">Advance</button>
              </div>
              <div class="carrier-controls">
                <button class="action-button" onclick="setDeploymentMode('board')">Board</button>
                <button class="action-button" onclick="setDeploymentMode('disembark')">Disembark</button>
                <button class="action-button" onclick="setDeploymentMode('gas')">Deploy Gas</button>
              </div>
              </div>
              
              <div id="movement-info" class="movement-info" style="display: none;">
                <strong>Movement Orders:</strong>
                <div style="margin-top: 5px;">
                  <span id="movement-unit-name">No unit selected</span> - 
                  <span id="movement-points">0</span> movement remaining
                </div>
                <div style="margin-top: 5px; font-size: 11px;">
                  Select highlighted positions for unit advancement
                </div>
              </div>
              
              <div id="selected-unit-info" class="selected-unit-info" style="display: none;">
                <strong>Selected: <span id="selected-unit-name">None</span></strong>
                <div style="font-size: 13px; margin-top: 5px;">
                  Designate deployment coordinates
                </div>
              </div>
            </div>
            
            <!-- Army Selection System -->
            <div class="army-selection-container" id="army-selection-container">
              <h3>Select Legion for Deployment</h3>
              <button class="debug-btn" onclick="debugArmySelection()" style="position: absolute; top: 10px; right: 10px; background: #333; color: #fff; border: 1px solid #666; padding: 5px 10px; font-size: 12px; cursor: pointer;">Debug</button>
              <div class="army-selector">
                <div class="themed-dropdown" id="army-selector-dropdown">
                  <div class="themed-dropdown-button" id="army-selector-button">
                    <span class="themed-dropdown-text" id="army-selector-text">Choose legion...</span>
                    <div class="themed-dropdown-icon"></div>
                  </div>
                  <div class="themed-dropdown-menu" id="army-selector-menu">
                    <!-- Options will be populated by JavaScript -->
                  </div>
                </div>
                <div id="selected-army-info" class="selected-army-info" style="display: none;">
                  <div class="army-info-header">
                    <span id="selected-army-name"></span>
                  </div>
                  <div class="army-info-stats">
                    <div class="combat-ready-section">
                      <div class="combat-ready-label">Combat Ready</div>
                      <div class="combat-ready-count"><span id="army-unit-count"></span></div>
                    </div>
                    <div class="legion-selection-section">
                      <button class="change-army-btn" onclick="showArmySelector()">Legion Selection</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="army-pool-container" id="army-pool-container" style="display: none;">
              <div class="army-pool-header">
                <div class="army-pool-title">Combat Ready</div>
                <div class="army-pool-count" id="army-pool-count">10</div>
                <button class="back-to-armies-btn" onclick="showArmySelection()"> Legion Selection</button>
              </div>
              <div id="zone-army-pool" class="army-pool-grid">
                <!-- Available units will be shown here -->
              </div>
            </div>
          </div>
          
          <div class="artillery-panel">
            <div class="artillery-panel-header">
            <h3>Hellfire Artillery</h3>
            </div>
            <div class="artillery-status" id="artillery-status">Artillery batteries offline</div>
            <div class="artillery-panel-content" id="artillery-panel-content" style="display: none;">
              <div class="artillery-units-container" id="artillery-units-container">
                <!-- Artillery units will be populated here -->
              </div>
              <div class="artillery-instructions" id="artillery-instructions">
                Target enemy positions for bombardment
              </div>
            </div>
          </div>
          
          <div class="aerial-panel">
            <div class="aerial-panel-header">
            <h3>Infernal Airwings</h3>
            </div>
            <div class="aerial-status" id="aerial-status">No aerial units deployed</div>
            <div class="aerial-panel-content" id="aerial-panel-content" style="display: none;">
              <div class="aerial-units-container" id="aerial-units-container">
                <!-- Aerial units will be populated here -->
              </div>
              <div class="aerial-instructions" id="aerial-instructions">
                Launch air strikes against enemy formations
              </div>
            </div>
          </div>
        </div>
        
        <!-- Bottom Panel - Command Status -->
        <div class="bottom-panel">
          <div class="decoration-left">
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div class="decoration-center">
            <button class="action-button" onclick="window.scrollTo(0, 0); showScreen('game')">Return to War Room</button>
          </div>
          <div class="decoration-right">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="game" class="screen">
    <!-- Victory Confirmation Overlay -->
    <div id="victory-confirmation-overlay" class="victory-overlay" style="display: none;">
      <div class="victory-overlay-content">
        <h2 id="victory-overlay-title">Victory Achieved!</h2>
        <p id="victory-overlay-message">Congratulations! You have achieved victory!</p>
        
        <!-- Player Status Indicators -->
        <div class="player-status-indicators" id="player-status-indicators" style="display: none;">
          <div class="player-status">
            <span class="player-name" id="player1-status-name">Player 1</span>
            <span class="status-indicator" id="player1-status">WAITING...</span>
          </div>
          <div class="player-status">
            <span class="player-name" id="player2-status-name">Player 2</span>
            <span class="status-indicator" id="player2-status">WAITING...</span>
          </div>
        </div>
        
        <div class="victory-overlay-buttons">
          <button id="accept-victory-btn" class="menu-button" onclick="acceptVictoryOverlay()">Accept Victory</button>
          <button id="accept-defeat-btn" class="menu-button" onclick="acceptDefeatOverlay()" style="display: none;">Accept Defeat</button>
        </div>
      </div>
    </div>
    
    <div class="main-container">
        <!-- Background Effects -->
        <div class="battlefield-backdrop"></div>
        <div class="blood-effects">
            <div class="blood-gradient corner-tl"></div>
            <div class="blood-gradient corner-br"></div>
        </div>
        <div class="environmental-effects"></div>
        <div class="depth-vignette"></div>
    
    <div class="game-container">
      <div class="battlefield-section">
        <h2>Strategic Battlefield</h2>
        <div id="battlefield" class="battlefield grid-6"></div>
        
        <div class="current-player" id="turn-indicator">
          Red Player's Turn - Choose zones to attack
        </div>
                
                <!-- Demonic Effects Section -->
                <div class="demonic-effects-section">
                    <div class="demonic-symbols">
                        <div class="symbol symbol-1"></div>
                        <div class="symbol symbol-2"></div>
                        <div class="symbol symbol-3"></div>
                        <div class="symbol symbol-4"></div>
                        <div class="symbol symbol-5"></div>
                        <div class="symbol symbol-6"></div>
                    </div>
                    <div class="demonic-text">
                        <span class="demonic-word">BLOOD</span>
                        <span class="demonic-word">WAR</span>
                        <span class="demonic-word">DEATH</span>
                        <span class="demonic-word">CHAOS</span>
                    </div>
                    <div class="demonic-pentagram">
                        <div class="pentagram-inner"></div>
                        <div class="pentagram-outer"></div>
                    </div>
        </div>
      </div>
      
      <div class="controls-section">
                <div class="control-panel">
        <div class="current-player" id="current-player">Red Player's Turn</div>
        
        <!-- AI Turn Indicator -->
                 <div class="ai-turn-indicator" id="ai-turn-indicator" style="display: none;">
           <div class="ai-thinking">
             <div class="ai-spinner"></div>
             <span>AI is thinking...</span>
           </div>
           <div class="ai-personality" id="ai-personality" style="display: none;">
             <div class="personality-info">
               <span class="personality-type" id="personality-type">Balanced</span>
               <span class="personality-mood" id="personality-mood">Neutral</span>
             </div>
             <div class="personality-stats">
               <div class="stat-bar">
                 <span>Confidence:</span>
                 <div class="bar"><div class="fill" id="confidence-bar"></div></div>
               </div>
               <div class="stat-bar">
                 <span>Aggression:</span>
                 <div class="bar"><div class="fill" id="aggression-bar"></div></div>
               </div>
             </div>
           </div>
         </div>
        
        <div class="command-points">
          <strong>Command Points: <span id="command-points">3</span></strong>
          <div style="font-size: 12px; margin-top: 5px; color: #ccc;">
            Place Unit: 1 CP | Move Unit: 1 CP | Attack: 1 CP | Artillery: 2 CP
          </div>
        </div>
        
        <!-- Weather and Day/Night Cycle Display -->
        <div class="weather-section">
          <strong>Environmental Conditions</strong>
          <div class="weather-display-controls">
            <div class="weather-item">
              <span class="weather-label">Day/Night:</span>
              <span class="weather-value" id="game-weather-day-night">Day</span>
            </div>
            <div class="weather-item">
              <span class="weather-label">Weather:</span>
              <span class="weather-value" id="game-weather-current">Clear Skies</span>
            </div>
          </div>
        </div>
        
        <div style="margin: 20px 0;">
                        <button class="menu-button" onclick="endTurn()">
                            <span>End Turn</span>
                        </button>
                        <button class="menu-button" onclick="surrenderGame()">
                            <span>Surrender</span>
                        </button>
                        <button class="menu-button" onclick="showScreen('main-menu')">
                            <span>Main Menu</span>
                        </button>
          </div>
        </div>
        
                <div class="control-panel">
        <div class="log" id="log"></div>
                </div>
            </div>
      </div>
    </div>
  </div>



    <!-- Summary Screen -->
  <div id="summary" class="screen">
    <!-- Demonic Background Symbols -->
    <div class="demonic-pentagram"></div>
    <div class="demonic-pentagram"></div>
    <div class="demonic-circle"></div>
    <div class="demonic-circle"></div>
    <div class="demonic-rune"></div>
    <div class="demonic-rune"></div>
    <div class="demonic-rune"></div>
    <div class="demonic-rune"></div>
    
    <!-- Main Content Container -->
    <div class="summary-container">
      <!-- Header Section -->
      <div class="summary-header">
        <h1 class="summary-title">Campaign Aftermath</h1>
        <div class="summary-result" id="summary-result">Victory!</div>
        <div class="summary-subtitle" id="summary-subtitle">Strategic Campaign Complete</div>
      </div>
      
      <!-- Tab Navigation -->
      <div class="summary-tabs">
        <button class="tab-button active" onclick="switchSummaryTab('overview')">
          <span>Battle Report</span>
        </button>
        <button class="tab-button" onclick="switchSummaryTab('details')">
          <span>Casualty Report</span>
        </button>
      </div>
      
      <!-- Overview Tab Content -->
      <div id="overview-tab" class="summary-tab-content active">
        <div class="summary-stats-grid">
          <!-- Player 1 Stats -->
          <div class="player-summary player1-summary">
            <div class="player-header">
              <h3 id="red-player-name">Red Player</h3>
              <div class="player-badge red-badge">Commander</div>
            </div>
            <div class="player-stats">
              <div class="stat-row">
                <span class="stat-label">Zones Controlled:</span>
                <span class="stat-value" id="red-zones-controlled">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Units Deployed:</span>
                <span class="stat-value" id="red-units-deployed">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Units Lost:</span>
                <span class="stat-value casualty-count" id="red-units-lost">0</span>
              </div>
            </div>
          </div>
          
          <!-- Player 2 Stats -->
          <div class="player-summary player2-summary">
            <div class="player-header">
              <h3 id="blue-player-name">Blue Player</h3>
              <div class="player-badge blue-badge">Commander</div>
            </div>
            <div class="player-stats">
              <div class="stat-row">
                <span class="stat-label">Zones Controlled:</span>
                <span class="stat-value" id="blue-zones-controlled">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Units Deployed:</span>
                <span class="stat-value" id="blue-units-deployed">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Units Lost:</span>
                <span class="stat-value casualty-count" id="blue-units-lost">0</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Campaign Information -->
        <div class="campaign-info-panel">
          <h3 class="panel-title">Campaign Intelligence</h3>
          <div class="info-grid">
            <div class="info-item">
              <span class="info-label">Total Turns:</span>
              <span class="info-value" id="total-turns">0</span>
            </div>
            <div class="info-item">
              <span class="info-label">Victor:</span>
              <span class="info-value victor-name" id="winner-name">Red Player</span>
            </div>
            <div class="info-item">
              <span class="info-label">End Condition:</span>
              <span class="info-value" id="end-condition">Victory</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Details Tab Content -->
      <div id="details-tab" class="summary-tab-content">
        <div class="detailed-stats-grid">
          <!-- Player 1 Detailed -->
          <div class="player-detailed player1-detailed">
            <div class="detailed-header">
              <h3 id="red-player-name-detailed">Red Player - Casualty Report</h3>
            </div>
            <div class="units-lost-section">
              <h4 class="section-title">Fallen Units</h4>
              <div id="red-units-lost-list" class="units-lost-list">
                <!-- Units will be populated here -->
              </div>
            </div>
          </div>
          
          <!-- Player 2 Detailed -->
          <div class="player-detailed player2-detailed">
            <div class="detailed-header">
              <h3 id="blue-player-name-detailed">Blue Player - Casualty Report</h3>
            </div>
            <div class="units-lost-section">
              <h4 class="section-title">Fallen Units</h4>
              <div id="blue-units-lost-list" class="units-lost-list">
                <!-- Units will be populated here -->
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Action Buttons -->
      <div class="summary-actions">
        <button class="menu-button" onclick="returnToMainMenu()">
          <span>Return to Command</span>
        </button>
        <button class="menu-button primary" onclick="startNewGame()">
          <span>New Campaign</span>
        </button>
      </div>
    </div>
  </div>

  <!-- AI Turn Indicator -->
  <!-- AI turn indicator removed -->

  <script>
    // Zone name mapping for demon-themed zones
    const zoneNames = {
      'A': 'Asmodeus',
      'B': 'Baal', 
      'C': 'Chort',
      'D': 'Dagon',
      'E': 'Eurynome',
      'F': 'Furfur',
      'G': 'Gaap',
      'H': 'Haures',
      'I': 'Ipos',
      'J': 'Jezebeth',
      'K': 'Kobal',
      'L': 'Leviathan'
    };

    // Enhanced Menu Functionality with Demonic Effects
    
    // Advanced Sigil Effects
    const sigil = document.querySelector('.demonic-sigil');
    const sigilContainer = document.querySelector('.sigil-container');
    
    if (sigil && sigilContainer) {
      setInterval(() => {
        if (Math.random() < 0.15) {
          const intensity = Math.random() * 0.4 + 0.6;
          sigil.style.opacity = intensity;
          sigil.style.filter = `drop-shadow(0 0 ${15 + intensity * 20}px rgba(255, 0, 0, ${intensity * 0.8}))`;
          
          setTimeout(() => {
            sigil.style.opacity = '';
            sigil.style.filter = '';
          }, 150 + Math.random() * 100);
        }
      }, 300);
    }
    
    // Premium Smoke System
    const smokeSystem = document.getElementById('smokeSystem');
    
    function createSmokeParticle() {
      const particle = document.createElement('div');
      particle.className = 'smoke-particle';
      
      const size = Math.random() * 100 + 60;
      const startX = Math.random() * window.innerWidth;
      const duration = Math.random() * 15 + 12;
      const delay = Math.random() * 3;
      
      particle.style.width = size + 'px';
      particle.style.height = size + 'px';
      particle.style.left = startX + 'px';
      particle.style.bottom = '-100px';
      particle.style.animationName = 'smokeRise';
      particle.style.animationDuration = duration + 's';
      particle.style.animationDelay = delay + 's';
      particle.style.animationTimingFunction = 'ease-out';
      particle.style.animationFillMode = 'forwards';
      
      smokeSystem.appendChild(particle);
      
      setTimeout(() => {
        if (particle.parentNode) {
          particle.remove();
        }
      }, (duration + delay) * 1000);
    }
    
    function createBloodMist() {
      const mist = document.createElement('div');
      const mistTypes = ['blood-mist', 'blood-mist dense'];
      mist.className = mistTypes[Math.floor(Math.random() * mistTypes.length)];
      
      const width = Math.random() * 150 + 80;
      const height = Math.random() * 100 + 60;
      const startX = Math.random() * window.innerWidth;
      const duration = Math.random() * 18 + 15;
      const delay = Math.random() * 4;
      
      mist.style.width = width + 'px';
      mist.style.height = height + 'px';
      mist.style.left = startX + 'px';
      mist.style.bottom = '-100px';
      mist.style.animationName = 'bloodMistDrift';
      mist.style.animationDuration = duration + 's';
      mist.style.animationDelay = delay + 's';
      mist.style.animationTimingFunction = 'ease-in-out';
      mist.style.animationFillMode = 'forwards';
      
      smokeSystem.appendChild(mist);
      
      setTimeout(() => {
        if (mist.parentNode) {
          mist.remove();
        }
      }, (duration + delay) * 1000);
    }
    
    // Generate atmospheric effects
    setInterval(createSmokeParticle, 2000);
    setInterval(createBloodMist, 3500);
    
    // Demonic Skeletal Hand Cursor System
    const cursor = document.getElementById('cursor');
    let mouseX = 0;
    let mouseY = 0;
    let cursorX = 0;
    let cursorY = 0;

    function updateCursor() {
      cursorX += (mouseX - cursorX) * 0.12;
      cursorY += (mouseY - cursorY) * 0.12;
      
      cursor.style.left = cursorX - 12 + 'px';
      cursor.style.top = cursorY - 20 + 'px';
      
      // Debug cursor position (only log occasionally to avoid spam)
      if (Math.random() < 0.01) { // 1% chance to log
        console.log(' Cursor position:', cursorX, cursorY, 'Mouse:', mouseX, mouseY);
      }
      
      requestAnimationFrame(updateCursor);
    }

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // Hover detection for interactive elements
    document.addEventListener('mouseover', (e) => {
      if (e.target.matches('a, button, input, .clickable, .menu-button')) {
        cursor.classList.add('hovering');
      }
    });

    document.addEventListener('mouseout', (e) => {
      if (e.target.matches('a, button, input, .clickable, .menu-button')) {
        cursor.classList.remove('hovering');
      }
    });

    document.addEventListener('mousedown', (e) => {
      cursor.classList.add('clicking');
      createBloodSpray(e.clientX, e.clientY);
      createPentagram(e.clientX, e.clientY);
      createBloodDrips(e.clientX, e.clientY);
      playClickSound();
    });

    document.addEventListener('mouseup', () => {
      cursor.classList.remove('clicking');
    });

    function createBloodSpray(x, y) {
      const spray = document.createElement('div');
      spray.className = 'blood-spray';
      spray.style.left = x + 'px';
      spray.style.top = y + 'px';
      
      for (let i = 0; i < 8; i++) {
        const particle = document.createElement('div');
        particle.className = 'blood-particle';
        
        // Bias the spray towards the bottom (underneath)
        const baseAngle = Math.PI * 0.3; // Start from bottom-left
        const angleRange = Math.PI * 1.4; // Cover bottom arc
        const angle = baseAngle + (i / 8) * angleRange;
        
        const distance = 20 + Math.random() * 30;
        const size = 3 + Math.random() * 4;
        
        particle.style.left = Math.cos(angle) * distance + 'px';
        particle.style.top = Math.sin(angle) * distance + 'px';
        particle.style.width = size + 'px';
        particle.style.height = size + 1 + 'px';
        
        // Add ember effect
        if (Math.random() > 0.7) {
          particle.style.boxShadow = '0 0 4px rgba(255, 100, 0, 0.8)';
        }
        
        spray.appendChild(particle);
      }
      
      document.body.appendChild(spray);
      
      setTimeout(() => {
        spray.remove();
      }, 1200);
    }

    function createPentagram(x, y) {
      const pentagram = document.createElement('div');
      pentagram.className = 'pentagram';
      pentagram.style.left = (x - 15) + 'px';
      pentagram.style.top = (y - 15) + 'px';
      
      pentagram.innerHTML = `
        <svg viewBox="0 0 100 100">
          <path d="M50 5 L61 35 L95 35 L68 57 L79 87 L50 65 L21 87 L32 57 L5 35 L39 35 Z" 
                fill="none" 
                stroke="#8b0000" 
                stroke-width="3" 
                opacity="0.8"/>
          <circle cx="50" cy="50" r="3" fill="#8b0000" opacity="0.6"/>
        </svg>
      `;
      
      document.body.appendChild(pentagram);
      
      setTimeout(() => {
        pentagram.remove();
      }, 1000);
    }

    function createBloodDrips(x, y) {
      for (let i = 0; i < 4; i++) {
        setTimeout(() => {
          const drip = document.createElement('div');
          drip.className = 'blood-drip';
          // Position drips slightly below and around the click point
          drip.style.left = (x + (Math.random() - 0.5) * 15) + 'px';
          drip.style.top = (y + 5 + Math.random() * 10) + 'px';
          
          document.body.appendChild(drip);
          
          setTimeout(() => {
            drip.remove();
          }, 2000);
        }, i * 80);
      }
    }

    // Sound effects for demonic cursor
    let clickSound;
    
    // Load the sound file
    function loadClickSound() {
      clickSound = new Audio('mixkit-hard-typewriter-click-1119.wav'); // Your typewriter sound
      clickSound.volume = 0.3; // Adjust volume (0.0 to 1.0)
      clickSound.preload = 'auto'; // Preload the audio
    }
    
    function playClickSound() {
      if (clickSound) {
        // Reset the audio to the beginning and play
        clickSound.currentTime = 0;
        clickSound.play().catch(e => {
          // Handle any playback errors silently
          console.log('Audio playback prevented by browser');
        });
      }
    }
    
    // Load the sound when the page loads
    loadClickSound();

    // Start cursor animation
    console.log(' Initializing custom cursor system...');
    console.log('Cursor element:', cursor);
    console.log('Cursor element display:', cursor ? window.getComputedStyle(cursor).display : 'null');
    console.log('Cursor element visibility:', cursor ? window.getComputedStyle(cursor).visibility : 'null');
    updateCursor();

    // Enforce skeletal cursor globally, overriding any element-specific cursors (including pseudo-elements)
    (function enforceSkeletalCursor() {
      try {
        if (!document.body.id) {
          document.body.id = 'app-root';
        }
        let styleEl = document.getElementById('forceCursorNone');
        if (!styleEl) {
          styleEl = document.createElement('style');
          styleEl.id = 'forceCursorNone';
          document.head.appendChild(styleEl);
        }
        styleEl.textContent = `
#app-root, #app-root * { cursor: none !important; }
#app-root input[type="range"],
#app-root input[type="range"]:hover,
#app-root input[type="range"]:active,
#app-root input[type="range"]:focus,
#app-root input[type="range"]::-webkit-slider-thumb,
#app-root input[type="range"]::-webkit-slider-thumb:hover,
#app-root input[type="range"]::-webkit-slider-thumb:active,
#app-root input[type="range"]::-moz-range-thumb,
#app-root input[type="range"]::-moz-range-thumb:hover,
#app-root input[type="range"]::-moz-range-thumb:active,
#app-root input[type="range"]::-webkit-slider-runnable-track,
#app-root input[type="range"]::-webkit-slider-runnable-track:hover,
#app-root input[type="range"]::-webkit-slider-runnable-track:active,
#app-root input[type="range"]::-moz-range-track,
#app-root input[type="range"]::-moz-range-track:hover,
#app-root input[type="range"]::-moz-range-track:active { cursor: none !important; }
        `;
      } catch (e) { console.warn('Failed to enforce skeletal cursor', e); }
    })();

    // Hide default cursor
    document.addEventListener('mouseenter', () => {
      // Default hide; screen logic below can override
      document.body.style.cursor = 'none';
    });
    
    // Enhanced game data storage
    let gameData = {
      customUnits: [],
      savedArmies: [],
      settings: {},
      stats: {},
      currentArmy: [],
      selectedUnits: [], // For unit creator selection
      selectedArmies: { // Multi-army selection for battle
        player1: [],
        player2: []
      }
    };
    
    // Army Builder state
    let currentUnitTab = 'regular';
    
      // Music System Variables
  let currentMusic = null;
  let musicVolume = 0.5; // Default volume 50%
  let currentTrackIndex = 0;
  let isMusicLooping = false;
  let dropdownInitialized = false; // Global flag for dropdown initialization
  
  // Music tracks configuration (only tracks that exist)
  const musicTracks = {
    'none': null,
    'the-devil': 'SpotiDownloader.com - The Devil - Peter Gundry.mp3',
    'girei': 'SpotiDownloader.com - Girei - Lorenzo Ferrara.mp3',
    'libera-me': 'SpotiDownloader.com - Libera Me - Johan Sderqvist.mp3',
    'lucifers-hymn': 'SpotiDownloader.com - Lucifer\'s Hymn - Peter Gundry.mp3',
    'night-of-the-wolf': 'SpotiDownloader.com - Night of the Wolf - Nox Arcana.mp3'
  };
  
  // Array of track IDs in order for looping
  const trackOrder = ['the-devil', 'girei', 'libera-me', 'lucifers-hymn', 'night-of-the-wolf'];
  

    
    let gameConfig = {
      player1: { name: 'Red Commander', color: '#DC143C', role: 'attacker' },
      player2: { name: 'Blue Commander', color: '#4169E1', role: 'defender' },
      opponentType: 'human',
      aiCommandPoints: 4,
      zoneCount: 6,
      winCondition: 'dominance',
      startingCP: 3,
      terrainType: 'random',
      gridSize: 8
    };
    
    // Helper function to convert hex colors to RGB for CSS variables
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '220, 20, 60';
    }
    
    // Function to update player color CSS variables
    function updatePlayerColorCSS() {
      console.log(' [COLOR DEBUG] updatePlayerColorCSS called');
      console.log(' [COLOR DEBUG] gameState.currentPlayer:', gameState.currentPlayer);
      console.log(' [COLOR DEBUG] gameConfig.player1.color:', gameConfig.player1.color);
      console.log(' [COLOR DEBUG] gameConfig.player2.color:', gameConfig.player2.color);
      
      const currentPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player1.color : gameConfig.player2.color;
      const enemyPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player2.color : gameConfig.player1.color;
      
      console.log(' [COLOR DEBUG] currentPlayerColor:', currentPlayerColor);
      console.log(' [COLOR DEBUG] enemyPlayerColor:', enemyPlayerColor);
      
      // Update root CSS variables
      document.documentElement.style.setProperty('--player-color', currentPlayerColor);
      document.documentElement.style.setProperty('--enemy-color', enemyPlayerColor);
      document.documentElement.style.setProperty('--player-color-rgb', hexToRgb(currentPlayerColor));
      document.documentElement.style.setProperty('--enemy-color-rgb', hexToRgb(enemyPlayerColor));
      
      console.log(' [COLOR DEBUG] CSS variables set:');
      console.log(' [COLOR DEBUG] --player-color:', getComputedStyle(document.documentElement).getPropertyValue('--player-color'));
      console.log(' [COLOR DEBUG] --enemy-color:', getComputedStyle(document.documentElement).getPropertyValue('--enemy-color'));
      console.log(' [COLOR DEBUG] --player-color-rgb:', getComputedStyle(document.documentElement).getPropertyValue('--player-color-rgb'));
      console.log(' [COLOR DEBUG] --enemy-color-rgb:', getComputedStyle(document.documentElement).getPropertyValue('--enemy-color-rgb'));
      
      // Update deployment zone colors
      const deploymentZones = document.querySelectorAll('.mini-zone.deployment-zone');
      console.log(' [COLOR DEBUG] Found deployment zones:', deploymentZones.length);
      deploymentZones.forEach((zone, index) => {
        const rgb = hexToRgb(currentPlayerColor);
        zone.style.background = `rgba(${rgb}, 0.5)`;
        zone.style.boxShadow = `0 0 25px rgba(${rgb}, 0.8), 0 0 40px rgba(${rgb}, 0.4)`;
        console.log(` [COLOR DEBUG] Updated deployment zone ${index} with color:`, currentPlayerColor, 'RGB:', rgb);
      });
      
      // Update attacker zone colors
      const attackerZones = document.querySelectorAll('.mini-zone.attacker-zone');
      console.log(' [COLOR DEBUG] Found attacker zones:', attackerZones.length);
      attackerZones.forEach((zone, index) => {
        const rgb = hexToRgb(currentPlayerColor);
        zone.style.background = `rgba(${rgb}, 0.4)`;
        zone.style.boxShadow = `0 0 25px rgba(${rgb}, 0.8), 0 0 40px rgba(${rgb}, 0.4)`;
        console.log(` [COLOR DEBUG] Updated attacker zone ${index} with color:`, currentPlayerColor, 'RGB:', rgb);
      });
      
      // Update defender zone colors
      const defenderZones = document.querySelectorAll('.mini-zone.defender-zone');
      console.log(' [COLOR DEBUG] Found defender zones:', defenderZones.length);
      defenderZones.forEach((zone, index) => {
        const rgb = hexToRgb(enemyPlayerColor);
        zone.style.background = `rgba(${rgb}, 0.4)`;
        zone.style.boxShadow = `0 0 25px rgba(${rgb}, 0.8), 0 0 40px rgba(${rgb}, 0.4)`;
        console.log(` [COLOR DEBUG] Updated defender zone ${index} with color:`, enemyPlayerColor, 'RGB:', rgb);
      });
      
      console.log(' [COLOR DEBUG] updatePlayerColorCSS completed');
    }
    
    let gameState = {
      currentPlayer: 'red',
      commandPoints: { red: 3, blue: 3 },
      buildPoints: { red: 10, blue: 10 }, // Initialize with default build points
      selectedDice: { attack: 0, defend: 0, morale: 0 },
      turnCount: 0,
      diceAugmented: false,
      currentZone: null,
      gamePhase: 'selection',
      lockedZones: { red: [], blue: [] },
      currentZonePhase: 'defense',
      selectedUnit: null,
      deploymentMode: 'place',
      deployedUnits: { red: [], blue: [] },
      zoneRoles: {},
      unitActions: {},
      zoneNames: {},
      movementMode: {
        active: false,
        selectedUnit: null,
        movementPoints: 0,
        validPositions: []
      },
      // AI system state
      aiState: {
        isAITurn: false,
        aiPlayer: null, // 'red' or 'blue' - which player is AI
        aiThinking: false,
        aiDifficulty: 4 // Default AI CP
      },
      // Multi-army system tracking
      unitDeployments: {}, // Track individual unit deployments: unitId -> { zoneId, playerId, armyId }
      selectedArmyInZone: { // Track which army is currently selected in zone detail
        red: null,
        blue: null
      },
      armySelectionMode: false, // Whether we're in army selection phase in zone detail
      // Unit deployment tracking to prevent duplicates across zones
      deployedUnitInstances: {}, // Track deployed unit instances: unitInstanceId -> { zoneId, playerId, armyId, unitData }
      // CP system tracking
      cpCosts: {
        placeUnit: 1,
        moveUnit: 1,
        attack: 1,
        artilleryAttack: 2,
        embark: 1,
        disembark: 1,
        gas: 2
      },
      contestedZones: { red: [], blue: [] },
      controlledZones: { red: [], blue: [] },
      // Artillery system
      artillery: {
        red: [],
        blue: []
      },
      // Artillery selection state
      selectedArtillery: null,
      artilleryMode: false,
      // Artillery actions tracking
      artilleryActions: {},
      // Campaign tracking for summary screen
      campaignStats: {
        red: {
          unitsDeployed: 0,
          unitsLost: 0,
          unitsLostDetails: [], // Array of specific unit names lost
          zonesControlled: 0
        },
        blue: {
          unitsDeployed: 0,
          unitsLost: 0,
          unitsLostDetails: [], // Array of specific unit names lost
          zonesControlled: 0
        }
      },
      // Gas cloud system
      gasClouds: {}, // Format: { zoneId: { position: { player, turnsRemaining, deployedOnTurn } } }
      // Weather and Day/Night Cycle system
      weatherSystem: {
        dayNightCycle: 'day', // 'day' or 'night'
        weatherType: 'clear', // Current weather type
        currentWeather: 'clear', // Current actual weather (calculated from weather type)
        turnCount: 0 // Track turns for weather changes
      }
    };
    
    // Flag to prevent recursive updates in multiplayer
    let isUpdatingFromServer = false;
    
    // Weather and Day/Night Cycle Definitions
    const weatherTypes = {
      'clear': {
        name: 'Clear Skies',
        probabilities: { 'clear': 90, 'light-clouds': 10 }
      },
      'heavy-rain': {
        name: 'Heavy Rain',
        probabilities: { 'rain': 80, 'thunderstorm': 10, 'cloudy': 10 }
      },
      'monsoon': {
        name: 'Monsoon',
        probabilities: { 'heavy-rain': 80, 'clear': 20 }
      },
      'foggy': {
        name: 'Foggy',
        probabilities: { 'fog': 70, 'cloudy': 20, 'clear': 10 }
      },
      'light-snow': {
        name: 'Light Snowfall',
        probabilities: { 'snow': 70, 'overcast': 20, 'clear': 10 }
      },
      'blizzard': {
        name: 'Blizzard',
        probabilities: { 'blizzard': 60, 'snow': 20, 'clear': 20 }
      },
      'dust-storm': {
        name: 'Dust Storm',
        probabilities: { 'dust-storm': 60, 'windy': 30, 'clear': 10 }
      },
      'ash-storm': {
        name: 'Ash Storm',
        probabilities: { 'ash-storm': 80, 'clear': 20 }
      },
      'tornado': {
        name: 'Tornado',
        probabilities: { 'tornado': 20, 'thunderstorm': 40, 'clear': 40 }
      }
    };
    
    const weatherEffects = {
      'clear': { attack: 0, defense: 0, movement: 0, range: 0 },
      'light-clouds': { attack: 0, defense: 0, movement: 0, range: 0 },
      'rain': { attack: 0, defense: 1, movement: 0, range: 0 },
      'thunderstorm': { attack: 0, defense: 1, movement: 0, range: -1 },
      'heavy-rain': { attack: 0, defense: 1, movement: 0, range: 0 },
      'fog': { attack: 0, defense: 0, movement: 0, range: -1 },
      'cloudy': { attack: 0, defense: 0, movement: 0, range: 0 }, // Bombers can't target
      'snow': { attack: 0, defense: 0, movement: -1, range: 0 },
      'overcast': { attack: 0, defense: 0, movement: 0, range: 0 }, // Fighters, Bombers, Airships can't act
      'blizzard': { attack: 0, defense: -1, movement: -1, range: 0 },
      'dust-storm': { attack: 0, defense: 0, movement: 0, range: 0 }, // Artillery can't fire
      'ash-storm': { attack: -1, defense: -1, movement: 0, range: 0 },
              'windy': { attack: 1, defense: 0, movement: 0, range: 0 },
      'tornado': { attack: 0, defense: -2, movement: 0, range: 0 }
    };
    
    const dayNightEffects = {
      'day': { attack: 0, defense: 0, movement: 0, range: 0 },
      'night': { attack: 0, defense: -1, movement: 0, range: 0 }
    };
    
    // Weather and Day/Night Cycle Functions
    function calculateWeather() {
      const weatherType = gameState.weatherSystem.weatherType;
      const probabilities = weatherTypes[weatherType].probabilities;
      
      console.log('[WEATHER CALC] Calculating weather for type:', weatherType);
      console.log('[WEATHER CALC] Probabilities:', probabilities);
      
      const random = Math.random() * 100;
      let cumulative = 0;
      
      for (const [weather, probability] of Object.entries(probabilities)) {
        cumulative += probability;
        if (random <= cumulative) {
          console.log('[WEATHER CALC] Random:', random, 'Selected weather:', weather);
          return weather;
        }
      }
      
              console.log('[WEATHER CALC] Fallback to clear weather');
      return 'clear'; // Fallback
    }
    
    function updateWeatherForTurn() {
      const oldDayNight = gameState.weatherSystem.dayNightCycle;
      const oldWeather = gameState.weatherSystem.currentWeather;
      
      gameState.weatherSystem.turnCount++;
      
      // Toggle day/night cycle
      gameState.weatherSystem.dayNightCycle = gameState.weatherSystem.dayNightCycle === 'day' ? 'night' : 'day';
      
      // Calculate new weather based on current weather type
      gameState.weatherSystem.currentWeather = calculateWeather();
      
              console.log('[WEATHER] Turn', gameState.weatherSystem.turnCount);
        console.log('[WEATHER] Day/Night changed from', oldDayNight, 'to', gameState.weatherSystem.dayNightCycle);
        console.log('[WEATHER] Weather changed from', oldWeather, 'to', gameState.weatherSystem.currentWeather);
      
      // Log current weather state for debugging
              console.log('[WEATHER STATE] Current state:', {
        dayNightCycle: gameState.weatherSystem.dayNightCycle,
        weatherType: gameState.weatherSystem.weatherType,
        currentWeather: gameState.weatherSystem.currentWeather,
        turnCount: gameState.weatherSystem.turnCount
      });
    }
    
    function getWeatherEffects() {
      const currentWeather = gameState.weatherSystem.currentWeather;
      const dayNightCycle = gameState.weatherSystem.dayNightCycle;
      
      const weatherEffect = weatherEffects[currentWeather] || { attack: 0, defense: 0, movement: 0, range: 0 };
      const dayNightEffect = dayNightEffects[dayNightCycle] || { attack: 0, defense: 0, movement: 0, range: 0 };
      
      const totalEffects = {
        attack: weatherEffect.attack + dayNightEffect.attack,
        defense: weatherEffect.defense + dayNightEffect.defense,
        movement: weatherEffect.movement + dayNightEffect.movement,
        range: weatherEffect.range + dayNightEffect.range
      };
      
              console.log('[WEATHER EFFECTS] Current weather:', currentWeather, 'Day/Night:', dayNightCycle);
        console.log('[WEATHER EFFECTS] Weather effect:', weatherEffect);
        console.log('[WEATHER EFFECTS] Day/Night effect:', dayNightEffect);
        console.log('[WEATHER EFFECTS] Total effects:', totalEffects);
      
      return totalEffects;
    }
    
    function applyWeatherRestrictions(unit, action) {
      const currentWeather = gameState.weatherSystem.currentWeather;
      
              console.log('[WEATHER RESTRICTIONS] Checking restrictions for:', unit.name, 'Type:', unit.type, 'Action:', action, 'Current weather:', currentWeather);
      
      // Artillery restrictions
      if (currentWeather === 'dust-storm' && unit.type === 'artillery') {
                    console.log('[WEATHER RESTRICTIONS] Artillery blocked by dust storm!');
        return false; // Artillery can't fire in dust storm
      }
      
      // Aerial restrictions
      if (currentWeather === 'overcast' && ['fighter', 'bomber', 'airship'].includes(unit.type)) {
                    console.log('[WEATHER RESTRICTIONS] Aerial unit blocked by overcast!');
        return false; // Aerial units can't act in overcast
      }
      
      // Bomber targeting restrictions
      if (currentWeather === 'cloudy' && unit.type === 'bomber') {
                    console.log('[WEATHER RESTRICTIONS] Bomber blocked by cloudy weather!');
        return false; // Bombers can't target in cloudy weather
      }
      
              console.log('[WEATHER RESTRICTIONS] No restrictions applied');
      return true; // No restrictions
    }
    
    function updateWeatherDisplay() {
      // This function is now deprecated since we removed the weather display from zone battle screen
      // The weather information is now shown in the unit tooltips instead
              console.log('[WEATHER DISPLAY] Weather display update called (deprecated - weather now shown in tooltips)');
    }
    
    function updateGameWeatherDisplay() {
      const dayNightElement = document.getElementById('game-weather-day-night');
      const weatherElement = document.getElementById('game-weather-current');
      
              console.log('[GAME WEATHER DISPLAY] Updating game weather display elements:', {
        dayNightElement: !!dayNightElement,
        weatherElement: !!weatherElement
      });
      
      if (dayNightElement) {
        const dayNightText = gameState.weatherSystem.dayNightCycle.charAt(0).toUpperCase() + gameState.weatherSystem.dayNightCycle.slice(1);
        dayNightElement.textContent = dayNightText;
        console.log('[GAME WEATHER DISPLAY] Updated game day/night display to:', dayNightText);
      }
      
      if (weatherElement) {
        const currentWeather = gameState.weatherSystem.currentWeather;
        let weatherName = 'Unknown';
        
        // Map current weather to display names
        const weatherDisplayNames = {
          'clear': 'Clear Skies',
          'light-clouds': 'Light Clouds',
          'rain': 'Rain',
          'thunderstorm': 'Thunderstorm',
          'heavy-rain': 'Heavy Rain',
          'fog': 'Fog',
          'cloudy': 'Cloudy',
          'snow': 'Snow',
          'overcast': 'Overcast',
          'blizzard': 'Blizzard',
          'dust-storm': 'Dust Storm',
          'ash-storm': 'Ash Storm',
          'windy': 'Windy',
          'tornado': 'Tornado'
        };
        
        weatherName = weatherDisplayNames[currentWeather] || currentWeather;
        weatherElement.textContent = weatherName;
        console.log('[GAME WEATHER DISPLAY] Updated game weather display to:', weatherName);
      }
    }
    
    // Construction System Data
    const constructionOptions = {
      trenches: {
        name: 'Trenches',
        cost: 2,
        duration: 2,
        description: '+2 Defense for Infantry/Support/Field Guns',
        icon: '',
        effects: { defense: 2 },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'jungle', 'ruins', 'infrastructure', 'road']
      },
      sandbags: {
        name: 'Sandbags',
        cost: 1,
        duration: 1,
        description: '+1 Defense',
        icon: '',
        effects: { defense: 1 },
        restrictedTerrain: ['mountain', 'river']
      },
      bunker: {
        name: 'Bunker',
        cost: 5,
        duration: 3,
        description: 'Immune to Artillery, Bomber, and Airship attacks',
        icon: '',
        effects: { artilleryImmune: true, bomberImmune: true, airshipImmune: true },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'jungle', 'ruins', 'infrastructure', 'road']
      },
      barbedWire: {
        name: 'Barbed Wire',
        cost: 1,
        duration: 1,
        description: 'Stops Infantry/Support/Field Guns',
        icon: '',
        effects: { movementBlock: true },
        restrictedTerrain: ['river', 'mountain', 'road']
      },
      minefield: {
        name: 'Minefield',
        cost: 2,
        duration: 1,
        description: 'Hidden, deals D6 damage when stepped on',
        icon: '',
        effects: { hidden: true, damage: 'D6' },
        restrictedTerrain: ['mountain', 'swamp', 'river']
      },
      tankTrap: {
        name: 'Tank Trap',
        cost: 3,
        duration: 2,
        description: 'Stops armored/vehicles',
        icon: '',
        effects: { vehicleBlock: true },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'jungle', 'ruins', 'infrastructure']
      },
      bridge: {
        name: 'Bridge',
        cost: 3,
        duration: 2,
        description: 'Removes river movement penalty',
        icon: '',
        effects: { riverCrossing: true },
        placement: 'river'
      },
      road: {
        name: 'Road',
        cost: 2,
        duration: 2,
        description: '+1 Movement while on this tile. -1 To Defense For Units On This Tile.',
        icon: '',
        effects: { movementBonus: 1 },
        restrictedTerrain: ['river', 'mountain', 'swamp', 'jungle']
      },
      snipersNest: {
        name: 'Snipers Nest',
        cost: 4,
        duration: 2,
        description: '+1 Range for Infantry. Can also fire over other units',
        icon: '',
        effects: { range: 1, lineOfSight: true },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      mortarPit: {
        name: 'Mortar Pit',
        cost: 6,
        duration: 3,
        description: '+2 Attack for Field Guns',
        icon: '',
        effects: { fieldGunAttack: 2 },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      barricade: {
        name: 'Barricade',
        cost: 2,
        duration: 1,
        description: '+2 Defense for units in ruins/infrastructure',
        icon: '',
        effects: { barricadeDefense: 2 },
        placement: 'ruins_infrastructure'
      },
      machineGunNest: {
        name: 'Machine Gun Nest',
        cost: 5,
        duration: 3,
        description: '+2 Attack for Infantry',
        icon: '',
        effects: { infantryAttack: 2 },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      antiTankPit: {
        name: 'Anti Tank Pit',
        cost: 5,
        duration: 3,
        description: '+4 Attack for Field Guns vs Armoured Units',
        icon: '',
        effects: { antiTankAttack: 4 },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      observationPost: {
        name: 'Observation Post',
        cost: 3,
        duration: 2,
        description: '+2 Range for artillery',
        icon: '',
        effects: { artilleryRange: 2 },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      supplyDepot: {
        name: 'Supply Depot',
        cost: 4,
        duration: 2,
        description: 'Heals adjacent units +1 HP/turn',
        icon: '',
        effects: { healing: 1 },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      commandCenter: {
        name: 'Command Center',
        cost: 8,
        duration: 4,
        description: '+1 Command Points, +1 Morale',
        icon: '',
        effects: { commandPoints: 1, morale: 1 },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      antiAirBattery: {
        name: 'Anti-Air Battery',
        cost: 6,
        duration: 3,
        description: 'Can attack aerial units',
        icon: '',
        effects: { antiAir: true },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      },
      radarStation: {
        name: 'Radar Station',
        cost: 5,
        duration: 3,
        description: 'Reveals hidden units',
        icon: '',
        effects: { detection: true },
        restrictedTerrain: ['mountain', 'river', 'swamp', 'road']
      }
    };
    
    // Enhanced terrain effects
    const terrainEffects = {
      plains: { 
        moveDelay: 1, 
        defenseBonus: 0, 
        description: 'Open ground with no special effects',
        color: '#556B2F'
      },
      forest: { 
        moveDelay: 2, 
        defenseBonus: 1, 
        description: '+1 Defense',
        color: '#006400',
        restrictedUnits: ['vehicle', 'tank']
      },
      river: { 
        moveDelay: 2, 
        defenseBonus: 0, 
        description: 'Slows movement and blocks further advancement unless unit has Amphibious ability or crosses via Bridge',
        color: '#4169E1',
        restrictedUnits: ['tank', 'vehicle', 'field_gun']
      },
      hills: { 
        moveDelay: 2, 
        defenseBonus: 1, 
        description: '+1 Defense, can see over other units',
        color: '#654321'
      },
      mountains: { 
        moveDelay: 999, 
        defenseBonus: 2, 
        description: 'Impassable to all units, +2 Defense, can see over other units',
        color: '#2F4F4F'
      },
      swamp: { 
        moveDelay: 3, 
        defenseBonus: 0, 
        attackBonus: -1,
        description: 'Slow movement (2 extra turns), -1 to attack rolls',
        color: '#006400',
        restrictedUnits: ['vehicle', 'tank', 'field_gun']
      },
      jungle: { 
        moveDelay: 3, 
        defenseBonus: 2, 
        attackBonus: -1,
        description: '+2 Defense, -1 Attack, slow movement',
        color: '#32CD32',
        restrictedUnits: ['vehicle', 'tank']
      },
      desert: { 
        moveDelay: 2, 
        defenseBonus: -1, 
        description: 'Slowed movement (1 extra turn), -1 Defense',
        color: '#D2B48C'
      },
      ruins: { 
        moveDelay: 2, 
        defenseBonus: 1, 
        attackBonus: 1,
        description: '+1 Defense, +1 Attack',
        color: '#A0A0A0'
      },
      road: { 
        moveDelay: 1, 
        defenseBonus: -1, 
        movementBonus: 1,
        description: '+1 Movement while on this tile. -1 To Defense For Units On This Tile.',
        color: '#696969'
      },
      infrastructure: { 
        moveDelay: 1, 
        defenseBonus: 1, 
        movementBonus: 1,
        description: 'Faster movement, +1 Defense',
        color: '#404040',
        restrictedUnits: ['tank', 'vehicle']
      },

      snow: { 
        moveDelay: 2, 
        defenseBonus: -1, 
        movementPenalty: -1,
        vehicleMovementPenalty: -2,
        description: 'Slowed movement, -1 Defense, -1 Movement (-2 for Vehicles)',
        color: '#E6F3FF'
      },
      volcanic: { 
        moveDelay: 2, 
        defenseBonus: 0, 
        damagePerTurn: 1, 
        description: 'Damages units for 1 HP per turn when standing on it',
        color: '#8B0000'
      },
      beach: { 
        moveDelay: 2, 
        defenseBonus: -2, 
        description: 'Units cannot move for 2 complete rounds after landing on beach (Amphibious units are exempt), -2 Defense',
        color: '#DEB887'
      }
    };
    
    // Terrain distribution system
    const terrainDistributions = {
      plains: {
        plains: 100
      },
      forest: {
        forest: 100
      },
      desert: {
        desert: 100
      },
      ruins: {
        forest: 90,
        ruins: 10
      },
      snow: {
        snow: 100
      },
      mountainous: {
        plains: 90,
        mountains: 10
      },
      hilly: {
        plains: 100
      },
      town: {
        infrastructure: 35,
        plains: 25,
        forest: 25
      },
      swamp: {
        swamp: 100
      },
      jungle: {
        jungle: 100
      },
      volcanic: {
        volcanic: 90,
        plains: 10
      },
        urban: {
          plains: 100
        },
        naval: {
          plains: 100
      },
      random: {
        plains: 20,
        forest: 15,
        hills: 12,
        mountains: 8,
        swamp: 8,
        desert: 8,
        ruins: 8,
        infrastructure: 5,
        volcanic: 5,
        snow: 3
      }
    };
    
    // Enhanced default units with comprehensive overhaul
    const defaultUnits = [
      //  Infantry Units
      { name: 'Mountaineers', type: 'infantry', attack: 1, defense: 1, morale: 4, range: 1, movement: 2, special: 'those_who_dare', description: 'Can traverse Mountain tiles and gains +1 Range and +1 Defense while on them.' },
      { name: 'Light Infantry', type: 'infantry', attack: 0, defense: 0, morale: 4, range: 1, movement: 3, special: 'stealth', description: 'Stays hidden on Forest, Swamp, Jungle tiles until they attack.' },
              { name: 'Infantry', type: 'infantry', attack: 0, defense: 1, morale: 4, range: 1, movement: 2, special: 'fortified', description: 'Gains +1 Defense on Construction Tiles.' },
      { name: 'Marines', type: 'infantry', attack: 1, defense: 1, morale: 5, range: 1, movement: 2, special: 'amphibious', description: 'Ignores River & Coastal Penalties, gains +1 Attack on Naval Landing Zones. Has "Shock Landing" ability.' },
      { name: 'Elite Infantry', type: 'infantry', attack: 2, defense: 1, morale: 5, range: 1, movement: 2, special: 'veteran', description: 'Gains +1 Attack when targeting enemies on Construction Tiles. Cannot be suppressed.' },
              { name: 'Dragoons', type: 'cavalry', attack: 1, defense: 0, morale: 4, range: 1, movement: 3, special: 'charge', description: '+2 Attack when attacking Infantry at range 1.' },
      
      //  Support Units
      { name: 'Medic', type: 'support', attack: -1, defense: 0, morale: 4, range: 1, movement: 2, special: 'healer', description: 'Can heal adjacent units by 1 HP per turn.' },
      { name: 'Mechanist', type: 'support', attack: 0, defense: 1, morale: 4, range: 1, movement: 2, special: 'mechanic', description: 'Restores +1 Armor per turn to adjacent units with armor.' },
      { name: 'Engineers', type: 'support', attack: 0, defense: 1, morale: 4, range: 1, movement: 2, special: 'sapper', description: 'Can construct fortifications and disable enemy barbed wire, mines, and traps.' },
      { name: 'Globadiers', type: 'support', attack: 1, defense: 0, morale: 4, range: 2, movement: 2, special: 'chemical_warfare', description: 'Deploy gas clouds that damage units entering the area.' },
      
      //  Vehicle Units
      { name: 'Armoured Vehicle', type: 'vehicle', attack: 1, defense: 2, morale: 3, range: 1, movement: 3, armour: 3, special: 'mobile_cover', description: 'Gains +2 Movement while on Roads. Grants +1 Defense aura to adjacent infantry.' },
      { name: 'Transport', type: 'vehicle', attack: 0, defense: 1, morale: 3, range: 0, movement: 4, armour: 2, special: 'carrier', description: 'Moves units long distances quickly. If destroyed while carrying troops, they die instantly.' },
      
      //  Tank Units
      { name: 'Light Tank', type: 'tank', attack: 2, defense: 2, morale: 3, range: 1, movement: 3, armour: 4, special: 'all_terrain', description: '+1 Movement while on Roads. Can enter Swamp and Jungle tiles but takes 1 damage when doing so.' },
      { name: 'Medium Tank', type: 'tank', attack: 3, defense: 3, morale: 3, range: 1, movement: 2, armour: 6, special: 'siege_mode', description: 'When stationary for 1 turn, gains +1 Attack next turn (like a "Siege Mode").' },
      { name: 'Heavy Tank', type: 'tank', attack: 4, defense: 4, morale: 2, range: 1, movement: 1, armour: 8, special: 'trample', description: 'High HP & Defense. Ignores Barbed Wires, Mines, and Tank Traps when moving.' },
      
      //  Mech Units
      { name: 'Light Mech', type: 'mech', attack: 2, defense: 1, morale: 4, range: 1, movement: 3, armour: 3, special: 'fear_pulse', description: 'Fast. Gains +2 Defense against Tanks, Artillery, and Bombers.' },
      { name: 'Medium Mech', type: 'mech', attack: 3, defense: 2, morale: 3, range: 1, movement: 2, armour: 5, special: 'mode_switch', description: 'Gains +1 Attack for each adjacent friendly Mech unit.' },
      { name: 'Heavy Mech', type: 'mech', attack: 4, defense: 3, morale: 2, range: 1, movement: 1, armour: 7, special: 'life_steal', description: 'Gains +2 Armor when attacking units with armor. Immune to Suppression, Artillery, and Bombers.' },
      
      //  Field Gun Units
      { name: 'Light Field Gun', type: 'field_gun', attack: 2, defense: 1, morale: 4, range: 3, movement: 2, special: 'mobile_fire', description: '+2 to attack rolls firing at any unit on a construction tile.' },
              { name: 'Medium Field Gun', type: 'field_gun', attack: 3, defense: 1, morale: 4, range: 4, movement: 1, special: 'fortified', description: 'Gains +1 Defense on Construction Tiles.' },
      { name: 'Anti-Air', type: 'field_gun', attack: 2, defense: 1, morale: 4, range: 3, movement: 1, special: 'air_defense', description: 'Can only attack air units (fighters and bombers).' },
      { name: 'Anti-Tank', type: 'field_gun', attack: 2, defense: 1, morale: 4, range: 3, movement: 1, special: 'armour_penetrating', description: '+3 To Attack Rolls Against Armoured Units' },
      
      //  Artillery Units
      { name: 'Grand Battery', type: 'artillery', attack: 4, defense: 1, morale: 3, range: 5, movement: 1, special: 'precision', description: 'Longest range. Gains +1 to hit chance for each consecutive attack on the same target. Resets when changing targets.' },
      
      //  Fighter Units
      { name: 'Fighter', type: 'fighter', attack: 3, defense: 1, morale: 4, range: 2, movement: 4, special: 'air_superiority', description: 'Engages enemy aircraft. High mobility and air combat bonuses.' },
      
      //  Bomber Units
      { name: 'Bomber', type: 'bomber', attack: 4, defense: 0, morale: 3, range: 1, movement: 3, special: 'terror_in_skys', description: 'Specialized in terrorizing infantry and support units on open plains.' },

      //  Airship Units
      { name: 'Airship', type: 'airship', attack: 3, defense: 2, morale: 3, range: 2, movement: 2, armour: 4, special: 'the_hub_in_the_sky', description: 'Can attack both air and ground units, provides +1 attack bonus to all friendly fighters while alive.' }
    ];
    
    // Helper function to count fighters for each player
    function countFightersByPlayer() {
      console.log(` [FIGHTER COUNT DEBUG] Checking aerial units for fighters...`);
      
      let player1Fighters = 0;
      let player2Fighters = 0;
      
      // Count fighters from aerial system
      if (gameState && gameState.aerial) {
        // Count red player fighters (Player 1)
        if (gameState.aerial.red && Array.isArray(gameState.aerial.red)) {
          const redFighters = gameState.aerial.red.filter(unit => unit.type === 'fighter' && unit.health > 0);
          player1Fighters = redFighters.length;
          console.log(` [FIGHTER COUNT DEBUG] Red player (Player 1) has ${player1Fighters} fighters:`, redFighters.map(f => f.name));
        } else {
          console.log(` [FIGHTER COUNT DEBUG] Red player has no aerial units or invalid data`);
        }
        
        // Count blue player fighters (Player 2)
        if (gameState.aerial.blue && Array.isArray(gameState.aerial.blue)) {
          const blueFighters = gameState.aerial.blue.filter(unit => unit.type === 'fighter' && unit.health > 0);
          player2Fighters = blueFighters.length;
          console.log(` [FIGHTER COUNT DEBUG] Blue player (Player 2) has ${player2Fighters} fighters:`, blueFighters.map(f => f.name));
        } else {
          console.log(` [FIGHTER COUNT DEBUG] Blue player has no aerial units or invalid data`);
        }
      } else {
        console.log(` [FIGHTER COUNT DEBUG] No gameState.aerial data available`);
      }
      
      console.log(` [FIGHTER COUNT DEBUG] Final count: Player 1 = ${player1Fighters}, Player 2 = ${player2Fighters}`);
      return { player1: player1Fighters, player2: player2Fighters };
    }
    
    // Special Ability System
    const specialAbilities = {
      // Infantry Abilities
      those_who_dare: {
        name: 'Those Who Dare',
        description: 'Can traverse Mountain tiles and gains +1 Range and +1 Defense while on them.',
        apply: (unit, pos, gridData) => {
          // Check if unit is on a mountain tile
          if (gridData && (gridData.terrain === 'mountain' || gridData.terrain === 'mountains')) {
            console.log(` [MOUNTAIN] ${unit.name} gains +1 Range and +1 Defense from Those Who Dare on mountain tile`);
            return { 
              defenseBonus: 1,
              rangeBonus: 1,
              canTraverseMountains: true
            };
          }
          // Even when not on mountain, still allow traversing them
          return { canTraverseMountains: true };
        }
      },
      stealth: {
        name: 'Stealth',
        description: 'Stays hidden on Forest, Swamp, Jungle tiles until they attack.',
        apply: (unit, pos, gridData) => {
          if (gridData && gridData.terrain) {
            const terrain = gridData.terrain;
            if (['forest', 'swamp', 'jungle'].includes(terrain) && !unit.hasAttacked && !unit.permanentlyUnhidden) {
              return { hidden: true };
            }
          }
          return {};
        }
      },
      
      fortified: {
        name: 'Fortified',
        description: 'Gains +1 Defense and +1 Range on Construction Tiles.',
        apply: (unit, pos, gridData) => {
          if (gridData && gridData.construction && gridData.construction.completed) {
            return { defenseBonus: 1, rangeBonus: 1 };
          }
          return {};
        }
      },
      
      amphibious: {
        name: 'Amphibious',
        description: 'Ignores River & Coastal Penalties, gains +2 Attack on River & Beach territories.',
        apply: (unit, pos, gridData) => {
          let bonuses = {};
          
          if (gridData && gridData.terrain) {
            const terrain = gridData.terrain;
            console.log(' [AMPHIBIOUS DEBUG] Unit:', unit.name, 'Terrain:', terrain);
            
            if (terrain === 'river' || terrain === 'beach') {
              bonuses.movementBonus = 1; // Ignore movement penalty
              bonuses.attackBonus = 2; // +2 Attack on river and beach territories
              console.log(' [AMPHIBIOUS DEBUG] Applied bonuses:', bonuses);
            }
          }
          
          return bonuses;
        }
      },
      
      veteran: {
        name: 'Veteran',
        description: 'Gains +1 Attack when targeting enemies on Construction Tiles. Ignores barbed wire.',
        apply: (unit, pos, gridData, targetPos, targetGridData) => {
          let bonuses = { ignoreBarbedWire: true };
          
          console.log(' [VETERAN DEBUG] Unit:', unit.name, 'Special:', unit.special);
          console.log(' [VETERAN DEBUG] Base bonuses:', bonuses);
          
          // Check if target is on a construction tile
          if (targetGridData && targetGridData.construction && targetGridData.construction.completed) {
            bonuses.attackBonus = 1;
            console.log(' [VETERAN DEBUG] Target on construction - added +1 attack');
          }
          
          console.log(' [VETERAN DEBUG] Final bonuses:', bonuses);
          return bonuses;
        }
      },
      
      charge: {
        name: 'Charge',
        description: '+2 Attack when attacking Infantry at range 1.',
        apply: (unit, pos, gridData, targetPos, targetGridData) => {
          console.log(` [CHARGE DEBUG] Evaluating charge for ${unit.name}`);
          console.log(` [CHARGE DEBUG] - pos: ${pos}, targetPos: ${targetPos}`);
          console.log(` [CHARGE DEBUG] - targetGridData exists: ${!!targetGridData}`);
          console.log(` [CHARGE DEBUG] - target unit exists: ${!!(targetGridData && targetGridData.unit)}`);
          console.log(` [CHARGE DEBUG] - target type: ${targetGridData && targetGridData.unit ? targetGridData.unit.type : 'none'}`);
          
          // Check if we're attacking Infantry at exactly range 1
          if (targetPos !== null && targetGridData && targetGridData.unit && targetGridData.unit.type === 'infantry') {
            const distance = calculateDistance(pos, targetPos);
            console.log(` [CHARGE DEBUG] - distance: ${distance}`);
            if (distance === 1) {
              console.log(` [CHARGE] ${unit.name} charges Infantry ${targetGridData.unit.name} at range 1, gaining +2 attack`);
              return { attackBonus: 2 };
            } else {
              console.log(` [CHARGE DEBUG] - Distance ${distance} is not 1, no charge bonus`);
            }
          } else {
            console.log(` [CHARGE DEBUG] - Target is not Infantry or missing data, no charge bonus`);
          }
          return {};
        }
      },
      
      // Support Abilities
      healer: {
        name: 'Healer',
        description: 'Can heal adjacent units by 1 HP per turn.',
        apply: (unit, pos, gridData) => {
          return { canHeal: true, healAmount: 1 };
        }
      },

      mechanic: {
        name: 'Mechanic',
        description: 'Restores +1 Armor per turn to adjacent units with armor.',
        apply: (unit, pos, gridData) => {
          return { canRepairArmor: true, armorRepairAmount: 1 };
        }
      },
      
      sapper: {
        name: 'Sapper',
        description: 'Can construct fortifications and disable enemy traps. Adjacent constructions build 1 turn faster.',
        apply: (unit, pos, gridData) => {
          return { canConstruct: true, canDisableTraps: true, constructionSpeedBonus: true };
        }
      },
      
      chemical_warfare: {
        name: 'Chemical Warfare',
        description: 'Deploy gas clouds in front, front-left, or front-right. Gas damages units entering (d6). Lasts 3 turns.',
        apply: (unit, pos, gridData) => {
          return { canDeployGas: true };
        }
      },
      
      // Vehicle Abilities
      mobile_cover: {
        name: 'Mobile Cover',
        description: 'Gains +2 Movement while on Roads. Grants +1 Defense aura to adjacent units.',
        apply: (unit, pos, gridData) => {
          let bonuses = { providesCover: true, coverBonus: 1 };
          
          // Check if on road terrain or road construction
          if (gridData) {
            const terrain = gridData.terrain;
            const hasRoadConstruction = gridData.construction && gridData.construction.completed && 
                                      gridData.construction.type === 'road';
            
            if (terrain === 'road' || hasRoadConstruction) {
              // Store the mobile cover road bonus on the unit for this turn only
              unit.mobileCoverRoadBonus = 2;
              console.log(' [MOBILE COVER DEBUG] +2 Movement bonus on road for', unit.name);
            }
          }
          
          return bonuses;
        }
      },
      
      carrier: {
        name: 'Carrier',
        description: 'Can transport Infantry units. If destroyed while carrying troops, they die instantly.',
        apply: (unit, pos, gridData) => {
          return { canTransport: true, transportCapacity: 2 };
        }
      },
      
      // Tank Abilities
      all_terrain: {
        name: 'All Terrain',
        description: 'Can enter Swamp, Jungle, and Forest tiles but takes 1 damage when entering them.',
        apply: (unit, pos, gridData) => {
          if (gridData && gridData.terrain) {
            const terrain = gridData.terrain;
            // Only take damage when entering these terrains, not when staying
            if ((terrain === 'swamp' || terrain === 'jungle' || terrain === 'forest') && unit.justMoved) {
              return { terrainDamage: 1 };
            }
          }
          return {};
        }
      },
      
      siege_mode: {
        name: 'Siege Mode',
        description: 'Gains +1 Attack on the next turn if this unit does not move this turn.',
        apply: (unit, pos, gridData) => {
          if (unit.turnsStationary >= 1) {
            return { attackBonus: 1 };
          }
          return {};
        }
      },
      
      trample: {
        name: 'Trample',
        description: 'Ignores Barbed Wires, Mines, and Tank Traps when moving.',
        apply: (unit, pos, gridData) => {
          return { ignoreBarbedWire: true, ignoreMines: true, ignoreTankTraps: true };
        }
      },
      
      // Mech Abilities
      fear_pulse: {
        name: 'Evasion',
        description: 'Gains +2 Defense against Tanks, Artillery, and Bombers.',
        apply: (unit, pos, gridData, attacker) => {
          // Check if attacker is a tank, artillery, or bomber
          if (attacker && (attacker.type === 'tank' || attacker.type === 'artillery' || attacker.type === 'bomber')) {
            return { defenseBonus: 2 };
          }
          return {};
        }
      },
      
      mode_switch: {
        name: 'Mech Assault',
        description: 'Gains +1 Attack for each adjacent Mech unit.',
        apply: (unit, pos, gridData) => {
          // Count adjacent Mech units
          let adjacentMechCount = 0;
          
          if (pos !== null && currentZoneDetail && currentZoneDetail.tacticalGrid) {
            const adjacentPositions = getAdjacentPositions(pos);
            
            adjacentPositions.forEach(adjPos => {
              const adjUnit = currentZoneDetail.tacticalGrid[adjPos].unit;
              if (adjUnit && adjUnit.type === 'mech' && adjUnit.player === unit.player) {
                adjacentMechCount++;
              }
            });
          }
          
          if (adjacentMechCount > 0) {
            return { attackBonus: adjacentMechCount };
          }
          return {};
        }
      },
      
      life_steal: {
        name: 'Salvage Systems',
        description: 'Gains +2 Armor when attacking units with armor. Immune to Suppression, Artillery, and Bombers.',
        apply: (unit, pos, gridData, attacker) => {
          return { immuneToSuppression: true, immuneToArtillery: true };
        }
      },
      
      // Artillery Abilities
      mobile_fire: {
        name: 'Defense Buster',
        description: '+2 to attack rolls firing at any unit on a construction tile.',
        apply: (unit, pos, gridData, targetPos, targetGridData) => {
          // Check if target is on a construction tile
          if (targetGridData && targetGridData.construction && targetGridData.construction.completed) {
            console.log(` [DEFENSE BUSTER] ${unit.name} gets +2 attack bonus vs unit on construction tile`);
            return { attackBonus: 2 };
          }
          return {};
        }
      },
      
      fortified: {
        name: 'Fortified',
        description: 'Gains +1 defense on Construction Tiles.',
        apply: (unit, pos, gridData) => {
          // Check if unit is on a construction tile
          if (gridData && gridData.construction && gridData.construction.completed) {
            console.log(`[FORTIFIED] ${unit.name} gets +1 defense bonus on construction tile`);
            return { defenseBonus: 1 };
          }
          return {};
        }
      },
      
      precision: {
        name: 'Precision',
        description: 'Gains +1 to hit chance for each consecutive attack on the same target. Resets when changing targets.',
        apply: (unit, pos, gridData, targetPos) => {
          if (unit.targetHistory && unit.targetHistory[targetPos] >= 2) {
            const bonus = Math.min(unit.targetHistory[targetPos] - 1, 3); // Cap at +3 bonus
            return { accuracyBonus: bonus };
          }
          return {};
        }
      },
      
      // Air Abilities
      the_hub_in_the_sky: {
        name: 'The Hub In The Sky',
        description: 'While this Airship is alive, all friendly Fighters gain +1 to attack rolls.',
        apply: (unit, pos, gridData, targetPos, targetGridData) => {
          // This ability provides a passive bonus to all friendly fighters
          // The bonus is applied in the aerial combat logic
          return { 
            providesFighterBonus: true
          };
        }
      },
      air_superiority: {
        name: 'Air Superiority',
        description: '+1 Attack For Every Fighter You Have Over Your Enemy',
        apply: (unit, pos, gridData, targetPos = null, targetGridData = null) => {
          console.log(` [AIR SUPERIORITY DEBUG] Checking for ${unit.name} (Player ${unit.player})`);
          
          const fighterCounts = countFightersByPlayer();
          console.log(` [AIR SUPERIORITY DEBUG] Fighter counts: Player 1 = ${fighterCounts.player1}, Player 2 = ${fighterCounts.player2}`);
          
          let attackBonus = 0;
          
          // Map player identifiers to the correct fighter counts
          if (unit.player === 'red') {
            attackBonus = Math.max(0, fighterCounts.player1 - fighterCounts.player2);
            console.log(` [AIR SUPERIORITY DEBUG] Red player calculation: Math.max(0, ${fighterCounts.player1} - ${fighterCounts.player2}) = ${attackBonus}`);
          } else if (unit.player === 'blue') {
            attackBonus = Math.max(0, fighterCounts.player2 - fighterCounts.player1);
            console.log(` [AIR SUPERIORITY DEBUG] Blue player calculation: Math.max(0, ${fighterCounts.player2} - ${fighterCounts.player1}) = ${attackBonus}`);
          } else {
            console.log(` [AIR SUPERIORITY DEBUG] Unknown player: ${unit.player}`);
          }
          
          console.log(` [AIR SUPERIORITY DEBUG] Final attack bonus: ${attackBonus}`);
          
          if (attackBonus > 0) {
            console.log(` [AIR SUPERIORITY] ${unit.name} (${unit.player}) gets +${attackBonus} attack bonus (${fighterCounts.player1} vs ${fighterCounts.player2} fighters)`);
          } else {
            console.log(` [AIR SUPERIORITY] ${unit.name} (${unit.player}) gets no bonus - equal or inferior fighter count`);
          }
          
          return { attackBonus: attackBonus, highMobility: true };
        }
      },
      
      terror_in_skys: {
        name: 'Terror In The Skys',
        description: '+2 To Attack Rolls Against Infantry and Support Units on Plains Terrain',
        apply: (unit, pos, gridData, targetPos, targetGridData) => {
          console.log(' [TERROR DEBUG] Checking Terror In The Skys ability:');
          console.log(' [TERROR DEBUG] Unit:', unit.name, 'type:', unit.type);
          console.log(' [TERROR DEBUG] Target data exists:', !!targetGridData);
          
          if (targetGridData) {
            console.log(' [TERROR DEBUG] Target unit exists:', !!targetGridData.unit);
            if (targetGridData.unit) {
              console.log(' [TERROR DEBUG] Target unit type:', targetGridData.unit.type);
              console.log(' [TERROR DEBUG] Target terrain:', targetGridData.terrain);
              console.log(' [TERROR DEBUG] Is eligible target:', 
                (targetGridData.unit.type === 'infantry' || targetGridData.unit.type === 'support'));
              console.log(' [TERROR DEBUG] Is plains terrain:', targetGridData.terrain === 'plains');
            }
          }

          // Check if target is infantry or support and on plains terrain
          if (targetGridData && targetGridData.unit && 
              (targetGridData.unit.type === 'infantry' || targetGridData.unit.type === 'support') &&
              targetGridData.terrain === 'plains') {
            console.log(' [TERROR DEBUG] Applying +2 attack bonus!');
            return { attackBonus: 2 };
          }
          console.log(' [TERROR DEBUG] Conditions not met, no bonus applied');
          return {};
        }
      },
      
      morale_collapse: {
        name: 'Morale Collapse',
        description: 'Causes morale collapse in adjacent enemy units after a kill.',
        apply: (unit, pos, gridData) => {
          return { causesMoraleCollapse: true };
        }
      },
      
      air_defense: {
        name: 'Air Defense',
        description: 'Can only attack air units (fighters and bombers).',
        apply: (unit, pos, gridData, targetPos, targetGridData) => {
          // This ability restricts attack targets to air units only
          return { airDefense: true };
        }
      },
      
      armour_penetrating: {
        name: 'Armour Penetrating Round',
        description: '+3 To Attack Rolls Against Armoured Units',
        apply: (unit, pos, gridData, targetPos, targetGridData) => {
          // Check if target is a vehicle, tank, or mech unit (armoured units)
          if (targetGridData && targetGridData.unit) {
            const targetType = targetGridData.unit.type;
            if (['vehicle', 'tank', 'mech'].includes(targetType)) {
              console.log(` [ARMOUR PENETRATING] ${unit.name} gets +3 damage bonus vs armoured target ${targetGridData.unit.name}`);
              return { damageBonus: 3 };
            }
          }
          return {};
        }
      }
    };
    
    // Function to apply special abilities
    function applySpecialAbilities(unit, pos, gridData, targetPos = null, targetGridData = null) {
      console.log(' [ABILITY DEBUG] Checking special abilities for unit:', unit.name);
      console.log(' [ABILITY DEBUG] Special ability:', unit.special);
      console.log(' [ABILITY DEBUG] Target position:', targetPos);
      console.log(' [ABILITY DEBUG] Has target data:', !!targetGridData);
      
      if (!unit.special || unit.special === 'none') {
        console.log(' [ABILITY DEBUG] No special ability found');
        return {};
      }
      
      const ability = specialAbilities[unit.special];
      if (!ability) {
        console.log(' [ABILITY DEBUG] Special ability not found in definitions');
        return {};
      }
      
      console.log(' [ABILITY DEBUG] Applying special ability:', ability.name);
      const effects = ability.apply(unit, pos, gridData, targetPos, targetGridData);
      
      // Log special ability effects for debugging
      if (effects.attackBonus) {
        if (unit.special === 'terror_in_skys' && targetGridData && targetGridData.unit) {
          console.log(` [TERROR] ${unit.name} gets +${effects.attackBonus} attack bonus against ${targetGridData.unit.type} on ${targetGridData.terrain}`);
        } else {
          console.log(` [ABILITY] ${unit.name} gets +${effects.attackBonus} attack bonus from ${unit.special}`);
        }
      }
      if (effects.defenseBonus) {
        console.log(` [ABILITY] ${unit.name} gets +${effects.defenseBonus} defense bonus from ${unit.special}`);
      }
      
      console.log(' [ABILITY DEBUG] Final effects:', effects);
      return effects;
    }
    
    // Function to process special ability effects
    function processSpecialAbilityEffects(unit, pos, gridData, effectType) {
      const abilities = applySpecialAbilities(unit, pos, gridData);
      
      switch (effectType) {
        case 'movement':
          if (abilities.movementBonus) {
            // Store the ability bonus on the unit for this turn only
            unit.abilityMovementBonus = abilities.movementBonus;
            gameState.movementMode.movementPoints += abilities.movementBonus;
          }
          if (abilities.terrainDamage) {
            const unitDestroyed = applyDamage(unit, abilities.terrainDamage, pos);
            logZoneMessage(`${unit.name} takes ${abilities.terrainDamage} damage from difficult terrain!`, 'combat');
            if (unitDestroyed) {
              logZoneMessage(`${unit.name} was destroyed by terrain damage!`, 'combat');
            }
          }
          break;
          
        case 'attack':
          if (abilities.attackBonus) {
            unit.attack += abilities.attackBonus;
          }
          if (abilities.attackPenalty) {
            unit.attack -= abilities.attackPenalty;
          }
          break;
          
        case 'defense':
          if (abilities.defenseBonus) {
            unit.defense += abilities.defenseBonus;
          }
          break;
          
        case 'combat':
          // Salvage Systems now works immediately during combat
          break;
      }
    }
    
    // Helper function to get adjacent positions
    function getAdjacentPositions(pos) {
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      const adjacent = [];
      
      // Check all 8 adjacent positions
      for (let r = Math.max(0, row - 1); r <= Math.min(gridSize - 1, row + 1); r++) {
        for (let c = Math.max(0, col - 1); c <= Math.min(gridSize - 1, col + 1); c++) {
          const adjPos = r * gridSize + c;
          if (adjPos !== pos) {
            adjacent.push(adjPos);
          }
        }
      }
      
      return adjacent;
    }
    
    // Mech Assault ability is handled automatically in the ability's apply function
    
    // Function to handle medic healing
    function performMedicHealing(medicUnit, medicPos) {
      if (medicUnit.special !== 'healer') return;
      
      const adjacentPositions = getAdjacentPositions(medicPos);
      let healedCount = 0;
      
      adjacentPositions.forEach(adjPos => {
        const adjUnit = currentZoneDetail.tacticalGrid[adjPos].unit;
        if (adjUnit && adjUnit.player === medicUnit.player && adjUnit.health < adjUnit.maxHealth) {
          adjUnit.health = Math.min(adjUnit.health + 1, adjUnit.maxHealth);
          healedCount++;
          logZoneMessage(`${medicUnit.name} heals ${adjUnit.name} for 1 HP!`, 'combat');
        }
      });
      
      if (healedCount > 0) {
        logZoneMessage(`${medicUnit.name} healed ${healedCount} adjacent unit(s)!`, 'combat');
      }
    }

    // Function to handle mechanic armor repair
    function performArmorRepair(mechanicUnit, mechanicPos) {
      if (mechanicUnit.special !== 'mechanic') return;
      
      const adjacentPositions = getAdjacentPositions(mechanicPos);
      let repairedCount = 0;
      
      adjacentPositions.forEach(adjPos => {
        const adjUnit = currentZoneDetail.tacticalGrid[adjPos].unit;
        // Repair armor for units with maxArmour > 0 and current armor < max
        if (adjUnit && adjUnit.player === mechanicUnit.player && adjUnit.maxArmour > 0 && adjUnit.armour < adjUnit.maxArmour) {
          adjUnit.armour = Math.min(adjUnit.armour + 1, adjUnit.maxArmour);
          repairedCount++;
          logZoneMessage(`${mechanicUnit.name} repairs ${adjUnit.name}'s armor by 1!`, 'combat');
        }
      });
      
      if (repairedCount > 0) {
        logZoneMessage(`${mechanicUnit.name} repaired armor for ${repairedCount} adjacent unit(s)!`, 'combat');
      }
    }
    
    // Gas deployment system
    function getGasDeploymentPositions(unitPos, player) {
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(unitPos / gridSize);
      const col = unitPos % gridSize;
      
      let positions = [];
      
      // Determine if this player is the attacker in the current zone
      const zoneRole = gameState.zoneRoles[gameState.currentZone];
      const isAttacker = zoneRole && zoneRole.attacker === player;
      
      console.log(` [GAS DEBUG] Player ${player} is ${isAttacker ? 'attacker' : 'defender'} in zone ${gameState.currentZone}`);
      
      if (isAttacker) {
        // Attackers deploy gas moving down (towards defenders at bottom)
        if (row < gridSize - 1) {
          positions.push((row + 1) * gridSize + col); // Front
          if (col > 0) positions.push((row + 1) * gridSize + (col - 1)); // Front-left
          if (col < gridSize - 1) positions.push((row + 1) * gridSize + (col + 1)); // Front-right
        }
      } else {
        // Defenders deploy gas moving up (towards attackers at top)
        if (row > 0) {
          positions.push((row - 1) * gridSize + col); // Front
          if (col > 0) positions.push((row - 1) * gridSize + (col - 1)); // Front-left
          if (col < gridSize - 1) positions.push((row - 1) * gridSize + (col + 1)); // Front-right
        }
      }
      
      console.log(` [GAS DEBUG] Valid gas positions for ${player} at ${unitPos}:`, positions);
      return positions.filter(pos => pos >= 0 && pos < gridSize * gridSize);
    }

    function deployGasCloud(position, player, zoneId) {
      console.log(` [GAS DEBUG] deployGasCloud called with position=${position}, player=${player}, zoneId=${zoneId}`);
      
      if (!gameState.gasClouds[zoneId]) {
        gameState.gasClouds[zoneId] = {};
        console.log(` [GAS DEBUG] Created gas clouds object for zone ${zoneId}`);
      }
      
      gameState.gasClouds[zoneId][position] = {
        player: player,
        turnsRemaining: 6,
        deployedOnTurn: gameState.turnCount
      };
      
      console.log(` [GAS DEBUG] Gas cloud data stored:`, gameState.gasClouds[zoneId][position]);
      logZoneMessage(`Gas cloud deployed at position ${position + 1}!`, 'combat');
      console.log(` [GAS] ${player} deployed gas at position ${position}, will last 6 turns`);
      
      // Check if there's a unit already at this position
      const unit = currentZoneDetail.tacticalGrid[position].unit;
      if (unit) {
        console.log(` [GAS DEBUG] Unit found at gas position, applying damage to ${unit.name}`);
        applyGasDamage(unit, position);
      } else {
        console.log(` [GAS DEBUG] No unit at gas position ${position}`);
      }
    }

    function applyGasDamage(unit, position) {
      // Units with armor are immune to gas
      if (unit.maxArmour > 0) {
        logZoneMessage(`${unit.name} is immune to gas (has armor)!`, 'combat');
        console.log(` [GAS] ${unit.name} immune to gas damage (armored unit)`);
        return;
      }
      
      // Roll d6 for gas damage
      const gasDamage = Math.floor(Math.random() * 6) + 1;
      console.log(` [GAS] ${unit.name} takes ${gasDamage} gas damage`);
      
      // DEBUGGING: Track when gas damage animation is triggered
      console.log(` [GAS DAMAGE DEBUG] About to show gas animation for ${unit.name}`);
      console.log(` [GAS DAMAGE DEBUG] Current screen state at damage time:`);
      const currentActiveScreen = document.querySelector('.screen.active');
      console.log(` [GAS DAMAGE DEBUG] Active screen:`, currentActiveScreen ? currentActiveScreen.id : 'none');
      console.log(` [GAS DAMAGE DEBUG] gameState.currentZone:`, gameState.currentZone);
      
      // Show gas dice animation
      showGasDiceAnimation(unit.name, gasDamage, () => {
        logZoneMessage(`${unit.name} takes ${gasDamage} gas damage!`, 'combat');
        
        // Apply damage (without position to avoid auto-elimination)
        const damageResult = applyDamage(unit, gasDamage, null);
        
        // Handle unit death through normal morale system
        console.log(` [GAS DEBUG] Unit health after damage: ${unit.health}/${unit.maxHealth}`);
        if (unit.health <= 0) {
          console.log(` [GAS] ${unit.name} reduced to 0 health by gas, checking if in active zone for morale`);
          
          // Check if we have a current zone - do morale check if zone is active
          const hasCurrentZone = !!gameState.currentZone;
          const isInGameScreen = document.querySelector('.screen.active')?.id === 'game';
          
          if (hasCurrentZone && !isInGameScreen) {
            // Use the position parameter directly instead of searching
            if (position !== undefined && position !== null) {
              console.log(` [GAS] Using provided position ${position} for morale check (hasCurrentZone=${hasCurrentZone}, isInGameScreen=${isInGameScreen})`);
              performMoraleCheckForSurvival(unit, position);
            } else {
              console.log(` [GAS ERROR] No position provided for morale check!`);
            }
          } else {
            console.log(` [GAS MORALE BLOCKED] Not in zone context - deferring morale check until zone is selected`);
            // Mark unit for morale check when zone is entered
            unit.needsMoraleCheck = true;
            unit.moraleCheckPosition = position;
          }
        }
        
        // Update battlefield to show changes
        generateMiniBattlefield();
      });
      
      return { gasApplied: true, damage: gasDamage };
    }

    function moveGasCloud(currentPosition, deployerPlayer, zoneId) {
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(currentPosition / gridSize);
      const col = currentPosition % gridSize;
      
      // Determine if the deployer was the attacker in this zone
      const zoneRole = gameState.zoneRoles[zoneId];
      const deployerIsAttacker = zoneRole && zoneRole.attacker === deployerPlayer;
      
      let newRow = row;
      
      if (deployerIsAttacker) {
        // Gas deployed by attacker moves down (towards defenders)
        newRow = row + 1;
      } else {
        // Gas deployed by defender moves up (towards attackers)
        newRow = row - 1;
      }
      
      // Check bounds
      if (newRow < 0 || newRow >= gridSize) {
        console.log(` [GAS] Gas at position ${currentPosition + 1} reached edge, will dissipate next turn`);
        return -1; // Special value indicating gas reached edge
      }
      
      const newPosition = newRow * gridSize + col;
      console.log(` [GAS] Moving gas from ${currentPosition + 1} to ${newPosition + 1} (${deployerIsAttacker ? 'attacker' : 'defender'} gas moving ${deployerIsAttacker ? 'down' : 'up'})`);
      
      return newPosition;
    }

    function processGasClouds() {
      try {
        if (!gameState.gasClouds) {
          console.log(' [GAS DEBUG] No gas clouds to process');
          return;
        }
        
        Object.keys(gameState.gasClouds).forEach(zoneId => {
          const zoneClouds = gameState.gasClouds[zoneId];
          if (!zoneClouds) return;
          
          // Only process gas movement in the currently active zone to prevent animations in zone selection screen
          const isCurrentZone = gameState.currentZone === zoneId;
          console.log(` [GAS DEBUG] Zone ${zoneId}: isCurrentZone=${isCurrentZone}, currentZone=${gameState.currentZone}`);
          
          const cloudsToRemove = [];
          
          const cloudsToMove = [];
          
          Object.keys(zoneClouds).forEach(position => {
            const cloud = zoneClouds[position];
            if (!cloud) return;
            
            cloud.turnsRemaining--;
            
            console.log(` [GAS] Cloud at position ${position} has ${cloud.turnsRemaining} turns remaining`);
            
            if (cloud.turnsRemaining <= 0 || cloud.atEdge) {
              cloudsToRemove.push(position);
              if (typeof logZoneMessage === 'function') {
                const reason = cloud.atEdge ? 'reached edge' : 'expired';
                logZoneMessage(`Gas cloud at position ${parseInt(position) + 1} dissipates (${reason})`, 'combat');
              }
            } else {
              // Only move gas clouds that belong to the current player AND are in the current zone
              console.log(` [GAS DEBUG] Checking gas movement: cloud.player=${cloud.player}, gameState.currentPlayer=${gameState.currentPlayer}`);
              if (cloud.player === gameState.currentPlayer && isCurrentZone) {
                // Move gas cloud
                const newPosition = moveGasCloud(parseInt(position), cloud.player, zoneId);
                if (newPosition === -1) {
                  // Gas reached edge, mark for removal next turn
                  cloud.atEdge = true;
                  console.log(` [GAS] ${cloud.player} gas reached edge, will dissipate next turn`);
                } else if (newPosition !== parseInt(position)) {
                  cloudsToMove.push({ oldPos: position, newPos: newPosition, cloud: cloud });
                  cloudsToRemove.push(position); // Remove from old position
                  console.log(` [GAS] ${cloud.player} gas moves on their turn`);
                }
              } else if (cloud.player === gameState.currentPlayer && !isCurrentZone) {
                console.log(` [GAS] ${cloud.player} gas waits (not in active zone)`);
              } else {
                console.log(` [GAS] ${cloud.player} gas waits (not their turn)`);
              }
            }
          });
          
          // Move clouds to new positions
          cloudsToMove.forEach(move => {
            zoneClouds[move.newPos] = move.cloud;
            console.log(` [GAS] Cloud moved from position ${parseInt(move.oldPos) + 1} to ${move.newPos + 1}`);
            
            // Check if unit is at new position and apply damage
            if (currentZoneDetail && currentZoneDetail.tacticalGrid[move.newPos] && currentZoneDetail.tacticalGrid[move.newPos].unit) {
              const unit = currentZoneDetail.tacticalGrid[move.newPos].unit;
              console.log(` [GAS] Gas moved onto unit ${unit.name}, applying damage`);
              applyGasDamage(unit, move.newPos);
            }
          });
          
          // Remove expired clouds
          cloudsToRemove.forEach(pos => {
            delete zoneClouds[pos];
          });
          
          // Clean up empty zone entries
          if (Object.keys(zoneClouds).length === 0) {
            delete gameState.gasClouds[zoneId];
          }
        });
        
        console.log(' [GAS DEBUG] Gas cloud processing completed successfully');
      } catch (error) {
        console.error(' [GAS ERROR] Error processing gas clouds:', error);
        // Don't let gas cloud errors break the turn system
      }
    }

    // Check for units that need deferred morale checks (from gas damage in other zones)
    function checkForDeferredMoraleChecks() {
      if (!currentZoneDetail) return;
      
      console.log(' [MORALE DEBUG] Checking for deferred morale checks');
      
      for (let pos = 0; pos < currentZoneDetail.tacticalGrid.length; pos++) {
        const gridData = currentZoneDetail.tacticalGrid[pos];
        const unit = gridData.unit;
        
        if (unit && unit.needsMoraleCheck && unit.health <= 0) {
          console.log(` [MORALE DEBUG] Found unit ${unit.name} needing deferred morale check at position ${pos}`);
          // Clear the flag and perform the morale check
          unit.needsMoraleCheck = false;
          const checkPosition = unit.moraleCheckPosition !== undefined ? unit.moraleCheckPosition : pos;
          performMoraleCheckForSurvival(unit, checkPosition);
          unit.moraleCheckPosition = undefined;
        }
      }
    }

    // Check for units standing in gas clouds when entering a zone
    function checkUnitsInGasClouds() {
      if (!currentZoneDetail || !gameState.gasClouds || !gameState.gasClouds[gameState.currentZone]) {
        console.log(' [GAS ENTRY DEBUG] No gas clouds in current zone or no zone detail');
        return;
      }
      
      const zoneClouds = gameState.gasClouds[gameState.currentZone];
      console.log(' [GAS ENTRY DEBUG] Checking for units in gas clouds in zone', gameState.currentZone);
      console.log(' [GAS ENTRY DEBUG] Gas cloud positions:', Object.keys(zoneClouds));
      
      // Delay gas processing to ensure screen transition is complete
      setTimeout(() => {
        console.log(' [GAS ENTRY DEBUG] Processing gas damage after screen transition delay');
        
        // Check each gas cloud position for units
        Object.keys(zoneClouds).forEach(position => {
          const pos = parseInt(position);
          const cloud = zoneClouds[position];
          const gridData = currentZoneDetail.tacticalGrid[pos];
          
          if (gridData && gridData.unit) {
            const unit = gridData.unit;
            console.log(` [GAS ENTRY DEBUG] Found unit ${unit.name} in gas cloud at position ${pos}`);
            
            // Apply gas damage with animation
            applyGasDamage(unit, pos);
          }
        });
      }, 200); // Wait for screen transition to complete
    }

    // Check for units at 0 HP that need morale checks
    function processZeroHealthUnits() {
      if (!currentZoneDetail) return;
      
      console.log(' [HEALTH DEBUG] Checking for units at 0 HP');
      
      for (let pos = 0; pos < currentZoneDetail.tacticalGrid.length; pos++) {
        const gridData = currentZoneDetail.tacticalGrid[pos];
        const unit = gridData.unit;
        
        if (unit && unit.health <= 0) {
          console.log(` [HEALTH DEBUG] Found unit at 0 HP: ${unit.name} at position ${pos}`);
          console.log(` [HEALTH DEBUG] Performing morale check for survival`);
          performMoraleCheckForSurvival(unit, pos);
        }
      }
    }

    // Function to process turn-based effects (called at end of turn)
    function processTurnBasedEffects() {
      console.log(' [TURN DEBUG] Starting processTurnBasedEffects');
      if (!currentZoneDetail) {
        console.log(' [TURN DEBUG] No currentZoneDetail, skipping turn-based effects');
        return;
      }
      
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = currentZoneDetail.tacticalGrid[pos].unit;
        if (!unit) continue;
        
        // Process bleeding damage
        if (unit.bleeding && unit.bleedingTurns > 0) {
          console.log(` [BLEEDING DEBUG] ${unit.name} takes 1 bleeding damage`);
          applyDamage(unit, 1, pos);
          unit.bleedingTurns--;
          logZoneMessage(`${unit.name} takes 1 bleeding damage! (${unit.bleedingTurns} turns remaining)`, 'combat');
          
          if (unit.bleedingTurns <= 0) {
            unit.bleeding = false;
            logZoneMessage(`${unit.name} stops bleeding.`, 'combat');
          }
        }
        
        // Process suppression
        if (unit.suppressed && unit.suppressionTurns > 0) {
          unit.suppressionTurns--;
          if (unit.suppressionTurns <= 0) {
            unit.suppressed = false;
            logZoneMessage(`${unit.name} is no longer suppressed.`, 'combat');
          }
        }
        
        // Process routing units that reached the edge
        if (unit.reachedEdgeWhileRouting) {
          console.log(` [ROUTING] Destroying unit ${unit.name} that reached edge while routing`);
          logZoneMessage(`${unit.name} is destroyed after routing to the edge!`, 'combat');
          currentZoneDetail.tacticalGrid[pos].unit = null;
          continue; // Skip other processing for destroyed unit
        }
        
        // Process morale collapse
        if (unit.moraleCollapse) {
          unit.moraleCollapse = false;
          logZoneMessage(`${unit.name} recovers from morale collapse.`, 'combat');
        }
        
        // Evasion ability is handled in applyDamage function when unit takes damage
        
        // Process medic healing
        if (unit.special === 'healer') {
          performMedicHealing(unit, pos);
        }

        // Process mechanic armor repair
        if (unit.special === 'mechanic') {
          performArmorRepair(unit, pos);
        }
        
        // Process beach landing restrictions (amphibious units are exempt)
        if (unit.beachLanding && unit.beachLandingTurns > 0 && unit.special !== 'amphibious') {
          unit.beachLandingTurns--;
          if (unit.beachLandingTurns <= 0) {
            unit.beachLanding = false;
            logZoneMessage(`${unit.name} has established beachhead and can now move!`, 'combat');
            logMessage(`INTELLIGENCE: ${unit.name} has successfully established a beachhead and is ready for offensive operations.`, 'intelligence');
          } else {
            const roundsRemaining = Math.ceil(unit.beachLandingTurns / 2);
            logZoneMessage(`${unit.name} is still establishing beachhead (${roundsRemaining} complete round(s) remaining)`, 'combat');
          }
        }
        
        // Reset kill counter
        unit.killsThisTurn = 0;
      }
      
      // Process gas cloud aging
      console.log(' [TURN DEBUG] About to process gas clouds');
      processGasClouds();
      
      // Check for any units at 0 HP that need morale checks
      processZeroHealthUnits();
      
      console.log(' [TURN DEBUG] Completed processTurnBasedEffects successfully');
    }
    
    let zones = [];
    let currentZoneDetail = null;
    let tooltipElement = null;
    
    // Animation state
    let diceAnimationState = {
      active: false,
      rollIntervalId: null,
      rollDuration: 2000, // 2 seconds of rolling
      finalValues: { attack: 0, defense: 0 },
      currentRolls: { attack: 1, defense: 1 },
      modifiers: { attack: 0, defense: 0 },
      callback: null
    };
    
    let moraleAnimationState = {
      active: false,
      rollIntervalId: null,
      rollDuration: 1500, // 1.5 seconds of rolling
      finalValue: 0,
      currentRoll: 1,
      unit: null,
      target: 4,
      callback: null
    };
    
    let artilleryAnimationState = {
      active: false,
      rollIntervalId: null,
      rollDuration: 2000, // 2 seconds of rolling
      finalValue: 0,
      currentRoll: 1,
      artillery: null,
      targetZone: null,
      hitChance: 9,
      callback: null,
      // New fields for two-phase system
      phase: 'hit', // 'hit' or 'combat'
      hitSuccess: false,
      attackerRoll: 0,
      defenderRoll: 0,
      attackerBonus: 0,
      defenderBonus: 0,
      attackTotal: 0,
      defenseTotal: 0,
      currentAttackerRoll: 1,
      currentDefenderRoll: 1,
      precisionBonus: 0
    };
    
    let aerialAnimationState = {
      active: false,
      rollIntervalId: null,
      rollDuration: 2000, // 2 seconds of rolling
      attacker: null,
      target: null,
      attackerRoll: 0,
      defenderRoll: 0,
      attackerBonus: 0,
      defenderBonus: 0,
      attackTotal: 0,
      defenseTotal: 0,
      currentAttackerRoll: 1,
      currentDefenderRoll: 1,
      callback: null
    };
    
    // Global function to reset aerial animation if it gets stuck
    window.resetAerialAnimation = function() {
      console.log(' [AERIAL DEBUG] Manually resetting aerial animation state');
      
      // Clear any active intervals
      if (aerialAnimationState.rollIntervalId) {
        clearInterval(aerialAnimationState.rollIntervalId);
        aerialAnimationState.rollIntervalId = null;
      }
      
      // Hide overlay
      const overlay = document.getElementById('aerial-overlay');
      if (overlay) {
        overlay.style.display = 'none';
      }
      
      // Reset dice
      const aerialAttackerDiceCube = document.getElementById('aerialAttackerDiceCube');
      const aerialDefenderDiceCube = document.getElementById('aerialDefenderDiceCube');
      if (aerialAttackerDiceCube) {
        aerialAttackerDiceCube.classList.remove('rolling', 'left-dice', 'winner', 'loser');
        setDiceRotation(aerialAttackerDiceCube, 1);
      }
      if (aerialDefenderDiceCube) {
        aerialDefenderDiceCube.classList.remove('rolling', 'right-dice', 'winner', 'loser');
        setDiceRotation(aerialDefenderDiceCube, 1);
      }
      
      // Reset state
      aerialAnimationState.active = false;
      aerialAnimationState.callback = null;
      aerialAnimationState.attacker = null;
      aerialAnimationState.target = null;
      aerialAnimationState.attackerRoll = 0;
      aerialAnimationState.defenderRoll = 0;
      aerialAnimationState.attackTotal = 0;
      aerialAnimationState.defenseTotal = 0;
      aerialAnimationState.currentAttackerRoll = 1;
      aerialAnimationState.currentDefenderRoll = 1;
      
      console.log(' [AERIAL DEBUG] Aerial animation state manually reset');
    };
    
    // 3D Dice Animation Functions
    function showDiceAnimation(attackerName, defenderName, attackMod, defenseMod, callback) {
      console.log(' [DICE DEBUG] ===== SHOW DICE ANIMATION START =====');
      console.log(' [DICE DEBUG] Attacker:', attackerName, 'Defender:', defenderName);
      console.log(' [DICE DEBUG] Attack mod:', attackMod, 'Defense mod:', defenseMod);
      console.log(' [DICE DEBUG] Current diceAnimationState:', diceAnimationState);
      
      if (diceAnimationState.active) {
        console.log(' [DICE DEBUG] Animation already active, returning');
        return;
      }
      
      diceAnimationState.active = true;
      diceAnimationState.callback = callback;
      
      // Roll actual dice values
      const attackRoll = Math.floor(Math.random() * 6) + 1;
      const defenseRoll = Math.floor(Math.random() * 6) + 1;
      
      diceAnimationState.finalValues = { attack: attackRoll, defense: defenseRoll };
      diceAnimationState.modifiers = { attack: attackMod, defense: defenseMod };
      
      console.log(' [DICE DEBUG] Final values:', diceAnimationState.finalValues);
      console.log(' [DICE DEBUG] Modifiers:', diceAnimationState.modifiers);
      
      // Setup UI
      const overlay = document.getElementById('dice-overlay');
      const leftBonus = document.getElementById('leftBonus');
      const rightBonus = document.getElementById('rightBonus');
      const leftResult = document.getElementById('leftResult');
      const rightResult = document.getElementById('rightResult');
      const winnerText = document.getElementById('winnerText');
      const prompt = document.getElementById('dice-click-prompt');
      
      console.log(' [DICE DEBUG] UI elements found:', {
        overlay: !!overlay,
        leftBonus: !!leftBonus,
        rightBonus: !!rightBonus,
        leftResult: !!leftResult,
        rightResult: !!rightResult,
        winnerText: !!winnerText,
        prompt: !!prompt
      });
      
      // Set bonus values (automatically calculated)
      leftBonus.textContent = attackMod >= 0 ? `+${attackMod}` : `${attackMod}`;
      rightBonus.textContent = defenseMod >= 0 ? `+${defenseMod}` : `${defenseMod}`;
      
      // Clear previous results
      leftResult.textContent = '-';
      rightResult.textContent = '-';
      winnerText.textContent = '';
      
      // Remove any existing winner/loser classes
      document.querySelectorAll('.dice-section').forEach(section => {
        section.classList.remove('winner', 'loser');
      });
      
      prompt.style.display = 'none';
      overlay.style.display = 'flex';
      
      console.log(' [DICE DEBUG] Overlay displayed, starting rolling animation');
      
      // Start rolling animation
      startDiceRolling();
      
      // Stop rolling after duration (but don't close the screen)
      console.log(' [DICE DEBUG] Setting timeout to stop rolling after', diceAnimationState.rollDuration, 'ms');
      setTimeout(() => {
        console.log(' [DICE DEBUG] Timeout fired - calling stopDiceRolling');
        stopDiceRolling();
      }, diceAnimationState.rollDuration);
    }
    
    // Function to automatically calculate combat bonuses
    function calculateCombatBonuses(attacker, defender, fromPos, toPos) {
      console.log(' [COMBAT DEBUG] Calculating combat bonuses:');
      console.log(' [COMBAT DEBUG] Attacker:', attacker.name, 'type:', attacker.type, 'special:', attacker.special);
      console.log(' [COMBAT DEBUG] Defender:', defender.name, 'type:', defender.type);
      console.log(' [COMBAT DEBUG] Positions - from:', fromPos, 'to:', toPos);
      
      let attackBonus = 0;
      let defenseBonus = 0;
      
      // Get current zone data
      if (!currentZoneDetail) {
        console.log(' [COMBAT DEBUG] No current zone data found!');
        return { attack: attackBonus, defense: defenseBonus };
      }
      
      // Terrain bonuses
      const attackerTerrain = currentZoneDetail.tacticalGrid[fromPos]?.terrain;
      const defenderTerrain = currentZoneDetail.tacticalGrid[toPos]?.terrain;
      
      if (attackerTerrain && terrainEffects[attackerTerrain]) {
        attackBonus += terrainEffects[attackerTerrain].attackBonus || 0;
      }
      
      if (defenderTerrain && terrainEffects[defenderTerrain]) {
        defenseBonus += terrainEffects[defenderTerrain].defenseBonus || 0;
      }
      
      // Unit special abilities
      if (attacker.special) {
        console.log(' [COMBAT DEBUG] Applying special abilities for attacker:', attacker.name);
        console.log(' [COMBAT DEBUG] From position:', fromPos, 'To position:', toPos);
        console.log(' [COMBAT DEBUG] Target grid data exists:', !!currentZoneDetail.tacticalGrid[toPos]);
        
        const attackerAbilities = applySpecialAbilities(attacker, fromPos, currentZoneDetail.tacticalGrid[fromPos], toPos, currentZoneDetail.tacticalGrid[toPos]);
        if (attackerAbilities.attackBonus) {
          attackBonus += attackerAbilities.attackBonus;
          console.log(' [COMBAT DEBUG] Added attack bonus:', attackerAbilities.attackBonus, 'Total attack bonus now:', attackBonus);
        }
      }
      
      if (defender.special) {
        const defenderAbilities = applySpecialAbilities(defender, toPos, currentZoneDetail.tacticalGrid[toPos], fromPos, currentZoneDetail.tacticalGrid[fromPos]);
        defenseBonus += defenderAbilities.defenseBonus || 0;
      }
      
      // Construction bonuses
      const attackerConstruction = currentZoneDetail.tacticalGrid[fromPos]?.construction;
      const defenderConstruction = currentZoneDetail.tacticalGrid[toPos]?.construction;
      
      if (attackerConstruction && attackerConstruction.completed) {
        attackBonus += attackerConstruction.attackBonus || 0;
      }
      
      if (defenderConstruction && defenderConstruction.completed) {
        defenseBonus += defenderConstruction.defenseBonus || 0;
      }
      
      // Air superiority bonuses
      if (attacker.type === 'aerial') {
        const airSuperiority = calculateAirSuperiorityBonus(attacker);
        attackBonus += airSuperiority.attackBonus || 0;
      }
      
      if (defender.type === 'aerial') {
        const airSuperiority = calculateAirSuperiorityBonus(defender);
        defenseBonus += airSuperiority.attackBonus || 0;
      }
      
      // Weather and Day/Night Cycle effects
      const weatherEffects = getWeatherEffects();
      attackBonus += weatherEffects.attack;
      defenseBonus += weatherEffects.defense;
      
              console.log('[WEATHER DEBUG] Weather effects applied - Attack:', weatherEffects.attack, 'Defense:', weatherEffects.defense);
      
      return { attack: attackBonus, defense: defenseBonus };
    }
    
    function startDiceRolling() {
      const leftCube = document.getElementById('leftDiceCube');
      const rightCube = document.getElementById('rightDiceCube');
      
      // Remove any existing face visibility classes to show all faces during rolling
      leftCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      rightCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Add rolling animation classes
      leftCube.classList.add('rolling', 'left-dice');
      rightCube.classList.add('rolling', 'right-dice');
      
      diceAnimationState.rollIntervalId = setInterval(() => {
        diceAnimationState.currentRolls.attack = Math.floor(Math.random() * 6) + 1;
        diceAnimationState.currentRolls.defense = Math.floor(Math.random() * 6) + 1;
        
        // Update dice rotations during rolling (without changing visibility)
        setDiceRotationForRolling(leftCube, diceAnimationState.currentRolls.attack);
        setDiceRotationForRolling(rightCube, diceAnimationState.currentRolls.defense);
      }, 100);
    }
    
    function stopDiceRolling() {
      console.log(' [DICE DEBUG] ===== STOP DICE ROLLING =====');
      console.log(' [DICE DEBUG] Current rollIntervalId:', diceAnimationState.rollIntervalId);
      
      if (diceAnimationState.rollIntervalId) {
        clearInterval(diceAnimationState.rollIntervalId);
        diceAnimationState.rollIntervalId = null;
        console.log(' [DICE DEBUG] Cleared roll interval');
      }
      
      // Show final values
      const leftCube = document.getElementById('leftDiceCube');
      const rightCube = document.getElementById('rightDiceCube');
      const leftResult = document.getElementById('leftResult');
      const rightResult = document.getElementById('rightResult');
      const winnerText = document.getElementById('winnerText');
      const prompt = document.getElementById('dice-click-prompt');
      
      console.log(' [DICE DEBUG] UI elements found in stopDiceRolling:', {
        leftCube: !!leftCube,
        rightCube: !!rightCube,
        leftResult: !!leftResult,
        rightResult: !!rightResult,
        winnerText: !!winnerText,
        prompt: !!prompt
      });
      
      // Set final dice positions
      setDiceRotation(leftCube, diceAnimationState.finalValues.attack);
      setDiceRotation(rightCube, diceAnimationState.finalValues.defense);
      
      // Remove rolling animation
      leftCube.classList.remove('rolling', 'left-dice');
      rightCube.classList.remove('rolling', 'right-dice');
      
      // Calculate totals
      const attackTotal = diceAnimationState.finalValues.attack + diceAnimationState.modifiers.attack;
      const defenseTotal = diceAnimationState.finalValues.defense + diceAnimationState.modifiers.defense;
      
      console.log(' [DICE DEBUG] Final totals - Attack:', attackTotal, 'Defense:', defenseTotal);
      
      // Display results with bonuses
      leftResult.textContent = diceAnimationState.modifiers.attack !== 0 ? 
        `${diceAnimationState.finalValues.attack}${diceAnimationState.modifiers.attack >= 0 ? '+' : ''}${diceAnimationState.modifiers.attack} = ${attackTotal}` : 
        diceAnimationState.finalValues.attack;
      rightResult.textContent = diceAnimationState.modifiers.defense !== 0 ? 
        `${diceAnimationState.finalValues.defense}${diceAnimationState.modifiers.defense >= 0 ? '+' : ''}${diceAnimationState.modifiers.defense} = ${defenseTotal}` : 
        diceAnimationState.finalValues.defense;
      
      // Determine winner
      const leftSection = document.querySelector('.dice-section:first-child');
      const rightSection = document.querySelector('.dice-section:last-child');
      
      if (attackTotal > defenseTotal) {
        winnerText.textContent = 'OFFENSIVE VICTORY!';
        leftSection.classList.add('winner');
        rightSection.classList.add('loser');
      } else if (defenseTotal > attackTotal) {
        winnerText.textContent = 'DEFENSIVE HOLD!';
        rightSection.classList.add('winner');
        leftSection.classList.add('loser');
      } else {
        winnerText.textContent = 'STALEMATE!';
      }
      
      console.log(' [DICE DEBUG] Showing prompt for user interaction');
      prompt.style.display = 'block';
    }
    
    // Dice rotation functions
    const diceRotations = {
      1: { x: 0, y: 0, z: 0 },      // front face (1 dot) - show 1
      2: { x: 0, y: 180, z: 0 },    // back face (2 dots) - show 2
      3: { x: 0, y: 90, z: 0 },     // right face (3 dots) - show 3
      4: { x: 0, y: -90, z: 0 },    // left face (4 dots) - show 4
      5: { x: 90, y: 0, z: 0 },     // top face (5 dots) - show 5
      6: { x: -90, y: 0, z: 0 }     // bottom face (6 dots) - show 6
    };
    
    // D10 dice rotation functions (for artillery hit chance)
    const d10Rotations = {
      1: { x: 0, y: 0, z: 0 },      // 1
      2: { x: 0, y: 36, z: 0 },     // 2
      3: { x: 0, y: 72, z: 0 },     // 3
      4: { x: 0, y: 108, z: 0 },    // 4
      5: { x: 0, y: 144, z: 0 },    // 5
      6: { x: 0, y: 180, z: 0 },    // 6
      7: { x: 0, y: 216, z: 0 },    // 7
      8: { x: 0, y: 252, z: 0 },    // 8
      9: { x: 0, y: 288, z: 0 },    // 9
      10: { x: 0, y: 324, z: 0 }    // 10
    };
    
    function setDiceRotation(cubeElement, value) {
      // First, remove any existing face classes
      cubeElement.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Add the class for the face we want to show
      cubeElement.classList.add(`show-face-${value}`);
      
      // Also set the rotation as backup
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    
    function setDiceRotationForRolling(cubeElement, value) {
      // During rolling, only set the rotation, don't change visibility
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    
    // Dual dice rolling function for the new interface (kept for compatibility)
    function rollDualDice() {
      const leftCube = document.getElementById('leftDiceCube');
      const rightCube = document.getElementById('rightDiceCube');
      const leftResult = document.getElementById('leftResult');
      const rightResult = document.getElementById('rightResult');
      const winnerText = document.getElementById('winnerText');
      
      // Get current bonuses (these should be automatically calculated)
      const leftBonus = parseInt(document.getElementById('leftBonus').textContent.replace('+', '')) || 0;
      const rightBonus = parseInt(document.getElementById('rightBonus').textContent.replace('+', '')) || 0;
      
      // Clear previous results
      leftResult.textContent = '-';
      rightResult.textContent = '-';
      winnerText.textContent = '';
      
      // Remove any existing winner/loser classes
      document.querySelectorAll('.dice-section').forEach(section => {
        section.classList.remove('winner', 'loser');
      });
      
      // Add rolling animation
      leftCube.classList.add('rolling', 'left-dice');
      rightCube.classList.add('rolling', 'right-dice');
      
      // Generate random results
      const leftDiceValue = Math.floor(Math.random() * 6) + 1;
      const rightDiceValue = Math.floor(Math.random() * 6) + 1;
      
      // Calculate final values with bonuses
      const leftFinalValue = leftDiceValue + leftBonus;
      const rightFinalValue = rightDiceValue + rightBonus;
      
      setTimeout(() => {
        // Set final dice positions
        setDiceRotation(leftCube, leftDiceValue);
        setDiceRotation(rightCube, rightDiceValue);
        
        // Remove rolling animation
        leftCube.classList.remove('rolling', 'left-dice');
        rightCube.classList.remove('rolling', 'right-dice');
        
        // Display results with bonuses
        leftResult.textContent = leftBonus !== 0 ? 
          `${leftDiceValue}${leftBonus >= 0 ? '+' : ''}${leftBonus} = ${leftFinalValue}` : 
          leftDiceValue;
        rightResult.textContent = rightBonus !== 0 ? 
          `${rightDiceValue}${rightBonus >= 0 ? '+' : ''}${rightBonus} = ${rightFinalValue}` : 
          rightDiceValue;
        
        // Determine winner
        const leftSection = document.querySelector('.dice-section:first-child');
        const rightSection = document.querySelector('.dice-section:last-child');
        
        if (leftFinalValue > rightFinalValue) {
          winnerText.textContent = 'OFFENSIVE VICTORY!';
          leftSection.classList.add('winner');
          rightSection.classList.add('loser');
        } else if (rightFinalValue > leftFinalValue) {
          winnerText.textContent = 'DEFENSIVE HOLD!';
          rightSection.classList.add('winner');
          leftSection.classList.add('loser');
        } else {
          winnerText.textContent = 'STALEMATE!';
        }
      }, 2500);
    }
    
    // Unified function to close any active dice animation
    function closeDiceAnimations() {
      if (diceAnimationState.active) {
        closeDiceAnimation();
        return;
      }
    }
    
    function closeDiceAnimation() {
      console.log(' [DICE DEBUG] ===== CLOSE DICE ANIMATION =====');
      console.log(' [DICE DEBUG] Animation active:', diceAnimationState.active);
      
      if (!diceAnimationState.active) {
        console.log(' [DICE DEBUG] Animation not active, returning');
        return;
      }
      
      // Stop rolling first
      stopDiceRolling();
      
      const overlay = document.getElementById('dice-overlay');
      console.log(' [DICE DEBUG] Found overlay:', !!overlay);
      if (overlay) {
        overlay.style.display = 'none';
        console.log(' [DICE DEBUG] Hidden overlay');
      }
      
      // Reset dice to initial state for next time
      const leftCube = document.getElementById('leftDiceCube');
      const rightCube = document.getElementById('rightDiceCube');
      leftCube.classList.remove('rolling', 'left-dice');
      rightCube.classList.remove('rolling', 'right-dice');
      setDiceRotation(leftCube, 1);
      setDiceRotation(rightCube, 1);
      
      // Clear winner text and results
      const winnerText = document.getElementById('winnerText');
      const leftResult = document.getElementById('leftResult');
      const rightResult = document.getElementById('rightResult');
      const prompt = document.getElementById('dice-click-prompt');
      
      if (winnerText) {
        winnerText.textContent = '';
        console.log(' [DICE DEBUG] Cleared winner text');
      }
      if (leftResult) {
        leftResult.textContent = '-';
        console.log(' [DICE DEBUG] Cleared left result');
      }
      if (rightResult) {
        rightResult.textContent = '-';
        console.log(' [DICE DEBUG] Cleared right result');
      }
      if (prompt) {
        prompt.style.display = 'none';
        console.log(' [DICE DEBUG] Hidden prompt');
      }
      
      // Remove winner/loser classes
      document.querySelectorAll('.dice-section').forEach(section => {
        section.classList.remove('winner', 'loser');
      });
      console.log(' [DICE DEBUG] Removed winner/loser classes');
      
      // Execute callback with results
      if (diceAnimationState.callback) {
        console.log(' [DICE DEBUG] Executing callback');
        const attackTotal = diceAnimationState.finalValues.attack + diceAnimationState.modifiers.attack;
        const defenseTotal = diceAnimationState.finalValues.defense + diceAnimationState.modifiers.defense;
        diceAnimationState.callback(attackTotal, defenseTotal, diceAnimationState.finalValues.attack, diceAnimationState.finalValues.defense);
      } else {
        console.log(' [DICE DEBUG] No callback to execute');
      }
      
      diceAnimationState.active = false;
      diceAnimationState.callback = null;
      console.log(' [DICE DEBUG] Animation closed and reset');
    }
    
    // Evasion animation removed - using simple defense bonus instead
    
    // Gas Damage Animation Functions
    function showGasDiceAnimation(unitName, damage, callback) {
      // EXTENSIVE DEBUGGING FOR GAS ANIMATION ZONE ISSUE
      console.log(` [GAS ANIMATION DEBUG] ==========================================`);
      console.log(` [GAS ANIMATION DEBUG] showGasDiceAnimation called for ${unitName} with ${damage} damage`);
      console.log(` [GAS ANIMATION DEBUG] Current gameState.currentZone:`, gameState.currentZone);
      
      // Check all possible screen states
      const gameScreen = document.getElementById('game');
      const zoneDetailScreen = document.getElementById('zone-detail');
      const allScreens = document.querySelectorAll('.screen');
      
      console.log(` [GAS ANIMATION DEBUG] Screen states:`);
      console.log(` [GAS ANIMATION DEBUG] - game screen exists:`, !!gameScreen);
      console.log(` [GAS ANIMATION DEBUG] - game screen active:`, gameScreen ? gameScreen.classList.contains('active') : false);
      console.log(` [GAS ANIMATION DEBUG] - zone-detail screen exists:`, !!zoneDetailScreen);
      console.log(` [GAS ANIMATION DEBUG] - zone-detail screen active:`, zoneDetailScreen ? zoneDetailScreen.classList.contains('active') : false);
      
      allScreens.forEach((screen, index) => {
        console.log(` [GAS ANIMATION DEBUG] - Screen ${index} (${screen.id}): active=${screen.classList.contains('active')}, display=${screen.style.display}`);
      });
      
      // Check call stack to see where this is being called from
      console.log(` [GAS ANIMATION DEBUG] Call stack trace:`);
      console.trace('Gas animation call stack');
      
      console.log(` [GAS ANIMATION DEBUG] ==========================================`);
      
      // DECISION: Show animation if we have a current zone (either in zone detail or entering zone)
      const hasCurrentZone = !!gameState.currentZone;
      const isInGameScreen = gameScreen && gameScreen.classList.contains('active');
      const shouldShowAnimation = hasCurrentZone && !isInGameScreen;
      
      console.log(` [GAS ANIMATION DEBUG] Animation decision: hasCurrentZone=${hasCurrentZone}, isInGameScreen=${isInGameScreen}, shouldShow=${shouldShowAnimation}`);
      
      if (!shouldShowAnimation) {
        console.log(` [GAS ANIMATION BLOCKED] Not showing animation - not in zone detail screen and not entering zone`);
        if (callback) callback();
        return;
      }
      
      console.log(` [GAS] Showing gas animation for ${unitName} with ${damage} damage`);
      
      // Create a simple gas damage animation overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        flex-direction: column;
      `;
      
      overlay.innerHTML = `
        <div style="background: linear-gradient(45deg, rgba(0, 255, 0, 0.2), rgba(50, 255, 50, 0.3)); 
                    border: 2px solid #00ff00; 
                    border-radius: 15px; 
                    padding: 30px; 
                    text-align: center; 
                    color: white;
                    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);">
          <h2 style="margin: 0 0 20px 0; color: #00ff00; text-shadow: 0 0 5px rgba(0, 255, 0, 1);"> Gas Damage </h2>
          <div style="font-size: 18px; margin-bottom: 20px;">${unitName} exposed to toxic gas!</div>
          <div class="gas-dice-display">
            <div class="gas-dice-cube" id="gasDiceCube">
              <div class="gas-dice-face front face-1">
                <div class="gas-dice-dot"></div>
              </div>
              <div class="gas-dice-face back face-2">
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
              </div>
              <div class="gas-dice-face right face-3">
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
              </div>
              <div class="gas-dice-face left face-4">
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
              </div>
              <div class="gas-dice-face top face-5">
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
              </div>
              <div class="gas-dice-face bottom face-6">
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
                <div class="gas-dice-dot"></div>
              </div>
            </div>
          </div>
          <div style="font-size: 20px; color: #ff4444; margin-top: 15px;" id="gas-damage-result">Rolling for damage...</div>
          <div style="font-size: 14px; margin-top: 15px; opacity: 0.8;">Click to continue</div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      // Start gas dice rolling animation
      const gasDiceCube = document.getElementById('gasDiceCube');
      gasDiceCube.classList.add('rolling');
      
      // Remove any existing face visibility classes to show all faces during rolling
      gasDiceCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Start rolling animation
      let rollCount = 0;
      const rollInterval = setInterval(() => {
        const randomRoll = Math.floor(Math.random() * 6) + 1;
        setGasDiceRotationForRolling(gasDiceCube, randomRoll);
        rollCount++;
        
        if (rollCount >= 10) { // Roll for 1 second (10 * 100ms)
          clearInterval(rollInterval);
          
          // Set final dice position
          setGasDiceRotation(gasDiceCube, damage);
          gasDiceCube.classList.remove('rolling');
          
          // Update result text
          const gasResult = document.getElementById('gas-damage-result');
          gasResult.textContent = `Takes ${damage} gas damage!`;
          gasResult.style.color = '#ff6666';
        }
      }, 100);
      
      // Click to close
      overlay.onclick = () => {
        document.body.removeChild(overlay);
        if (callback) callback();
      };
      
      // Auto-close after 3 seconds
      setTimeout(() => {
        if (document.body.contains(overlay)) {
          document.body.removeChild(overlay);
          if (callback) callback();
        }
      }, 3000);
    }
    
    // Minefield Damage Animation Functions
    function showMinefieldDiceAnimation(unitName, damage, callback) {
      console.log(` [MINEFIELD ANIMATION DEBUG] showMinefieldDiceAnimation called for ${unitName} with ${damage} damage`);
      
      // Check if we should show animation (similar to gas animation logic)
      const hasCurrentZone = !!gameState.currentZone;
      const gameScreen = document.getElementById('game');
      const isInGameScreen = gameScreen && gameScreen.classList.contains('active');
      const shouldShowAnimation = hasCurrentZone && !isInGameScreen;
      
      console.log(` [MINEFIELD ANIMATION DEBUG] Animation decision: hasCurrentZone=${hasCurrentZone}, isInGameScreen=${isInGameScreen}, shouldShow=${shouldShowAnimation}`);
      
      if (!shouldShowAnimation) {
        console.log(` [MINEFIELD ANIMATION BLOCKED] Not showing animation - not in zone detail screen and not entering zone`);
        if (callback) callback();
        return;
      }
      
      console.log(` [MINEFIELD] Showing minefield animation for ${unitName} with ${damage} damage`);
      
      // Create minefield damage animation overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        flex-direction: column;
      `;
      
      overlay.innerHTML = `
        <div style="background: linear-gradient(45deg, rgba(128, 128, 128, 0.2), rgba(80, 80, 80, 0.3)); 
                    border: 2px solid #808080; 
                    border-radius: 15px; 
                    padding: 30px; 
                    text-align: center; 
                    color: white;
                    box-shadow: 0 0 20px rgba(128, 128, 128, 0.5);">
          <h2 style="margin: 0 0 20px 0; color: #808080; text-shadow: 0 0 5px rgba(128, 128, 128, 1);"> Minefield Explosion </h2>
          <div style="font-size: 18px; margin-bottom: 20px;">${unitName} triggered a mine!</div>
          <div class="minefield-dice-display">
            <div class="minefield-dice-cube" id="minefieldDiceCube">
              <div class="minefield-dice-face front face-1">
                <div class="minefield-dice-dot"></div>
              </div>
              <div class="minefield-dice-face back face-2">
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
              </div>
              <div class="minefield-dice-face right face-3">
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
              </div>
              <div class="minefield-dice-face left face-4">
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
              </div>
              <div class="minefield-dice-face top face-5">
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
              </div>
              <div class="minefield-dice-face bottom face-6">
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
                <div class="minefield-dice-dot"></div>
              </div>
            </div>
          </div>
          <div style="font-size: 20px; color: #ff4444; margin-top: 15px;" id="minefield-damage-result">Rolling for damage...</div>
          <div style="font-size: 14px; margin-top: 15px; opacity: 0.8;">Click to continue</div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      // Start minefield dice rolling animation
      const minefieldDiceCube = document.getElementById('minefieldDiceCube');
      minefieldDiceCube.classList.add('rolling');
      
      // Remove any existing face visibility classes to show all faces during rolling
      minefieldDiceCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Start rolling animation
      let rollCount = 0;
      const rollInterval = setInterval(() => {
        const randomRoll = Math.floor(Math.random() * 6) + 1;
        setMinefieldDiceRotationForRolling(minefieldDiceCube, randomRoll);
        rollCount++;
        
        if (rollCount >= 10) { // Roll for 1 second (10 * 100ms)
          clearInterval(rollInterval);
          
          // Set final dice position
          setMinefieldDiceRotation(minefieldDiceCube, damage);
          minefieldDiceCube.classList.remove('rolling');
          
          // Update result text
          const minefieldResult = document.getElementById('minefield-damage-result');
          minefieldResult.textContent = `Takes ${damage} minefield damage!`;
          minefieldResult.style.color = '#ff6666';
        }
      }, 100);
      
      // Click to close
      overlay.onclick = () => {
        document.body.removeChild(overlay);
        if (callback) callback();
      };
      
      // Auto-close after 3 seconds
      setTimeout(() => {
        if (document.body.contains(overlay)) {
          document.body.removeChild(overlay);
          if (callback) callback();
        }
      }, 3000);
    }
    
    // Morale Animation Functions
    function showMoraleAnimation(unit, targetNumber, callback) {
      console.log(' [MORALE DEBUG] showMoraleAnimation called:', unit?.name, 'target:', targetNumber);
      
      if (moraleAnimationState.active) {
        console.log(' [MORALE DEBUG] Morale animation already active, returning');
        return;
      }
      
      moraleAnimationState.active = true;
      moraleAnimationState.callback = callback;
      moraleAnimationState.unit = unit;
      moraleAnimationState.target = targetNumber;
      
      // Roll actual morale value
      const moraleRoll = Math.floor(Math.random() * 6) + 1;
      moraleAnimationState.finalValue = moraleRoll;
      
      // Setup UI
      const overlay = document.getElementById('morale-overlay');
      const unitInfo = document.getElementById('morale-unit-info');
      const result = document.getElementById('morale-result');
      const target = document.getElementById('morale-target');
      const prompt = document.getElementById('morale-click-prompt');
      
      if (!overlay) {
        console.error(' [MORALE DEBUG] Morale overlay not found!');
        return;
      }
      
      if (!unitInfo || !result || !target || !prompt) {
        console.error(' [MORALE DEBUG] One or more morale UI elements not found!');
        console.error(' [MORALE DEBUG] unitInfo:', unitInfo, 'result:', result, 'target:', target, 'prompt:', prompt);
        return;
      }
      
      console.log(' [MORALE DEBUG] All morale UI elements found successfully');
      
      unitInfo.textContent = `${unit.name} must roll ${targetNumber}+ on a d6 to maintain morale`;
      target.textContent = `Target: ${targetNumber}`;
      result.innerHTML = '<div>Rolling for morale...</div>';
      prompt.style.display = 'none';
      
      console.log(' [MORALE DEBUG] Setting overlay display to flex');
      overlay.style.display = 'flex';
      overlay.style.visibility = 'visible';
      overlay.style.opacity = '1';
      
      // Force a reflow to ensure the display change takes effect
      overlay.offsetHeight;
      
      console.log(' [MORALE DEBUG] Overlay display style:', overlay.style.display);
      console.log(' [MORALE DEBUG] Overlay computed style:', window.getComputedStyle(overlay).display);
      
      // Check if overlay is visible
      const rect = overlay.getBoundingClientRect();
      console.log(' [MORALE DEBUG] Overlay bounds:', rect);
      
      // Start rolling animation
      startMoraleRolling();
      
      // Stop rolling after duration (but don't close the screen)
      setTimeout(() => {
        stopMoraleRolling();
      }, moraleAnimationState.rollDuration);
    }
    
    function startMoraleRolling() {
      console.log(' [MORALE DEBUG] startMoraleRolling called');
      const moraleCube = document.getElementById('moraleDiceCube');
      
      if (!moraleCube) {
        console.error(' [MORALE DEBUG] Morale dice cube not found!');
        return;
      }
      
      // Add rolling animation
      moraleCube.classList.add('rolling');
      console.log(' [MORALE DEBUG] Added rolling class to morale cube');
      
      moraleAnimationState.rollIntervalId = setInterval(() => {
        moraleAnimationState.currentRoll = Math.floor(Math.random() * 6) + 1;
        // Update dice rotation during rolling
        setMoraleDiceRotation(moraleCube, moraleAnimationState.currentRoll);
      }, 150);
    }
    
    function stopMoraleRolling() {
      if (moraleAnimationState.rollIntervalId) {
        clearInterval(moraleAnimationState.rollIntervalId);
        moraleAnimationState.rollIntervalId = null;
      }
      
      // Show final value
      const moraleCube = document.getElementById('moraleDiceCube');
      const result = document.getElementById('morale-result');
      const prompt = document.getElementById('morale-click-prompt');
      
      // Set final dice position
      setMoraleDiceRotation(moraleCube, moraleAnimationState.finalValue);
      
      // Remove rolling animation
      moraleCube.classList.remove('rolling');
      
      // Show results
      let resultText = `<div>Rolled: ${moraleAnimationState.finalValue}</div>`;
      
      if (moraleAnimationState.finalValue >= moraleAnimationState.target) {
        resultText += `<div style="color: #32CD32; font-weight: bold; margin-top: 10px;">MORALE HOLDS!</div>`;
        resultText += `<div style="color: #32CD32;">Unit stands firm!</div>`;
      } else {
        resultText += `<div style="color: #FF4500; font-weight: bold; margin-top: 10px;">MORALE BREAKS!</div>`;
        resultText += `<div style="color: #FF4500;">Unit retreats or routes!</div>`;
      }
      
      result.innerHTML = resultText;
      
      prompt.style.display = 'block';
    }
    
    function closeMoraleAnimation() {
      if (!moraleAnimationState.active) return;
      
      // Stop rolling first
      stopMoraleRolling();
      
      const overlay = document.getElementById('morale-overlay');
      overlay.style.display = 'none';
      
      // Reset dice to initial state for next time
      const moraleCube = document.getElementById('moraleDiceCube');
      moraleCube.classList.remove('rolling');
      setMoraleDiceRotation(moraleCube, 1);
      
      // Execute callback with results
      if (moraleAnimationState.callback) {
        const success = moraleAnimationState.finalValue >= moraleAnimationState.target;
        moraleAnimationState.callback(success, moraleAnimationState.finalValue, moraleAnimationState.target);
      }
      
      moraleAnimationState.active = false;
      moraleAnimationState.callback = null;
      moraleAnimationState.unit = null;
    }
    
    // Morale dice rotation function
    function setMoraleDiceRotation(cubeElement, value) {
      // First, remove any existing face classes
      cubeElement.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Add the class for the face we want to show
      cubeElement.classList.add(`show-face-${value}`);
      
      // Also set the rotation as backup
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    
    function setMoraleDiceRotationForRolling(cubeElement, value) {
      // During rolling, only set the rotation, don't change visibility
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    
    // Artillery dice rotation function (slot machine style for hit chance)
    function setArtilleryDiceRotation(cubeElement, value) {
      // For slot machine style, just update the text content
      cubeElement.textContent = value;
    }
    
    function setArtilleryDiceRotationForRolling(cubeElement, value) {
      // During rolling, update the text content for slot machine effect
      cubeElement.textContent = value;
    }
    
    // Gas dice rotation function
    function setGasDiceRotation(cubeElement, value) {
      // First, remove any existing face classes
      cubeElement.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Add the class for the face we want to show
      cubeElement.classList.add(`show-face-${value}`);
      
      // Also set the rotation as backup
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    
    function setGasDiceRotationForRolling(cubeElement, value) {
      // During rolling, only set the rotation, don't change visibility
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    
    // Minefield dice rotation function
    function setMinefieldDiceRotation(cubeElement, value) {
      // First, remove any existing face classes
      cubeElement.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Add the class for the face we want to show
      cubeElement.classList.add(`show-face-${value}`);
      
      // Also set the rotation as backup
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    
    function setMinefieldDiceRotationForRolling(cubeElement, value) {
      // During rolling, only set the rotation, don't change visibility
      const rotation = diceRotations[value];
      cubeElement.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg) rotateZ(${rotation.z}deg)`;
    }
    

    
    // Artillery Animation Functions - Updated for "The Rains of Hell" System
    function showArtilleryAnimation(artillery, targetZone, hitChance, targetPos, callback) {
      console.log(' [ARTILLERY DEBUG] showArtilleryAnimation called:', artillery.name, 'target:', targetZone.name, 'hitChance:', hitChance, 'targetPos:', targetPos);
      
      if (artilleryAnimationState.active) {
        console.log(' [ARTILLERY DEBUG] Artillery animation already active, returning');
        return;
      }
      
      artilleryAnimationState.active = true;
      artilleryAnimationState.callback = callback;
      artilleryAnimationState.artillery = artillery;
      artilleryAnimationState.targetZone = targetZone;
      artilleryAnimationState.hitChance = hitChance;
      artilleryAnimationState.phase = 'hit';
      artilleryAnimationState.hitSuccess = false;
      artilleryAnimationState.precisionBonus = 0; // Initialize to 0
      
      // Note: Precision ability is already applied to hitChance in fireArtilleryAtZone function
      // We just need to check if there's a precision bonus to display in the UI
      if (artillery.special === 'precision' && artillery.targetHistory) {
        const targetKey = `${targetZone.id}_${targetPos}`;
        const consecutiveAttacks = artillery.targetHistory[targetKey] || 0;
        if (consecutiveAttacks >= 2) {
          const bonus = Math.min(consecutiveAttacks - 1, 3);
          artilleryAnimationState.precisionBonus = bonus;
          console.log(` [ARTILLERY PRECISION] ${artillery.name} has +${bonus} precision bonus from ${consecutiveAttacks} consecutive attacks on tile ${targetPos}`);
        }
      }
      
      // Setup UI for Phase 1: Hit Chance
      const overlay = document.getElementById('artillery-overlay');
      const artilleryInfo = document.getElementById('artillery-info');
      const hitPhase = document.getElementById('artillery-hit-phase');
      const combatPhase = document.getElementById('artillery-combat-phase');
      const hitResult = document.getElementById('artillery-hit-result');
      const hitTarget = document.getElementById('artillery-hit-target');
      const prompt = document.getElementById('artillery-click-prompt');
      const targetTileSpan = document.getElementById('artillery-target-tile');
      
      if (!overlay || !artilleryInfo || !hitPhase || !combatPhase || !hitResult || !hitTarget || !prompt || !targetTileSpan) {
        console.error(' [ARTILLERY DEBUG] One or more artillery UI elements not found!');
        return;
      }
      
      // Set the target tile number in the UI
      targetTileSpan.textContent = targetPos;
      
              const zoneName = zoneNames[targetZone.name] || targetZone.name;
      artilleryInfo.textContent = `${artillery.name} preparing "The Rains of Hell" on Zone ${zoneName} - Tile ${targetPos}`;
      
      let targetText = `Target: ${hitChance}+`;
      console.log(` [UI DEBUG] Setting target text - hitChance: ${hitChance}, precisionBonus: ${artilleryAnimationState.precisionBonus}`);
      if (artilleryAnimationState.precisionBonus > 0) {
        const originalHitChance = hitChance + artilleryAnimationState.precisionBonus;
        targetText = `Target: ${originalHitChance}+ (${hitChance}+ with precision)`;
        console.log(` [UI DEBUG] Precision bonus applied - originalHitChance: ${originalHitChance}, final targetText: ${targetText}`);
      }
      hitTarget.textContent = targetText;
      hitResult.innerHTML = '<div>Rolling for hit...</div>';
      prompt.style.display = 'none';
      
      // Show only hit phase initially
      hitPhase.style.display = 'block';
      combatPhase.style.display = 'none';
      
      overlay.style.display = 'flex';
      
      // Start Phase 1: Hit Chance Roll
      startArtilleryHitRoll();
      
      // Stop rolling after duration
      setTimeout(() => {
        stopArtilleryHitRoll();
      }, artilleryAnimationState.rollDuration);
    }
    
    function startArtilleryHitRoll() {
      const artilleryHitDiceCube = document.getElementById('artilleryHitDiceCube');
      
      if (!artilleryHitDiceCube) {
        console.error(' [ARTILLERY DEBUG] Artillery hit dice cube not found!');
        return;
      }
      
      // Add rolling animation for slot machine
      artilleryHitDiceCube.classList.add('rolling');
      
      artilleryAnimationState.rollIntervalId = setInterval(() => {
        artilleryAnimationState.currentRoll = Math.floor(Math.random() * 10) + 1;
        setArtilleryDiceRotationForRolling(artilleryHitDiceCube, artilleryAnimationState.currentRoll);
      }, 100);
    }
    
    function stopArtilleryHitRoll() {
      if (artilleryAnimationState.rollIntervalId) {
        clearInterval(artilleryAnimationState.rollIntervalId);
        artilleryAnimationState.rollIntervalId = null;
      }
      
      // Roll actual hit chance (d10)
      const hitRoll = Math.floor(Math.random() * 10) + 1;
      artilleryAnimationState.finalValue = hitRoll;
      
      // Note: hitChance already includes precision bonus from fireArtilleryAtZone
      artilleryAnimationState.hitSuccess = hitRoll >= artilleryAnimationState.hitChance;
      
      // Show final value
      const artilleryHitDiceCube = document.getElementById('artilleryHitDiceCube');
      const hitResult = document.getElementById('artillery-hit-result');
      const prompt = document.getElementById('artillery-click-prompt');
      
      if (!artilleryHitDiceCube || !hitResult || !prompt) {
        console.error(' [ARTILLERY DEBUG] Artillery hit UI elements not found!');
        return;
      }
      
      // Set final dice position
      setArtilleryDiceRotation(artilleryHitDiceCube, hitRoll);
      artilleryHitDiceCube.classList.remove('rolling');
      
      // Show hit results
      let resultText = `<div>Rolled: ${hitRoll}</div>`;
      let targetText = `Needed: ${artilleryAnimationState.hitChance}+`;
      console.log(` [UI DEBUG] stopArtilleryHitRoll - hitChance: ${artilleryAnimationState.hitChance}, precisionBonus: ${artilleryAnimationState.precisionBonus}`);
      if (artilleryAnimationState.precisionBonus > 0) {
        const originalHitChance = artilleryAnimationState.hitChance + artilleryAnimationState.precisionBonus;
        targetText = `Needed: ${originalHitChance}+ (${artilleryAnimationState.hitChance}+ with precision bonus)`;
        console.log(` [UI DEBUG] stopArtilleryHitRoll precision applied - originalHitChance: ${originalHitChance}, final targetText: ${targetText}`);
      }
      resultText += `<div>${targetText}</div>`;
      
      if (artilleryAnimationState.hitSuccess) {
        resultText += `<div style="color: #FF4500; font-weight: bold; margin-top: 15px;">HIT SUCCESSFUL!</div>`;
        resultText += `<div style="color: #FF4500;">Proceeding to Phase 2: The Rains of Hell</div>`;
        
        // Show combat phase after a short delay
      setTimeout(() => {
          startArtilleryCombatPhase();
        }, 1500);
      } else {
        resultText += `<div style="color: #4169E1; font-weight: bold; margin-top: 15px;">HIT FAILED!</div>`;
        resultText += `<div style="color: #4169E1;">The barrage falls short!</div>`;
        
        // Show continue prompt for miss
        prompt.style.display = 'block';
      }
      
      hitResult.innerHTML = resultText;
    }
    
    function startArtilleryCombatPhase() {
      artilleryAnimationState.phase = 'combat';
      
      // Hide hit phase and show combat phase
      const hitPhase = document.getElementById('artillery-hit-phase');
      const combatPhase = document.getElementById('artillery-combat-phase');
      const prompt = document.getElementById('artillery-click-prompt');
      
      if (!hitPhase || !combatPhase || !prompt) {
        console.error(' [ARTILLERY DEBUG] Artillery combat phase UI elements not found!');
        return;
      }
      
      hitPhase.style.display = 'none';
      combatPhase.style.display = 'block';
      prompt.style.display = 'none';
      
      // Calculate combat bonuses
      const artillery = artilleryAnimationState.artillery;
      const targetZone = artilleryAnimationState.targetZone;
      
      let attackBonus = artillery.attack || 0;
      let defenseBonus = 0;
      let precisionBonus = 0;
      
      // Apply special abilities to artillery (excluding precision which affects hit chance)
      if (artillery.special && artillery.special !== 'none' && artillery.special !== 'precision') {
        const ability = specialAbilities[artillery.special];
        if (ability && ability.apply) {
          const abilityEffects = ability.apply(artillery, null, null, targetZone.id);
          if (abilityEffects.attackBonus) {
            attackBonus += abilityEffects.attackBonus;
            console.log(` [ARTILLERY] ${artillery.name} gets +${abilityEffects.attackBonus} attack bonus from ${artillery.special}`);
          }
        }
      }
      
      // Calculate defender bonus (sum of all unit defenses in zone) with terrain effects
      let totalDefense = 0;
      let unitCount = 0;
      const defendingUnits = [];
      
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = targetZone.tacticalGrid[pos].unit;
        if (unit && unit.player !== gameState.currentPlayer) {
          let unitDefense = unit.defense || 0;
          
          // Apply terrain effects to unit defense
          const gridData = targetZone.tacticalGrid[pos];
          const terrainEffect = terrainEffects[gridData.terrain];
          if (terrainEffect) {
            if (terrainEffect.defenseBonus) {
              unitDefense += terrainEffect.defenseBonus;
              console.log(` [ARTILLERY TERRAIN] ${unit.name} on ${gridData.terrain} gets ${terrainEffect.defenseBonus >= 0 ? '+' : ''}${terrainEffect.defenseBonus} defense from terrain`);
            }
            if (terrainEffect.attackBonus) {
              // For artillery, terrain attack bonuses don't apply to defenders
              console.log(` [ARTILLERY TERRAIN] ${unit.name} on ${gridData.terrain} has ${terrainEffect.attackBonus >= 0 ? '+' : ''}${terrainEffect.attackBonus} attack bonus from terrain (not applied to artillery defense)`);
            }
          }
          
          totalDefense += unitDefense;
          unitCount++;
          defendingUnits.push({ name: unit.name, defense: unitDefense, terrain: gridData.terrain });
          console.log(` [ARTILLERY DEFENSE] ${unit.name} on ${gridData.terrain} contributes ${unitDefense} defense (base: ${unit.defense || 0}, terrain: ${terrainEffect ? terrainEffect.defenseBonus || 0 : 0})`);
        }
      }
      
      // Use total defense instead of average for more accurate representation
      defenseBonus = totalDefense;
      
      console.log(` [ARTILLERY DEFENSE] Total defense: ${totalDefense} from ${unitCount} units`);
      
      // Get actual combat values for proper bonus calculation
      console.log(' [ARTILLERY DICE DEBUG] Getting grid data for artillery position:', artillery.position);
      const attackerGridData = getGridDataAtPosition(artillery.position);
      console.log(' [ARTILLERY DICE DEBUG] Artillery grid data:', attackerGridData ? 'exists' : 'null');
      
      const attackerCombatValues = getActualCombatValues(artillery, artillery.position, attackerGridData);
      
      // Calculate total defense from all individual units in target zone
      let actualTotalDefense = 0;
      const gridSize = gameConfig.gridSize;
      
      for (let pos = 0; pos < gridSize * gridSize; pos++) {
        const cell = targetZone.tacticalGrid[pos];
        if (cell && cell.unit && cell.unit.player !== artillery.player) {
          const unitCombatValues = getActualCombatValues(cell.unit, pos, cell);
          actualTotalDefense += unitCombatValues.actualDefense;
          console.log(` [ARTILLERY DEBUG] Unit ${cell.unit.name} at position ${pos} defense: ${unitCombatValues.actualDefense}`);
        }
      }
      
      console.log(` [ARTILLERY DICE DEBUG] Attacker actual attack: ${attackerCombatValues.actualAttack}`);
      console.log(` [ARTILLERY DICE DEBUG] Target total defense: ${actualTotalDefense}`);
      
      // Use the actual combat values from getActualCombatValues instead of manual calculation
      // This ensures we include all bonuses including construction effects
      artilleryAnimationState.attackerBonus = attackerCombatValues.actualAttack;
      artilleryAnimationState.defenderBonus = actualTotalDefense;
      
      // Roll actual dice values with bonuses (like No Man's Land combat)
      console.log(` [ARTILLERY DICE DEBUG] Calculating dice rolls with bonuses...`);
      console.log(` [ARTILLERY DICE DEBUG] Attack bonus: ${artilleryAnimationState.attackerBonus}, Defense bonus: ${artilleryAnimationState.defenderBonus}`);
      
      const attackerRoll = Math.floor(Math.random() * 6) + 1 + artilleryAnimationState.attackerBonus;
      const defenderRoll = Math.floor(Math.random() * 6) + 1 + artilleryAnimationState.defenderBonus;
      
      artilleryAnimationState.attackerRoll = attackerRoll;
      artilleryAnimationState.defenderRoll = defenderRoll;
      artilleryAnimationState.attackTotal = attackerRoll;
      artilleryAnimationState.defenseTotal = defenderRoll;
      
      // Setup combat UI
      const artilleryAttackerLabel = document.getElementById('artillery-attacker-label');
      const artilleryDefenderLabel = document.getElementById('artillery-defender-label');
      const artilleryAttackBonus = document.getElementById('artillery-attack-bonus');
      const artilleryDefenseBonus = document.getElementById('artillery-defense-bonus');
      const artilleryCombatResult = document.getElementById('artillery-combat-result');
      
      if (!artilleryAttackerLabel || !artilleryDefenderLabel || !artilleryAttackBonus || !artilleryDefenseBonus || !artilleryCombatResult) {
        console.error(' [ARTILLERY DEBUG] Artillery combat UI elements not found!');
        return;
      }
      
      artilleryAttackerLabel.textContent = `${artillery.name}`;
      artilleryDefenderLabel.textContent = `Zone ${zoneNames[targetZone.name] || targetZone.name}`;
      
      // Show attack bonus
      artilleryAttackBonus.textContent = artilleryAnimationState.attackerBonus >= 0 ? `+${artilleryAnimationState.attackerBonus}` : `${artilleryAnimationState.attackerBonus}`;
      
      // Show defense bonus with terrain info
      let defenseText = artilleryAnimationState.defenderBonus >= 0 ? `+${artilleryAnimationState.defenderBonus}` : `${artilleryAnimationState.defenderBonus}`;
      if (defendingUnits.length > 0) {
        const terrainInfo = defendingUnits.map(unit => `${unit.name} on ${unit.terrain}`).join(', ');
        console.log(` [ARTILLERY UI] Defense bonus: ${defenseText} from units: ${terrainInfo}`);
      }
      artilleryDefenseBonus.textContent = defenseText;
      
      artilleryCombatResult.innerHTML = '<div>Combat resolution...</div>';
      
      // Start combat dice rolling
      startArtilleryCombatRoll();
      
      // Stop rolling after duration
      setTimeout(() => {
        stopArtilleryCombatRoll();
      }, artilleryAnimationState.rollDuration);
    }
    
    function startArtilleryCombatRoll() {
      const artilleryAttackerDiceCube = document.getElementById('artilleryAttackerDiceCube');
      const artilleryDefenderDiceCube = document.getElementById('artilleryDefenderDiceCube');
      
      if (!artilleryAttackerDiceCube || !artilleryDefenderDiceCube) {
        console.error(' [ARTILLERY DEBUG] Artillery combat dice cubes not found!');
        return;
      }
      
      // Remove any existing face visibility classes to show all faces during rolling
      artilleryAttackerDiceCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      artilleryDefenderDiceCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Add rolling animation classes
      artilleryAttackerDiceCube.classList.add('rolling', 'left-dice');
      artilleryDefenderDiceCube.classList.add('rolling', 'right-dice');
      
      artilleryAnimationState.rollIntervalId = setInterval(() => {
        // During rolling, show base dice values (1-6) for visual effect
        artilleryAnimationState.currentAttackerRoll = Math.floor(Math.random() * 6) + 1;
        artilleryAnimationState.currentDefenderRoll = Math.floor(Math.random() * 6) + 1;
        console.log(` [ARTILLERY ROLLING DEBUG] Rolling dice: ${artilleryAnimationState.currentAttackerRoll} vs ${artilleryAnimationState.currentDefenderRoll} (base values)`);
        setDiceRotationForRolling(artilleryAttackerDiceCube, artilleryAnimationState.currentAttackerRoll);
        setDiceRotationForRolling(artilleryDefenderDiceCube, artilleryAnimationState.currentDefenderRoll);
      }, 150);
    }
    
    function stopArtilleryCombatRoll() {
      if (artilleryAnimationState.rollIntervalId) {
        clearInterval(artilleryAnimationState.rollIntervalId);
        artilleryAnimationState.rollIntervalId = null;
      }
      
      // Show final values
      const artilleryAttackerDiceCube = document.getElementById('artilleryAttackerDiceCube');
      const artilleryDefenderDiceCube = document.getElementById('artilleryDefenderDiceCube');
      const artilleryAttackerResult = document.getElementById('artillery-attacker-result');
      const artilleryDefenderResult = document.getElementById('artillery-defender-result');
      const artilleryCombatResult = document.getElementById('artillery-combat-result');
      const prompt = document.getElementById('artillery-click-prompt');
      
      if (!artilleryAttackerDiceCube || !artilleryDefenderDiceCube || !artilleryAttackerResult || !artilleryDefenderResult || !artilleryCombatResult || !prompt) {
        console.error(' [ARTILLERY DEBUG] Artillery combat result UI elements not found!');
        return;
      }
      
      // Calculate base dice values (1-6) for dice display
      const attackerBaseRoll = artilleryAnimationState.attackerRoll - artilleryAnimationState.attackerBonus;
      const defenderBaseRoll = artilleryAnimationState.defenderRoll - artilleryAnimationState.defenderBonus;
      
      // Set final dice positions
      console.log(` [ARTILLERY FINAL DEBUG] Final results with bonuses:`);
      console.log(` [ARTILLERY FINAL DEBUG] Attacker: ${artilleryAnimationState.attackerRoll} (base: ${attackerBaseRoll} + bonus: ${artilleryAnimationState.attackerBonus})`);
      console.log(` [ARTILLERY FINAL DEBUG] Defender: ${artilleryAnimationState.defenderRoll} (base: ${defenderBaseRoll} + bonus: ${artilleryAnimationState.defenderBonus})`);
      
      setDiceRotation(artilleryAttackerDiceCube, attackerBaseRoll);
      setDiceRotation(artilleryDefenderDiceCube, defenderBaseRoll);
      
      artilleryAttackerDiceCube.classList.remove('rolling', 'left-dice');
      artilleryDefenderDiceCube.classList.remove('rolling', 'right-dice');
      
      // Show results
      artilleryAttackerResult.textContent = `${attackerBaseRoll}${artilleryAnimationState.attackerBonus >= 0 ? '+' : ''}${artilleryAnimationState.attackerBonus} = ${artilleryAnimationState.attackTotal}`;
      artilleryDefenderResult.textContent = `${defenderBaseRoll}${artilleryAnimationState.defenderBonus >= 0 ? '+' : ''}${artilleryAnimationState.defenderBonus} = ${artilleryAnimationState.defenseTotal}`;
      
      // Determine combat result
      let resultText = '';
      if (artilleryAnimationState.attackTotal > artilleryAnimationState.defenseTotal) {
        const damage = artilleryAnimationState.attackTotal - artilleryAnimationState.defenseTotal;
        resultText = `<div style="color: #FF4500; font-weight: bold; margin-top: 15px;">THE RAINS OF HELL SUCCEED!</div>`;
        resultText += `<div style="color: #FF4500;">Deals ${damage} damage to the unit!</div>`;
      } else {
        resultText = `<div style="color: #4169E1; font-weight: bold; margin-top: 15px;">THE RAINS OF HELL FAILED!</div>`;
        resultText += `<div style="color: #4169E1;">The defenders withstand the barrage!</div>`;
      }
      
      artilleryCombatResult.innerHTML = resultText;
      console.log(' [ARTILLERY COMBAT FINAL DEBUG] Showing continue button for artillery combat phase');
      prompt.style.display = 'block';
    }
    
    function startArtilleryRolling() {
      const artilleryDiceCube = document.getElementById('artilleryDiceCube');
      
      // Remove any existing face visibility classes to show all faces during rolling
      artilleryDiceCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      artilleryAnimationState.rollIntervalId = setInterval(() => {
        artilleryAnimationState.currentRoll = Math.floor(Math.random() * 6) + 1;
        setArtilleryDiceRotationForRolling(artilleryDiceCube, artilleryAnimationState.currentRoll);
      }, 100);
    }
    
    function stopArtilleryRolling() {
      if (artilleryAnimationState.rollIntervalId) {
        clearInterval(artilleryAnimationState.rollIntervalId);
        artilleryAnimationState.rollIntervalId = null;
      }
      
      // Show final value
      const artilleryDiceCube = document.getElementById('artilleryDiceCube');
      const result = document.getElementById('artillery-result');
      const prompt = document.getElementById('artillery-click-prompt');
      
      // Set final dice position
      setArtilleryDiceRotation(artilleryDiceCube, artilleryAnimationState.finalValue);
      artilleryDiceCube.classList.remove('rolling');
      
      // Show results
      let resultText = `<div>Rolled: ${artilleryAnimationState.finalValue}</div>`;
      resultText += `<div>Needed: ${artilleryAnimationState.hitChance}+</div>`;
      
      if (artilleryAnimationState.finalValue >= artilleryAnimationState.hitChance) {
        resultText += `<div style="color: #FF4500; font-weight: bold; margin-top: 15px;">ARTILLERY HITS!</div>`;
        const zoneName = zoneNames[artilleryAnimationState.targetZone.name] || artilleryAnimationState.targetZone.name;
        resultText += `<div style="color: #FF4500;">Zone ${zoneName} takes damage!</div>`;
      } else {
        resultText += `<div style="color: #4169E1; font-weight: bold; margin-top: 15px;">ARTILLERY MISSES!</div>`;
        resultText += `<div style="color: #4169E1;">The barrage falls short!</div>`;
      }
      
      result.innerHTML = resultText;
      
      console.log(' [ARTILLERY FINAL DEBUG] Showing continue button for artillery combat');
      prompt.style.display = 'block';
    }
    
    function closeArtilleryAnimation() {
      if (!artilleryAnimationState.active) return;
      
      // Stop any active rolling
      if (artilleryAnimationState.rollIntervalId) {
        clearInterval(artilleryAnimationState.rollIntervalId);
        artilleryAnimationState.rollIntervalId = null;
      }
      
      const overlay = document.getElementById('artillery-overlay');
      overlay.style.display = 'none';
      
      // Reset dice to initial state for next time
      const artilleryHitDiceCube = document.getElementById('artilleryHitDiceCube');
      const artilleryAttackerDiceCube = document.getElementById('artilleryAttackerDiceCube');
      const artilleryDefenderDiceCube = document.getElementById('artilleryDefenderDiceCube');
      
      if (artilleryHitDiceCube) {
        artilleryHitDiceCube.classList.remove('rolling');
        setArtilleryDiceRotation(artilleryHitDiceCube, 1);
      }
      
      if (artilleryAttackerDiceCube) {
        artilleryAttackerDiceCube.classList.remove('rolling', 'left-dice', 'winner', 'loser');
        setDiceRotation(artilleryAttackerDiceCube, 1);
      }
      
      if (artilleryDefenderDiceCube) {
        artilleryDefenderDiceCube.classList.remove('rolling', 'right-dice', 'winner', 'loser');
        setDiceRotation(artilleryDefenderDiceCube, 1);
      }
      
      // Execute callback with results
      if (artilleryAnimationState.callback) {
        let success = false;
        let damage = 0;
        
        if (artilleryAnimationState.hitSuccess && artilleryAnimationState.phase === 'combat') {
          // Both hit chance and combat succeeded
          success = artilleryAnimationState.attackTotal > artilleryAnimationState.defenseTotal;
          if (success) {
            damage = artilleryAnimationState.attackTotal - artilleryAnimationState.defenseTotal;
          }
        } else if (!artilleryAnimationState.hitSuccess) {
          // Hit chance failed
          success = false;
        }
        
        console.log(' [ARTILLERY DEBUG] Executing callback with success:', success, 'hitSuccess:', artilleryAnimationState.hitSuccess, 'damage:', damage);
        artilleryAnimationState.callback(success, artilleryAnimationState.finalValue, artilleryAnimationState.hitChance, damage);
      }
      
      // Reset animation state
      artilleryAnimationState.active = false;
      artilleryAnimationState.callback = null;
      artilleryAnimationState.artillery = null;
      artilleryAnimationState.targetZone = null;
      artilleryAnimationState.phase = 'hit';
      artilleryAnimationState.hitSuccess = false;
      artilleryAnimationState.attackerRoll = 0;
      artilleryAnimationState.defenderRoll = 0;
      artilleryAnimationState.attackerBonus = 0;
      artilleryAnimationState.defenderBonus = 0;
      artilleryAnimationState.attackTotal = 0;
      artilleryAnimationState.defenseTotal = 0;
    }
    
    // Aerial Combat Animation Functions - Updated to Mirror Grid Battle System
    function showAerialAnimation(attacker, target, targetPos, callback) {
      console.log(' [AERIAL DEBUG] showAerialAnimation called:', attacker?.name, 'vs', target?.name, 'at position:', targetPos);
      
      if (aerialAnimationState.active) {
        console.log(' [AERIAL DEBUG] Aerial animation already active, forcing reset');
        // Force reset the animation state if it's stuck
        aerialAnimationState.active = false;
        aerialAnimationState.callback = null;
        aerialAnimationState.attacker = null;
        aerialAnimationState.target = null;
        if (aerialAnimationState.rollIntervalId) {
          clearInterval(aerialAnimationState.rollIntervalId);
          aerialAnimationState.rollIntervalId = null;
        }
        // Hide any existing overlay
        const overlay = document.getElementById('aerial-overlay');
        if (overlay) {
          overlay.style.display = 'none';
        }
      }
      
      aerialAnimationState.active = true;
      aerialAnimationState.callback = callback;
      aerialAnimationState.attacker = attacker;
      aerialAnimationState.target = target;
      
      // Calculate bonuses (mirroring grid battle system)
      let attackBonus = attacker.attack || 0;
      let defenseBonus = target.defense || 0;
      
      // Initialize target position and grid data variables
      let localTargetPos = targetPos;
      let targetGridData = null;
      
      // Find target position and grid data if not provided
      if (localTargetPos === null || localTargetPos === undefined) {
        if (currentZoneDetail && currentZoneDetail.tacticalGrid) {
          console.log(' [AERIAL DEBUG] Searching for target:', target.name, 'with ID:', target.id);
          console.log(' [AERIAL DEBUG] Current zone tactical grid length:', currentZoneDetail.tacticalGrid.length);
          
          for (let pos = 0; pos < currentZoneDetail.tacticalGrid.length; pos++) {
            const gridData = currentZoneDetail.tacticalGrid[pos];
            if (gridData && gridData.unit) {
              console.log(' [AERIAL DEBUG] Checking position:', pos, 'unit:', gridData.unit.name, 'ID:', gridData.unit.id);
              if (gridData.unit.id === target.id) {
                localTargetPos = pos;
                targetGridData = gridData;
                console.log(' [AERIAL DEBUG] Found target at position:', pos, 'with terrain:', targetGridData.terrain);
                break;
              }
            }
          }
        }
      } else {
        // Use the provided target position
        targetGridData = currentZoneDetail && currentZoneDetail.tacticalGrid ? currentZoneDetail.tacticalGrid[localTargetPos] : null;
        console.log(' [AERIAL DEBUG] Using provided target position:', localTargetPos, 'Target grid data exists:', !!targetGridData);
      }
      
      // Apply terrain effects to aerial attacker (if any terrain effects apply to aerial units)
      // Note: Most terrain effects don't apply to aerial units, but we log for debugging
      if (targetGridData && targetGridData.terrain) {
        const terrainEffect = terrainEffects[targetGridData.terrain];
        if (terrainEffect) {
          console.log(` [AERIAL TERRAIN] Aerial attacker ${attacker.name} targeting unit on ${targetGridData.terrain} terrain`);
          if (terrainEffect.attackBonus) {
            console.log(` [AERIAL TERRAIN] Terrain has ${terrainEffect.attackBonus >= 0 ? '+' : ''}${terrainEffect.attackBonus} attack bonus (not applied to aerial attackers)`);
          }
          if (terrainEffect.defenseBonus) {
            console.log(` [AERIAL TERRAIN] Terrain has ${terrainEffect.defenseBonus >= 0 ? '+' : ''}${terrainEffect.defenseBonus} defense bonus (will be applied to defender)`);
          }
        }
      }
      
      // Apply special abilities to aerial unit
      if (attacker.special && attacker.special !== 'none') {
        console.log(' [AERIAL DEBUG] Applying special abilities for attacker:', attacker.name, 'special:', attacker.special);
        const ability = specialAbilities[attacker.special];
        if (ability && ability.apply) {
          const abilityEffects = ability.apply(attacker, null, null, localTargetPos, targetGridData);
          if (abilityEffects.attackBonus) {
            attackBonus += abilityEffects.attackBonus;
            console.log(` [AERIAL] ${attacker.name} gets +${abilityEffects.attackBonus} attack bonus from ${attacker.special}`);
          }
        }
      }
      
      // Check for Carpet Bombing bonus for fighters
      if (attacker.type === 'fighter') {
        const currentPlayer = gameState.currentPlayer;
        const playerAerial = gameState.aerial[currentPlayer] || [];
        
        // Check if there's an airship with the hub in the sky alive
        const hasHubInTheSkyAirship = playerAerial.some(unit => 
          unit.type === 'airship' && 
          unit.special === 'the_hub_in_the_sky' && 
          unit.health > 0
        );
        
        if (hasHubInTheSkyAirship) {
          attackBonus += 1;
          console.log(` [THE HUB IN THE SKY] ${attacker.name} gets +1 attack bonus from friendly Airship with The Hub In The Sky`);
        }
      }
      
      // Apply terrain effects to defender
      if (targetGridData && targetGridData.terrain) {
        const terrainEffect = terrainEffects[targetGridData.terrain];
        if (terrainEffect) {
          if (terrainEffect.defenseBonus) {
            defenseBonus += terrainEffect.defenseBonus;
            console.log(` [AERIAL TERRAIN] ${target.name} on ${targetGridData.terrain} gets ${terrainEffect.defenseBonus >= 0 ? '+' : ''}${terrainEffect.defenseBonus} defense from terrain`);
          }
          if (terrainEffect.attackBonus) {
            // For aerial combat, terrain attack bonuses don't apply to defenders
            console.log(` [AERIAL TERRAIN] ${target.name} on ${targetGridData.terrain} has ${terrainEffect.attackBonus >= 0 ? '+' : ''}${terrainEffect.attackBonus} attack bonus from terrain (not applied to aerial defense)`);
          }
        }
      }
      
      // Apply special abilities to defender
      if (target.special && target.special !== 'none') {
        const ability = specialAbilities[target.special];
        if (ability && ability.apply) {
          const abilityEffects = ability.apply(target, localTargetPos, targetGridData);
          if (abilityEffects.defenseBonus) {
            defenseBonus += abilityEffects.defenseBonus;
            console.log(` [DEFENSE] ${target.name} gets +${abilityEffects.defenseBonus} defense bonus from ${target.special}`);
          }
        }
      }
      
      // Get actual combat values for proper bonus calculation
      console.log(' [AIR DICE DEBUG] Getting grid data for attacker position:', attacker.position);
      const attackerGridData = getGridDataAtPosition(attacker.position);
      console.log(' [AIR DICE DEBUG] Attacker grid data:', attackerGridData ? 'exists' : 'null');
      
      const attackerCombatValues = getActualCombatValues(attacker, attacker.position, attackerGridData, target.position, targetGridData);
      const targetCombatValues = getActualCombatValues(target, target.position, targetGridData);
      
      console.log(` [AIR DICE DEBUG] Attacker actual attack: ${attackerCombatValues.actualAttack}`);
      console.log(` [AIR DICE DEBUG] Target actual defense: ${targetCombatValues.actualDefense}`);
      
      // Use the actual combat values from getActualCombatValues instead of manual calculation
      // This ensures we include all bonuses including construction effects
      aerialAnimationState.attackerBonus = attackerCombatValues.actualAttack;
      aerialAnimationState.defenderBonus = targetCombatValues.actualDefense;
      
      // Roll actual dice values with bonuses (like No Man's Land combat)
      console.log(` [AIR DICE DEBUG] Calculating dice rolls with bonuses...`);
      console.log(` [AIR DICE DEBUG] Attack bonus: ${aerialAnimationState.attackerBonus}, Defense bonus: ${aerialAnimationState.defenderBonus}`);
      
      const attackerRoll = Math.floor(Math.random() * 6) + 1 + aerialAnimationState.attackerBonus;
      const defenderRoll = Math.floor(Math.random() * 6) + 1 + aerialAnimationState.defenderBonus;
      
      aerialAnimationState.attackerRoll = attackerRoll;
      aerialAnimationState.defenderRoll = defenderRoll;
      aerialAnimationState.attackTotal = attackerRoll;
      aerialAnimationState.defenseTotal = defenderRoll;
      
      // Setup UI
      const overlay = document.getElementById('aerial-overlay');
      const aerialInfo = document.getElementById('aerial-info');
      const aerialAttackerLabel = document.getElementById('aerial-attacker-label');
      const aerialDefenderLabel = document.getElementById('aerial-defender-label');
      const aerialAttackBonus = document.getElementById('aerial-attack-bonus');
      const aerialDefenseBonus = document.getElementById('aerial-defense-bonus');
      const aerialClickPrompt = document.getElementById('aerial-click-prompt');
      
      if (!overlay || !aerialInfo || !aerialAttackerLabel || !aerialDefenderLabel || !aerialAttackBonus || !aerialDefenseBonus || !aerialClickPrompt) {
        console.error(' [AERIAL DEBUG] One or more aerial UI elements not found!');
        return;
      }
      
      // Set up the animation
      aerialInfo.innerHTML = `${attacker.name} (${formatUnitType(attacker.type)}) vs ${target.name} (${formatUnitType(target.type)})`;
      aerialAttackerLabel.textContent = `${attacker.name}`;
      aerialDefenderLabel.textContent = `${target.name}`;
      aerialAttackBonus.textContent = aerialAnimationState.attackerBonus >= 0 ? `+${aerialAnimationState.attackerBonus}` : `${aerialAnimationState.attackerBonus}`;
      
      // Show defense bonus with terrain info
      let defenseText = aerialAnimationState.defenderBonus >= 0 ? `+${aerialAnimationState.defenderBonus}` : `${aerialAnimationState.defenderBonus}`;
      if (targetGridData && targetGridData.terrain) {
        const terrainEffect = terrainEffects[targetGridData.terrain];
        if (terrainEffect && terrainEffect.defenseBonus) {
          console.log(` [AERIAL UI] Defense bonus: ${defenseText} (includes ${terrainEffect.defenseBonus >= 0 ? '+' : ''}${terrainEffect.defenseBonus} from ${targetGridData.terrain} terrain)`);
        }
      }
      aerialDefenseBonus.textContent = defenseText;
      aerialClickPrompt.style.display = 'none';
      
      // Show overlay
      overlay.style.display = 'flex';
      
      // Start rolling animation
      startAerialRolling();
      
      // Stop rolling after duration (but don't close the screen)
      setTimeout(() => {
        stopAerialRolling();
      }, aerialAnimationState.rollDuration);
      
      // REMOVED: Auto-close animation timeout - user must click to continue
    }
    
    function startAerialRolling() {
      console.log(' [AERIAL DEBUG] startAerialRolling called');
      const aerialAttackerDiceCube = document.getElementById('aerialAttackerDiceCube');
      const aerialDefenderDiceCube = document.getElementById('aerialDefenderDiceCube');
      
      if (!aerialAttackerDiceCube || !aerialDefenderDiceCube) {
        console.error(' [AERIAL DEBUG] Aerial dice cubes not found!');
        return;
      }
      
      // Remove any existing face visibility classes to show all faces during rolling
      aerialAttackerDiceCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      aerialDefenderDiceCube.classList.remove('show-face-1', 'show-face-2', 'show-face-3', 'show-face-4', 'show-face-5', 'show-face-6');
      
      // Add rolling animation classes
      aerialAttackerDiceCube.classList.add('rolling', 'left-dice');
      aerialDefenderDiceCube.classList.add('rolling', 'right-dice');
      
      aerialAnimationState.rollIntervalId = setInterval(() => {
        // During rolling, show base dice values (1-6) for visual effect
        aerialAnimationState.currentAttackerRoll = Math.floor(Math.random() * 6) + 1;
        aerialAnimationState.currentDefenderRoll = Math.floor(Math.random() * 6) + 1;
        console.log(` [AIR ROLLING DEBUG] Rolling dice: ${aerialAnimationState.currentAttackerRoll} vs ${aerialAnimationState.currentDefenderRoll} (base values)`);
        setDiceRotationForRolling(aerialAttackerDiceCube, aerialAnimationState.currentAttackerRoll);
        setDiceRotationForRolling(aerialDefenderDiceCube, aerialAnimationState.currentDefenderRoll);
      }, 150);
    }
    
    function stopAerialRolling() {
      if (aerialAnimationState.rollIntervalId) {
        clearInterval(aerialAnimationState.rollIntervalId);
        aerialAnimationState.rollIntervalId = null;
      }
      
      // Show final values
      console.log(` [AIR FINAL DEBUG] Final results with bonuses:`);
      console.log(` [AIR FINAL DEBUG] Attacker: ${aerialAnimationState.attackerRoll} (base: ${aerialAnimationState.attackerRoll - aerialAnimationState.attackerBonus} + bonus: ${aerialAnimationState.attackerBonus})`);
      console.log(` [AIR FINAL DEBUG] Defender: ${aerialAnimationState.defenderRoll} (base: ${aerialAnimationState.defenderRoll - aerialAnimationState.defenderBonus} + bonus: ${aerialAnimationState.defenderBonus})`);
      
      const aerialAttackerDiceCube = document.getElementById('aerialAttackerDiceCube');
      const aerialDefenderDiceCube = document.getElementById('aerialDefenderDiceCube');
      const aerialAttackerResult = document.getElementById('aerial-attacker-result');
      const aerialDefenderResult = document.getElementById('aerial-defender-result');
      const aerialWinnerAnnouncement = document.getElementById('aerial-winner-announcement');
      const aerialClickPrompt = document.getElementById('aerial-click-prompt');
      
      // Set final dice positions (use base dice values, not total with bonuses)
      const attackerBaseRoll = aerialAnimationState.attackerRoll - aerialAnimationState.attackerBonus;
      const defenderBaseRoll = aerialAnimationState.defenderRoll - aerialAnimationState.defenderBonus;
      setDiceRotation(aerialAttackerDiceCube, attackerBaseRoll);
      setDiceRotation(aerialDefenderDiceCube, defenderBaseRoll);
      aerialAttackerDiceCube.classList.remove('rolling', 'left-dice');
      aerialDefenderDiceCube.classList.remove('rolling', 'right-dice');
      
      // Show results
      const attackTotal = aerialAnimationState.attackTotal;
      const defenseTotal = aerialAnimationState.defenseTotal;
      
      aerialAttackerResult.textContent = aerialAnimationState.attackerBonus !== 0 ?
        `${aerialAnimationState.attackerRoll}${aerialAnimationState.attackerBonus >= 0 ? '+' : ''}${aerialAnimationState.attackerBonus} = ${attackTotal}` :
        aerialAnimationState.attackerRoll;
      
      aerialDefenderResult.textContent = aerialAnimationState.defenderBonus !== 0 ?
        `${aerialAnimationState.defenderRoll}${aerialAnimationState.defenderBonus >= 0 ? '+' : ''}${aerialAnimationState.defenderBonus} = ${defenseTotal}` :
        aerialAnimationState.defenderRoll;
      
             // Clear previous winner announcement
       aerialWinnerAnnouncement.textContent = '';
       
       // Determine winner and show announcement
       if (attackTotal > defenseTotal) {
         const damage = attackTotal - defenseTotal;
         aerialWinnerAnnouncement.textContent = `${aerialAnimationState.attacker.name} VICTORY! Damage: ${damage}`;
         aerialAttackerDiceCube.parentElement.parentElement.classList.add('winner');
         aerialDefenderDiceCube.parentElement.parentElement.classList.add('loser');
       } else if (defenseTotal > attackTotal) {
         aerialWinnerAnnouncement.textContent = `${aerialAnimationState.target.name} DEFENDS!`;
         aerialDefenderDiceCube.parentElement.parentElement.classList.add('winner');
         aerialAttackerDiceCube.parentElement.parentElement.classList.add('loser');
       } else {
         aerialWinnerAnnouncement.textContent = 'DRAW!';
       }
      
      console.log(' [AIR FINAL DEBUG] Showing continue button for aerial combat');
      aerialClickPrompt.style.display = 'block';
    }
    
    function closeAerialAnimation() {
      console.log(' [AERIAL DEBUG] closeAerialAnimation called, active state:', aerialAnimationState.active);
      
      if (!aerialAnimationState.active) {
        console.log(' [AERIAL DEBUG] Animation not active, returning');
        return;
      }
      
      try {
        // Stop rolling first
        stopAerialRolling();
        
        const overlay = document.getElementById('aerial-overlay');
        if (overlay) {
          overlay.style.display = 'none';
        }
        
        // Reset dice to initial state for next time
        const aerialAttackerDiceCube = document.getElementById('aerialAttackerDiceCube');
        const aerialDefenderDiceCube = document.getElementById('aerialDefenderDiceCube');
        if (aerialAttackerDiceCube) {
          aerialAttackerDiceCube.classList.remove('rolling', 'left-dice', 'winner', 'loser');
          setDiceRotation(aerialAttackerDiceCube, 1);
        }
        if (aerialDefenderDiceCube) {
          aerialDefenderDiceCube.classList.remove('rolling', 'right-dice', 'winner', 'loser');
          setDiceRotation(aerialDefenderDiceCube, 1);
        }
        
        // Clear winner announcement and results
        const aerialWinnerAnnouncement = document.getElementById('aerial-winner-announcement');
        const aerialAttackerResult = document.getElementById('aerial-attacker-result');
        const aerialDefenderResult = document.getElementById('aerial-defender-result');
        const aerialClickPrompt = document.getElementById('aerial-click-prompt');
        
        if (aerialWinnerAnnouncement) {
          aerialWinnerAnnouncement.textContent = '';
          console.log(' [AERIAL DEBUG] Cleared winner announcement');
        }
        if (aerialAttackerResult) {
          aerialAttackerResult.textContent = '';
          console.log(' [AERIAL DEBUG] Cleared attacker result');
        }
        if (aerialDefenderResult) {
          aerialDefenderResult.textContent = '';
          console.log(' [AERIAL DEBUG] Cleared defender result');
        }
        if (aerialClickPrompt) {
          aerialClickPrompt.style.display = 'none';
          console.log(' [AERIAL DEBUG] Hidden click prompt');
        }
        
        // Remove winner/loser classes
        document.querySelectorAll('.aerial-dice-section').forEach(section => {
          section.classList.remove('winner', 'loser');
        });
        console.log(' [AERIAL DEBUG] Removed winner/loser classes');
        
        // Execute callback with results (using new grid battle system)
        if (aerialAnimationState.callback) {
          const attackTotal = aerialAnimationState.attackTotal;
          const defenseTotal = aerialAnimationState.defenseTotal;
          const success = attackTotal > defenseTotal;
          const damage = success ? aerialAnimationState.attackerRoll - aerialAnimationState.defenderRoll : 0;
          
          console.log(' [AERIAL DEBUG] Executing callback with success:', success, 'attackTotal:', attackTotal, 'defenseTotal:', defenseTotal, 'damage:', damage);
          aerialAnimationState.callback(success, attackTotal, defenseTotal);
        }
      } catch (error) {
        console.error(' [AERIAL DEBUG] Error in closeAerialAnimation:', error);
      } finally {
        // Always reset the state, even if there was an error
        aerialAnimationState.active = false;
        aerialAnimationState.callback = null;
        aerialAnimationState.attacker = null;
        aerialAnimationState.target = null;
        if (aerialAnimationState.rollIntervalId) {
          clearInterval(aerialAnimationState.rollIntervalId);
          aerialAnimationState.rollIntervalId = null;
        }
        console.log(' [AERIAL DEBUG] Aerial animation state reset');
      }
    }
    
    // Enhanced Screen management with smooth transitions
    function showScreen(screenId) {
          console.log(' ===== SHOWING SCREEN =====');
    console.log(' Target screen ID:', screenId);
      
      const currentActiveScreen = document.querySelector('.screen.active');
      const targetScreen = document.getElementById(screenId);
      
      console.log(' Current active screen:', currentActiveScreen?.id);
      console.log(' Target screen found:', !!targetScreen);
      
      if (!targetScreen) {
        console.error(' Screen not found:', screenId);
        return;
      }
      
      // Fade out current screen
      if (currentActiveScreen) {
        console.log(' Fading out current screen:', currentActiveScreen.id);
        
        // Reset scroll position when leaving zone-detail screen
        if (currentActiveScreen.id === 'zone-detail') {
          window.scrollTo(0, 0);
          
          // Also reset the zone detail screen's internal scroll
          const zoneDetail = document.getElementById('zone-detail');
          if (zoneDetail) {
            zoneDetail.scrollTop = 0;
            console.log(' [SCROLL DEBUG] Reset zone detail internal scroll to top when leaving screen');
          }
          
          console.log(' Reset scroll position when leaving zone-detail screen');
        }
        
        currentActiveScreen.classList.add('fade-out');
        setTimeout(() => {
          currentActiveScreen.classList.remove('active', 'fade-out');
          console.log(' Current screen faded out');
        }, 150);
      }
      
      // Fade in target screen
      setTimeout(() => {
        console.log(' Fading in target screen:', screenId);
        targetScreen.classList.add('active', 'fade-in');
        setTimeout(() => {
          targetScreen.classList.remove('fade-in');
          console.log(' Target screen fade-in complete');
        }, 300);
      }, 150);
      
      // Always show skeletal custom cursor and hide OS cursor
      try {
        const customCursorEl = document.getElementById('cursor');
        if (customCursorEl) {
          customCursorEl.style.display = '';
        }
        document.body.style.cursor = 'none';
      } catch (e) { console.warn('Cursor toggle error', e); }

      // Load screen-specific content
      if (screenId === 'unit-creator') {
        loadCustomUnits();
        // Initialize the unit creator after a short delay to ensure DOM is ready
        setTimeout(() => {
          initializeUnitCreator();
        }, 100);
      }
      if (screenId === 'game-setup') {
        console.log(' Game setup screen detected, initializing...');
        
        // Reset build point sliders to default values
        resetSingleplayerBuildPoints();
        
        // Ensure selectedArmies is initialized
        if (!gameData.selectedArmies) {
          console.log(' [DEBUG] Initializing gameData.selectedArmies');
          gameData.selectedArmies = { player1: [], player2: [] };
        }
        console.log(' [DEBUG] gameData.selectedArmies at game setup:', gameData.selectedArmies);
        
        // Immediately update the button state to prevent delay
        console.log(' Immediately updating Unleash Hell button state...');
        updateUnleashHellButton();
        
        // Initialize dropdowns and other setup
        setTimeout(() => {
          console.log(' Calling setupOpponentToggle after timeout...');
          setupOpponentToggle();
          console.log(' Calling loadArmyDropdowns after setupOpponentToggle...');
          loadArmyDropdowns();
          
          // Update the "Unleash Hell" button state immediately and after initialization
          console.log(' Updating Unleash Hell button state immediately...');
          updateUnleashHellButton();
          
          // Also update after a short delay to ensure everything is loaded
          setTimeout(() => {
            console.log(' Updating Unleash Hell button state after delay...');
            updateUnleashHellButton();
          }, 500);
          
          // Add a manual refresh button for debugging
          const debugButton = document.createElement('button');
          debugButton.textContent = ' Debug: Refresh Army Dropdowns';
          debugButton.style.cssText = 'position: fixed; top: 10px; right: 10px; z-index: 9999; background: #ff4444; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;';
          debugButton.onclick = () => {
            console.log(' [DEBUG] Manual refresh triggered');
            loadArmyDropdowns();
          };
          document.body.appendChild(debugButton);
          
          // Remove debug button after 10 seconds
          setTimeout(() => {
            if (debugButton.parentNode) {
              debugButton.parentNode.removeChild(debugButton);
            }
          }, 10000);
        }, 500); // Increased timeout to ensure DOM is ready
      }
      if (screenId === 'army-builder') loadArmyBuilder();
      if (screenId === 'zone-detail') {
        // Reset scroll position to top when entering zone detail screen
        window.scrollTo(0, 0);
        
        loadTerrainInfo();
        // Ensure Intelligence Report panel is visible when entering zone detail (preserve original styling)
        setTimeout(() => {
          const chatPanel = document.querySelector('.chat-panel');
          if (chatPanel) {
            // Only set display if it's currently hidden, otherwise preserve original styling
            if (chatPanel.style.display === 'none') {
              chatPanel.style.display = 'block';
              console.log(' [INTELLIGENCE DEBUG] Ensured Intelligence Report panel is visible when entering zone detail');
            } else {
              console.log(' [INTELLIGENCE DEBUG] Intelligence Report panel already visible when entering zone detail, preserving styling');
            }
            
            // Ensure scrollbar styling is preserved
            const chatMessages = chatPanel.querySelector('.chat-messages');
            if (chatMessages && chatMessages.style.overflowY === '') {
              chatMessages.style.overflowY = 'auto';
              console.log(' [INTELLIGENCE DEBUG] Restored chat-messages overflow-y styling when entering zone detail');
            }
          }
        }, 300); // Wait for fade-in to complete
      }
      if (screenId === 'game') renderBattlefield();
      if (screenId === 'game-setup') {
        console.log(' Game setup screen detected, loading army dropdowns...');
        // Load army dropdowns after the screen is shown
        setTimeout(() => {
          console.log(' Loading army dropdowns after timeout...');
          
          // Reset army selection for new game
          if (gameData && gameData.selectedArmies) {
            gameData.selectedArmies.player1 = [];
            gameData.selectedArmies.player2 = [];
            console.log(' [GAME SETUP] Cleared selected armies for new game');
          }
          
          // Reset dropdown selected text
          const player1ArmySelected = document.getElementById('player1ArmySelected');
          const player2ArmySelected = document.getElementById('player2ArmySelected');
          
          if (player1ArmySelected) {
            player1ArmySelected.textContent = 'Select Legion Type';
            console.log(' [GAME SETUP] Reset player1 dropdown to "Select Legion Type"');
          }
          
          if (player2ArmySelected) {
            player2ArmySelected.textContent = 'Select Legion Type';
            console.log(' [GAME SETUP] Reset player2 dropdown to "Select Legion Type"');
          }
          
          loadArmyDropdowns(); // Load army dropdowns for single player
        }, 350); // Wait for fade-in to complete
      }
      if (screenId === 'multiplayer-game-setup') {
        console.log(' Multiplayer game setup screen detected, scheduling restrictions...');
        // Apply name and color restrictions after the screen is shown
        setTimeout(() => {
          console.log(' Applying restrictions after timeout...');
          applyNameColorRestrictions();
          setupNameColorEventListeners();
          loadArmyDropdowns(); // Load army dropdowns for multiplayer
        }, 350); // Wait for fade-in to complete
      }
      if (screenId === 'settings') {
        console.log(' Settings screen detected, initializing...');
        // Initialize settings after the screen is shown
        setTimeout(() => {
          console.log(' Initializing settings after timeout...');
          initializeSettingsScreen();
        }, 350); // Wait for fade-in to complete
      }
      

      
      console.log(' ===== SCREEN SHOW COMPLETED =====');
    }
    
    // Opponent toggle setup removed (AI functionality removed)
    
    // AI difficulty slider setup removed
    
    // Load terrain information
    function loadTerrainInfo() {
      const container = document.getElementById('terrain-info-content');
      if (!container) return;
      
      container.innerHTML = '';
      
      for (const [terrain, effect] of Object.entries(terrainEffects)) {
        const entry = document.createElement('div');
        entry.className = 'terrain-entry';
        entry.innerHTML = `
          <span class="terrain-name">${terrain.charAt(0).toUpperCase() + terrain.slice(1)}:</span> 
          ${effect.description}
        `;
        container.appendChild(entry);
      }
    }
    
    // Zone count display update
    function updateZoneDisplay() {
      const zoneCountSlider = document.getElementById('zone-count');
      const zoneDisplay = document.getElementById('zone-display');
      if (!zoneCountSlider || !zoneDisplay) return;
      
      const zoneCount = zoneCountSlider.value;
      zoneDisplay.textContent = zoneCount;
      gameConfig.zoneCount = parseInt(zoneCount);
    }
    
    // Debug cursor function
    function debugCursor(elementId, event) {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      const computedStyle = window.getComputedStyle(element);
      const cursor = computedStyle.cursor;
      const elementType = element.tagName;
      const elementClass = element.className;
      
      console.log(`[CURSOR DEBUG] ${event} on ${elementId}:`);
      console.log(`  - Element: ${elementType}.${elementClass}`);
      console.log(`  - Computed cursor: ${cursor}`);
      console.log(`  - Inline cursor: ${element.style.cursor}`);
      console.log(`  - Element:`, element);
      
      // Force cursor to none if it's crosshair
      if (cursor === 'crosshair') {
        console.log(`[CURSOR DEBUG] Forcing cursor to none for ${elementId}`);
        element.style.cursor = 'none !important';
        element.style.setProperty('cursor', 'none', 'important');
      }
      
      // DEBUG: Check if this is a range input and inspect its pseudo-elements
      if (element.type === 'range') {
        console.log(`[CURSOR DEBUG] Range input detected, checking pseudo-elements...`);
        
        // Force cursor none on the element itself
        element.style.cursor = 'none !important';
        element.style.setProperty('cursor', 'none', 'important');
        
        // Try to force cursor none on pseudo-elements by creating a style rule
        const styleId = 'range-cursor-fix-' + elementId;
        let existingStyle = document.getElementById(styleId);
        if (!existingStyle) {
          existingStyle = document.createElement('style');
          existingStyle.id = styleId;
          existingStyle.textContent = `
            #${elementId}::-webkit-slider-thumb {
              cursor: none !important;
            }
            #${elementId}::-webkit-slider-thumb:hover {
              cursor: none !important;
            }
            #${elementId}::-webkit-slider-thumb:active {
              cursor: none !important;
            }
            #${elementId}::-moz-range-thumb {
              cursor: none !important;
            }
            #${elementId}::-moz-range-thumb:hover {
              cursor: none !important;
            }
            #${elementId}::-moz-range-thumb:active {
              cursor: none !important;
            }
            #${elementId}::-webkit-slider-track {
              cursor: none !important;
            }
            #${elementId}::-moz-range-track {
              cursor: none !important;
            }
          `;
          document.head.appendChild(existingStyle);
          console.log(`[CURSOR DEBUG] Added specific style rule for ${elementId}`);
        }
        
        // Try to get the slider thumb element (this is tricky since pseudo-elements aren't directly accessible)
        // But we can check if there are any CSS rules affecting the thumb
        const allStyles = document.styleSheets;
        let foundThumbRules = false;
        
        for (let i = 0; i < allStyles.length; i++) {
          try {
            const rules = allStyles[i].cssRules || allStyles[i].rules;
            for (let j = 0; j < rules.length; j++) {
              const rule = rules[j];
              if (rule.selectorText && rule.selectorText.includes('::-webkit-slider-thumb') && rule.selectorText.includes('cursor')) {
                console.log(`[CURSOR DEBUG] Found thumb rule:`, rule.selectorText, rule.style.cursor);
                foundThumbRules = true;
              }
            }
          } catch (e) {
            // Cross-origin stylesheets will throw errors
          }
        }
        
        if (!foundThumbRules) {
          console.log(`[CURSOR DEBUG] No explicit thumb cursor rules found, browser default may be crosshair`);
        }
        
        // Additional aggressive approach: try to override with CSS custom properties
        element.style.setProperty('--cursor-override', 'none');
        console.log(`[CURSOR DEBUG] Set CSS custom property --cursor-override to none`);
      }
    }
    

    
    // Slider updates
    document.addEventListener('DOMContentLoaded', function() {
      // Load custom units from localStorage
      loadCustomUnitsFromStorage();
      // Load saved armies from localStorage
      loadArmiesFromStorage();
      

      
      // Attack modifier slider
      const attackSlider = document.getElementById('attack-mod');
      const attackDisplay = document.getElementById('attack-display');
      if (attackSlider && attackDisplay) {
        attackSlider.addEventListener('input', function() {
          attackDisplay.textContent = this.value;
        });
      }
      
      // Defense modifier slider
      const defenseSlider = document.getElementById('defense-mod');
      const defenseDisplay = document.getElementById('defense-display');
      if (defenseSlider && defenseDisplay) {
        defenseSlider.addEventListener('input', function() {
          defenseDisplay.textContent = this.value;
        });
      }
      
      // Morale modifier slider
      const moraleSlider = document.getElementById('morale-mod');
      const moraleDisplay = document.getElementById('morale-display');
      if (moraleSlider && moraleDisplay) {
        moraleSlider.addEventListener('input', function() {
          moraleDisplay.textContent = this.value;
        });
      }
      
      // Range modifier slider
      const rangeSlider = document.getElementById('range-mod');
      const rangeDisplay = document.getElementById('range-display');
      if (rangeSlider && rangeDisplay) {
        rangeSlider.addEventListener('input', function() {
          rangeDisplay.textContent = this.value;
        });
      }
      
      // Movement modifier slider
      const movementSlider = document.getElementById('movement-mod');
      const movementDisplay = document.getElementById('movement-display');
      if (movementSlider && movementDisplay) {
        movementSlider.addEventListener('input', function() {
          movementDisplay.textContent = this.value;
        });
      }
      
      // Starting CP slider
      const cpSlider = document.getElementById('starting-cp');
      const cpDisplay = document.getElementById('cp-display');
      if (cpSlider && cpDisplay) {
        cpSlider.addEventListener('input', function() {
          cpDisplay.textContent = this.value;
        });
      }
      
      // AI CP slider
      const aiCpSlider = document.getElementById('ai-cp');
      const aiCpDisplay = document.getElementById('ai-cp-display');
      if (aiCpSlider && aiCpDisplay) {
        aiCpSlider.addEventListener('input', function() {
          aiCpDisplay.textContent = this.value;
        });
      }
      
          // Create tooltip element
    tooltipElement = document.createElement('div');
    tooltipElement.className = 'unit-tooltip';
    tooltipElement.style.display = 'none';
    tooltipElement.style.position = 'fixed'; // Ensure position is set
    tooltipElement.style.zIndex = '10000'; // Ensure high z-index
    document.body.appendChild(tooltipElement);
      
      // Grid size selection (only bind to actual size buttons)
      const gridSizeButtons = document.querySelectorAll('.grid-size-container .grid-size-btn[data-size]');
      gridSizeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
          // Toggle active state only among real grid-size buttons
          gridSizeButtons.forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          const selectedSize = parseInt(this.dataset.size, 10);
          if (!isNaN(selectedSize)) {
            gameConfig.gridSize = selectedSize;

            // Update mini-battlefield preview class if present
            const miniBattlefield = document.getElementById('mini-battlefield');
            if (miniBattlefield) {
              miniBattlefield.classList.remove('grid-6', 'grid-8', 'grid-10', 'grid-12');
              miniBattlefield.classList.add(`grid-${selectedSize}`);
            }
          }
        });
      });
      
      // Unit type selection for hit chance field - now handled by custom dropdowns
      // Initialize field visibility
      updateUnitTypeFields();
      
      // Hit chance slider
      const hitChanceSlider = document.getElementById('hit-chance-mod');
      const hitChanceDisplay = document.getElementById('hit-chance-display');
      if (hitChanceSlider && hitChanceDisplay) {
        hitChanceSlider.addEventListener('input', function() {
          hitChanceDisplay.textContent = this.value + '+';
        });
      }
      
      // Army name input for save button updates
      const armyNameInput = document.getElementById('army-name');
      if (armyNameInput) {
        armyNameInput.addEventListener('input', updateSaveButton);
      }
    });
    
    // Unit Creator Enhanced Functions
    const unitTypeIcons = {
      infantry: '', // dagger/cross
      vehicle: '', // double arrow
      tank: '', // spade
      mech: '', // cross
      support: '', // heart
      artillery: '', // bullet point
      field_gun: '', // up arrow
      cavalry: '', // knight
      fighter: '', // fighter plane
      bomber: '', // bomber plane
      airship: ''  // airship
    };
    
    // Initialize displays
    function updateStatDisplays() {
      // Update slider displays
      document.getElementById('attack-display').textContent = document.getElementById('attack-mod').value;
      document.getElementById('defense-display').textContent = document.getElementById('defense-mod').value;
      document.getElementById('morale-display').textContent = document.getElementById('morale-mod').value;
      document.getElementById('range-display').textContent = document.getElementById('range-mod').value;
      document.getElementById('movement-display').textContent = document.getElementById('movement-mod').value;
      document.getElementById('hit-chance-display').textContent = document.getElementById('hit-chance-mod').value;
      
      // Update armour display if element exists
      const armourDisplay = document.getElementById('armour-display');
      const armourMod = document.getElementById('armour-mod');
      if (armourDisplay && armourMod) {
        armourDisplay.textContent = armourMod.value;
      }
      
      // Update preview displays
      updatePreview();
    }
    
    function updatePreview() {
      const name = document.getElementById('unit-name').value || 'Unnamed Unit';
      const typeSelected = document.getElementById('unit-type-selected');
      const specialAbilitySelected = document.getElementById('special-ability-selected');
      const type = typeSelected ? typeSelected.getAttribute('data-value') : 'infantry';
      const special = specialAbilitySelected ? specialAbilitySelected.getAttribute('data-value') : 'none';
      
      // Update preview panel with null checks
      const previewName = document.getElementById('preview-name');
      if (previewName) previewName.textContent = name;
      
      // Format unit type display
      let displayType = formatUnitType(type);
      const previewType = document.getElementById('preview-type');
      if (previewType) previewType.textContent = displayType;
      
      const previewIcon = document.getElementById('unit-preview-icon');
      if (previewIcon) previewIcon.textContent = unitTypeIcons[type] || '';
      
      // Update stat previews with null checks
      const attackMod = document.getElementById('attack-mod');
      const defenseMod = document.getElementById('defense-mod');
      const moraleMod = document.getElementById('morale-mod');
      const rangeMod = document.getElementById('range-mod');
      const movementMod = document.getElementById('movement-mod');
      const hitChanceMod = document.getElementById('hit-chance-mod');
      
      const previewAttack = document.getElementById('preview-attack');
      const previewDefense = document.getElementById('preview-defense');
      const previewMorale = document.getElementById('preview-morale');
      const previewRange = document.getElementById('preview-range');
      const previewMovement = document.getElementById('preview-movement');
      const previewHitChance = document.getElementById('preview-hit-chance');
      
      if (previewAttack && attackMod) previewAttack.textContent = attackMod.value;
      if (previewDefense && defenseMod) previewDefense.textContent = defenseMod.value;
      if (previewMorale && moraleMod) previewMorale.textContent = moraleMod.value;
      if (previewRange && rangeMod) previewRange.textContent = rangeMod.value;
      if (previewMovement && movementMod) previewMovement.textContent = movementMod.value;
      if (previewHitChance && hitChanceMod) previewHitChance.textContent = hitChanceMod.value;
      
      // Update armour preview if element exists
      const previewArmour = document.getElementById('preview-armour');
      const armourMod = document.getElementById('armour-mod');
      if (previewArmour && armourMod) {
        previewArmour.textContent = armourMod.value;
      }
      
      // Update special ability preview
      const specialAbilityElement = document.getElementById('preview-special-ability');
      if (specialAbilityElement) {
        if (special === 'none') {
          specialAbilityElement.textContent = 'None';
          specialAbilityElement.setAttribute('data-special-ability', 'none');
        } else {
          // Get the special ability name from the dropdown
          const specialAbilityText = specialAbilitySelected ? specialAbilitySelected.textContent : special;
          specialAbilityElement.textContent = specialAbilityText;
          
          // Set data attribute for tooltip
          specialAbilityElement.setAttribute('data-special-ability', special);
          
          // Add Fortified indicator if applicable
          if (special === 'fortified') {
            specialAbilityElement.innerHTML += ' <span style="color: #FFD700; font-weight: bold;">[FORTIFIED]</span>';
          }
        }
      }
    }
    
    // Format unit type for display
    function formatUnitType(unitType) {
      // Handle null, undefined, or empty values
      if (!unitType || typeof unitType !== 'string') {
        return 'Infantry'; // Default fallback
      }
      
      if (unitType === 'field_gun') {
        return 'Field Guns';
      }
      return unitType.charAt(0).toUpperCase() + unitType.slice(1);
    }
    
    // Get special ability description for tooltips
    function getSpecialAbilityDescription(specialAbilityKey) {
      const descriptions = {
        stealth: 'Stays hidden on Forest, Swamp, Jungle tiles until they attack.',
        fortified: 'Gains +1 Defense on Construction Tiles.',
        amphibious: 'Ignores River & Coastal Penalties, gains +1 Attack on Naval Landing Zones. Has "Shock Landing" ability.',
        veteran: 'Gains +1 Attack when targeting enemies on Construction Tiles. Cannot be suppressed.',
                  charge: '+2 Attack when attacking Infantry at range 1.',
        healer: 'Can heal adjacent units by 1 HP per turn.',
        mechanic: 'Restores +1 Armor per turn to adjacent units with armor.',
        sapper: 'Can construct fortifications and disable enemy barbed wire, mines, and traps. Adjacent constructions build 1 turn faster.',
        chemical_warfare: 'Deploy gas clouds in front, front-left, or front-right. Gas damages units entering (d6). Lasts 3 turns.',
        mobile_cover: 'Gains +2 Movement while on Roads. Grants +1 Defense aura to adjacent units.',
        carrier: 'Moves units long distances quickly. If destroyed while carrying troops, they die instantly.',
        all_terrain: 'Can enter Swamp, Jungle, and Forest tiles but takes 1 damage when entering them.',
        siege_mode: 'When stationary for 1 turn, gains +1 Attack next turn (like a "Siege Mode").',
        trample: 'High HP & Defense. Ignores Barbed Wires, Mines, and Tank Traps when moving.',
        fear_pulse: 'Fast. Gains +2 Defense against Tanks, Artillery, and Bombers.',
        mode_switch: 'Gains +1 Attack for each adjacent friendly Mech unit.',
        life_steal: 'Gains +2 Armor when attacking units with armor. Immune to Suppression, Artillery, and Bombers.',
        mobile_fire: '+2 to attack rolls firing at any unit on a construction tile.',
        fortified: 'Gains +1 Defense on Construction Tiles.',
        precision: 'Longest range. Gains +1 to hit chance for each consecutive attack on the same target. Resets when changing targets.',
        air_superiority: 'Engages enemy aircraft. High mobility and air combat bonuses.',
        terror_in_skys: '+2 To Attack Rolls Against Infantry and Support Units on Plains Terrain',
        those_who_dare: 'Can traverse Mountain tiles and gains +1 Range and +1 Defense while on them.',
        the_hub_in_the_sky: 'While this Airship is alive, all friendly Fighters gain +1 to attack rolls.',
        air_defense: 'Can only attack air units (fighters and bombers).',
        armour_penetrating: '+3 To Attack Rolls Against Armoured Units'
      };
      
      return descriptions[specialAbilityKey] || 'No description available.';
    }
    
    // Custom tooltip functions for special abilities
    function showSpecialAbilityTooltip(event) {
      const element = event.target;
      const specialAbility = element.getAttribute('data-special-ability');
      
      if (!specialAbility || specialAbility === 'none') {
        return;
      }
      
      // Remove any existing tooltip
      hideSpecialAbilityTooltip();
      
      // Create tooltip element
      const tooltip = document.createElement('div');
      tooltip.className = 'custom-tooltip';
      tooltip.textContent = getSpecialAbilityDescription(specialAbility);
      tooltip.id = 'special-ability-tooltip';
      
      // Add to body
      document.body.appendChild(tooltip);
      
      // Position tooltip directly under the element (same as unit tooltip)
      const rect = element.getBoundingClientRect();
      
      // Position tooltip directly under the hovered element
      let left = rect.left + window.scrollX;
      let top = rect.bottom + window.scrollY + 5; // 5px gap under element
      
      // Adjust if tooltip would go off-screen horizontally
      const tooltipWidth = 300; // max-width from CSS
      const tooltipHeight = 100; // estimated height
      if (left + tooltipWidth > window.innerWidth) {
        left = Math.max(10, window.innerWidth - tooltipWidth - 10);
      }
      
      // Adjust if tooltip would go off-screen vertically
      if (top + tooltipHeight > window.innerHeight + window.scrollY) {
        // Position above the element instead
        top = rect.top + window.scrollY - tooltipHeight - 5;
        // If still off-screen, position at a safe location
        if (top < window.scrollY) {
          top = rect.bottom + window.scrollY + 5;
        }
      }
      
      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
      
      // Show tooltip
      setTimeout(() => {
        tooltip.classList.add('show');
      }, 10);
    }
    
    function hideSpecialAbilityTooltip() {
      const tooltip = document.getElementById('special-ability-tooltip');
      if (tooltip) {
        tooltip.remove();
      }
    }
    
    function createUnit() {
      const nameInput = document.getElementById('unit-name');
      const typeSelected = document.getElementById('unit-type-selected');
      const unitSelectSelected = document.getElementById('unit-select-selected');
      const specialAbilitySelected = document.getElementById('special-ability-selected');
      const attackSlider = document.getElementById('attack-mod');
      const defenseSlider = document.getElementById('defense-mod');
      const moraleSlider = document.getElementById('morale-mod');
      const rangeSlider = document.getElementById('range-mod');
      const movementSlider = document.getElementById('movement-mod');
      const hitChanceSlider = document.getElementById('hit-chance-mod');
      const armourSlider = document.getElementById('armour-mod');
      
      if (!nameInput || !typeSelected || !attackSlider || !defenseSlider || !moraleSlider || !rangeSlider || !movementSlider) {
        console.error('Unit creation form elements missing');
        return;
      }
      
      const name = nameInput.value.trim();
      const type = typeSelected.getAttribute('data-value');
      const special = specialAbilitySelected ? specialAbilitySelected.getAttribute('data-value') : 'none';
      const attack = parseInt(attackSlider.value);
      const defense = parseInt(defenseSlider.value);
      const morale = parseInt(moraleSlider.value);
      const range = parseInt(rangeSlider.value);
      const movement = parseInt(movementSlider.value);
      const hitChance = hitChanceSlider ? parseInt(hitChanceSlider.value) : 9;
      const armour = armourSlider ? parseInt(armourSlider.value) : 0;
      
      if (!name) {
        alert('Please enter a unit name');
        return;
      }
      
      // Check if unit name already exists (only for new units, not when editing)
      if (!unitSelectSelected || unitSelectSelected.getAttribute('data-value') === '') {
      if (gameData.customUnits && gameData.customUnits.some(unit => unit.name.toLowerCase() === name.toLowerCase())) {
        alert('A unit with this name already exists');
        return;
        }
      }
      
      // Check if we're editing an existing unit
      const isEditing = unitSelectSelected && unitSelectSelected.getAttribute('data-value') !== '';
      let unitId = Date.now();
      
      if (isEditing) {
        // Find existing unit to update
        const existingUnitIndex = gameData.customUnits.findIndex(unit => unit.name === unitSelectSelected.getAttribute('data-value'));
        if (existingUnitIndex !== -1) {
          unitId = gameData.customUnits[existingUnitIndex].id;
          // Remove the old unit
          gameData.customUnits.splice(existingUnitIndex, 1);
        }
      }
      
      const newUnit = {
        id: unitId,
        name,
        type,
        attack,
        defense: defense, // HP for all units including artillery
        morale: (type === 'artillery' || type === 'fighter' || type === 'bomber' || type === 'airship') ? 0 : morale,
        range: type === 'artillery' ? 999 : (type === 'fighter' || type === 'bomber' || type === 'airship') ? 999 : range, // Only Artillery has infinite range
        movement: (type === 'artillery' || type === 'fighter' || type === 'bomber' || type === 'airship') ? 0 : movement, // Only Artillery and Air units don't move on grid
        armour: (type === 'vehicle' || type === 'tank' || type === 'mech') ? armour : undefined, // Only armoured units have armour
        special: special,
        hitChance: type === 'artillery' ? hitChance : undefined,
        targetHistory: {} // Track consecutive attacks on same target for Precision ability
      };
      
      console.log('Created new unit:', newUnit);
      
      gameData.customUnits.push(newUnit);
      
      // Save custom units to localStorage
      saveCustomUnits();
      
      // Clear form
      nameInput.value = '';
      
      // Reset dropdown displays
      if (unitSelectSelected) {
        unitSelectSelected.textContent = 'Create New Unit';
        unitSelectSelected.setAttribute('data-value', '');
      }
      if (specialAbilitySelected) {
        specialAbilitySelected.textContent = 'None';
        specialAbilitySelected.setAttribute('data-value', 'none');
      }
      if (typeSelected) {
        typeSelected.textContent = 'Infantry';
        typeSelected.setAttribute('data-value', 'infantry');
      }
      
      attackSlider.value = 0;
      if (defenseSlider) defenseSlider.value = 0;
      if (moraleSlider) moraleSlider.value = 4;
      if (rangeSlider) rangeSlider.value = 1;
      if (movementSlider) movementSlider.value = 1;
      if (hitChanceSlider) hitChanceSlider.value = 9;
      
      // Update displays
      updateStatDisplays();
      
      loadCustomUnits();
      
      // Visual feedback
      const forgeButton = document.querySelector('.action-button');
      if (forgeButton) {
        forgeButton.style.boxShadow = '0 0 50px rgba(255, 100, 0, 0.8), 0 0 100px rgba(255, 0, 0, 0.6)';
        setTimeout(() => {
          forgeButton.style.boxShadow = '';
        }, 500);
      }
      
      const message = isEditing ? 'Unit updated successfully!' : 'Unit forged successfully in the depths of war!';
      alert(message);
    }
    
    // Show/hide fields based on unit type
    function updateUnitTypeFields() {
      const typeSelected = document.getElementById('unit-type-selected');
      const unitSelectOptions = document.getElementById('unit-select-options');
      const specialAbilityOptions = document.getElementById('special-ability-options');
      const hitChanceGroup = document.getElementById('hit-chance-group');
      const defenseGroup = document.getElementById('defense-group');
      const moraleGroup = document.getElementById('morale-group');
      const rangeGroup = document.getElementById('range-group');
      const movementGroup = document.getElementById('movement-group');
      const armourGroup = document.getElementById('armour-group');
      const previewArmourDisplay = document.getElementById('preview-armour-display');
      
      if (typeSelected) {
        const unitType = typeSelected.getAttribute('data-value') || typeSelected.textContent.toLowerCase();
        
        // Populate unit selection dropdown
        populateUnitSelection(unitType);
        
        // Populate special ability dropdown
        populateSpecialAbilities(unitType);
        
        if (unitType === 'artillery') {
          // Artillery: show attack, hit chance, and HP (defense)
          if (hitChanceGroup) hitChanceGroup.style.display = 'block';
          if (defenseGroup) defenseGroup.style.display = 'block';
          if (moraleGroup) moraleGroup.style.display = 'none';
          if (rangeGroup) rangeGroup.style.display = 'none';
          if (movementGroup) movementGroup.style.display = 'none';
          if (armourGroup) armourGroup.style.display = 'none';
          if (previewArmourDisplay) previewArmourDisplay.style.display = 'none';
        } else if (unitType === 'fighter' || unitType === 'bomber') {
          // Air units: only show attack and HP (defense)
          if (hitChanceGroup) hitChanceGroup.style.display = 'none';
          if (defenseGroup) defenseGroup.style.display = 'block';
          if (moraleGroup) moraleGroup.style.display = 'none';
          if (rangeGroup) rangeGroup.style.display = 'none';
          if (movementGroup) movementGroup.style.display = 'none';
          if (armourGroup) armourGroup.style.display = 'none';
          if (previewArmourDisplay) previewArmourDisplay.style.display = 'none';
        } else if (unitType === 'airship') {
          // Airship: show attack, HP (defense), and armour
          if (hitChanceGroup) hitChanceGroup.style.display = 'none';
          if (defenseGroup) defenseGroup.style.display = 'block';
          if (moraleGroup) moraleGroup.style.display = 'none';
          if (rangeGroup) rangeGroup.style.display = 'none';
          if (movementGroup) movementGroup.style.display = 'none';
          if (armourGroup) armourGroup.style.display = 'block';
          if (previewArmourDisplay) previewArmourDisplay.style.display = 'block';
        } else if (unitType === 'vehicle' || unitType === 'tank' || unitType === 'mech') {
          // Armoured units: show all fields including armour
          if (hitChanceGroup) hitChanceGroup.style.display = 'none';
          if (defenseGroup) defenseGroup.style.display = 'block';
          if (moraleGroup) moraleGroup.style.display = 'block';
          if (rangeGroup) rangeGroup.style.display = 'block';
          if (movementGroup) movementGroup.style.display = 'block';
          if (armourGroup) armourGroup.style.display = 'block';
          if (previewArmourDisplay) previewArmourDisplay.style.display = 'block';
        } else {
          // Regular units: show all fields except hit chance and armour
          if (hitChanceGroup) hitChanceGroup.style.display = 'none';
          if (defenseGroup) defenseGroup.style.display = 'block';
          if (moraleGroup) moraleGroup.style.display = 'block';
          if (rangeGroup) rangeGroup.style.display = 'block';
          if (movementGroup) movementGroup.style.display = 'block';
          if (armourGroup) armourGroup.style.display = 'none';
          if (previewArmourDisplay) previewArmourDisplay.style.display = 'none';
        }
      }
      
      // Update preview when type changes
      updatePreview();
    }
    
    // Populate unit selection dropdown based on unit type
    function populateUnitSelection(unitType) {
      const unitSelectOptions = document.getElementById('unit-select-options');
      if (!unitSelectOptions) return;
      
      // Clear existing options except the first one
      unitSelectOptions.innerHTML = '<div class="dropdown-option" data-value="">Create New Unit</div>';
      
      // Get all units of the selected type (default + custom)
      const allUnits = [...defaultUnits, ...gameData.customUnits];
      const unitsOfType = allUnits.filter(unit => unit.type === unitType);
      
      console.log(`Populating dropdown for type: ${unitType}`);
      console.log(`Found ${unitsOfType.length} units of type ${unitType}:`, unitsOfType.map(u => u.name));
      
      // Add units to dropdown
      unitsOfType.forEach(unit => {
        const option = document.createElement('div');
        option.className = 'dropdown-option';
        option.setAttribute('data-value', unit.name);
        option.textContent = unit.name;
        unitSelectOptions.appendChild(option);
      });
    }
    
    // Populate special ability dropdown based on unit type
    function populateSpecialAbilities(unitType) {
      const specialAbilityOptions = document.getElementById('special-ability-options');
      if (!specialAbilityOptions) return;
      
      // Clear existing options
      specialAbilityOptions.innerHTML = '<div class="dropdown-option" data-value="none">None</div>';
      
      // Get available special abilities for this unit type
      const availableAbilities = getAvailableAbilitiesForType(unitType);
      
      // Add abilities to dropdown
      availableAbilities.forEach(ability => {
        const option = document.createElement('div');
        option.className = 'dropdown-option';
        option.setAttribute('data-value', ability.key);
        option.textContent = ability.name;
        specialAbilityOptions.appendChild(option);
      });
    }
    
    // Get available special abilities for a unit type
    function getAvailableAbilitiesForType(unitType) {
      const abilities = [];
      
      switch (unitType) {
        case 'infantry':
          abilities.push(
            { key: 'stealth', name: 'Stealth' },
            { key: 'fortified', name: 'Fortified' },
            { key: 'amphibious', name: 'Amphibious' },
            { key: 'veteran', name: 'Veteran' },
            { key: 'those_who_dare', name: 'Those Who Dare' }
          );
          break;
        case 'cavalry':
          abilities.push(
            { key: 'charge', name: 'Charge' }
          );
          break;
        case 'support':
          abilities.push(
            { key: 'healer', name: 'Healer' },
            { key: 'sapper', name: 'Sapper' },
            { key: 'grenadier', name: 'Grenadier' }
          );
          break;
        case 'vehicle':
          abilities.push(
            { key: 'mobile_cover', name: 'Mobile Cover' },
            { key: 'carrier', name: 'Carrier' }
          );
          break;
        case 'tank':
          abilities.push(
            { key: 'all_terrain', name: 'All Terrain' },
            { key: 'siege_mode', name: 'Siege Mode' },
            { key: 'trample', name: 'Trample' }
          );
          break;
        case 'mech':
          abilities.push(
            { key: 'fear_pulse', name: 'Evasion' },
            { key: 'mode_switch', name: 'Mech Assault' },
            { key: 'life_steal', name: 'Salvage Systems' }
          );
          break;
        case 'field_gun':
          abilities.push(
            { key: 'mobile_fire', name: 'Defense Buster' },
            { key: 'fortified', name: 'Fortified' },
            { key: 'air_defense', name: 'Air Defense' },
            { key: 'armour_penetrating', name: 'Armour Penetrating Round' }
          );
          break;
        case 'artillery':
          abilities.push(
            { key: 'precision', name: 'Precision' }
          );
          break;
        case 'fighter':
          abilities.push(
            { key: 'air_superiority', name: 'Air Superiority' }
          );
          break;
        case 'bomber':
          abilities.push(
            { key: 'terror_in_skys', name: 'Terror In The Skys' }
          );
          break;
        case 'airship':
          abilities.push(
            { key: 'the_hub_in_the_sky', name: 'The Hub In The Sky' }
          );
          break;
      }
      
      return abilities;
    }
    
    // Load unit data for editing
    function loadUnitForEditing() {
      const unitSelectSelected = document.getElementById('unit-select-selected');
      const nameInput = document.getElementById('unit-name');
      const typeSelected = document.getElementById('unit-type-selected');
      const specialAbilitySelected = document.getElementById('special-ability-selected');
      const attackSlider = document.getElementById('attack-mod');
      const defenseSlider = document.getElementById('defense-mod');
      const moraleSlider = document.getElementById('morale-mod');
      const rangeSlider = document.getElementById('range-mod');
      const movementSlider = document.getElementById('movement-mod');
      const hitChanceSlider = document.getElementById('hit-chance-mod');
      const armourSlider = document.getElementById('armour-mod');
      
      if (!unitSelectSelected || unitSelectSelected.getAttribute('data-value') === '') {
        // Clear form for new unit
        if (nameInput) nameInput.value = '';
        if (attackSlider) attackSlider.value = 0;
        if (defenseSlider) defenseSlider.value = 0;
        if (moraleSlider) moraleSlider.value = 4;
        if (rangeSlider) rangeSlider.value = 1;
        if (movementSlider) movementSlider.value = 1;
        if (hitChanceSlider) hitChanceSlider.value = 9;
        if (armourSlider) armourSlider.value = 0;
        
        // Clear dropdown displays
        if (typeSelected) {
          typeSelected.textContent = 'Infantry';
          typeSelected.setAttribute('data-value', 'infantry');
        }
        if (specialAbilitySelected) {
          specialAbilitySelected.textContent = 'None';
          specialAbilitySelected.setAttribute('data-value', 'none');
        }
        
        updateStatDisplays();
        updatePreview();
        return;
      }
      
      // Find the selected unit
      const allUnits = [...defaultUnits, ...gameData.customUnits];
      const selectedUnit = allUnits.find(unit => unit.name === unitSelectSelected.getAttribute('data-value'));
      
      if (selectedUnit) {
        // Load unit data into form
        if (nameInput) nameInput.value = selectedUnit.name;
        if (attackSlider) attackSlider.value = selectedUnit.attack;
        if (defenseSlider) defenseSlider.value = selectedUnit.defense;
        if (moraleSlider) moraleSlider.value = selectedUnit.morale || 4;
        if (rangeSlider) rangeSlider.value = selectedUnit.range || 1;
        if (movementSlider) movementSlider.value = selectedUnit.movement || 1;
        if (hitChanceSlider) hitChanceSlider.value = selectedUnit.hitChance || 9;
        if (armourSlider) armourSlider.value = selectedUnit.armour || 0;
        
        // Update dropdown displays
        if (typeSelected) {
          typeSelected.textContent = selectedUnit.type.charAt(0).toUpperCase() + selectedUnit.type.slice(1);
          typeSelected.setAttribute('data-value', selectedUnit.type);
        }
        if (specialAbilitySelected) {
          const abilityName = selectedUnit.special || 'none';
          specialAbilitySelected.textContent = 'None';
          specialAbilitySelected.setAttribute('data-value', 'none');
        }
        
        // Update displays
        updateStatDisplays();
        updateUnitTypeFields(); // This will repopulate dropdowns
        
        updatePreview();
      }
    }
    
    // Save custom units to localStorage
    function saveCustomUnits() {
      try {
        localStorage.setItem('customUnits', JSON.stringify(gameData.customUnits));
        console.log('Custom units saved to localStorage');
      } catch (error) {
        console.error('Error saving custom units:', error);
      }
    }
    
    // Load custom units from localStorage
    function loadCustomUnitsFromStorage() {
      try {
        const saved = localStorage.getItem('customUnits');
        if (saved) {
          gameData.customUnits = JSON.parse(saved);
          console.log('Custom units loaded from localStorage:', gameData.customUnits);
        }
      } catch (error) {
        console.error('Error loading custom units:', error);
        gameData.customUnits = [];
      }
    }
    
    function loadCustomUnits() {
      const unitsList = document.getElementById('custom-units-list');
      
      if (!gameData.customUnits || gameData.customUnits.length === 0) {
        unitsList.innerHTML = '<div style="text-align: center; color: #cc4444; opacity: 0.7; padding: 20px; font-style: italic;">No war machines forged yet...</div>';
        return;
      }
      
      let html = '';
      gameData.customUnits.forEach(unit => {
        const icon = unitTypeIcons[unit.type] || '';
        html += `
          <div class="unit-item">
            <div class="unit-item-header">
              <div class="unit-item-name">${icon} ${unit.name}</div>
              <div class="unit-item-type">${formatUnitType(unit.type)}</div>
            </div>
            <div class="unit-stats">
              <span class="stat attack">ATK: ${unit.attack >= 0 ? '+' : ''}${unit.attack}</span>
              ${unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship' || unit.type === 'artillery' ? 
                `<span class="stat defend">HP: ${unit.defense}</span>` : 
                `<span class="stat defend">DEF: ${unit.defense >= 0 ? '+' : ''}${unit.defense}</span>`
              }
              ${unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber' && unit.type !== 'airship' ? 
                `<span class="stat morale">MOR: ${unit.morale}</span>` : ''
              }
              ${unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber' && unit.type !== 'airship' ? 
                `<span class="stat range">RNG: ${unit.range}</span>` : ''
              }
              ${unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber' && unit.type !== 'airship' ? 
                `<span class="stat movement">MOV: ${unit.movement}</span>` : ''
              }
              ${unit.type === 'artillery' && unit.hitChance ? `<span class="stat hit-chance">HIT: ${unit.hitChance}+</span>` : ''}
            </div>
            <div class="unit-actions">
              <button class="small-button select" onclick="selectUnit(${unit.id})">Select</button>
              <button class="small-button delete" onclick="deleteUnit(${unit.id})">Destroy</button>
            </div>
          </div>
        `;
      });
      
      unitsList.innerHTML = html;
    }
    
    function selectUnit(unitId) {
      const unit = gameData.customUnits.find(u => u.id === unitId);
      if (unit) {
        // Fill form with unit data for editing
        document.getElementById('unit-name').value = unit.name;
        
        // Update unit type dropdown
        const unitTypeSelected = document.getElementById('unit-type-selected');
        if (unitTypeSelected) {
          unitTypeSelected.textContent = unit.type.charAt(0).toUpperCase() + unit.type.slice(1);
          unitTypeSelected.setAttribute('data-value', unit.type);
        }
        
        // Update unit select dropdown
        const unitSelectSelected = document.getElementById('unit-select-selected');
        if (unitSelectSelected) {
          unitSelectSelected.textContent = unit.name;
          unitSelectSelected.setAttribute('data-value', unit.name);
        }
        
        // Update special ability dropdown - always start with "None" for editing
        const specialAbilitySelected = document.getElementById('special-ability-selected');
        if (specialAbilitySelected) {
          specialAbilitySelected.textContent = 'None';
          specialAbilitySelected.setAttribute('data-value', 'none');
        }
        
        document.getElementById('attack-mod').value = unit.attack;
        document.getElementById('defense-mod').value = unit.defense;
        document.getElementById('morale-mod').value = unit.morale;
        document.getElementById('range-mod').value = unit.range;
        document.getElementById('movement-mod').value = unit.movement;
        document.getElementById('hit-chance-mod').value = unit.hitChance || 9;
        
        updateStatDisplays();
      }
    }
    
    function deleteUnit(unitId) {
      if (confirm('Are you sure you want to destroy this war machine forever?')) {
        gameData.customUnits = gameData.customUnits.filter(unit => unit.id !== unitId);
        saveCustomUnits();
        loadCustomUnits();
      }
    }
    
    // Save armies to localStorage
    function saveArmiesToStorage() {
      try {
        localStorage.setItem('savedArmies', JSON.stringify(gameData.savedArmies));
        console.log('Saved armies to localStorage:', gameData.savedArmies);
      } catch (error) {
        console.error('Error saving armies:', error);
      }
    }
    
    // Load armies from localStorage
    function loadArmiesFromStorage() {
      console.log(' [DEBUG] loadArmiesFromStorage called');
      try {
        const saved = localStorage.getItem('savedArmies');
        console.log(' [DEBUG] Raw saved armies from localStorage:', saved);
        
        if (saved) {
          gameData.savedArmies = JSON.parse(saved);
          console.log(' [DEBUG] Saved armies loaded from localStorage:', gameData.savedArmies);
          console.log(' [DEBUG] Number of saved armies:', gameData.savedArmies.length);
        } else {
          console.log(' [DEBUG] No saved armies found in localStorage');
          gameData.savedArmies = [];
        }
      } catch (error) {
        console.error(' [DEBUG] Error loading armies:', error);
        gameData.savedArmies = [];
      }
    }
    
    // Game Start
    function startGame() {
      // Check if this is multiplayer mode
      if (isMultiplayerMode) {
        console.log('Starting multiplayer game...');
        startMultiplayerGame();
        return;
      }
      
      console.log('Starting single-player game...');
      console.log(' [DEBUG] Initial gameConfig.gridSize:', gameConfig.gridSize);
      
      // Initialize gameConfig with safe defaults first
      if (!gameConfig.gridSize || isNaN(gameConfig.gridSize)) {
        gameConfig.gridSize = 8;
        console.log(' [DEBUG] Initialized gameConfig.gridSize to default: 8');
      }
      if (!gameConfig.zoneCount || isNaN(gameConfig.zoneCount)) {
        gameConfig.zoneCount = 6;
        console.log(' [DEBUG] Initialized gameConfig.zoneCount to default: 6');
      }
      
      // Get configuration with safe defaults
      gameConfig.player1.name = document.getElementById('player1-name')?.value || 'Red Commander';
      gameConfig.player1.color = document.getElementById('player1-color-display')?.style.getPropertyValue('--color-value') || '#DC143C';
      gameConfig.player1.role = document.getElementById('player1-role')?.value || 'attacker';
      gameConfig.player2.name = document.getElementById('player2-name')?.value || 'Blue Commander';
      gameConfig.player2.color = document.getElementById('player2-color-display')?.style.getPropertyValue('--color-value') || '#4169E1';
      gameConfig.opponentType = getDropdownValue('opponentDropdown') || 'human';
      gameConfig.aiCommandPoints = parseInt(document.getElementById('ai-cp')?.value || 4);
      gameConfig.zoneCount = parseInt(document.getElementById('zone-count')?.value || 6);
      gameConfig.winCondition = getDropdownValue('winConditionDropdown') || 'dominance';
      gameConfig.player1CP = parseInt(document.getElementById('player1-cp')?.value || 3);
      gameConfig.player2CP = parseInt(document.getElementById('player2-cp')?.value || 3);
      // Get individual player build points
      const player1BuildPoints = parseInt(document.getElementById('player1-build-points')?.value || 10);
      const player2BuildPoints = parseInt(document.getElementById('player2-build-points')?.value || 10);
      gameConfig.player1BuildPoints = player1BuildPoints;
      gameConfig.player2BuildPoints = player2BuildPoints;
      gameConfig.buildPoints = Math.max(player1BuildPoints, player2BuildPoints); // Use max for backward compatibility
      
      // Debug logging for build points
      console.log(' [BUILD POINTS DEBUG] Singleplayer build points configuration:');
      console.log('  - Player 1 Build Points:', player1BuildPoints);
      console.log('  - Player 2 Build Points:', player2BuildPoints);
      console.log('  - gameConfig.player1BuildPoints:', gameConfig.player1BuildPoints);
      console.log('  - gameConfig.player2BuildPoints:', gameConfig.player2BuildPoints);
      console.log('  - gameConfig.buildPoints:', gameConfig.buildPoints);
      gameConfig.terrainType = getDropdownValue('terrainDropdown') || 'random';
      
      // Get weather and day/night cycle settings
      gameConfig.dayNightCycle = getDropdownValue('dayNightDropdown') || 'day';
      gameConfig.weatherType = getDropdownValue('weatherDropdown') || 'clear';
      
      // Check if grid size is set from UI
      const activeGridButton = document.querySelector('.grid-size-container .grid-size-btn.active');
      console.log(' [DEBUG] Active grid button:', activeGridButton);
      if (activeGridButton) {
        const gridSize = parseInt(activeGridButton.dataset.size);
        console.log(' [DEBUG] Setting grid size from UI:', gridSize);
        gameConfig.gridSize = gridSize;
        
        // Also update the mini-battlefield grid class
        const miniBattlefield = document.getElementById('mini-battlefield');
        if (miniBattlefield) {
          miniBattlefield.className = `mini-battlefield grid-${gridSize}`;
          console.log(' [DEBUG] Updated mini-battlefield grid class to:', `grid-${gridSize}`);
        }
      } else {
        console.log(' [DEBUG] No active grid button found, using default:', gameConfig.gridSize);
      }
      
      // Ensure gridSize has a valid value - more robust fallback
      if (isNaN(gameConfig.gridSize) || gameConfig.gridSize <= 0) {
        console.log(' [DEBUG] Invalid grid size detected, setting to default: 8');
        gameConfig.gridSize = 8;
      }
      
      // Also ensure zoneCount has a valid value
      if (isNaN(gameConfig.zoneCount) || gameConfig.zoneCount <= 0) {
        console.log(' [DEBUG] Invalid zone count detected, setting to default: 6');
        gameConfig.zoneCount = 6;
      }
      
      // Set player 2 role as opposite of player 1
      gameConfig.player2.role = gameConfig.player1.role === 'attacker' ? 'defender' : 'attacker';
      
      // Update CSS variables with player colors
      console.log(' [COLOR DEBUG] startGame - Player 1 color:', gameConfig.player1.color);
      console.log(' [COLOR DEBUG] startGame - Player 2 color:', gameConfig.player2.color);
      document.documentElement.style.setProperty('--player1-color', gameConfig.player1.color);
      document.documentElement.style.setProperty('--player2-color', gameConfig.player2.color);
      document.documentElement.style.setProperty('--player1-color-rgb', hexToRgb(gameConfig.player1.color));
      document.documentElement.style.setProperty('--player2-color-rgb', hexToRgb(gameConfig.player2.color));
      
      // Update player color CSS
      console.log(' [COLOR DEBUG] startGame - About to call updatePlayerColorCSS');
      updatePlayerColorCSS();
      console.log(' [COLOR DEBUG] startGame - updatePlayerColorCSS called');
      
      // Initialize game state
      gameState = {
        currentPlayer: 'red',
        commandPoints: { 
          red: gameConfig.player1CP, 
          blue: gameConfig.opponentType === 'ai' ? gameConfig.aiCommandPoints : gameConfig.player2CP
        },
        buildPoints: { 
          red: gameConfig.player1BuildPoints, 
          blue: gameConfig.player2BuildPoints
        },
        selectedDice: { attack: 0, defend: 0, morale: 0 },
        turnCount: 0,
        diceAugmented: false,
        currentZone: null,
        gamePhase: 'selection',
        lockedZones: { red: [], blue: [] },
        currentZonePhase: 'defense',
        selectedUnit: null,
        deploymentMode: 'place',
        deployedUnits: { red: [], blue: [] },
        zoneRoles: {},
        unitActions: {},
        zoneNames: {},
        gasClouds: {}, // Format: { zoneId: { position: { player, turnsRemaining, deployedOnTurn } } }
        movementMode: {
          active: false,
          selectedUnit: null,
          movementPoints: 0,
          validPositions: []
        },
        // Multi-army system tracking
        unitDeployments: {},
        selectedArmyInZone: { red: null, blue: null },
        armySelectionMode: false,
        // Unit deployment tracking to prevent duplicates across zones
        deployedUnitInstances: {},
        // CP system tracking
        cpCosts: {
          placeUnit: 1,
          moveUnit: 1,
          attack: 1,
          artilleryAttack: 2
        },
        contestedZones: { red: [], blue: [] },
        controlledZones: { red: [], blue: [] },
        // Artillery system
        artillery: {
          red: [],
          blue: []
        },
        // Artillery selection state
        selectedArtillery: null,
        artilleryMode: false,
        // Artillery actions tracking
        artilleryActions: {},
        // Aerial combat system
        aerial: {
          red: [],
          blue: []
        },
        selectedAerial: null,
        aerialMode: false,
        aerialActions: {},
        antiAirTargeting: false,
        // AI system state
        aiState: {
          isAITurn: false,
          aiPlayer: null, // 'red' or 'blue' - which player is AI
          aiThinking: false,
          aiDifficulty: 4 // Default AI CP
        }
      };
      
      // Debug logging for game state build points
      console.log(' [GAME STATE DEBUG] Build points in game state:');
      console.log('  - gameState.buildPoints.red:', gameState.buildPoints.red);
      console.log('  - gameState.buildPoints.blue:', gameState.buildPoints.blue);
      
      // Initialize weather system
      gameState.weatherSystem = {
        dayNightCycle: gameConfig.dayNightCycle,
        weatherType: gameConfig.weatherType,
        currentWeather: 'clear', // Will be calculated on first turn
        turnCount: 0
      };
      
      // Initialize the first weather based on the selected weather type
      gameState.weatherSystem.currentWeather = calculateWeather();
      
      // Ensure selected armies are initialized
      if (!gameData.selectedArmies.player1) {
        gameData.selectedArmies.player1 = [];
      }
      if (!gameData.selectedArmies.player2) {
        gameData.selectedArmies.player2 = [];
      }
      
      // Add default armies if none are selected
      if (gameData.selectedArmies.player1.length === 0) {
        gameData.selectedArmies.player1.push({
          id: 'default',
          name: 'Default Army',
          units: [...defaultUnits, ...gameData.customUnits]
        });
      }
      
      if (gameData.selectedArmies.player2.length === 0) {
        gameData.selectedArmies.player2.push({
          id: 'default',
          name: 'Default Army',
          units: [...defaultUnits, ...gameData.customUnits]
        });
      }
      
      // Note: Custom armies are now handled by the proper army selection system
      // and should not be automatically added to both players here
      console.log(' [ARMY FIX] Using proper army selection system - no automatic army assignment');
      
      // Debug: Log the selected armies to see what's available
      console.log('Player 1 selected armies:', gameData.selectedArmies.player1);
      console.log('Player 2 selected armies:', gameData.selectedArmies.player2);
      console.log(' [ARMY FIX] Total saved armies:', gameData.savedArmies?.length || 0);
      console.log(' [ARMY FIX] Player1 has', gameData.selectedArmies.player1.length, 'armies available');
      console.log(' [ARMY FIX] Player2 has', gameData.selectedArmies.player2.length, 'armies available');
      
      // Generate battlefield
      generateBattlefield();
      
      // Update zone display classes
      const battlefield = document.getElementById('battlefield');
      if (battlefield) {
        battlefield.className = 'battlefield';
      }
      
      // Expose test helpers for victory conditions
      window.testDominance = testVictoryCondition;
      window.testElimination = testEliminationVictory;
      
      // Show game screen
      showScreen('game');
      
      // Initialize game
      renderBattlefield();
      // Ensure top-right Build Points reflects current player's starting BP when the game screen first shows
      updateBuildPointsDisplay();
      
      // Initialize weather displays
      updateWeatherDisplay();
      updateGameWeatherDisplay();
      
      // Initialize AI system
      initializeAI();
      
      // Ensure AI aerial units are initialized if playing against AI
      if (gameConfig.opponentType === 'ai') {
        setTimeout(() => {
          ensureAIAerialUnitsInitialized();
        }, 100);
      }
      
      // Log army selections
      const player1ArmySelect = document.getElementById('player1-army');
      const player2ArmySelect = document.getElementById('player2-army');
      const player1ArmyName = player1ArmySelect?.options[player1ArmySelect.selectedIndex]?.text || 'Default Army';
      const player2ArmyName = player2ArmySelect?.options[player2ArmySelect.selectedIndex]?.text || 'Default Army';
      
      logMessage(`${gameConfig.player1.name} (${gameConfig.player1.role.toUpperCase()}) vs ${gameConfig.player2.name} (${gameConfig.player2.role.toUpperCase()}) - Battle begins!`, 'system');
      logMessage(`${gameConfig.player1.name} selected army: ${player1ArmyName}`, 'system');
      logMessage(`${gameConfig.player2.name} selected army: ${player2ArmyName}`, 'system');
      logMessage('Select zones to attack by clicking on them', 'system');
    }
    
    function generateBattlefield() {
      console.log(' [DEBUG] generateBattlefield called');
      console.log(' [DEBUG] gameConfig.gridSize:', gameConfig.gridSize);
      console.log(' [DEBUG] gameConfig.zoneCount:', gameConfig.zoneCount);
      
      // Ensure gridSize has a valid value - more robust validation
      if (!gameConfig.gridSize || isNaN(gameConfig.gridSize) || gameConfig.gridSize <= 0) {
        console.log(' [DEBUG] Invalid grid size detected in generateBattlefield, setting to default: 8');
        gameConfig.gridSize = 8;
      }
      
      // Ensure zoneCount has a valid value - more robust validation
      if (!gameConfig.zoneCount || isNaN(gameConfig.zoneCount) || gameConfig.zoneCount <= 0) {
        console.log(' [DEBUG] Invalid zone count detected, setting to default: 6');
        gameConfig.zoneCount = 6;
      }
      
      // Final validation before proceeding
      console.log(' [DEBUG] Final gridSize:', gameConfig.gridSize);
      console.log(' [DEBUG] Final zoneCount:', gameConfig.zoneCount);
      
      zones = [];
      const zoneLabels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      
      // Use deterministic seed for multiplayer, random seed for singleplayer
      let seed = null;
      if (isMultiplayerMode && gameConfig.terrainSeed) {
        seed = gameConfig.terrainSeed;
      } else if (!isMultiplayerMode) {
        // Generate a random seed for singleplayer to ensure different layouts each time
        seed = 'singleplayer_' + Date.now() + '_' + Math.random();
      }
      
      for (let i = 0; i < gameConfig.zoneCount; i++) {
        // Use the terrain category directly instead of getting random terrain
        const terrainCategory = gameConfig.terrainType || 'random';
        const zone = {
          id: zoneLabels[i],
          name: generateTerrainBasedZoneName(zoneLabels[i], terrainCategory, seed, i),
          control: 'neutral',
          units: {},
          conditions: [],
          defenses: [],
          terrain: terrainCategory,
          contested: false,
          tacticalGrid: generateTacticalGrid(terrainCategory, seed, i),
          locked: false
        };
        
        zones.push(zone);
        console.log(` [DEBUG] Created zone ${zone.id} with tactical grid size: ${Object.keys(zone.tacticalGrid).length}`);
      }
      
      console.log(` [DEBUG] Total zones created: ${zones.length}`);
    }
    
    function generateTerrainBasedZoneName(letter, terrain, seed = null, index = 0) {
      console.log(`Generating zone name for terrain: ${terrain}, letter: ${letter}`);
      
      // Use demon names instead of terrain-based names
      const demonName = zoneNames[letter];
      if (demonName) {
        console.log(`Using demon name: ${demonName} for zone ${letter}`);
        return demonName;
      }
      
      console.log(`No demon name found for letter ${letter}, using fallback`);
      return letter;
    }
    
    function generateTacticalGrid(zoneTerrain = null, seed = null, zoneIndex = 0) {
      // Ensure we have a valid grid size
      let gridSize = gameConfig.gridSize;
      if (!gridSize || isNaN(gridSize) || gridSize <= 0) {
        console.log(' [DEBUG] Invalid gridSize in generateTacticalGrid, using default: 8');
        gridSize = 8;
        gameConfig.gridSize = 8;
      }
      
      console.log(' [DEBUG] generateTacticalGrid using gridSize:', gridSize);
      const grid = {};
      
      // Get the appropriate terrain distribution
      const terrainType = zoneTerrain || 'random';
      const distribution = terrainDistributions[terrainType] || terrainDistributions.random;
      
      // Use the seed provided (random for singleplayer, deterministic for multiplayer)
      const randomSeed = seed;
      
      // Initialize grid with base terrain (100% of the selected type)
      const baseTerrain = getBaseTerrain(terrainType);
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const pos = row * gridSize + col;
          
          grid[pos] = {
            terrain: baseTerrain,
            unit: null,
            delayedUnits: []
          };
        }
      }
      
      // Generate infrastructure (road or river) - HIGHEST PRIORITY
      // Urban and Swamp terrain always get infrastructure
      let shouldGenerateInfrastructure = false;
      if (terrainType === 'urban' || terrainType === 'swamp') {
        shouldGenerateInfrastructure = true;
      } else {
        const infrastructureChance = getDeterministicRandom(randomSeed + zoneIndex + 'infrastructure');
        shouldGenerateInfrastructure = infrastructureChance <= 0.3;
      }
      
      if (shouldGenerateInfrastructure) {
        generateInfrastructure(grid, gridSize, randomSeed, zoneIndex, terrainType);
      }
      
      // Generate terrain-specific clusters based on terrain type
      generateTerrainSpecificClusters(grid, gridSize, randomSeed, zoneIndex, terrainType);
      
      // Special handling for naval terrain - generate beach in first row
      if (terrainType === 'naval') {
        generateBeachTerrain(grid, gridSize);
      }
      
      return grid;
    }
    
    function getBaseTerrain(terrainType) {
      const baseTerrainMap = {
        plains: 'plains',
        forest: 'forest',
        desert: 'desert',
        ruins: 'forest', // Ruins zones start with forest base
        snow: 'snow',
        mountainous: 'plains', // Mountainous zones start with plains base
        hilly: 'plains', // Hilly zones start with plains base
        town: 'plains',
        swamp: 'swamp',
        jungle: 'jungle',
        volcanic: 'volcanic',
        urban: 'plains', // Urban zones start with plains base
        naval: 'plains', // Naval zones start with plains base
        random: 'plains'
      };
      
      return baseTerrainMap[terrainType] || 'plains';
    }
    
    function generateTerrainSpecificClusters(grid, gridSize, seed, zoneIndex, terrainType) {
      console.log(`Generating terrain clusters for: ${terrainType}`);
      // Define cluster configurations for each terrain type
      const clusterConfigs = {
        plains: {
          clusters: [
            { type: 'forest', count: [1, 5] },
            { type: 'hills', count: [1, 5] }
          ]
        },
        forest: {
          clusters: [
            { type: 'plains', count: [1, 5] },
            { type: 'hills', count: [1, 5] }
          ]
        },
        desert: {
          clusters: [
            { type: 'hills', count: [1, 5] }
          ]
        },
        ruins: {
          clusters: [
            { type: 'ruins', count: [1, 1] }, // Guaranteed ruins cluster
            { type: 'plains', count: [1, 3] },
            { type: 'hills', count: [1, 3] },
            { type: 'volcanic', count: [0, 1] }
          ]
        },
        snow: {
          clusters: [
            { type: 'forest', count: [1, 5] },
            { type: 'hills', count: [1, 5] }
          ]
        },
        mountainous: {
          clusters: [
            { type: 'mountains', count: [4, 6] }, // 4-6 mountain clusters (further increased spawn rate)
            { type: 'hills', count: [1, 3] }
          ]
        },
        hilly: {
          clusters: [
            { type: 'hills', count: [2, 4] }, // More hills
            { type: 'mountains', count: [0, 1] } // Rare mountains
          ]
        },
        swamp: {
          clusters: [
            { type: 'plains', count: [1, 5] },
            { type: 'forest', count: [1, 5] }
          ]
        },
        jungle: {
          clusters: [
            { type: 'plains', count: [2, 4] },
            { type: 'swamp', count: [1, 3] },
            { type: 'forest', count: [2, 4] }
          ]
        },
        volcanic: {
          clusters: [
            { type: 'plains', count: [1, 1] }, // Guaranteed plains
            { type: 'hills', count: [1, 1] }, // Guaranteed hills
            { type: 'mountains', count: [1, 1] } // Guaranteed mountains
          ]
        },
        naval: {
          clusters: [
            { type: 'forest', count: [1, 3] },
            { type: 'hills', count: [1, 3] }
          ]
        },
        urban: {
          clusters: [
            { type: 'forest', count: [1, 5] },
            { type: 'hills', count: [1, 2] }, // Less hills
            { type: 'infrastructure', count: [2, 4] } // More infrastructure clusters
          ]
        }
      };
      
      const config = clusterConfigs[terrainType];
      if (!config) {
        console.log(`No cluster config found for terrain: ${terrainType}`);
        return;
      }
      
      console.log(`Generating clusters for ${terrainType}:`, config.clusters);
      
      // Generate clusters for each terrain type in the configuration
      // Add variety by shuffling the order of cluster types
      const clusterTypes = [...config.clusters];
      const shuffleSeed = getDeterministicRandom(seed + zoneIndex + 'shuffle');
      if (shuffleSeed > 0.5) {
        // Shuffle the order for some zones to create more variety
        clusterTypes.reverse();
        console.log(`Zone ${zoneIndex} using reversed cluster order for variety`);
      }
      
      clusterTypes.forEach(clusterConfig => {
        const clusterCount = Math.floor(getDeterministicRandom(seed + zoneIndex + 'clusterCount' + clusterConfig.type) * 
          (clusterConfig.count[1] - clusterConfig.count[0] + 1)) + clusterConfig.count[0];
        
        console.log(`Placing ${clusterCount} clusters of type: ${clusterConfig.type}`);
        
        for (let i = 0; i < clusterCount; i++) {
          const success = generateTerrainCluster(grid, clusterConfig.type, gridSize, seed, zoneIndex, i);
          console.log(`Cluster ${i} of ${clusterConfig.type} placed: ${success}`);
        }
      });
    }
    
    function generateTerrainCluster(grid, terrainType, gridSize, seed, zoneIndex, clusterIndex) {
      const clusterSizes = [1, 2, 3, 4]; // 1x1, 2x2, 3x3, 4x4
      
      // Determine cluster size with larger sizes being less frequent
      const sizeWeights = [40, 30, 20, 10]; // 40% 1x1, 30% 2x2, 20% 3x3, 10% 4x4
      const totalWeight = sizeWeights.reduce((sum, weight) => sum + weight, 0);
      
      let randomValue = getDeterministicRandom(seed + zoneIndex + 'clusterSize' + terrainType + clusterIndex);
      let cumulativeWeight = 0;
      let clusterSize = 1;
      
      for (let i = 0; i < sizeWeights.length; i++) {
        cumulativeWeight += sizeWeights[i];
        if (randomValue <= cumulativeWeight / totalWeight) {
          clusterSize = clusterSizes[i];
          break;
        }
      }
      
      // For guaranteed clusters, try harder to find a position
      const maxAttempts = 50; // Reasonable attempts for guaranteed clusters
      
      console.log(`Attempting to place ${terrainType} cluster (size: ${clusterSize}, attempts: ${maxAttempts})`);
      
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const position = findValidClusterPosition(grid, clusterSize, gridSize, seed, zoneIndex, clusterIndex + attempt);
        if (position) {
          placeTerrainCluster(grid, terrainType, position.row, position.col, clusterSize, gridSize);
          console.log(`Successfully placed ${terrainType} cluster at (${position.row}, ${position.col})`);
          return true; // Successfully placed cluster
        }
      }
      
      console.log(`Failed to place ${terrainType} cluster after ${maxAttempts} attempts`);
      
      // If we couldn't find a position, try with smaller cluster size
      if (clusterSize > 1) {
        console.log(`Trying smaller cluster size for ${terrainType}`);
        for (let smallerSize = clusterSize - 1; smallerSize >= 1; smallerSize--) {
          const smallerPosition = findValidClusterPosition(grid, smallerSize, gridSize, seed, zoneIndex, clusterIndex + 'small' + smallerSize);
          if (smallerPosition) {
            placeTerrainCluster(grid, terrainType, smallerPosition.row, smallerPosition.col, smallerSize, gridSize);
            console.log(`Successfully placed smaller ${terrainType} cluster (${smallerSize}x${smallerSize}) at (${smallerPosition.row}, ${smallerPosition.col})`);
            return true;
          }
        }
      }
      
      // Last resort: force placement anywhere (but avoid edges)
      console.log(`Force placing ${terrainType} cluster`);
      const margin = Math.max(1, Math.floor(gridSize * 0.1)); // 10% margin from edges
      const maxPos = gridSize - margin - 1;
      const forcedRow = margin + Math.floor(getDeterministicRandom(seed + zoneIndex + 'force' + terrainType) * maxPos);
      const forcedCol = margin + Math.floor(getDeterministicRandom(seed + zoneIndex + 'force' + terrainType + 'col') * maxPos);
      placeTerrainCluster(grid, terrainType, forcedRow, forcedCol, 1, gridSize);
      console.log(`Force placed ${terrainType} cluster at (${forcedRow}, ${forcedCol})`);
      return true;
      
      return false; // Failed to place cluster
    }
    
    function generateTerrainClusters(grid, terrainType, gridSize, seed, zoneIndex) {
      const clusterSizes = [1, 2, 3, 4]; // 1x1, 2x2, 3x3, 4x4
      const maxClusters = Math.floor(gridSize / 3); // Reduce cluster count to avoid overcrowding
      
      for (let cluster = 0; cluster < maxClusters; cluster++) {
        // Determine cluster size
        let randomValue = getDeterministicRandom(seed + zoneIndex + 'cluster' + cluster + terrainType);
        const clusterSize = clusterSizes[Math.floor(randomValue * clusterSizes.length)];
        
        // Determine if we should place this cluster (lower probability)
        randomValue = getDeterministicRandom(seed + zoneIndex + 'place' + cluster + terrainType);
        if (randomValue > 0.15) continue; // 85% chance to skip cluster (reduced from 70%)
        
        // Find valid position for cluster
        const position = findValidClusterPosition(grid, clusterSize, gridSize, seed, zoneIndex, cluster);
        if (position) {
          placeTerrainCluster(grid, terrainType, position.row, position.col, clusterSize, gridSize);
        }
      }
    }
    
    function findValidClusterPosition(grid, clusterSize, gridSize, seed, zoneIndex, cluster) {
      const maxAttempts = 30;
      
      // Add zone-specific positioning strategy to create variety between zones
      const zoneStrategy = Math.floor(getDeterministicRandom(seed + zoneIndex + 'strategy') * 4);
      const strategies = ['center', 'edge', 'corner', 'scattered'];
      console.log(`Zone ${zoneIndex} using ${strategies[zoneStrategy]} cluster strategy`);
      
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        // Use different positioning strategies for variety
        let row, col;
        
        if (zoneStrategy === 0) {
          // Zone prefers center clusters
          if (attempt < 15) {
            // Try center area first
            const centerStart = Math.floor(gridSize * 0.2);
            const centerEnd = Math.floor(gridSize * 0.8) - clusterSize;
            row = centerStart + Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (centerEnd - centerStart));
            col = centerStart + Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt + 'col') * (centerEnd - centerStart));
          } else {
            // Then try random positions
            row = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize + 1));
            col = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt + 'col') * (gridSize - clusterSize + 1));
          }
        } else if (zoneStrategy === 1) {
          // Zone prefers edge clusters
          if (attempt < 15) {
            // Try edge positions first
            const edge = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * 4);
            if (edge === 0) { // Top edge
              row = 1;
              col = 1 + Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize - 1));
            } else if (edge === 1) { // Bottom edge
              row = gridSize - clusterSize - 1;
              col = 1 + Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize - 1));
            } else if (edge === 2) { // Left edge
              row = 1 + Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize - 1));
              col = 1;
            } else { // Right edge
              row = 1 + Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize - 1));
              col = gridSize - clusterSize - 1;
            }
          } else {
            // Then try random positions
            row = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize + 1));
            col = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt + 'col') * (gridSize - clusterSize + 1));
          }
        } else if (zoneStrategy === 2) {
          // Zone prefers corner clusters
          if (attempt < 15) {
            // Try corner areas first
            const corner = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * 4);
            if (corner === 0) { // Top-left corner
              row = 1;
              col = 1;
            } else if (corner === 1) { // Top-right corner
              row = 1;
              col = gridSize - clusterSize - 1;
            } else if (corner === 2) { // Bottom-left corner
              row = gridSize - clusterSize - 1;
              col = 1;
            } else { // Bottom-right corner
              row = gridSize - clusterSize - 1;
              col = gridSize - clusterSize - 1;
            }
          } else {
            // Then try random positions
            row = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize + 1));
            col = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt + 'col') * (gridSize - clusterSize + 1));
          }
        } else {
          // Zone prefers scattered clusters
          // Always use random positions for maximum variety
          row = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt) * (gridSize - clusterSize + 1));
          col = Math.floor(getDeterministicRandom(seed + zoneIndex + 'pos' + cluster + attempt + 'col') * (gridSize - clusterSize + 1));
        }
        
        // Ensure bounds
        row = Math.max(0, Math.min(row, gridSize - clusterSize));
        col = Math.max(0, Math.min(col, gridSize - clusterSize));
        
        // Check if position is valid
        if (isValidClusterPosition(grid, row, col, clusterSize, gridSize)) {
          return { row, col };
        }
      }
      
      return null;
    }
    
    function isValidClusterPosition(grid, startRow, startCol, clusterSize, gridSize) {
      // Check if cluster fits within grid bounds
      if (startRow + clusterSize > gridSize || startCol + clusterSize > gridSize) {
        return false;
      }
      
      // For guaranteed clusters, be much more permissive
      // Only block if there are roads, rivers, or the exact same terrain type
      for (let row = startRow; row < startRow + clusterSize; row++) {
        for (let col = startCol; col < startCol + clusterSize; col++) {
          const pos = row * gridSize + col;
          if (grid[pos]) {
            // Only block roads, rivers, and the exact terrain we're trying to place
            if (grid[pos].terrain === 'road' || grid[pos].terrain === 'river') {
              return false;
            }
          }
        }
      }
      
      return true;
    }
    
    function placeTerrainCluster(grid, terrainType, startRow, startCol, clusterSize, gridSize) {
      for (let row = startRow; row < startRow + clusterSize; row++) {
        for (let col = startCol; col < startCol + clusterSize; col++) {
          const pos = row * gridSize + col;
          if (grid[pos]) {
            // Don't overwrite roads or rivers - they have priority
            if (grid[pos].terrain !== 'road' && grid[pos].terrain !== 'river') {
              grid[pos].terrain = terrainType;
            }
          }
        }
      }
    }
    
    function getDeterministicRandom(seed) {
            let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        const char = seed.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
            }
      return Math.abs(hash) / 2147483647;
    }
    
    function generateRoads(grid, gridSize, seed, zoneIndex) {
      // Determine number of roads (1-3 roads)
      const roadCount = Math.floor(getDeterministicRandom(seed + zoneIndex + 'roadCount') * 3) + 1;
      
      for (let road = 0; road < roadCount; road++) {
        // Determine road direction (horizontal or vertical)
        const isHorizontal = getDeterministicRandom(seed + zoneIndex + 'roadDir' + road) > 0.5;
        
        if (isHorizontal) {
          // Generate horizontal road
          const row = Math.floor(getDeterministicRandom(seed + zoneIndex + 'roadRow' + road) * gridSize);
          for (let col = 0; col < gridSize; col++) {
            const pos = row * gridSize + col;
            if (grid[pos]) {
              grid[pos].terrain = 'road';
            }
          }
          } else {
          // Generate vertical road
          const col = Math.floor(getDeterministicRandom(seed + zoneIndex + 'roadCol' + road) * gridSize);
          for (let row = 0; row < gridSize; row++) {
            const pos = row * gridSize + col;
            if (grid[pos]) {
              grid[pos].terrain = 'road';
            }
          }
        }
      }
    }
    
    function generateInfrastructure(grid, gridSize, seed, zoneIndex, terrainType) {
      console.log(`Generating infrastructure for: ${terrainType}`);
      // Urban terrain always gets at least one road
      if (terrainType === 'urban') {
        console.log('Urban terrain - generating roads');
        generateRoads(grid, gridSize, seed, zoneIndex);
        return;
      }
      
      // Swamp terrain always gets a river
      if (terrainType === 'swamp') {
        generateRiver(grid, gridSize, seed, zoneIndex);
        return;
      }
      
      // Jungle terrain gets rivers but no roads
      if (terrainType === 'jungle') {
        console.log('Jungle terrain - generating rivers only');
        generateRiver(grid, gridSize, seed, zoneIndex);
        return;
      }
      
      // Mountainous, Volcanic, and Naval terrain get no infrastructure
      if (terrainType === 'mountainous' || terrainType === 'volcanic' || terrainType === 'naval') {
        console.log(`${terrainType} terrain - NO infrastructure allowed`);
        return;
      }
      
      // Determine if it should be road or river based on terrain type
      const roadChance = getInfrastructureChance(terrainType, 'road');
      const riverChance = getInfrastructureChance(terrainType, 'river');
      
      const infrastructureRoll = getDeterministicRandom(seed + zoneIndex + 'infrastructureType');
      
      if (infrastructureRoll <= roadChance) {
        // Generate road
        generateRoads(grid, gridSize, seed, zoneIndex);
      } else if (infrastructureRoll <= roadChance + riverChance) {
        // Generate river
        generateRiver(grid, gridSize, seed, zoneIndex);
      }
      // If neither, no infrastructure is generated
    }
    
    function getInfrastructureChance(terrainType, infrastructureType) {
      const infrastructureChances = {
        plains: { road: 0.6, river: 0.4 },
        forest: { road: 0.2, river: 0.8 },
        town: { road: 0.6, river: 0.4 },
        // Default for other terrain types
        default: { road: 0.5, river: 0.5 }
      };
      
      const chances = infrastructureChances[terrainType] || infrastructureChances.default;
      return chances[infrastructureType] || 0;
    }
    
    function generateBeachTerrain(grid, gridSize) {
      // Generate beach terrain in the first row (attacker's side)
      for (let col = 0; col < gridSize; col++) {
        const pos = 0 * gridSize + col; // First row
        if (grid[pos]) {
          grid[pos].terrain = 'beach';
        }
      }
    }
    
    function generateRiver(grid, gridSize, seed, zoneIndex) {
      // Generate single horizontal river
      const riverRow = Math.floor(getDeterministicRandom(seed + zoneIndex + 'riverRow') * gridSize);
      
      for (let col = 0; col < gridSize; col++) {
        const pos = riverRow * gridSize + col;
        if (grid[pos]) {
          grid[pos].terrain = 'river';
        }
      }
    }
    
    function getTerrainCategory(terrain) {
      const terrainCategories = {
        plains: 'plains',
        forest: 'forest',
        river: 'forest',
        hills: 'plains',
        mountains: 'mountainous',
        swamp: 'swamp',
        desert: 'desert',
        ruins: 'ruins',
        road: 'plains',
        infrastructure: 'town',
        snow: 'snow',
        volcanic: 'volcanic',
        urban: 'urban',
        hilly: 'hilly',
        naval: 'naval',
        beach: 'plains'
      };
      
      return terrainCategories[terrain] || 'random';
    }
    
    function getTerrainFromDistribution(distribution, seed = null, index = 0) {
      const weightedArray = [];
      for (const [terrain, weight] of Object.entries(distribution)) {
        // Skip road and river as they're generated separately
        if (terrain !== 'road' && terrain !== 'river') {
        for (let i = 0; i < weight; i++) {
          weightedArray.push(terrain);
          }
        }
      }
      
      // Use deterministic random if seed is provided
      let randomValue;
      if (seed) {
        const combinedSeed = seed + index + 'dist';
        let hash = 0;
        for (let i = 0; i < combinedSeed.length; i++) {
          const char = combinedSeed.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        randomValue = Math.abs(hash) / 2147483647;
      } else {
        randomValue = Math.random();
      }
      
      return weightedArray[Math.floor(randomValue * weightedArray.length)];
    }
    
    function getRandomTerrain(seed = null, index = 0) {
      const terrainType = gameConfig.terrainType || 'random';
      const distribution = terrainDistributions[terrainType];
      
      // Use deterministic random if seed is provided
      let randomValue;
      if (seed) {
        // Simple deterministic random based on seed and index
        const combinedSeed = seed + index;
        let hash = 0;
        for (let i = 0; i < combinedSeed.length; i++) {
          const char = combinedSeed.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        randomValue = Math.abs(hash) / 2147483647; // Normalize to 0-1
      } else {
        randomValue = Math.random();
      }
      
      if (!distribution) {
        const terrains = Object.keys(terrainEffects);
        return terrains[Math.floor(randomValue * terrains.length)];
      }
      
      const weightedArray = [];
      for (const [terrain, weight] of Object.entries(distribution)) {
        for (let i = 0; i < weight; i++) {
          weightedArray.push(terrain);
        }
      }
      
      return weightedArray[Math.floor(randomValue * weightedArray.length)];
    }
    
    // Zone Action Choice UI
    function showZoneActionChoice(zoneId) {
      if (gameState.gamePhase !== 'selection') return;
      
      const zone = zones.find(z => z.id === zoneId);
      if (!zone || zone.locked) return;
      
      // Check if player has enough CP
      if (!canSpendCP(1)) {
        logMessage('Not enough Command Points to choose zone action (need 1 CP)', 'system');
        return;
      }
      
      // Create action choice modal
      const modal = document.createElement('div');
      modal.className = 'action-choice-modal';
      modal.innerHTML = `
        <div class="action-choice-content">
          <h3>Choose Action for Zone ${zoneNames[zone.name] || zone.name}</h3>
          <div class="cp-cost-info">Cost: 1 Command Point</div>
          <div class="action-buttons">
            <button class="action-btn attack-btn" onclick="selectZoneForAttack('${zoneId}')">
              <strong>Attack</strong><br>
              <small>Deploy units in top row</small>
            </button>
            <button class="action-btn defend-btn" onclick="selectZoneForDefense('${zoneId}')">
              <strong>Defend</strong><br>
              <small>Deploy units in bottom 3 rows</small>
            </button>
          </div>
          <button class="cancel-btn" onclick="closeActionChoice()">Cancel</button>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Add CSS for the modal
      if (!document.getElementById('action-choice-styles')) {
        const style = document.createElement('style');
        style.id = 'action-choice-styles';
        style.textContent = `
          .action-choice-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
          }
          .action-choice-content {
            background: linear-gradient(135deg, 
              rgba(80, 20, 20, 0.95) 0%, 
              rgba(50, 12, 12, 0.98) 25%, 
              rgba(100, 25, 25, 0.92) 50%,
              rgba(60, 15, 15, 0.96) 75%,
              rgba(90, 22, 22, 0.94) 100%
            );
            border: 3px solid rgba(139, 0, 0, 0.9);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            color: white;
            min-width: 350px;
            box-shadow: 
              0 0 60px rgba(255, 0, 0, 0.5),
              0 0 120px rgba(139, 0, 0, 0.3),
              inset 0 2px 0 rgba(255, 80, 80, 0.3),
              inset 0 -2px 0 rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
          }
          .action-choice-content h3 {
            color: #ffd700;
            font-size: 1.5em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
          }
          .cp-cost-info {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 8px 15px;
            margin: 15px 0;
            color: #ffd700;
            font-weight: bold;
            font-size: 0.9em;
          }
          .action-buttons {
            display: flex;
            gap: 20px;
            margin: 25px 0;
            justify-content: center;
          }
          .action-btn {
            padding: 18px 25px;
            border: 2px solid #fff;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
            font-size: 1.1em;
          }
          .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
          }
          .attack-btn {
            border-color: #DC143C;
            background: rgba(220, 20, 60, 0.2);
          }
          .attack-btn:hover {
            background: rgba(220, 20, 60, 0.4);
            border-color: #ff4444;
          }
          .defend-btn {
            border-color: #4169E1;
            background: rgba(65, 105, 225, 0.2);
          }
          .defend-btn:hover {
            background: rgba(65, 105, 225, 0.4);
            border-color: #6666ff;
          }
          .cancel-btn {
            padding: 10px 20px;
            border: 1px solid #fff;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
          }
          .cancel-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
          }
        `;
        document.head.appendChild(style);
      }
    }
    
    function closeActionChoice() {
      const modal = document.querySelector('.action-choice-modal');
      if (modal) {
        modal.remove();
      }
    }
    
    function showZoneAlreadyChosenInfo(zoneId) {
      const zone = zones.find(z => z.id === zoneId);
      if (!zone) return;
      
      const zoneRole = gameState.zoneRoles[zoneId];
      const attackerName = zoneRole.attacker === 'red' ? gameConfig.player1.name : gameConfig.player2.name;
      const defenderName = zoneRole.defender === 'red' ? gameConfig.player1.name : gameConfig.player2.name;
      
      // Create info modal
      const modal = document.createElement('div');
      modal.className = 'action-choice-modal';
      modal.innerHTML = `
        <div class="action-choice-content">
          <h3>Zone ${zoneNames[zone.name] || zone.name} Already Chosen</h3>
          <div class="zone-info">
            <p><strong>Attacker:</strong> ${attackerName}</p>
            <p><strong>Defender:</strong> ${defenderName}</p>
            <p style="color: #FFD700; margin-top: 15px;">
              This zone has already been selected for battle. 
              You cannot change the attack/defense choice once made.
            </p>
          </div>
          <button class="cancel-btn" onclick="closeActionChoice()">Close</button>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    // Zone Selection Functions
    function selectZoneForAttack(zoneId) {
      console.log('=== SELECT ZONE FOR ATTACK ===');
      console.log('Zone ID:', zoneId);
      console.log('Game Phase:', gameState.gamePhase);
      console.log('Is AI Turn:', isAITurn());
      
      if (gameState.gamePhase !== 'selection') {
        console.log('BLOCKED: Wrong game phase');
        return;
      }
      if (isAITurn()) {
        console.log('BLOCKED: AI turn');
        return;
      }
      if (!isMyTurn()) {
        console.log('BLOCKED: Not your turn');
        return;
      }
      
      const zone = zones.find(z => z.id === zoneId);
      if (!zone || zone.locked) return;
      
      // Spend CP for choosing zone action
      spendCP(1);
      
      // Set zone roles - current player is attacker, other player is defender
      gameState.zoneRoles[zoneId] = {
        attacker: gameState.currentPlayer,
        defender: gameState.currentPlayer === 'red' ? 'blue' : 'red'
      };
      
      // Lock zone for current player
      zone.locked = true;
      gameState.lockedZones[gameState.currentPlayer].push(zoneId);
      
      const zoneName = zoneNames[zoneId] || zoneId;
      logMessage(`Zone ${zoneName} selected for attack by ${gameState.currentPlayer === 'red' ? gameConfig.player1.name : gameConfig.player2.name}`, 'system');
      logMessage(`Zone ${zoneId} is now locked - ${gameState.currentPlayer === 'red' ? 'Blue' : 'Red'} player will defend`, 'system');
      
      closeActionChoice();
      renderBattlefield();
      
      // Send update to other players in multiplayer (only if not updating from server)
      if (isMultiplayerMode && !isUpdatingFromServer) {
        sendBattlefieldUpdate();
      }
      
      // Enter zone detail for this zone
      enterZone(zoneId);
    }
    
    function selectZoneForDefense(zoneId) {
      console.log('=== SELECT ZONE FOR DEFENSE ===');
      console.log('Zone ID:', zoneId);
      console.log('Game Phase:', gameState.gamePhase);
      console.log('Is AI Turn:', isAITurn());
      
      if (gameState.gamePhase !== 'selection') {
        console.log('BLOCKED: Wrong game phase');
        return;
      }
      if (isAITurn()) {
        console.log('BLOCKED: AI turn');
        return;
      }
      if (!isMyTurn()) {
        console.log('BLOCKED: Not your turn');
        return;
      }
      
      const zone = zones.find(z => z.id === zoneId);
      if (!zone || zone.locked) return;
      
      // Spend CP for choosing zone action
      spendCP(1);
      
      // Set zone roles - current player is defender, other player is attacker
      gameState.zoneRoles[zoneId] = {
        attacker: gameState.currentPlayer === 'red' ? 'blue' : 'red',
        defender: gameState.currentPlayer
      };
      
      // Lock zone for current player
      zone.locked = true;
      gameState.lockedZones[gameState.currentPlayer].push(zoneId);
      
      const zoneName = zoneNames[zoneId] || zoneId;
      logMessage(`Zone ${zoneName} selected for defense by ${gameState.currentPlayer === 'red' ? gameConfig.player1.name : gameConfig.player2.name}`, 'system');
      logMessage(`Zone ${zoneId} is now locked - ${gameState.currentPlayer === 'red' ? 'Blue' : 'Red'} player will attack`, 'system');
      
      closeActionChoice();
      renderBattlefield();
      
      // Send update to other players in multiplayer (only if not updating from server)
      if (isMultiplayerMode && !isUpdatingFromServer) {
        sendBattlefieldUpdate();
      }
      
      // Enter zone detail for this zone
      enterZone(zoneId);
    }
    
    // Zone selection functions restored with attack/defense choice
    
    // Zone Detail Functions
    function enterZone(zoneId) {
      console.log('=== ENTER ZONE ===', zoneId);
      currentZoneDetail = zones.find(z => z.id === zoneId);
      if (!currentZoneDetail) {
        console.error('Zone not found:', zoneId);
        return;
      }
      
      gameState.currentZone = zoneId;
      
      // Determine game mode based on zone roles (first-come-first-served)
      const zoneRole = gameState.zoneRoles[zoneId];
      let gameMode;
      
      console.log('=== ZONE ROLE DEBUG ===');
      console.log('Zone ID:', zoneId);
      console.log('Current Player:', gameState.currentPlayer);
      console.log('Zone Role:', zoneRole);
      
      if (zoneRole) {
        // Zone has been selected - check if current player is attacker or defender
        if (zoneRole.attacker === gameState.currentPlayer) {
          gameMode = 'attack';
          console.log('Current player is attacker (first to select)');
        } else if (zoneRole.defender === gameState.currentPlayer) {
          gameMode = 'defense';
          console.log('Current player is defender (first to select)');
        } else {
          // Current player didn't select this zone - they get the opposite role
          // If someone else is attacker, current player is defender
          // If someone else is defender, current player is attacker
          if (zoneRole.attacker !== gameState.currentPlayer) {
            gameMode = 'defense'; // Someone else is attacking, so we defend
          } else {
            gameMode = 'attack'; // Someone else is defending, so we attack
          }
          console.log('Current player gets opposite role:', gameMode);
        }
      } else {
        // Zone hasn't been selected yet - default to attack mode
        gameMode = 'attack';
        console.log('No zone role set, defaulting to attack');
      }
      
      console.log('Final game mode:', gameMode);
      gameState.currentZonePhase = gameMode;
      
      // Reset unit actions for this zone
      resetUnitActions();
      
      // Reset movement mode
      resetMovementMode();
      
      console.log(`Zone mode set to: ${gameState.currentZonePhase}`);
      console.log('About to show zone-detail screen...');
      showScreen('zone-detail');
      console.log('Zone detail screen should be shown now');
      setupZoneDetail();
      
      // Fix scrolling to prevent going past bottom panel
      // Temporarily disabled to test scrolling
      // fixZoneDetailScrolling();
    }
    
    function resetUnitActions() {
      // Reset actions for all units in the current zone
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = currentZoneDetail.tacticalGrid[pos].unit;
        if (unit && unit.player === gameState.currentPlayer) {
          gameState.unitActions[unit.id] = { 
            hasAttacked: false,
            hasMoved: false
          };
        }
      }
    }

    // Fix scrolling to prevent going past bottom panel
    function fixZoneDetailScrolling() {
      console.log(' [SCROLL DEBUG] Fixing zone detail scrolling...');
      
      const zoneDetail = document.getElementById('zone-detail');
      if (!zoneDetail) {
        console.warn(' [SCROLL DEBUG] Zone detail element not found');
        return;
      }

      // Calculate the actual content height
      const contentHeight = zoneDetail.scrollHeight;
      const containerHeight = zoneDetail.clientHeight;
      const maxScroll = contentHeight - containerHeight;
      
      console.log(' [SCROLL DEBUG] Content height:', contentHeight);
      console.log(' [SCROLL DEBUG] Container height:', containerHeight);
      console.log(' [SCROLL DEBUG] Max scroll:', maxScroll);

      // Remove any existing scroll listeners to prevent duplicates
      zoneDetail.removeEventListener('scroll', zoneDetail._scrollHandler);
      
      // Create a new scroll handler function
      zoneDetail._scrollHandler = function(e) {
        // Only prevent scrolling if we're trying to go past the bottom
        if (this.scrollTop > maxScroll) {
          console.log(' [SCROLL DEBUG] Preventing scroll past bottom');
          this.scrollTop = maxScroll;
        }
      };
      
      // Add the scroll event listener
      zoneDetail.addEventListener('scroll', zoneDetail._scrollHandler);

      // Force scroll to top initially
      zoneDetail.scrollTop = 0;
      
      console.log(' [SCROLL DEBUG] Zone detail scrolling fixed');
    }
    
    function clearTemporaryMovementBonuses() {
      // Clear all temporary movement bonuses for all units at the end of turn
      for (const zone of zones) {
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const unit = zone.tacticalGrid[pos].unit;
          if (unit && unit.roadMovementBonus) {
            console.log(` [ROAD DEBUG] Clearing road movement bonus for ${unit.name} at position ${pos}`);
            unit.roadMovementBonus = undefined;
            // Restore defense penalty that was applied on road
            unit.defense += 1;
          }
          if (unit && unit.mobileCoverRoadBonus) {
            console.log(` [ROAD DEBUG] Clearing mobile cover road bonus for ${unit.name} at position ${pos}`);
            unit.mobileCoverRoadBonus = undefined;
          }
          if (unit && unit.terrainMovementBonus) {
            console.log(` [TERRAIN DEBUG] Clearing terrain movement bonus for ${unit.name} at position ${pos}`);
            unit.terrainMovementBonus = undefined;
          }
          if (unit && unit.abilityMovementBonus) {
            console.log(` [AMPHIBIOUS DEBUG] Clearing ability movement bonus for ${unit.name} at position ${pos}`);
            unit.abilityMovementBonus = undefined;
          }
        }
      }
      
      // Also reset movement mode if it's active
      if (gameState.movementMode && gameState.movementMode.active) {
        const unit = gameState.movementMode.selectedUnit;
        if (unit) {
          // Recalculate movement points without temporary bonuses
          const temporaryBonus = (unit.roadMovementBonus || 0) + 
                                (unit.mobileCoverRoadBonus || 0) + 
                                (unit.terrainMovementBonus || 0) + 
                                (unit.abilityMovementBonus || 0);
          gameState.movementMode.movementPoints = unit.movement;
          console.log(` [ROAD DEBUG] Reset movement mode points for ${unit.name}: base=${unit.movement}, cleared bonus=${temporaryBonus}`);
        }
      }
    }
    
    function setupZoneDetail() {
      console.log('=== SETUP ZONE DETAIL ===');
      
      // Ensure page scrolls to top when zone detail loads
      window.scrollTo(0, 0);
      
      // Reset zone detail screen scroll position
      const zoneDetail = document.getElementById('zone-detail');
      if (zoneDetail) {
        zoneDetail.scrollTop = 0;
        console.log(' [SCROLL DEBUG] Reset zone detail scroll to top');
        
        // Debug scroll container properties
        console.log('Zone detail scroll properties:');
        console.log('- scrollHeight:', zoneDetail.scrollHeight);
        console.log('- clientHeight:', zoneDetail.clientHeight);
        console.log('- scrollTop:', zoneDetail.scrollTop);
        console.log('- overflow-y:', getComputedStyle(zoneDetail).overflowY);
        console.log('- height:', getComputedStyle(zoneDetail).height);
        console.log('- min-height:', getComputedStyle(zoneDetail).minHeight);
        
        // Apply scroll fix to prevent going past bottom panel
        // Temporarily disabled to test scrolling
        // fixZoneDetailScrolling();
      }
      
      // Ensure Intelligence Report panel is visible (preserve original styling)
      const chatPanel = document.querySelector('.chat-panel');
      if (chatPanel) {
        // Only set display if it's currently hidden, otherwise preserve original styling
        if (chatPanel.style.display === 'none') {
          chatPanel.style.display = 'block';
          console.log(' [INTELLIGENCE DEBUG] Ensured Intelligence Report panel is visible in zone detail');
        } else {
          console.log(' [INTELLIGENCE DEBUG] Intelligence Report panel already visible, preserving styling');
        }
        
        // Ensure scrollbar styling is preserved
        const chatMessages = chatPanel.querySelector('.chat-messages');
        if (chatMessages && chatMessages.style.overflowY === '') {
          chatMessages.style.overflowY = 'auto';
          console.log(' [INTELLIGENCE DEBUG] Restored chat-messages overflow-y styling in zone detail');
        }
      }
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
      
      updatePhaseIndicator();
      updateZoneDetailTitle();
      generateMiniBattlefield();
      updateCommandPointsDisplay();
      // Ensure Build Points UI reflects current player's value when entering zone detail
      updateBuildPointsDisplay();
      
      // Initialize systems after a short delay to ensure screen is loaded
      setTimeout(() => {
        console.log(' [SETUP DEBUG] Starting system initialization...');
        
        // Test if panels exist
        const constructionPanel = document.querySelector('.construction-panel');
        const artilleryPanel = document.querySelector('.artillery-panel');
        const aerialPanel = document.querySelector('.aerial-panel');
        
        console.log(' [SETUP DEBUG] Panel elements found:');
        console.log(' [SETUP DEBUG] - Construction panel:', !!constructionPanel);
        console.log(' [SETUP DEBUG] - Artillery panel:', !!artilleryPanel);
        console.log(' [SETUP DEBUG] - Aerial panel:', !!aerialPanel);
        
        // Check if zone detail screen is visible
        const zoneDetailScreen = document.getElementById('zone-detail');
        console.log(' [SETUP DEBUG] Zone detail screen visible:', zoneDetailScreen?.style.display !== 'none');
        console.log(' [SETUP DEBUG] Zone detail screen display:', zoneDetailScreen?.style.display);
        
        // Initialize artillery system for current player
        console.log(' [SETUP DEBUG] Initializing artillery system...');
        initializeArtillerySystem();
        
        // Initialize aerial system for current player
        console.log(' [SETUP DEBUG] Initializing aerial system...');
        initializeAerialSystem();
        
        // Initialize construction system
        console.log(' [SETUP DEBUG] About to initialize construction panel...');
        initializeConstructionPanel();
        console.log(' [SETUP DEBUG] Construction panel initialization completed');
        
        console.log(' [SETUP DEBUG] All systems initialized');
        
        // Check for any units that need deferred morale checks from gas damage
        checkForDeferredMoraleChecks();
        
        // Check for units standing in gas clouds and apply damage with animations
        checkUnitsInGasClouds();
      }, 100);
      
      logZoneMessage('Phase started');
      
      // Reset deployment mode and selected unit
      gameState.deploymentMode = 'place';
      gameState.selectedUnit = null;
      updateSelectedUnitInfo();
      setDeploymentModeUI('place');
      
      // Show army selection first
      console.log('About to show army selection...');
      showArmySelection();
      console.log('Army selection should be shown now');
    }
    
    // New Simple Army Selection Functions
    function showArmySelection() {
      console.log(' [SHOW ARMY SELECTION DEBUG] showArmySelection() called');
      console.log(' [SHOW ARMY SELECTION DEBUG] Current screen:', document.querySelector('.screen.active')?.id);
      console.log('=== SHOW ARMY SELECTION ===');
      gameState.armySelectionMode = true;
      
      // Show army selection container, hide army pool
      const armySelectionContainer = document.getElementById('army-selection-container');
      const armyPoolContainer = document.getElementById('army-pool-container');
      
      if (armySelectionContainer) {
        armySelectionContainer.style.display = 'block';
        console.log('Army selection container shown');
      } else {
        console.error('Army selection container not found!');
      }
      
      if (armyPoolContainer) {
        armyPoolContainer.style.display = 'none';
        console.log('Army pool container hidden');
      }
      
      // Reset army selection state
      gameState.selectedArmyInZone[gameState.currentPlayer] = null;
      gameState.selectedUnit = null;
      
      // Reset the army selector UI
      const dropdown = document.getElementById('army-selector-dropdown');
      const armyInfo = document.getElementById('selected-army-info');
      const armySelectorText = document.getElementById('army-selector-text');
      
      if (dropdown) {
        dropdown.style.display = 'block';
        dropdown.value = '';
      }
      
      if (armyInfo) {
        armyInfo.style.display = 'none';
      }
      
      // Reset the legion selection button text
      if (armySelectorText) {
        console.log(' [LEGION DEBUG] Current army selector text before reset:', armySelectorText.textContent);
        armySelectorText.textContent = 'Choose legion...';
        console.log(' [LEGION DEBUG] Legion selection button text reset to "Choose legion..."');
        console.log(' [LEGION DEBUG] Army selector text after reset:', armySelectorText.textContent);
      } else {
        console.log(' [LEGION DEBUG] army-selector-text element not found in showArmySelection!');
      }
      
      console.log(' [DEBUG] About to load army dropdown...');
      console.log(' [DEBUG] Current player:', gameState.currentPlayer);
      console.log(' [DEBUG] gameData.selectedArmies:', gameData.selectedArmies);
      console.log(' [DEBUG] gameData.savedArmies:', gameData.savedArmies);
      loadArmyDropdown();
      console.log(' [DEBUG] Army dropdown should be loaded');
    }
    
    function loadArmySelectionCards() {
      console.log('=== LOAD ARMY SELECTION CARDS ===');
      const container = document.getElementById('army-cards-grid');
      console.log('Army cards grid container:', container);
      
      if (!container) {
        console.error('Army cards grid container not found!');
        return;
      }
      
      container.innerHTML = '';
      console.log('Cleared army cards grid');
      
      // Get available armies for current player
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      let availableArmies = gameData.selectedArmies[playerId];
      
      console.log('Loading army selection cards for player:', playerId);
      console.log('Available armies:', availableArmies);
      console.log('gameData.selectedArmies:', gameData.selectedArmies);
      
      // If no armies are selected, create a default army
      if (!availableArmies || availableArmies.length === 0) {
        console.log('No armies found, creating default army');
        availableArmies = [{
          id: 'default',
          name: 'Default Army',
          units: [...defaultUnits, ...gameData.customUnits]
        }];
        console.log('Created default army:', availableArmies[0]);
      }
      
            availableArmies.forEach((army, armyIndex) => {
        const armyCard = document.createElement('div');
        armyCard.className = 'army-card';
        armyCard.onclick = () => selectArmyForDeployment(army, armyIndex);
        
        // Re-enable tooltips for deployed units
        if (deployedUnits.length > 0) {
          try {
            const tooltipText = deployedUnits.map(d => {
              const zone = zones.find(z => z.id === d.zoneId);
              const zoneName = zone ? zone.name : d.zoneId;
              const displayZoneName = zoneNames[zoneName] || zoneName;
        return `${d.unitData.name}  Zone ${displayZoneName}`;
            }).join('\n');
            armyCard.title = `Deployed units:\n${tooltipText}`;
          } catch (error) {
            console.warn('Error creating tooltip for army:', army.name, error);
          }
        }
        
        // Re-enable army deployment checking
        let deployedUnits = [];
        try {
          deployedUnits = getDeployedUnitsFromArmy(army.id, playerId);
        } catch (error) {
          console.warn('Error checking deployed units for army:', army.name, error);
          deployedUnits = [];
        }
        // Count only non-artillery and non-aerial units for deployment
        // Field guns can be deployed on the grid (they have movement values)
        const deployableUnits = army.units.filter(unit => 
          unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber'
        );
        const totalUnits = deployableUnits.length;
        const availableUnits = totalUnits - deployedUnits.length;
        
        let statusClass = 'available';
        let statusText = 'Available';
        
        if (availableUnits === 0) {
          statusClass = 'exhausted';
          statusText = 'Exhausted';
        } else if (deployedUnits.length > 0) {
          statusClass = 'partially-used';
          statusText = 'Partially Used';
        }
        
        armyCard.classList.add(statusClass);
        
        // Calculate army composition (excluding artillery and aerial for deployment count)
        const unitTypes = {};
        const artilleryCount = army.units.filter(unit => unit.type === 'artillery').length;
        const aerialCount = army.units.filter(unit => unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship').length;
        army.units.forEach(unit => {
                      if (unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber') {
            unitTypes[unit.type] = (unitTypes[unit.type] || 0) + 1;
          }
        });
        
        const compositionText = Object.entries(unitTypes)
          .map(([type, count]) => `${count} ${formatUnitType(type)}`)
          .join(', ');
        
        const artilleryText = artilleryCount > 0 ? ` + ${artilleryCount} artillery` : '';
        const aerialText = aerialCount > 0 ? ` + ${aerialCount} aerial` : '';
        
        armyCard.innerHTML = `
          <div class="army-card-name">${army.name}</div>
          <div class="army-card-stats">${totalUnits} units: ${compositionText}${artilleryText}${aerialText}</div>
          <div class="army-card-stats">Available: ${availableUnits}/${totalUnits}</div>
          ${deployedUnits.length > 0 ? `<div class="army-card-stats" style="color: #FFD700; font-size: 12px;">Deployed: ${deployedUnits.map(d => {
            const zone = zones.find(z => z.id === d.zoneId);
            const zoneName = zone ? zone.name : d.zoneId;
        return zoneNames[zoneName] || zoneName;
          }).join(', ')}</div>` : ''}
          <div class="army-card-status ${statusClass}">${statusText}</div>
          ${deployedUnits.length > 0 ? '<div class="army-deployed-indicator"></div>' : ''}
          ${availableUnits > 0 ? '<div class="army-available-indicator"></div>' : ''}
          ${army.id !== 'default' ? `<button class="small-button delete" onclick="deleteArmyFromBattle('${army.id}')" style="position: absolute; top: 5px; right: 5px; font-size: 10px;">Delete</button>` : ''}
        `;
        
        container.appendChild(armyCard);
        console.log('Added army card for:', army.name);
      });
      
      console.log('Total army cards created:', container.children.length);
      console.log('=== END LOAD ARMY SELECTION CARDS ===');
    }
    
    // New Dropdown-based Army Selection Functions
    function loadArmyDropdown() {
      console.log('=== LOAD ARMY DROPDOWN ===');
      const dropdown = document.getElementById('army-selector-dropdown');
      const menu = document.getElementById('army-selector-menu');
      console.log('Army dropdown:', dropdown);
      
      if (!dropdown || !menu) {
        console.error('Themed army dropdown elements not found!');
        return;
      }
      
      // Clear existing options
      menu.innerHTML = '';
      console.log('Cleared army dropdown');
      
      // Get available armies for current player only
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      let availableArmies = gameData.selectedArmies[playerId] || [];
      
      console.log(' [DEBUG] Loading army dropdown for player:', playerId);
      console.log(' [DEBUG] Available armies from selectedArmies:', availableArmies);
      console.log(' [DEBUG] gameData.selectedArmies:', gameData.selectedArmies);
      console.log(' [DEBUG] gameData.savedArmies:', gameData.savedArmies);
      
      // Only show armies that are actually selected for the current player
      console.log(' [DEBUG] Using only selected armies for current player...');
      
      // Use only the armies that are in selectedArmies for this player
      // No need to add custom armies from savedArmies - they should only appear if selected
      availableArmies = availableArmies || [];
      
      console.log(' [DEBUG] Final available armies for dropdown:', availableArmies);
      
      // Validate and fix army data
      availableArmies = availableArmies.map(army => {
        if (!army.units || !Array.isArray(army.units)) {
          console.warn(' [DEBUG] Army missing units array, fixing:', army.name);
          army.units = [...defaultUnits, ...gameData.customUnits];
        }
        return army;
      });
      
      console.log(' [DEBUG] Validated armies:', availableArmies);
      
      // If no armies are available, create a default army
      if (availableArmies.length === 0) {
        console.log('No armies found, creating default army');
        availableArmies = [{
          id: 'default',
          name: 'Default Army',
          units: [...defaultUnits, ...gameData.customUnits]
        }];
        console.log('Created default army:', availableArmies[0]);
      }
      
      // Add army options to dropdown
      console.log(' [DEBUG] Creating dropdown options for', availableArmies.length, 'armies');
      
      availableArmies.forEach((army, armyIndex) => {
        console.log(' [DEBUG] Creating option for army:', army.name, 'ID:', army.id, 'Index:', armyIndex);
        
        const option = document.createElement('div');
        option.className = 'themed-dropdown-option';
        option.setAttribute('data-value', army.id || armyIndex);
        
        // Create detailed army option with unit information
        const unitTypes = {};
        if (army.units && Array.isArray(army.units)) {
          army.units.forEach(unit => {
            unitTypes[unit.type] = (unitTypes[unit.type] || 0) + 1;
          });
        } else {
          console.warn(' [DEBUG] Army has no units array:', army);
        }
        
        const compositionText = Object.entries(unitTypes)
          .map(([type, count]) => `${count} ${formatUnitType(type)}`)
          .join(', ');
        
        option.innerHTML = `
          <div class="army-option-name">${army.name}</div>
          <div class="army-option-composition">${army.units ? army.units.length : 0} units: ${compositionText}</div>
        `;
        
        menu.appendChild(option);
        console.log(' [DEBUG] Added army option:', army.name, 'with composition:', compositionText, 'value:', army.id);
      });
      
      console.log(' [DEBUG] Total dropdown options created:', menu.children.length);
      
      console.log('Total army options created:', menu.children.length);
      
      // Initialize the themed dropdown functionality
      console.log(' [DEBUG] Initializing themed dropdown...');
      initializeArmyDropdown();
      console.log(' [DEBUG] Themed dropdown initialization complete');
    }
    
    function initializeArmyDropdown() {
      console.log(' Initializing themed army dropdown...');
      
      const dropdown = document.getElementById('army-selector-dropdown');
      const button = document.getElementById('army-selector-button');
      const text = document.getElementById('army-selector-text');
      const menu = document.getElementById('army-selector-menu');
      
      if (!dropdown || !button || !text || !menu) {
        console.error(' Themed army dropdown elements not found');
        return;
      }
      
      // Clone and replace to prevent duplicate event listeners
      const freshDropdown = dropdown.cloneNode(true);
      const freshButton = freshDropdown.querySelector('#army-selector-button');
      const freshText = freshDropdown.querySelector('#army-selector-text');
      const freshMenu = freshDropdown.querySelector('#army-selector-menu');
      
      dropdown.parentNode.replaceChild(freshDropdown, dropdown);
      
      // Re-get elements after replacement
      const newDropdown = document.getElementById('army-selector-dropdown');
      const newButton = document.getElementById('army-selector-button');
      const newText = document.getElementById('army-selector-text');
      const newMenu = document.getElementById('army-selector-menu');
      
      let isOpen = false;
      let isSelecting = false; // Flag to prevent multiple rapid selections
      
      // Toggle dropdown
      newButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log(' [CLICK DEBUG] Toggle button clicked');
        console.log(' [CLICK DEBUG] Current isOpen state:', isOpen);
        console.log(' [CLICK DEBUG] Event target:', e.target);
        console.log(' [CLICK DEBUG] Event type:', e.type);
        
        // Add a small delay to prevent double-click issues
        setTimeout(() => {
          console.log(' [CLICK DEBUG] Executing toggle after delay');
        isOpen = !isOpen;
          console.log(' [CLICK DEBUG] New isOpen state:', isOpen);
        
        if (isOpen) {
            console.log(' [CLICK DEBUG] Opening dropdown...');
          newDropdown.classList.add('open');
            
            // Expand the screen when dropdown opens
            const zoneDetail = document.getElementById('zone-detail');
            const armySelectionContainer = document.querySelector('.army-selection-container');
            
            if (zoneDetail) {
              zoneDetail.classList.add('dropdown-open');
              console.log(' [CLICK DEBUG] Screen expanded for dropdown');
            }
            
            if (armySelectionContainer) {
              // Calculate dynamic height based on number of armies
              const dropdownOptions = newDropdown.querySelectorAll('.themed-dropdown-option');
              const numArmies = dropdownOptions.length;
              
              // Calculate height: base height + (number of armies * height per army) + padding
              const baseHeight = 200; // Base height for the container
              const heightPerArmy = 80; // Height per army option
              const padding = 40; // Extra padding
              const dynamicHeight = baseHeight + (numArmies * heightPerArmy) + padding;
              
              // Set dynamic height
              armySelectionContainer.style.minHeight = `${dynamicHeight}px`;
              armySelectionContainer.style.height = `${dynamicHeight}px`;
              
              // Add a subtle animation to the legion box
              armySelectionContainer.style.transition = 'all 0.3s ease';
              console.log(' [CLICK DEBUG] Legion box expanded with animation');
              console.log(' [CLICK DEBUG] Dynamic height calculated:', dynamicHeight, 'px for', numArmies, 'armies');
            }
            
            // Position the dropdown options correctly for expanded layout
            const options = newDropdown.querySelector('.themed-dropdown-options');
            if (options) {
              // In expanded mode, position relative to the container
              options.style.position = 'relative';
              options.style.top = 'auto';
              options.style.left = 'auto';
              options.style.width = '100%';
              options.style.marginTop = '10px';
              console.log(' [CLICK DEBUG] Dropdown positioned for expanded layout');
            }
            
            console.log(' [CLICK DEBUG] Dropdown opened and positioned');
        } else {
            console.log(' [CLICK DEBUG] Closing dropdown...');
          newDropdown.classList.remove('open');
            
            // Collapse the screen when dropdown closes
            const zoneDetail = document.getElementById('zone-detail');
            if (zoneDetail) {
              zoneDetail.classList.remove('dropdown-open');
              console.log(' [CLICK DEBUG] Screen collapsed');
            }
            
            console.log(' [CLICK DEBUG] Dropdown closed');
          }
        }, 10);
      });
      
      // Handle option selection
      newMenu.addEventListener('click', function(e) {
        console.log(' [CLICK DEBUG] Menu click event triggered');
        console.log(' [CLICK DEBUG] Event target:', e.target);
        console.log(' [CLICK DEBUG] Target classes:', e.target.classList);
        
        // Find the closest themed-dropdown-option parent
        let targetElement = e.target;
        let dropdownOption = null;
        
        while (targetElement && targetElement !== newMenu) {
          if (targetElement.classList.contains('themed-dropdown-option')) {
            dropdownOption = targetElement;
            break;
          }
          targetElement = targetElement.parentElement;
        }
        
        console.log(' [CLICK DEBUG] Found dropdown option:', !!dropdownOption);
        
        if (dropdownOption && !isSelecting) {
          e.preventDefault();
          e.stopPropagation();
          
          // Set flag to prevent multiple selections
          isSelecting = true;
          console.log(' [CLICK DEBUG] Setting selection flag to prevent multiple clicks');
          
          const selectedValue = dropdownOption.getAttribute('data-value');
          const armyNameElement = dropdownOption.querySelector('.army-option-name');
          const selectedText = armyNameElement ? armyNameElement.textContent : dropdownOption.textContent;
          
          console.log(' [CLICK DEBUG] Army option clicked!');
          console.log(' [CLICK DEBUG] Selected value:', selectedValue);
          console.log(' [CLICK DEBUG] Selected text:', selectedText);
          console.log(' [CLICK DEBUG] Army name element found:', !!armyNameElement);
          
          newText.textContent = selectedText;
          newDropdown.classList.remove('open');
          isOpen = false;
          
          console.log(' [CLICK DEBUG] Dropdown closed after selection');
          
          // Collapse the screen when option is selected
          const zoneDetail = document.getElementById('zone-detail');
          if (zoneDetail) {
            zoneDetail.classList.remove('dropdown-open');
            console.log(' [CLICK DEBUG] Screen collapsed after selection');
          }
          
          // Add selection effect
          dropdownOption.classList.add('selected');
          
          setTimeout(() => {
            dropdownOption.classList.remove('selected');
          }, 200);
          
          // Trigger army selection immediately
          console.log(' [CLICK DEBUG] About to call selectArmyFromDropdown with value:', selectedValue);
          selectArmyFromDropdown(selectedValue);
          console.log(' [CLICK DEBUG] selectArmyFromDropdown call completed');
          
          // Reset selection flag after a delay
          setTimeout(() => {
            isSelecting = false;
            console.log(' [CLICK DEBUG] Reset selection flag');
          }, 1000);
        } else if (isSelecting) {
          console.log(' [CLICK DEBUG] Selection in progress, ignoring click');
        } else {
          console.log(' [CLICK DEBUG] Click was not on a dropdown option');
        }
      });
      
      // Close dropdown when clicking outside
      document.addEventListener('click', function(e) {
        // Only close if dropdown is open and click is outside the dropdown
        if (isOpen && !newDropdown.contains(e.target)) {
          console.log(' [CLICK DEBUG] Click outside detected');
          console.log(' [CLICK DEBUG] Click target:', e.target);
          console.log(' [CLICK DEBUG] Dropdown contains target:', newDropdown.contains(e.target));
          
          // Add a small delay to prevent conflicts with the toggle
          setTimeout(() => {
            if (isOpen) {
              console.log(' [CLICK DEBUG] Closing dropdown due to outside click');
          newDropdown.classList.remove('open');
          isOpen = false;
              
              // Collapse the screen when dropdown is closed by outside click
              const zoneDetail = document.getElementById('zone-detail');
              if (zoneDetail) {
                zoneDetail.classList.remove('dropdown-open');
                console.log(' [CLICK DEBUG] Screen collapsed after outside click');
              }
              
              console.log(' [CLICK DEBUG] Dropdown closed by click outside');
            } else {
              console.log(' [CLICK DEBUG] Dropdown already closed, ignoring outside click');
            }
          }, 50);
        }
      });
      
      console.log(' Themed army dropdown initialization complete');
    }
    
    function selectArmyFromDropdown(selectedValue) {
      console.log(' [SELECTION DEBUG] ===== ARMY SELECTION START =====');
      console.log(' [SELECTION DEBUG] selectArmyFromDropdown called with value:', selectedValue);
      console.log(' [SELECTION DEBUG] Current player:', gameState.currentPlayer);
      console.log(' [SELECTION DEBUG] Current game phase:', gameState.gamePhase);
      
      if (!selectedValue || selectedValue === '') {
        console.log(' [SELECTION DEBUG] No army selected - empty value');
        return;
      }
      
      // Ensure we have the current player info
      if (!gameState.currentPlayer) {
        console.error(' [SELECTION DEBUG] No current player set');
        return;
      }
      
      // Get available armies for current player (same logic as in loadArmyDropdown)
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      let availableArmies = gameData.selectedArmies[playerId] || [];
      
      console.log(' [DEBUG] selectArmyFromDropdown - playerId:', playerId);
      console.log(' [DEBUG] selectArmyFromDropdown - selectedArmies:', gameData.selectedArmies[playerId]);
      
      // Use only the armies that are actually selected for the current player
      console.log(' [DEBUG] Using only selected armies for current player in selection...');
      
      // Use only the armies that are in selectedArmies for this player
      // No need to add custom armies from savedArmies - they should only appear if selected
      availableArmies = availableArmies || [];
      
      // If no armies are available, create a default army
      if (availableArmies.length === 0) {
        console.log('No armies found, creating default army');
        availableArmies = [{
          id: 'default',
          name: 'Default Army',
          units: [...defaultUnits, ...gameData.customUnits]
        }];
        console.log('Created default army:', availableArmies[0]);
      }
      
      // Find the selected army by value
      let selectedArmy = null;
      let selectedIndex = -1;
      
      console.log(' [DEBUG] Looking for army with ID:', selectedValue);
      console.log(' [DEBUG] Available armies:', availableArmies);
      console.log(' [DEBUG] Available armies length:', availableArmies.length);
      console.log(' [DEBUG] Available armies details:', availableArmies.map(army => ({
        id: army.id,
        name: army.name,
        unitsCount: army.units ? army.units.length : 0
      })));
      
      // First check if it's one of the predefined armies
      if (selectedValue === 'demonic-horde') {
        selectedArmy = {
          id: 'demonic-horde',
          name: '1st Demonic Horde',
          units: [...defaultUnits, ...gameData.customUnits]
        };
        selectedIndex = 0;
      } else if (selectedValue === 'hellfire-battalion') {
        selectedArmy = {
          id: 'hellfire-battalion',
          name: 'Hellfire Battalion',
          units: [...defaultUnits, ...gameData.customUnits]
        };
        selectedIndex = 1;
      } else if (selectedValue === 'shadow-regiment') {
        selectedArmy = {
          id: 'shadow-regiment',
          name: 'Shadow Regiment',
          units: [...defaultUnits, ...gameData.customUnits]
        };
        selectedIndex = 2;
      } else {
        // Check available armies - try both exact match and string conversion
        selectedIndex = availableArmies.findIndex(army => {
          const armyId = String(army.id);
          const selectedId = String(selectedValue);
          console.log(` [DEBUG] Comparing army ID: ${armyId} with selected: ${selectedId}`);
          return armyId === selectedId;
        });
        
        if (selectedIndex !== -1) {
          selectedArmy = availableArmies[selectedIndex];
          console.log(' [DEBUG] Found army in available armies:', selectedArmy);
        } else {
          // If not found in selected armies, check saved armies
          console.log(' [DEBUG] Army not found in selected armies, checking saved armies...');
          if (gameData.savedArmies && gameData.savedArmies.length > 0) {
            const savedArmyIndex = gameData.savedArmies.findIndex(army => {
              const armyId = String(army.id);
              const selectedId = String(selectedValue);
              return armyId === selectedId;
            });
            
            if (savedArmyIndex !== -1) {
              selectedArmy = gameData.savedArmies[savedArmyIndex];
              selectedIndex = savedArmyIndex;
              console.log(' [DEBUG] Found army in saved armies:', selectedArmy);
              
              // Ensure the army has the correct structure
              if (!selectedArmy.units || !Array.isArray(selectedArmy.units)) {
                console.warn(' [DEBUG] Army found but missing units array, using default units');
                selectedArmy.units = [...defaultUnits, ...gameData.customUnits];
              }
            }
          }
        }
      }
      
      if (!selectedArmy) {
        console.log(' [SELECTION DEBUG] Selected army not found for value:', selectedValue);
        console.log(' [SELECTION DEBUG] Available armies:', availableArmies);
        console.log(' [SELECTION DEBUG] Saved armies:', gameData.savedArmies);
        console.log(' [SELECTION DEBUG] ===== ARMY SELECTION FAILED =====');
        return;
      }
      
      console.log(' [SELECTION DEBUG] Selected army found:', selectedArmy);
      console.log(' [SELECTION DEBUG] Selected army units count:', selectedArmy.units ? selectedArmy.units.length : 0);
      
      // Validate army data structure
      if (!selectedArmy.units || !Array.isArray(selectedArmy.units)) {
        console.error(' [SELECTION DEBUG] Selected army has invalid unit structure:', selectedArmy);
        console.log(' [SELECTION DEBUG] ===== ARMY SELECTION FAILED - INVALID STRUCTURE =====');
        return;
      }
      
      console.log(' [SELECTION DEBUG] Army units:', selectedArmy.units.map(unit => ({
        name: unit.name,
        type: unit.type
      })));
      
      // Set the selected army for this zone
      gameState.selectedArmyInZone[gameState.currentPlayer] = {
        army: selectedArmy,
        index: selectedIndex
      };
      
      console.log(' [SELECTION DEBUG] Set selected army in zone:', gameState.selectedArmyInZone[gameState.currentPlayer]);
      
      // Show army info and hide dropdown
      console.log(' [SELECTION DEBUG] About to show selected army info...');
      showSelectedArmyInfo(selectedArmy);
      
      // Show the army pool container and hide army selection
      const armySelectionContainer = document.getElementById('army-selection-container');
      const armyPoolContainer = document.getElementById('army-pool-container');
      
      console.log(' [SELECTION DEBUG] Army selection container found:', !!armySelectionContainer);
      console.log(' [SELECTION DEBUG] Army pool container found:', !!armyPoolContainer);
      
      if (armySelectionContainer) {
        armySelectionContainer.style.display = 'none';
        console.log(' [SELECTION DEBUG] Hidden army selection container');
      }
      
      if (armyPoolContainer) {
        armyPoolContainer.style.display = 'block';
        console.log(' [SELECTION DEBUG] Shown army pool container');
      }
      
      // Load units from the selected army
      console.log(' [SELECTION DEBUG] Loading zone army pool...');
      loadZoneArmyPool();
      updateArmyPoolStats();
      
      // Initialize AI aerial units if this is the AI player
      if (gameState.aiState.aiPlayer === gameState.currentPlayer) {
        console.log(' [SELECTION DEBUG] AI army selected, initializing AI aerial units');
        initializeAIAerialUnits();
      }
      
      console.log(' [SELECTION DEBUG] Army selection complete, showing units');
      console.log(' [SELECTION DEBUG] ===== ARMY SELECTION SUCCESS =====');
      
      // Force a refresh of the army pool after a short delay to ensure it loads
      setTimeout(() => {
        console.log(' [SELECTION DEBUG] Refreshing army pool...');
        loadZoneArmyPool();
      }, 100);
    }
    
    function showSelectedArmyInfo(army) {
      const dropdown = document.getElementById('army-selector-dropdown');
      const armyInfo = document.getElementById('selected-army-info');
      const armyName = document.getElementById('selected-army-name');
      const armyUnitCount = document.getElementById('army-unit-count');
      
      // Hide dropdown, show army info
      dropdown.style.display = 'none';
      armyInfo.style.display = 'block';
      
      // Update army info (show only deployable units)
      // Include field_gun units in the count since they can be deployed on the grid
      const deployableUnits = army.units.filter(unit => 
        unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber'
      );
      armyName.textContent = army.name;
      armyUnitCount.textContent = deployableUnits.length;
      
      console.log('Showing army info for:', army.name);
    }
    
    function showArmySelector() {
      const dropdown = document.getElementById('army-selector-dropdown');
      const armyInfo = document.getElementById('selected-army-info');
      
      // Show dropdown, hide army info
      dropdown.style.display = 'block';
      armyInfo.style.display = 'none';
      
      // Reset dropdown to default state
      const dropdownSelected = document.getElementById('army-selector-selected');
      if (dropdownSelected) {
        dropdownSelected.textContent = 'Choose legion...';
      }
      
      // Remove selected class from all options
      const options = document.querySelectorAll('#army-selector-options .dropdown-option');
      options.forEach(option => {
        option.classList.remove('selected');
      });
      
      // Re-initialize the dropdown to ensure event listeners are working
      initializeArmyDropdown();
      
      console.log('Showing army selector and re-initializing dropdown');
    }
    
    function getDeployedUnitsFromArmy(armyId, playerId) {
      const deployedUnits = [];
      
      for (const [instanceId, deployment] of Object.entries(gameState.deployedUnitInstances)) {
        if (deployment.armyId === armyId && deployment.playerId === playerId) {
          // Exclude artillery and aerial units from deployment count
          if (deployment.unitData.type !== 'artillery' && 
            deployment.unitData.type !== 'fighter' && 
            deployment.unitData.type !== 'bomber') {
            deployedUnits.push(deployment);
          }
        }
      }
      
      return deployedUnits;
    }
    
    function selectArmyForDeployment(army, armyIndex) {
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      const deployedUnits = getDeployedUnitsFromArmy(army.id, playerId);
      // Count only non-artillery and non-aerial units for deployment
      // Field guns can be deployed on the grid (they have movement values)
      const deployableUnits = army.units.filter(unit => 
        unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber'
      );
              const availableUnits = deployableUnits.length - deployedUnits.length;
      
      if (availableUnits === 0) {
        logZoneMessage('This army has no available units for deployment');
        return;
      }
      
      // Set selected army
      gameState.selectedArmyInZone[gameState.currentPlayer] = {
        army: army,
        armyIndex: armyIndex
      };
      
      // Switch to unit selection mode
      showUnitSelection();
      
      logZoneMessage(`Selected ${army.name} for deployment (${availableUnits} units available)`);
    }
    
    function showUnitSelection() {
      gameState.armySelectionMode = false;
      
      // Hide army selection container, show army pool
      const armySelectionContainer = document.getElementById('army-selection-container');
      const armyPoolContainer = document.getElementById('army-pool-container');
      
      if (armySelectionContainer) armySelectionContainer.style.display = 'none';
      if (armyPoolContainer) armyPoolContainer.style.display = 'block';
      
      loadZoneArmyPool();
      updateArmyPoolStats();
    }
    
    function debugArmySelection() {
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      console.log('=== DEBUG ARMY SELECTION ===');
      console.log('Current player:', gameState.currentPlayer);
      console.log('Player ID:', playerId);
      console.log('Selected armies for player:', gameData.selectedArmies[playerId]);
      console.log('All saved armies:', gameData.savedArmies);
      console.log('Custom units:', gameData.customUnits);
      console.log('Default units count:', defaultUnits.length);
      console.log('Army dropdown element:', document.getElementById('army-selector-dropdown'));
      console.log('Army dropdown menu element:', document.getElementById('army-selector-menu'));
      console.log('Army dropdown menu children:', document.getElementById('army-selector-menu')?.children?.length || 0);
      
      // Force reload the army dropdown
      console.log('Force reloading army dropdown...');
      loadArmyDropdown();
      
      alert(`Debug info logged to console. Player ${playerId} has ${gameData.selectedArmies[playerId]?.length || 0} armies selected. Total saved armies: ${gameData.savedArmies?.length || 0}. Dropdown options: ${document.getElementById('army-selector-menu')?.children?.length || 0}`);
    }
    
    function updatePhaseIndicator() {
      const indicator = document.getElementById('phase-indicator');
      
      if (!indicator) return;
      
      const zoneRole = gameState.zoneRoles[gameState.currentZone];
      const isDefender = zoneRole && zoneRole.defender === gameState.currentPlayer;
      
      if (gameState.currentZonePhase === 'defense') {
        indicator.textContent = 'Defense Mode - Place units in bottom 3 rows';
        indicator.style.borderColor = '#4169E1';
        indicator.className = 'status-item phase-indicator defender';
      } else if (gameState.currentZonePhase === 'attack') {
        indicator.textContent = 'Attack Mode - Place units in top row';
        indicator.style.borderColor = '#DC143C';
        indicator.className = 'status-item phase-indicator attacker';
      }
    }
    
    function updateZoneDetailTitle() {
      const title = document.getElementById('zone-detail-title');
      if (title && currentZoneDetail) {
        const zoneName = zoneNames[currentZoneDetail.name] || currentZoneDetail.name;
        title.textContent = `Zone ${zoneName} - ${currentZoneDetail.terrain.charAt(0).toUpperCase() + currentZoneDetail.terrain.slice(1)} Battlefield`;
      }
    }
    
    // Debounce mechanism for generateMiniBattlefield
    let battlefieldUpdateTimeout = null;
    
    function generateMiniBattlefield() {
      console.log(' [DEBUG] generateMiniBattlefield called');
      console.log(' [DEBUG] currentZoneDetail:', currentZoneDetail);
      console.log(' [DEBUG] gameConfig.gridSize:', gameConfig.gridSize);
      
      // Clear any pending update
      if (battlefieldUpdateTimeout) {
        clearTimeout(battlefieldUpdateTimeout);
      }
      
      // Debounce the update to prevent excessive re-rendering
      battlefieldUpdateTimeout = setTimeout(() => {
        const container = document.getElementById('mini-battlefield');
        console.log(' [DEBUG] mini-battlefield container found:', !!container);
        console.log(' [DEBUG] currentZoneDetail exists:', !!currentZoneDetail);
        
        if (!container || !currentZoneDetail) {
          console.error(' [DEBUG] Missing container or currentZoneDetail');
          return;
        }
      
      const gridSize = gameConfig.gridSize;
      
      // Remove existing grid classes and add the appropriate one
      container.classList.remove('grid-6', 'grid-8', 'grid-10', 'grid-12');
      container.classList.add(`grid-${gridSize}`);
      
      console.log(' [DEBUG] Clearing container and generating grid for size:', gridSize);
      container.innerHTML = '';
      
      // Generate positions based on selected size
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const pos = row * gridSize + col;
          const gridData = currentZoneDetail.tacticalGrid[pos];
          console.log(` [DEBUG] Creating position ${pos} (row ${row}, col ${col}) with terrain: ${gridData.terrain}`);
          const position = document.createElement('div');
          
          position.className = `mini-zone terrain-${gridData.terrain}`;
          position.dataset.position = pos;
          
          // Apply terrain color from terrainEffects
          const terrainEffect = terrainEffects[gridData.terrain];
          if (terrainEffect && terrainEffect.color) {
            position.style.backgroundColor = terrainEffect.color;
            position.style.setProperty('background-color', terrainEffect.color, 'important');
            console.log(` [TERRAIN COLOR] Applied ${gridData.terrain} color: ${terrainEffect.color} to position ${pos}`);
          }
          
          position.innerHTML = `
            <div>${pos + 1}</div>
            <div style="font-size: 9px;">${gridData.terrain}</div>
          `;
          
          // Add construction if present
          if (gridData.construction) {
            const construction = constructionOptions[gridData.construction.type];
            
            // Check if construction should be hidden (minefields are hidden from enemy)
            const shouldHideConstruction = construction.effects && construction.effects.hidden && 
                                         gridData.construction.player !== gameState.currentPlayer;
            
            if (!shouldHideConstruction) {
              position.classList.add('has-construction');
              position.classList.add(`${gridData.construction.player}-construction`);
              
              if (gridData.construction.completed) {
                position.innerHTML += `
                  <div class="construction-marker completed" style="background: ${gridData.construction.player === 'red' ? '#DC143C' : '#4169E1'};">
                    ${construction.icon}
                  </div>
                `;
              } else {
                position.innerHTML += `
                  <div class="construction-marker building" style="background: ${gridData.construction.player === 'red' ? '#DC143C' : '#4169E1'};">
                    
                  </div>
                  <div class="construction-progress">${gridData.construction.turnsRemaining}</div>
                `;
              }
            }
          }
          
          // Add unit if present
          let shouldHide = false; // Initialize shouldHide variable
          
          if (gridData.unit) {
            // Check if unit should be hidden due to stealth
            const stealthAbilities = applySpecialAbilities(gridData.unit, pos, gridData);
            shouldHide = stealthAbilities.hidden && gridData.unit.player !== gameState.currentPlayer;
            
            if (!shouldHide) {
            position.classList.add('has-unit');
            position.classList.add(`${gridData.unit.player}-unit`);
            const unitIcon = getUnitIcon(gridData.unit.type);
            position.innerHTML += `
              <div class="unit-marker" style="background: ${gridData.unit.player === 'red' ? '#DC143C' : '#4169E1'};">${unitIcon}</div>
            `;
            
      // Add carrier indicator if unit has transported units (align position to left-mid, opposite gas icon)
      if (gridData.unit.special === 'carrier' && gridData.unit.transportedUnits && gridData.unit.transportedUnits.length > 0) {
                position.innerHTML += `
                  <div class="carrier-indicator">${gridData.unit.transportedUnits.length}/2</div>
                `;
              }
            }
            
            // Add movement indicator if unit hasn't moved (only if unit is visible)
            if (!shouldHide && gameState.unitActions[gridData.unit.id] && 
                !gameState.unitActions[gridData.unit.id].hasMoved &&
                !gridData.unit.placedThisTurn) {
              position.innerHTML += `<div class="movement-indicator">M</div>`;
            }
            
            // Add volcanic damage indicator if unit is on volcanic terrain (only if unit is visible)
            if (!shouldHide && gridData.terrain === 'volcanic') {
              position.classList.add('volcanic-damage');
              position.innerHTML += `<div class="volcanic-damage-indicator"></div>`;
            }
          }
          
          // Add info button if there's a visible unit OR construction OR gas cloud
          // For hidden units, only show info button if there's construction or gas (don't reveal hidden unit)
          // For hidden construction (minefields), only show info button to the owner
          const hasGas = gameState.gasClouds && gameState.gasClouds[gameState.currentZone] && 
                        gameState.gasClouds[gameState.currentZone][pos];
          const hasVisibleConstruction = gridData.construction && 
            (!constructionOptions[gridData.construction.type].effects.hidden || 
             gridData.construction.player === gameState.currentPlayer);
          if ((gridData.unit && !shouldHide) || (hasVisibleConstruction && (!gridData.unit || shouldHide)) || hasGas) {
            position.innerHTML += `
              <div class="unit-info-button" 
                   onmouseover="showUnitTooltip(event, ${pos})" 
                   onmouseout="hideUnitTooltip()">i</div>
            `;
            console.log(`Added info button for position ${pos}, unit: ${!!gridData.unit}, construction: ${!!gridData.construction}, shouldHide: ${shouldHide}`);
          }
          
          // Add gas cloud styling if present
          if (gameState.gasClouds && gameState.gasClouds[gameState.currentZone] && 
              gameState.gasClouds[gameState.currentZone][pos]) {
            position.classList.add('gas-cloud');
            const gasData = gameState.gasClouds[gameState.currentZone][pos];
            console.log(` [GAS VISUAL] Adding gas cloud styling to position ${pos}, turns remaining: ${gasData.turnsRemaining}`);
          }
          
          position.onclick = () => handlePositionClick(pos);
          container.appendChild(position);
        }
      }
      
      updateSelectablePositions();
      }, 200); // 200ms debounce delay to prevent scroll interference
    }
    
    // Calculate actual combat values with all modifiers applied
    function calculateCombatValues(unit, pos, gridData) {
      let actualAttack = unit.attack || 0;
      let actualDefense = unit.defense || 0;
      let modifiers = [];
      
      // Terrain modifiers
      const terrainEffect = terrainEffects[gridData.terrain];
      if (terrainEffect) {
        if (terrainEffect.attackBonus) {
          actualAttack += terrainEffect.attackBonus;
          modifiers.push(`Terrain: ${terrainEffect.attackBonus >= 0 ? '+' : ''}${terrainEffect.attackBonus} ATK`);
        }
        if (terrainEffect.defenseBonus) {
          actualDefense += terrainEffect.defenseBonus;
          modifiers.push(`Terrain: ${terrainEffect.defenseBonus >= 0 ? '+' : ''}${terrainEffect.defenseBonus} DEF`);
        }
      }
      
      // Construction modifiers
      if (gridData.construction && gridData.construction.completed) {
        console.log(' [TOOLTIP CONSTRUCTION DEBUG] Found completed construction:', gridData.construction);
        const constructionData = constructionOptions[gridData.construction.type];
        console.log(' [TOOLTIP CONSTRUCTION DEBUG] Construction data:', constructionData);
        if (constructionData && constructionData.effects) {
          console.log(' [TOOLTIP CONSTRUCTION DEBUG] Construction effects:', constructionData.effects);
          
          // Snipers Nest: +1 Range for Infantry only
          if (constructionData.effects.range && unit.type === 'infantry') {
            // Range is handled separately in getActualCombatValues
            modifiers.push(`Snipers Nest: +1 Range`);
          }
          
          // Mortar Pit: +2 Attack for Field Guns only
          if (constructionData.effects.fieldGunAttack && unit.type === 'field_gun') {
            actualAttack += constructionData.effects.fieldGunAttack;
            modifiers.push(`Mortar Pit: +${constructionData.effects.fieldGunAttack} ATK`);
            console.log(' [TOOLTIP CONSTRUCTION DEBUG] Added field gun attack bonus:', constructionData.effects.fieldGunAttack);
          }
          
          // Machine Gun Nest: +2 Attack for Infantry only
          if (constructionData.effects.infantryAttack && unit.type === 'infantry') {
            actualAttack += constructionData.effects.infantryAttack;
            modifiers.push(`Machine Gun Nest: +${constructionData.effects.infantryAttack} ATK`);
            console.log(' [TOOLTIP CONSTRUCTION DEBUG] Added infantry attack bonus:', constructionData.effects.infantryAttack);
          }
          
          // Trenches: +2 Defense for Infantry, Support, and Field Guns only
          if (constructionData.effects.defense && ['infantry', 'support', 'field_gun'].includes(unit.type)) {
            actualDefense += constructionData.effects.defense;
            modifiers.push(`Trenches: +${constructionData.effects.defense} DEF`);
            console.log(' [TOOLTIP CONSTRUCTION DEBUG] Added defense bonus:', constructionData.effects.defense);
          }
          
          // Barricade: +2 Defense for units in ruins/infrastructure
          if (constructionData.effects.barricadeDefense && gridData.terrain && ['ruins', 'infrastructure'].includes(gridData.terrain)) {
            actualDefense += constructionData.effects.barricadeDefense;
            modifiers.push(`Barricade: +${constructionData.effects.barricadeDefense} DEF`);
            console.log(' [TOOLTIP CONSTRUCTION DEBUG] Added barricade defense bonus:', constructionData.effects.barricadeDefense);
          }
          
          // Road: -1 Defense penalty for units on road tiles
          if (gridData.construction.type === 'road' && gridData.construction.completed) {
            actualDefense = Math.max(0, actualDefense - 1);
            modifiers.push('Road: -1 DEF');
            console.log(' [TOOLTIP CONSTRUCTION DEBUG] Applied road defense penalty: -1 DEF');
          }
          
          // Anti Tank Pit: +4 Attack for Field Guns vs Armoured Units
          if (constructionData.effects.antiTankAttack && unit.type === 'field_gun') {
            // Check if target is an armoured unit (tank, vehicle, mech)
            if (targetGridData && targetGridData.unit && ['tank', 'vehicle', 'mech'].includes(targetGridData.unit.type)) {
              actualAttack += constructionData.effects.antiTankAttack;
              modifiers.push(`Anti Tank Pit: +${constructionData.effects.antiTankAttack} ATK vs Armoured`);
              console.log(' [TOOLTIP CONSTRUCTION DEBUG] Added anti-tank attack bonus:', constructionData.effects.antiTankAttack);
            }
          }
          
          // General attack/defense effects (for other constructions)
          if (constructionData.effects.attack && !constructionData.effects.fieldGunAttack && !constructionData.effects.infantryAttack) {
            actualAttack += constructionData.effects.attack;
            modifiers.push(`Construction: ${constructionData.effects.attack >= 0 ? '+' : ''}${constructionData.effects.attack} ATK`);
            console.log(' [TOOLTIP CONSTRUCTION DEBUG] Added attack bonus:', constructionData.effects.attack);
          }
          if (constructionData.effects.defense && !['infantry', 'support', 'field_gun'].includes(unit.type)) {
            actualDefense += constructionData.effects.defense;
            modifiers.push(`Construction: ${constructionData.effects.defense >= 0 ? '+' : ''}${constructionData.effects.defense} DEF`);
            console.log(' [TOOLTIP CONSTRUCTION DEBUG] Added defense bonus:', constructionData.effects.defense);
          }
        }
      }
      
      // Special ability modifiers
      if (unit.special && unit.special !== 'none') {
        const ability = specialAbilities[unit.special];
        if (ability && ability.apply) {
          // Apply special ability effects
          const abilityEffects = ability.apply(unit, pos, gridData);
          if (abilityEffects.attackBonus) {
            actualAttack += abilityEffects.attackBonus;
            // Show specific ability name for Air Superiority
            if (unit.special === 'air_superiority') {
              modifiers.push(`Air Superiority: +${abilityEffects.attackBonus} ATK`);
            } else {
              modifiers.push(`Special: ${abilityEffects.attackBonus >= 0 ? '+' : ''}${abilityEffects.attackBonus} ATK`);
            }
          }
          if (abilityEffects.defenseBonus) {
            actualDefense += abilityEffects.defenseBonus;
            modifiers.push(`Special: ${abilityEffects.defenseBonus >= 0 ? '+' : ''}${abilityEffects.defenseBonus} DEF`);
          }
        }
      }
      
      // Status effect modifiers
      if (unit.bleeding) {
        actualAttack = Math.max(0, actualAttack - 1);
        modifiers.push('Bleeding: -1 ATK');
      }
      if (unit.suppressed) {
        actualAttack = Math.max(0, actualAttack - 1);
        actualDefense = Math.max(0, actualDefense - 1);
        modifiers.push('Suppressed: -1 ATK, -1 DEF');
      }
      if (unit.moraleCollapse) {
        actualAttack = Math.max(0, actualAttack - 2);
        actualDefense = Math.max(0, actualDefense - 2);
        modifiers.push('Morale Collapse: -2 ATK, -2 DEF');
      }
      
      // Check for adjacent Mobile Cover units providing defense bonus
      const adjacentCoverBonus = getAdjacentMobileCoverBonus(unit, pos);
      if (adjacentCoverBonus > 0) {
        actualDefense += adjacentCoverBonus;
        modifiers.push(`Mobile Cover: +${adjacentCoverBonus} DEF`);
      }
      
      return {
        actualAttack,
        actualDefense,
        modifiers
      };
    }
    
    // Helper function to get grid data at a position
    function getGridDataAtPosition(position) {
      if (!currentZoneDetail || !currentZoneDetail.tacticalGrid) return null;
      return currentZoneDetail.tacticalGrid[position] || null;
    }
    
    // Get actual combat values for combat calculations (simplified version without modifiers list)
    function getActualCombatValues(unit, pos, gridData, targetPos = null, targetGridData = null, attacker = null) {
      console.log(' [COMBAT VALUES DEBUG] getActualCombatValues called with:', {
        unit: unit ? unit.name : 'null',
        pos: pos,
        gridData: gridData ? 'exists' : 'null',
        targetPos: targetPos,
        targetGridData: targetGridData ? 'exists' : 'null'
      });
      
      let actualAttack = unit ? (unit.attack || 0) : 0;
      let actualDefense = unit ? (unit.defense || 0) : 0;
      
      // Terrain modifiers
      if (gridData && gridData.terrain) {
        const terrainEffect = terrainEffects[gridData.terrain];
        if (terrainEffect) {
          if (terrainEffect.attackBonus) {
            actualAttack += terrainEffect.attackBonus;
          }
          if (terrainEffect.defenseBonus) {
            actualDefense += terrainEffect.defenseBonus;
          }
        }
      }
      
      // Construction modifiers
      if (gridData && gridData.construction && gridData.construction.completed) {
        console.log(' [CONSTRUCTION DEBUG] Found completed construction:', gridData.construction);
        const constructionData = constructionOptions[gridData.construction.type];
        console.log(' [CONSTRUCTION DEBUG] Construction data:', constructionData);
        if (constructionData && constructionData.effects) {
          console.log(' [CONSTRUCTION DEBUG] Construction effects:', constructionData.effects);
          
          // Snipers Nest: +1 Range for Infantry only
          if (constructionData.effects.range && unit.type === 'infantry') {
            // Range is handled separately below
            console.log(' [CONSTRUCTION DEBUG] Snipers Nest range bonus applied to infantry');
          }
          
          // Mortar Pit: +2 Attack for Field Guns only
          if (constructionData.effects.fieldGunAttack && unit.type === 'field_gun') {
            actualAttack += constructionData.effects.fieldGunAttack;
            console.log(' [CONSTRUCTION DEBUG] Added field gun attack bonus:', constructionData.effects.fieldGunAttack);
          }
          
          // Machine Gun Nest: +2 Attack for Infantry only
          if (constructionData.effects.infantryAttack && unit.type === 'infantry') {
            actualAttack += constructionData.effects.infantryAttack;
            console.log(' [CONSTRUCTION DEBUG] Added infantry attack bonus:', constructionData.effects.infantryAttack);
          }
          
          // Trenches: +2 Defense for Infantry, Support, and Field Guns only
          if (constructionData.effects.defense && ['infantry', 'support', 'field_gun'].includes(unit.type)) {
            actualDefense += constructionData.effects.defense;
            console.log(' [CONSTRUCTION DEBUG] Added defense bonus:', constructionData.effects.defense);
          }
          
          // Barricade: +2 Defense for units in ruins/infrastructure
          if (constructionData.effects.barricadeDefense && gridData.terrain && ['ruins', 'infrastructure'].includes(gridData.terrain)) {
            actualDefense += constructionData.effects.barricadeDefense;
            console.log(' [CONSTRUCTION DEBUG] Added barricade defense bonus:', constructionData.effects.barricadeDefense);
          }
          
          // Road: -1 Defense penalty for units on road tiles
          if (gridData.construction.type === 'road' && gridData.construction.completed) {
            actualDefense = Math.max(0, actualDefense - 1);
            console.log(' [CONSTRUCTION DEBUG] Applied road defense penalty: -1 DEF');
          }
          
          // Anti Tank Pit: +4 Attack for Field Guns vs Armoured Units
          if (constructionData.effects.antiTankAttack && unit.type === 'field_gun') {
            // Check if target is an armoured unit (tank, vehicle, mech)
            if (targetGridData && targetGridData.unit && ['tank', 'vehicle', 'mech'].includes(targetGridData.unit.type)) {
              actualAttack += constructionData.effects.antiTankAttack;
              console.log(' [CONSTRUCTION DEBUG] Added anti-tank attack bonus:', constructionData.effects.antiTankAttack);
            }
          }
          
          // General attack/defense effects (for other constructions)
          if (constructionData.effects.attack && !constructionData.effects.fieldGunAttack && !constructionData.effects.infantryAttack) {
            actualAttack += constructionData.effects.attack;
            console.log(' [CONSTRUCTION DEBUG] Added attack bonus:', constructionData.effects.attack);
          }
          if (constructionData.effects.defense && !['infantry', 'support', 'field_gun'].includes(unit.type)) {
            actualDefense += constructionData.effects.defense;
            console.log(' [CONSTRUCTION DEBUG] Added defense bonus:', constructionData.effects.defense);
          }
        }
      }
      
      // Special ability modifiers
      if (unit && unit.special && unit.special !== 'none') {
        const ability = specialAbilities[unit.special];
        if (ability && ability.apply) {
          console.log(' [VETERAN DEBUG] Checking special ability:', unit.special);
          console.log(' [VETERAN DEBUG] Unit:', unit.name);
          console.log(' [VETERAN DEBUG] Target position:', targetPos);
          console.log(' [VETERAN DEBUG] Target grid data:', targetGridData);
          
          const abilityEffects = ability.apply(unit, pos, gridData, targetPos, targetGridData);
          console.log(' [VETERAN DEBUG] Ability effects:', abilityEffects);
          
          if (abilityEffects.attackBonus) {
            actualAttack += abilityEffects.attackBonus;
            console.log(' [VETERAN DEBUG] Added attack bonus:', abilityEffects.attackBonus);
          }
          if (abilityEffects.defenseBonus) {
            actualDefense += abilityEffects.defenseBonus;
            console.log(' [VETERAN DEBUG] Added defense bonus:', abilityEffects.defenseBonus);
          }
        }
      }
      
      // Armour Penetration bonus (+3 attack vs vehicles, tanks, mechs)
      if (unit.special === 'armour_penetrating' && targetGridData && targetGridData.unit) {
        const targetType = targetGridData.unit.type;
        if (['vehicle', 'tank', 'mech'].includes(targetType)) {
          actualAttack += 3;
          console.log(` [ARMOUR PENETRATION] ${unit.name} gets +3 attack bonus vs ${targetType} ${targetGridData.unit.name}`);
        }
      }
      
      // Status effect modifiers
      if (unit && unit.bleeding) {
        actualAttack = Math.max(0, actualAttack - 1);
      }
      if (unit && unit.suppressed) {
        actualAttack = Math.max(0, actualAttack - 1);
        actualDefense = Math.max(0, actualDefense - 1);
      }
      if (unit && unit.moraleCollapse) {
        actualAttack = Math.max(0, actualAttack - 2);
        actualDefense = Math.max(0, actualDefense - 2);
      }
      
      // Apply weather effects to attack and defense
      const weatherEffects = getWeatherEffects();
      actualAttack += weatherEffects.attack;
      actualDefense += weatherEffects.defense;
      
      // Ensure minimum values of 0
      actualAttack = Math.max(0, actualAttack);
      actualDefense = Math.max(0, actualDefense);
      
              console.log(`[WEATHER DEBUG] Unit: ${unit.name}, Weather attack modifier: ${weatherEffects.attack}, Weather defense modifier: ${weatherEffects.defense}`);
      
      // Check for adjacent Mobile Cover units providing defense bonus
      if (unit && pos !== null) {
        const adjacentCoverBonus = getAdjacentMobileCoverBonus(unit, pos);
        if (adjacentCoverBonus > 0) {
          actualDefense += adjacentCoverBonus;
        }
      }
      
      // Calculate range bonus from special abilities and constructions
      let actualRange = unit.range || 1;
      
      // Apply weather effects to range
      const weatherRangeEffects = getWeatherEffects();
      actualRange += weatherRangeEffects.range;
      
      // Ensure minimum range of 1 (unless unit already has 0 range)
      if (unit.range > 0 && actualRange < 1) {
        actualRange = 1;
      }
      
              console.log(`[WEATHER DEBUG] Unit: ${unit.name}, Base range: ${unit.range}, Weather range modifier: ${weatherRangeEffects.range}, Final range: ${actualRange}`);
      
      // Snipers Nest: +1 Range for Infantry only
      if (gridData && gridData.construction && gridData.construction.completed) {
        const constructionData = constructionOptions[gridData.construction.type];
        if (constructionData && constructionData.effects && constructionData.effects.range && unit.type === 'infantry') {
          actualRange += constructionData.effects.range;
          console.log(` [SNIPERS NEST] ${unit.name} range increased from ${unit.range} to ${actualRange}`);
        }
      }
      
      if (unit && unit.special && unit.special !== 'none') {
        const ability = specialAbilities[unit.special];
        if (ability && ability.apply) {
          const abilityEffects = ability.apply(unit, pos, gridData, targetPos, targetGridData);
          if (abilityEffects.rangeBonus) {
            actualRange += abilityEffects.rangeBonus;
            console.log(` [RANGE BONUS] ${unit.name} range increased from ${unit.range} to ${actualRange}`);
          }
        }
      }

      const result = {
        actualAttack,
        actualDefense,
        actualRange
      };
      
      console.log(' [COMBAT VALUES DEBUG] Final combat values:', result);
      return result;
    }
    
    // Check for adjacent Mobile Cover units and return defense bonus
    function getAdjacentMobileCoverBonus(unit, pos) {
      if (!currentZoneDetail || !currentZoneDetail.tacticalGrid) return 0;
      
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      
      let totalCoverBonus = 0;
      
      // Check all 8 adjacent positions (including diagonals)
      const directions = [
        {row: -1, col: -1}, {row: -1, col: 0}, {row: -1, col: 1},
        {row: 0, col: -1},                     {row: 0, col: 1},
        {row: 1, col: -1},  {row: 1, col: 0},  {row: 1, col: 1}
      ];
      
      for (const dir of directions) {
        const newRow = row + dir.row;
        const newCol = col + dir.col;
        
        // Check if position is within bounds
        if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
          const adjacentPos = newRow * gridSize + newCol;
          const adjacentGridData = currentZoneDetail.tacticalGrid[adjacentPos];
          
          // Check if there's a friendly unit with Mobile Cover ability
          if (adjacentGridData.unit && 
              adjacentGridData.unit.player === unit.player && 
              adjacentGridData.unit.special === 'mobile_cover') {
            
            // Get the cover bonus from the Mobile Cover unit's special ability
            const mobileCoverAbility = specialAbilities.mobile_cover;
            if (mobileCoverAbility && mobileCoverAbility.apply) {
              const abilityEffects = mobileCoverAbility.apply(adjacentGridData.unit, adjacentPos, adjacentGridData);
              if (abilityEffects.coverBonus) {
                totalCoverBonus += abilityEffects.coverBonus;
                console.log(' [MOBILE COVER DEBUG] Unit', unit.name, 'receives +' + abilityEffects.coverBonus + ' DEF from adjacent', adjacentGridData.unit.name);
              }
            }
          }
        }
      }
      
      return totalCoverBonus;
    }
    
    function showUnitTooltip(event, pos) {
      console.log(' [TOOLTIP DEBUG] showUnitTooltip called for position:', pos);
      
      if (!currentZoneDetail || !tooltipElement) {
        console.error('Missing required elements for tooltip');
        console.error('currentZoneDetail:', currentZoneDetail);
        console.error('tooltipElement:', tooltipElement);
        return;
      }
      
      const gridData = currentZoneDetail.tacticalGrid[pos];
      const unit = gridData.unit;
      const construction = gridData.construction;
      const terrainEffect = terrainEffects[gridData.terrain];
      
      let tooltipContent = '';
      let shouldHide = false; // Initialize shouldHide variable
      
      if (unit) {
        // Check if unit should be hidden due to stealth
        const stealthAbilities = applySpecialAbilities(unit, pos, gridData);
        shouldHide = stealthAbilities.hidden && unit.player !== gameState.currentPlayer;
        
        // Only show unit information if the unit is not hidden from the current player
        if (!shouldHide) {
          // Calculate actual combat values with all modifiers
          const combatValues = calculateCombatValues(unit, pos, gridData);
          
        // Check Siege Mode for tooltip
        const siegeModeActive = unit.special === 'siege_mode' && unit.turnsStationary >= 1;
        
        tooltipContent += `
        <strong>${unit.name}</strong><br>
        Player: ${unit.player === 'red' ? gameConfig.player1.name : gameConfig.player2.name}<br>
        Type: ${formatUnitType(unit.type)}<br>
          <strong>Combat Values:</strong><br>
          ATK: ${unit.attack >= 0 ? '+' : ''}${unit.attack}  <span style="color: #FF4500; font-weight: bold;">${combatValues.actualAttack >= 0 ? '+' : ''}${combatValues.actualAttack}</span>${siegeModeActive ? ' <span style="color: #FFD700; font-weight: bold;">[SIEGE MODE ACTIVE]</span>' : ''}<br>
          DEF: ${unit.defense >= 0 ? '+' : ''}${unit.defense}  <span style="color: #4169E1; font-weight: bold;">${combatValues.actualDefense >= 0 ? '+' : ''}${combatValues.actualDefense}</span><br>
        MOR: ${unit.morale + 50}<br>
        RNG: ${unit.range + 50}<br>
        MOV: ${unit.movement + 50}<br>
        Health: ${unit.health}/${unit.maxHealth}<br>
          ${unit.armour ? `<span style="color: #FFD700; font-weight: bold;">Armour: ${unit.armour}/${unit.maxArmour}</span><br>` : ''}
          `;
          
          // Show modifiers if any exist
          if (combatValues.modifiers.length > 0) {
            tooltipContent += `<br><strong>Active Modifiers:</strong><br>`;
            combatValues.modifiers.forEach(modifier => {
              tooltipContent += ` ${modifier}<br>`;
            });
            
            // Calculate total modifier impact
            const attackModifier = combatValues.actualAttack - unit.attack;
            const defenseModifier = combatValues.actualDefense - unit.defense;
            
            if (attackModifier !== 0 || defenseModifier !== 0) {
              tooltipContent += `<br><strong>Total Modifier Impact:</strong><br>`;
              if (attackModifier !== 0) {
                const color = attackModifier > 0 ? '#32CD32' : '#FF4500';
                tooltipContent += `<span style="color: ${color};">ATK: ${attackModifier >= 0 ? '+' : ''}${attackModifier}</span><br>`;
              }
              if (defenseModifier !== 0) {
                const color = defenseModifier > 0 ? '#32CD32' : '#FF4500';
                tooltipContent += `<span style="color: ${color};">DEF: ${defenseModifier >= 0 ? '+' : ''}${defenseModifier}</span><br>`;
              }
            }
          }
        }
      }
      
      // Add special ability information (only if unit is visible and not hidden)
      if (unit && !shouldHide && unit.special && unit.special !== 'none') {
          const ability = specialAbilities[unit.special];
          if (ability) {
            tooltipContent += `<br><strong>Special Ability:</strong><br>`;
            tooltipContent += `${ability.name}: ${ability.description}<br>`;
          }
        }
        
      // Add status effects (only if unit is visible and not hidden)
      if (unit && !shouldHide) {
        let statusEffects = [];
        if (unit.bleeding) statusEffects.push(`Bleeding (${unit.bleedingTurns} turns)`);
        if (unit.suppressed) statusEffects.push(`Suppressed (${unit.suppressionTurns} turns)`);
        if (unit.moraleCollapse) statusEffects.push('Morale Collapse');
        
        if (statusEffects.length > 0) {
          tooltipContent += `<br><strong>Status Effects:</strong><br>`;
          tooltipContent += statusEffects.join(', ');
        }
      }
      
      tooltipContent += `Position: ${pos + 1}<br>`;
      tooltipContent += `Terrain: ${gridData.terrain} (${terrainEffect.description})<br>`;
      
      // Add weather and day/night effects
      if (gameState.weatherSystem) {
        const weatherEffects = getWeatherEffects();
        const currentWeather = gameState.weatherSystem.currentWeather;
        const dayNightCycle = gameState.weatherSystem.dayNightCycle;
        
        // Map weather names for display
        const weatherDisplayNames = {
          'clear': 'Clear Skies',
          'light-clouds': 'Light Clouds',
          'rain': 'Rain',
          'thunderstorm': 'Thunderstorm',
          'heavy-rain': 'Heavy Rain',
          'fog': 'Fog',
          'cloudy': 'Cloudy',
          'snow': 'Snow',
          'overcast': 'Overcast',
          'blizzard': 'Blizzard',
          'dust-storm': 'Dust Storm',
          'ash-storm': 'Ash Storm',
          'windy': 'Windy',
          'tornado': 'Tornado'
        };
        
        const weatherName = weatherDisplayNames[currentWeather] || currentWeather;
        const dayNightName = dayNightCycle.charAt(0).toUpperCase() + dayNightCycle.slice(1);
        
        tooltipContent += `<br><strong>Environmental Conditions:</strong><br>`;
        tooltipContent += `Weather: ${weatherName}<br>`;
        tooltipContent += `Time: ${dayNightName}<br>`;
        
        // Show weather effects if any exist
        if (weatherEffects.attack !== 0 || weatherEffects.defense !== 0 || weatherEffects.movement !== 0 || weatherEffects.range !== 0) {
          tooltipContent += `<strong>Weather Effects:</strong><br>`;
          if (weatherEffects.attack !== 0) {
            const color = weatherEffects.attack > 0 ? '#32CD32' : '#FF4500';
            tooltipContent += `<span style="color: ${color};">ATK: ${weatherEffects.attack >= 0 ? '+' : ''}${weatherEffects.attack}</span><br>`;
          }
          if (weatherEffects.defense !== 0) {
            const color = weatherEffects.defense > 0 ? '#32CD32' : '#FF4500';
            tooltipContent += `<span style="color: ${color};">DEF: ${weatherEffects.defense >= 0 ? '+' : ''}${weatherEffects.defense}</span><br>`;
          }
          if (weatherEffects.movement !== 0) {
            const color = weatherEffects.movement > 0 ? '#32CD32' : '#FF4500';
            tooltipContent += `<span style="color: ${color};">MOV: ${weatherEffects.movement >= 0 ? '+' : ''}${weatherEffects.movement}</span><br>`;
          }
          if (weatherEffects.range !== 0) {
            const color = weatherEffects.range > 0 ? '#32CD32' : '#FF4500';
            tooltipContent += `<span style="color: ${color};">RNG: ${weatherEffects.range >= 0 ? '+' : ''}${weatherEffects.range}</span><br>`;
          }
        }
      }
      
      if (construction) {
        const constructionData = constructionOptions[construction.type];
        if (constructionData) {
          // Check if construction should be hidden from current player (minefields)
          const shouldHideConstruction = constructionData.effects && constructionData.effects.hidden && 
                                       construction.player !== gameState.currentPlayer;
          
          if (!shouldHideConstruction) {
            tooltipContent += `<br><strong>Construction:</strong><br>`;
            tooltipContent += `${constructionData.icon} ${constructionData.name}<br>`;
            tooltipContent += `Player: ${construction.player === 'red' ? gameConfig.player1.name : gameConfig.player2.name}<br>`;
            if (construction.completed) {
              tooltipContent += `Status: Completed<br>`;
              tooltipContent += `Effects: ${constructionData.description}`;
              
              // Add construction bonus notice for units
              if (unit && constructionData.effects) {
                let bonusNotice = [];
                if (constructionData.effects.attack) {
                  bonusNotice.push(`+${constructionData.effects.attack} Attack`);
                }
                if (constructionData.effects.defense) {
                  bonusNotice.push(`+${constructionData.effects.defense} Defense`);
                }
                if (bonusNotice.length > 0) {
                  tooltipContent += `<br><span style="color: #FFD700; font-weight: bold;"> Unit receives: ${bonusNotice.join(', ')}</span>`;
                }
              }
            } else {
              tooltipContent += `Status: Building (${construction.turnsRemaining} turns remaining)<br>`;
              tooltipContent += `Cost: ${constructionData.cost} BP`;
            }
          }
        }
      }
      
      // Add gas cloud information
      if (gameState.gasClouds && gameState.gasClouds[gameState.currentZone] && 
          gameState.gasClouds[gameState.currentZone][pos]) {
        const gasData = gameState.gasClouds[gameState.currentZone][pos];
        const playerName = gasData.player === 'red' ? gameConfig.player1.name : gameConfig.player2.name;
        tooltipContent += `<br><strong> Gas Cloud:</strong><br>`;
        tooltipContent += `Deployed by: ${playerName}<br>`;
        tooltipContent += `Turns remaining: ${gasData.turnsRemaining}<br>`;
        tooltipContent += `<span style="color: #FF4500;">Deals D6 damage to non-armored units</span>`;
      }
      
      tooltipElement.innerHTML = tooltipContent;
      tooltipElement.style.display = 'block';
      
      // Calculate position to appear directly under the hovered element
      const tooltipWidth = 300; // max-width from CSS
      const tooltipHeight = 200; // estimated height
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      

      
      // Get the position element (the actual grid cell/tile) that contains the unit
      // Prefer the stats icon so the tooltip anchors directly under it
      let positionElement = event.target.closest('.unit-info-button') || event.target.closest('[data-position]');
      if (!positionElement) {
        // Fallback to the target element if no position element found
        positionElement = event.target;
      }
      
      let targetRect = positionElement.getBoundingClientRect();
      
      // Position tooltip directly under the specific tile/position that was hovered
      // Center the tooltip horizontally under the tile
      let left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
      let top = targetRect.bottom + 5;
      

      
      // Adjust if tooltip would go off-screen horizontally
      if (left + tooltipWidth > viewportWidth) {
        left = Math.max(10, viewportWidth - tooltipWidth - 10);
      }
      
      // Ensure tooltip doesn't go off the left edge
      if (left < 10) {
        left = 10;
      }
      
      // Adjust if tooltip would go off-screen vertically
      if (top + tooltipHeight > viewportHeight + window.scrollY) {
        // Position above the element instead
        top = targetRect.top - tooltipHeight - 5;
        
        // If still off-screen, position at the top of the viewport
        if (top < 10) {
          top = 10;
        }
      }
      
      tooltipElement.style.left = `${left}px`;
      tooltipElement.style.top = `${top}px`;
      tooltipElement.style.zIndex = '10000'; // Ensure it's on top
      
      // Enhanced smooth animation
      tooltipElement.classList.remove('show');
      // Force reflow
      tooltipElement.offsetWidth;
      tooltipElement.classList.add('show');
    }
    
    function hideUnitTooltip() {
      console.log(' [TOOLTIP DEBUG] hideUnitTooltip called');
      if (tooltipElement) {
        console.log(' [TOOLTIP DEBUG] Hiding tooltip - removing show class');
        tooltipElement.classList.remove('show');
        
        // Wait for animation to complete before hiding
        setTimeout(() => {
          if (tooltipElement) {
            console.log(' [TOOLTIP DEBUG] Setting tooltip display to none');
            tooltipElement.style.display = 'none';
          }
        }, 300); // Match the CSS transition duration
      }
    }

    /* PHASE 2: ENHANCED VISUAL FEEDBACK FUNCTIONS */
    
    // Enhanced animation trigger functions
    function triggerUnitPlacedAnimation(pos) {
      const position = document.querySelector(`[data-position="${pos}"]`);
      if (position) {
        position.classList.add('unit-placed');
        setTimeout(() => {
          position.classList.remove('unit-placed');
        }, 800);
      }
    }

    function triggerAttackAnimation(pos) {
      const position = document.querySelector(`[data-position="${pos}"]`);
      if (position) {
        position.classList.add('attack-effect');
        setTimeout(() => {
          position.classList.remove('attack-effect');
        }, 600);
      }
    }

    function triggerMovementAnimation(pos) {
      const position = document.querySelector(`[data-position="${pos}"]`);
      if (position) {
        position.classList.add('movement-effect');
        setTimeout(() => {
          position.classList.remove('movement-effect');
        }, 500);
      }
    }

    function triggerConstructionAnimation(pos) {
      const position = document.querySelector(`[data-position="${pos}"]`);
      if (position) {
        position.classList.add('construction-effect');
        setTimeout(() => {
          position.classList.remove('construction-effect');
        }, 1000);
      }
    }

    function triggerSelectionAnimation(pos) {
      const position = document.querySelector(`[data-position="${pos}"]`);
      if (position) {
        position.classList.add('selection-effect');
        setTimeout(() => {
          position.classList.remove('selection-effect');
        }, 400);
      }
    }

    function triggerDamageAnimation(pos) {
      const position = document.querySelector(`[data-position="${pos}"]`);
      if (position) {
        position.classList.add('damage-effect');
        setTimeout(() => {
          position.classList.remove('damage-effect');
        }, 800);
      }
    }

    function triggerVictoryAnimation(pos) {
      const position = document.querySelector(`[data-position="${pos}"]`);
      if (position) {
        position.classList.add('victory-effect');
        setTimeout(() => {
          position.classList.remove('victory-effect');
        }, 1200);
      }
    }

    // Enhanced visual feedback for unit actions
    function addEnhancedVisualFeedback(action, pos) {
      switch (action) {
        case 'place':
          triggerUnitPlacedAnimation(pos);
          break;
        case 'attack':
          triggerAttackAnimation(pos);
          break;
        case 'move':
          triggerMovementAnimation(pos);
          break;
        case 'construct':
          triggerConstructionAnimation(pos);
          break;
        case 'select':
          triggerSelectionAnimation(pos);
          break;
        case 'damage':
          triggerDamageAnimation(pos);
          break;
        case 'victory':
          triggerVictoryAnimation(pos);
          break;
      }
    }
    
    function handlePositionClick(pos) {
      console.log(` [CLICK DEBUG] handlePositionClick called with pos: ${pos}`);
      console.log(` [CLICK DEBUG] currentZoneDetail exists: ${!!currentZoneDetail}`);
      console.log(` [CLICK DEBUG] isAITurn: ${isAITurn()}`);
      
      if (!currentZoneDetail) {
        console.log(` [CLICK DEBUG] No currentZoneDetail, returning`);
        return;
      }
      if (isAITurn()) {
        console.log(` [CLICK DEBUG] AI turn, returning`);
        return; // Prevent actions during AI turn
      }
      
      const gridData = currentZoneDetail.tacticalGrid[pos];
      console.log(` [CLICK DEBUG] gridData at pos ${pos}:`, gridData);
      console.log(` [CLICK DEBUG] gameState.deploymentMode: ${gameState.deploymentMode}`);
      
      // Check if in artillery mode
      if (gameState.artilleryMode && gameState.selectedArtillery) {
        // Artillery mode - fire at the current zone
        fireArtilleryAtZone(currentZoneDetail.id, pos);
        return;
      }
      
      // Check if clicking on a hidden enemy unit (stealth) - only when not in artillery mode
      if (gridData.unit && gridData.unit.player !== gameState.currentPlayer) {
        const stealthAbilities = applySpecialAbilities(gridData.unit, pos, gridData);
        const shouldHide = stealthAbilities.hidden;
        
        if (shouldHide) {
          logZoneMessage('Cannot interact with hidden enemy unit');
          return;
        }
      }
      
      // Check if in aerial mode
      if (gameState.aerialMode && gameState.selectedAerialUnit) {
        console.log(' [AERIAL DEBUG] Aerial mode active, selectedAerialUnit:', gameState.selectedAerialUnit.name);
        console.log(' [AERIAL DEBUG] Target unit:', gridData.unit ? gridData.unit.name : 'none');
        console.log(' [AERIAL DEBUG] Target unit type:', gridData.unit ? gridData.unit.type : 'none');
        console.log(' [AERIAL DEBUG] Target unit player:', gridData.unit ? gridData.unit.player : 'none');
        console.log(' [AERIAL DEBUG] Current player:', gameState.currentPlayer);
        
        // Aerial mode - attack enemy units
        if (gridData.unit && gridData.unit.player !== gameState.currentPlayer) {
          console.log(' [AERIAL DEBUG] Attempting aerial attack on enemy unit:', gridData.unit.name);
          // Check if bomber can attack this target
          if (gameState.selectedAerialUnit.airUnitType === 'bomber') {
            console.log(' [AERIAL DEBUG] Bomber attack - checking target type:', gridData.unit.type);
            // Bombers can only attack ground units (not aerial units)
            if (gridData.unit.type === 'fighter' || gridData.unit.type === 'bomber' || gridData.unit.type === 'airship') {
              logZoneMessage('Bombers cannot attack aerial units!');
              return;
            }
            // Check if unit is in a bunker
            if (gridData.construction && gridData.construction.completed && 
                gridData.construction.type === 'bunker' && 
                constructionOptions.bunker.effects.bomberImmune) {
              logZoneMessage(`${gridData.unit.name} is protected by bunker - bomber attack blocked!`, 'combat');
              return;
            }
            console.log(' [AERIAL DEBUG] Bomber attack proceeding - target is valid ground unit');
          } else if (gameState.selectedAerialUnit.airUnitType === 'fighter') {
            // Fighters can only attack aerial units
            if (gridData.unit.type !== 'fighter' && gridData.unit.type !== 'bomber' && gridData.unit.type !== 'airship') {
              logZoneMessage('Fighters can only attack aerial units!');
              return;
            }
          } else if (gameState.selectedAerialUnit.airUnitType === 'airship') {
            // Airships can attack both ground and aerial units, but check for bunker immunity
            if (gridData.construction && gridData.construction.completed && 
                gridData.construction.type === 'bunker' && 
                constructionOptions.bunker.effects.airshipImmune) {
              logZoneMessage(`${gridData.unit.name} is protected by bunker - airship attack blocked!`, 'combat');
              return;
            }
            console.log(' [AIRSHIP] Airship attack proceeding - can target both ground and aerial units');
          }
          console.log(' [AERIAL DEBUG] Calling fireAerialAtUnit');
          fireAerialAtUnit(gridData.unit);
          return; // Only return if we actually performed an aerial attack
        } else {
          // If clicking on empty space or friendly unit while in aerial mode, just log message but don't return
          // This allows other modes (like deployment) to still work
          console.log(' [AERIAL DEBUG] No valid aerial target, allowing other modes to handle click');
          logZoneMessage('Select an enemy unit to attack with aerial forces');
          // Don't return here - let other modes handle the click
        }
      }
      
      // Check if Anti-Air unit is selected and trying to attack aerial units
      if (gameState.deploymentMode === 'attack' && gameState.selectedUnit && gameState.selectedUnit.special === 'air_defense') {
        // Anti-Air units can attack aerial units - show aerial targeting automatically
        if (!gameState.antiAirTargeting) {
          showAerialTargetSelection();
        }
        // Don't return here - let the normal assault logic handle ground unit selection
      }
      
      // Check if in construction mode
      if (constructionMode && selectedConstruction) {
        placeConstruction(pos);
        return;
      }
      
      if (gameState.deploymentMode === 'place') {
        console.log(` [PLACEMENT DEBUG] In placement mode`);
        console.log(` [PLACEMENT DEBUG] gameState.selectedUnit:`, gameState.selectedUnit);
        console.log(` [PLACEMENT DEBUG] gridData.unit:`, gridData.unit);
        console.log(` [PLACEMENT DEBUG] isValidDeploymentPosition(${pos}):`, isValidDeploymentPosition(pos));
        console.log(` [PLACEMENT DEBUG] aerialMode:`, gameState.aerialMode);
        console.log(` [PLACEMENT DEBUG] selectedAerialUnit:`, gameState.selectedAerialUnit);
        
        // Deselect if clicking on empty space or invalid position
        if (gameState.selectedUnit && (!isValidDeploymentPosition(pos) || gridData.unit)) {
          console.log(` [PLACEMENT DEBUG] Deselecting unit - invalid position or occupied`);
          gameState.selectedUnit = null;
          updateSelectedUnitInfo();
          updateSelectablePositions();
          logZoneMessage('Unit deselected');
          return;
        }
        
        if (gameState.selectedUnit && !gridData.unit && isValidDeploymentPosition(pos)) {
          console.log(` [PLACEMENT DEBUG] Attempting to place unit`);
          console.log(` [PLACEMENT DEBUG] Selected unit:`, gameState.selectedUnit);
          
          // Re-enable deployment checking
          const isDeployed = isUnitDeployedFromArmy(gameState.selectedUnit, gameState.selectedUnit.armyId);
          console.log(` [PLACEMENT DEBUG] isDeployed:`, isDeployed);
          
          if (isDeployed) {
            console.log(` [PLACEMENT DEBUG] Unit is already deployed`);
            const deploymentInfo = getUnitDeploymentInfo(gameState.selectedUnit, gameState.selectedUnit.armyId);
            if (deploymentInfo) {
              const zoneName = zoneNames[deploymentInfo.zoneName] || deploymentInfo.zoneName;
              logZoneMessage(`${gameState.selectedUnit.name} is already deployed in Zone ${zoneName}`, 'system');
            } else {
              logZoneMessage(`${gameState.selectedUnit.name} is already deployed in another zone`, 'system');
            }
            return;
          }
          
          console.log(` [PLACEMENT DEBUG] Calling placeUnit`);
          placeUnit(gameState.selectedUnit, pos);
        } else if (!gameState.selectedUnit) {
          console.log(` [PLACEMENT DEBUG] No unit selected`);
          logZoneMessage('Please select a unit from the army pool first');
        } else if (gridData.unit) {
          console.log(` [PLACEMENT DEBUG] Position occupied`);
          logZoneMessage('Position is already occupied');
        } else if (!isValidDeploymentPosition(pos)) {
          console.log(` [PLACEMENT DEBUG] Invalid deployment position`);
          const validRows = getValidDeploymentRows();
          logZoneMessage(`Units must be placed in rows ${validRows.join(', ')} during this phase`);
        }
      } else if (gameState.deploymentMode === 'attack') {
        // Deselect if clicking on empty space or invalid target
        if (gameState.selectedUnit && (!gridData.unit || gridData.unit.player === gameState.currentPlayer || !canAttackPosition(gameState.selectedUnit.position, pos))) {
          gameState.selectedUnit = null;
          updateSelectablePositions();
          updateSelectedUnitInfo();
          logZoneMessage('Unit deselected');
          return;
        }
        
        if (gridData.unit && gridData.unit.player === gameState.currentPlayer) {
          selectUnitForAttack(pos);
        } else if (gameState.selectedUnit && canAttackPosition(gameState.selectedUnit.position, pos)) {
          attackPosition(gameState.selectedUnit.position, pos);
        }
      } else if (gameState.deploymentMode === 'move') {
        console.log(` [CLICK DEBUG] Deployment mode is 'move', calling handleMovementClick`);
        handleMovementClick(pos);
      } else if (gameState.deploymentMode === 'board') {
        console.log(' [BOARD DEBUG] Board mode detected, calling handleBoardingClick');
        handleBoardingClick(pos);
      } else if (gameState.deploymentMode === 'disembark') {
        handleDisembarkClick(pos);
      } else if (gameState.deploymentMode === 'gas') {
        handleGasDeploymentClick(pos);
      } else {
        console.log(` [CLICK DEBUG] No matching deployment mode - deploymentMode: ${gameState.deploymentMode}`);
        console.log(` [CLICK DEBUG] This might be why movement isn't working!`);
      }
    }
    
    // Movement handling
    function handleMovementClick(pos) {
      console.log(` [MOVEMENT DEBUG] handleMovementClick called with pos: ${pos}`);
      const gridData = currentZoneDetail.tacticalGrid[pos];
      const unit = gridData.unit;
      console.log(` [MOVEMENT DEBUG] Grid data at pos ${pos}:`, gridData);
      console.log(` [MOVEMENT DEBUG] Unit at pos ${pos}:`, unit);
      console.log(` [MOVEMENT DEBUG] Movement mode active: ${gameState.movementMode.active}`);
      console.log(` [MOVEMENT DEBUG] Valid positions:`, gameState.movementMode.validPositions);
      
      // If we're already in movement mode and clicked on a valid position
      if (gameState.movementMode.active && gameState.movementMode.validPositions.includes(pos)) {
        console.log(` [MOVEMENT DEBUG] Moving to valid position ${pos}`);
        moveUnitToPosition(pos);
        return;
      }
      
      // If clicking on a friendly unit that hasn't moved this turn
      if (unit && unit.player === gameState.currentPlayer && 
          !gameState.unitActions[unit.id]?.hasMoved) {
        
        // Check if unit is under beach landing restriction (amphibious units are exempt)
        if (unit.beachLanding && unit.beachLandingTurns > 0 && unit.special !== 'amphibious') {
          const roundsRemaining = Math.ceil(unit.beachLandingTurns / 2);
          logZoneMessage(`${unit.name} is still establishing beachhead and cannot move for ${roundsRemaining} more complete round(s)!`, 'system');
          return;
        }
        
        startMovementMode(unit, pos);
        return;
      }
      
      // If clicking on an invalid unit
      // Removed hard block; movement is blocked only by beach landing rule above
    }
    
    function applyTemporaryMovementBonuses(unit, pos) {
      // Apply temporary movement bonuses for a unit that's already on a tile
      let totalBonus = 0;
      
      // Get the grid data for the unit's current position
      const gridData = currentZoneDetail.tacticalGrid[pos];
      
      // Debug: Log the terrain and construction data
      console.log(` [DEBUG] Position ${pos} terrain: ${gridData.terrain}, construction:`, gridData.construction);
      
      // Apply road construction bonus
      if (gridData.construction && gridData.construction.completed && 
          gridData.construction.type === 'road' && 
          constructionOptions.road.effects.movementBonus) {
        const movementBonus = constructionOptions.road.effects.movementBonus;
        unit.roadMovementBonus = movementBonus;
        totalBonus += movementBonus;
        console.log(` [ROAD DEBUG] Applied +${movementBonus} road construction bonus to ${unit.name} at position ${pos}`);
      }
      
      // Apply road terrain bonus
      console.log(` [DEBUG] Checking road terrain: gridData.terrain = "${gridData.terrain}", terrainEffects.road =`, terrainEffects.road);
      if (gridData.terrain === 'road' && terrainEffects.road.movementBonus) {
        const movementBonus = terrainEffects.road.movementBonus;
        unit.roadMovementBonus = movementBonus;
        totalBonus += movementBonus;
        console.log(` [ROAD DEBUG] Applied +${movementBonus} road terrain bonus to ${unit.name} at position ${pos}`);
      }
      
      // Apply infrastructure terrain bonus (in case the terrain is actually infrastructure)
      console.log(` [DEBUG] Checking infrastructure terrain: gridData.terrain = "${gridData.terrain}", terrainEffects.infrastructure =`, terrainEffects.infrastructure);
      if (gridData.terrain === 'infrastructure' && terrainEffects.infrastructure.movementBonus) {
        const movementBonus = terrainEffects.infrastructure.movementBonus;
        unit.terrainMovementBonus = movementBonus;
        totalBonus += movementBonus;
        console.log(` [TERRAIN DEBUG] Applied +${movementBonus} infrastructure terrain bonus to ${unit.name} at position ${pos}`);
      }
      
      // Apply mobile cover bonus if unit has that ability (for road construction)
      if (unit.special === 'mobile_cover' && 
          gridData.construction && gridData.construction.completed && 
          gridData.construction.type === 'road') {
        unit.mobileCoverRoadBonus = 2;
        totalBonus += 2;
        console.log(` [ROAD DEBUG] Applied +2 mobile cover bonus to ${unit.name} at position ${pos} (road construction)`);
      }
      
      // Apply mobile cover bonus if unit has that ability (for road terrain)
      if (unit.special === 'mobile_cover' && gridData.terrain === 'road') {
        unit.mobileCoverRoadBonus = 2;
        totalBonus += 2;
        console.log(` [ROAD DEBUG] Applied +2 mobile cover bonus to ${unit.name} at position ${pos} (road terrain)`);
      }
      
      // Apply terrain movement bonus (for infrastructure terrain)
      if (gridData.terrain && terrainEffects[gridData.terrain].movementBonus) {
        const terrainBonus = terrainEffects[gridData.terrain].movementBonus;
        unit.terrainMovementBonus = terrainBonus;
        totalBonus += terrainBonus;
        console.log(` [TERRAIN DEBUG] Applied +${terrainBonus} terrain bonus to ${unit.name} at position ${pos}`);
      }
      
      // Apply ability movement bonus (for amphibious units on river/beach)
      if (unit.special === 'amphibious' && 
          (gridData.terrain === 'river' || gridData.terrain === 'beach')) {
        // Get the ability bonus from applySpecialAbilities
        const abilities = applySpecialAbilities(unit, pos, gridData);
        if (abilities.movementBonus) {
          unit.abilityMovementBonus = abilities.movementBonus;
          totalBonus += abilities.movementBonus;
          console.log(` [AMPHIBIOUS DEBUG] Applied +${abilities.movementBonus} ability bonus to ${unit.name} at position ${pos}`);
        }
      }
      
      return totalBonus;
    }
    
    function startMovementMode(unit, pos) {
      console.log(` [MOVEMENT DEBUG] startMovementMode called for ${unit.name} at pos ${pos}`);
      console.log(` [MOVEMENT DEBUG] Unit movement points: ${unit.movement}`);
      
      // Reset any previous movement mode
      resetMovementMode();
      
      // Apply any temporary bonuses that should be active for this unit at this position
      const temporaryBonus = applyTemporaryMovementBonuses(unit, pos);
      
      // Apply weather effects to movement
      const weatherEffects = getWeatherEffects();
      const weatherMovementModifier = weatherEffects.movement;
      
      // Calculate total movement points with weather effects
      let totalMovementPoints = unit.movement + temporaryBonus + weatherMovementModifier;
      
      // Ensure minimum movement of 1 (unless unit already has 0 movement)
      if (unit.movement > 0 && totalMovementPoints < 1) {
        totalMovementPoints = 1;
      }
      
      // Apply weather restrictions to movement
      if (weatherEffects.movement < 0) {
        console.log(`[MOVEMENT RESTRICTION] ${unit.name} movement reduced by weather: ${unit.movement} -> ${totalMovementPoints}`);
      }
      
              console.log(`[WEATHER DEBUG] Unit: ${unit.name}, Base movement: ${unit.movement}, Weather modifier: ${weatherMovementModifier}, Total: ${totalMovementPoints}`);
      
      // Initialize movement mode
      gameState.movementMode = {
        active: true,
        selectedUnit: { ...unit, position: pos },
        movementPoints: totalMovementPoints,
        validPositions: calculateValidMovementPositions(pos, totalMovementPoints)
      };
      
      console.log(` [MOVEMENT DEBUG] Movement mode initialized:`, gameState.movementMode);
      console.log(` [MOVEMENT DEBUG] Base movement: ${unit.movement}, Temporary bonus: ${temporaryBonus}, Total: ${totalMovementPoints}`);
      console.log(` [MOVEMENT DEBUG] Valid positions calculated:`, gameState.movementMode.validPositions);
      
      // Update UI
      updateMovementInfo();
      generateMiniBattlefield();
      logZoneMessage(`${unit.name} selected for movement (${totalMovementPoints} points available)`, 'movement');
      console.log(` [MOVEMENT DEBUG] startMovementMode completed`);
    }
    
    function calculateValidMovementPositions(startPos, movementPoints) {
      if (!currentZoneDetail || movementPoints <= 0) return [];
      
      const gridSize = gameConfig.gridSize;
      const validPositions = [];
      const visited = new Set();
      
      // Directions: up, down, left, right
      const directions = [
        { row: -1, col: 0 }, // Up
        { row: 1, col: 0 },  // Down
        { row: 0, col: -1 }, // Left
        { row: 0, col: 1 }   // Right
      ];
      
      // Recursive function to explore possible moves
      function explore(currentPos, remainingPoints) {
        if (remainingPoints < 0) return;
        if (visited.has(currentPos)) return;
        
        visited.add(currentPos);
        
        // Only consider empty positions
        if (!currentZoneDetail.tacticalGrid[currentPos].unit) {
          validPositions.push(currentPos);
        }
        
        const row = Math.floor(currentPos / gridSize);
        const col = currentPos % gridSize;
        
        for (const dir of directions) {
          const newRow = row + dir.row;
          const newCol = col + dir.col;
          
          if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
            const newPos = newRow * gridSize + newCol;
            
            // Check if the target position has barbed wire (blocks movement completely)
            const targetGridData = currentZoneDetail.tacticalGrid[newPos];
            if (targetGridData.construction && targetGridData.construction.completed && 
                targetGridData.construction.type === 'barbedWire' && 
                constructionOptions.barbedWire.effects.movementBlock) {
              
              // Calculate movement cost based on terrain
              const terrain = currentZoneDetail.tacticalGrid[newPos].terrain;
              const cost = terrainEffects[terrain].moveDelay;
            
              // Check if the moving unit has Veteran or Trample ability (ignores barbed wire)
              const movingUnit = currentZoneDetail.tacticalGrid[startPos].unit;
              console.log(' [BARBED WIRE DEBUG] Moving unit:', movingUnit.name, 'Special:', movingUnit.special);
              
              const unitAbilities = movingUnit.special && specialAbilities[movingUnit.special] ? 
                specialAbilities[movingUnit.special].apply(movingUnit, startPos, currentZoneDetail.tacticalGrid[startPos]) : {};
              
              console.log(' [BARBED WIRE DEBUG] Special abilities:', unitAbilities);
              
              if (unitAbilities.ignoreBarbedWire) {
                // Veteran units can move through barbed wire normally
                if (!currentZoneDetail.tacticalGrid[newPos].unit) {
                  validPositions.push(newPos);
                }
            explore(newPos, remainingPoints - cost);
              } else {
                // Regular units: barbed wire blocks movement THROUGH it, but units can move INTO it
                // Don't explore further paths from barbed wire positions
                // But still add the barbed wire position itself as a valid move
                if (!currentZoneDetail.tacticalGrid[newPos].unit) {
                  validPositions.push(newPos);
                }
                continue; // Don't explore paths beyond barbed wire
              }
            } else if (targetGridData.construction && targetGridData.construction.completed && 
                       targetGridData.construction.type === 'tankTrap' && 
                       constructionOptions.tankTrap.effects.vehicleBlock) {
              
              // Calculate movement cost based on terrain
              const terrain = currentZoneDetail.tacticalGrid[newPos].terrain;
              const cost = terrainEffects[terrain].moveDelay;
            
              // Check if the moving unit is a tank or vehicle
              const movingUnit = currentZoneDetail.tacticalGrid[startPos].unit;
              console.log(' [TANK TRAP DEBUG] Moving unit:', movingUnit.name, 'Type:', movingUnit.type);
              
              // Check if the moving unit has Trample ability (ignores tank traps)
              const unitAbilities = movingUnit.special && specialAbilities[movingUnit.special] ? 
                specialAbilities[movingUnit.special].apply(movingUnit, startPos, currentZoneDetail.tacticalGrid[startPos]) : {};
              
              console.log(' [TANK TRAP DEBUG] Special abilities:', unitAbilities);
              
              if (unitAbilities.ignoreTankTraps) {
                // Units with Trample can move through tank traps normally
                if (!currentZoneDetail.tacticalGrid[newPos].unit) {
                  validPositions.push(newPos);
                }
                explore(newPos, remainingPoints - cost);
              } else if (movingUnit.type === 'tank' || movingUnit.type === 'vehicle') {
                // Tanks and Vehicles: tank trap blocks movement THROUGH it, but units can move INTO it
                // Don't explore further paths from tank trap positions
                // But still add the tank trap position itself as a valid move
                if (!currentZoneDetail.tacticalGrid[newPos].unit) {
                  validPositions.push(newPos);
                }
                continue; // Don't explore paths beyond tank trap
              } else {
                // Non-tank/vehicle units can move through tank traps normally
                if (!currentZoneDetail.tacticalGrid[newPos].unit) {
                  validPositions.push(newPos);
                }
                explore(newPos, remainingPoints - cost);
              }
            } else {
              // Calculate movement cost based on terrain
              const terrain = currentZoneDetail.tacticalGrid[newPos].terrain;
              let cost = terrainEffects[terrain].moveDelay;
              
              console.log(' [MOVEMENT DEBUG] Checking position:', newPos, 'terrain:', terrain);
              
              // Special handling for river terrain
              if (terrain === 'river') {
                const movingUnit = currentZoneDetail.tacticalGrid[startPos].unit;
                const hasAmphibious = movingUnit.special === 'amphibious';
                const targetGridData = currentZoneDetail.tacticalGrid[newPos];
                const hasBridge = targetGridData.construction && targetGridData.construction.completed && 
                                targetGridData.construction.type === 'bridge';
                
                console.log(' [RIVER DEBUG] Moving unit:', movingUnit.name, 'Has amphibious:', hasAmphibious, 'Has bridge:', hasBridge);
                
                // Vehicles, Tanks, and Field Guns can't cross river tiles without a bridge
                if ((movingUnit.type === 'vehicle' || movingUnit.type === 'tank' || movingUnit.type === 'field_gun') && 
                    !hasBridge && !hasAmphibious) {
                  console.log(' [RIVER DEBUG] Vehicle/Tank/Field Gun cannot cross river without bridge');
                  continue; // Skip this position
                }
                
                if (hasAmphibious || hasBridge) {
                  // Amphibious units or bridges treat river as normal terrain (cost 1)
                  cost = 1;
                  if (hasBridge) {
                    console.log(' [BRIDGE DEBUG] Bridge removes river penalty');
                  }
                } else {
                  // Regular units without bridge: can move INTO river but it blocks further movement
                  if (!currentZoneDetail.tacticalGrid[newPos].unit) {
                    validPositions.push(newPos);
                  }
                  continue; // Don't explore further from river positions
                }
              }
              
              // Special handling for mountain terrain
              if (terrain === 'mountain' || terrain === 'mountains') {
                const movingUnit = currentZoneDetail.tacticalGrid[startPos].unit;
                const hasThoseWhoDare = movingUnit.special === 'those_who_dare';
                
                console.log(' [MOUNTAIN DEBUG] Moving unit:', movingUnit.name, 'Type:', movingUnit.type, 'Has Those Who Dare:', hasThoseWhoDare);
                console.log(' [MOUNTAIN DEBUG] Checking position:', newPos, 'terrain:', terrain);
                
                // Only Mechs and units with "Those Who Dare" can move on Mountain terrain
                if (movingUnit.type !== 'mech' && !hasThoseWhoDare) {
                  console.log(' [MOUNTAIN DEBUG] Unit cannot traverse mountain terrain - skipping position', newPos);
                  continue; // Skip this position
                }
                
                console.log(' [MOUNTAIN DEBUG] Unit can traverse mountain terrain - allowing position', newPos);
                
                // Add mountain position to valid positions if no unit is there
                if (!currentZoneDetail.tacticalGrid[newPos].unit) {
                  validPositions.push(newPos);
                  console.log(' [MOUNTAIN DEBUG] Added mountain position', newPos, 'to valid positions');
                }
              }
              
              explore(newPos, remainingPoints - cost);
            }
          }
        }
      }
      
      // Start exploration from the unit's position
      explore(startPos, movementPoints);
      
      // Remove starting position from valid positions
      const finalValidPositions = validPositions.filter(p => p !== startPos);
      console.log(' [MOVEMENT DEBUG] Final valid positions:', finalValidPositions);
      console.log(' [MOVEMENT DEBUG] Valid positions include mountain tiles:', finalValidPositions.some(pos => {
        const terrain = currentZoneDetail.tacticalGrid[pos].terrain;
        return terrain === 'mountain' || terrain === 'mountains';
      }));
      return finalValidPositions;
    }
    
    function moveUnitToPosition(targetPos) {
      console.log(` [MOVEMENT DEBUG] moveUnitToPosition called with targetPos: ${targetPos}`);
      console.log(` [MOVEMENT DEBUG] currentZoneDetail exists: ${!!currentZoneDetail}`);
      console.log(` [MOVEMENT DEBUG] movementMode.active: ${gameState.movementMode.active}`);
      
      if (!currentZoneDetail || !gameState.movementMode.active) {
        console.log(` [MOVEMENT DEBUG] Early return - currentZoneDetail: ${!!currentZoneDetail}, movementMode.active: ${gameState.movementMode.active}`);
        return;
      }
      
      // Check CP cost for moving unit
      console.log(` [MOVEMENT DEBUG] Checking CP cost: need ${gameState.cpCosts.moveUnit}, can spend: ${canSpendCP(gameState.cpCosts.moveUnit)}`);
      if (!canSpendCP(gameState.cpCosts.moveUnit)) {
        console.log(` [MOVEMENT DEBUG] Not enough CP to move unit`);
        logZoneMessage(`Not enough Command Points to move unit (need ${gameState.cpCosts.moveUnit} CP)`, 'system');
        return;
      }
      console.log(` [MOVEMENT DEBUG] CP check passed, continuing with movement`);
      
      
      const startPos = gameState.movementMode.selectedUnit.position;
      const startGridData = currentZoneDetail.tacticalGrid[startPos];
      const targetGridData = currentZoneDetail.tacticalGrid[targetPos];
      
      console.log(` [MOVEMENT DEBUG] Movement details:`);
      console.log(` [MOVEMENT DEBUG] - startPos: ${startPos}`);
      console.log(` [MOVEMENT DEBUG] - targetPos: ${targetPos}`);
      console.log(` [MOVEMENT DEBUG] - startGridData:`, startGridData);
      console.log(` [MOVEMENT DEBUG] - targetGridData:`, targetGridData);
      
      if (!startGridData.unit || targetGridData.unit) return;
      
      // Check terrain movement restrictions
      const unit = startGridData.unit;
      const terrain = targetGridData.terrain;
      const terrainEffect = terrainEffects[terrain];
      
      // Check for restricted units based on terrain (all_terrain units can bypass restrictions)
      if (terrainEffect.restrictedUnits && terrainEffect.restrictedUnits.includes(unit.type) && unit.special !== 'all_terrain') {
        logZoneMessage(`${unit.name} cannot move through ${terrain} terrain!`, 'system');
        return;
      }
      
      // Special handling for mountain terrain (only Mechs and units with "Those Who Dare")
      if (terrain === 'mountain' || terrain === 'mountains') {
        if (unit.type !== 'mech' && unit.special !== 'those_who_dare') {
          logZoneMessage(`Only Mech units or units with "Those Who Dare" can traverse mountain terrain!`, 'system');
          return;
        }
      }
      
      // Special handling for river terrain (Vehicles, Tanks, and Field Guns need bridge or amphibious)
      if (terrain === 'river' && (unit.type === 'vehicle' || unit.type === 'tank' || unit.type === 'field_gun')) {
        const hasBridge = targetGridData.construction && targetGridData.construction.completed && 
                         targetGridData.construction.type === 'bridge';
        const hasAmphibious = unit.special === 'amphibious';
        
        if (!hasBridge && !hasAmphibious) {
          logZoneMessage(`${unit.name} cannot cross river terrain without a bridge!`, 'system');
          return;
        }
      }
      
      // Calculate movement cost
      let cost = terrainEffect.moveDelay;
      
      // Apply terrain-specific movement penalties
      if (terrainEffect.movementPenalty) {
        cost += Math.abs(terrainEffect.movementPenalty);
      }
      
      // Apply vehicle-specific movement penalties
      if (terrainEffect.vehicleMovementPenalty && (unit.type === 'vehicle' || unit.type === 'tank')) {
        cost += Math.abs(terrainEffect.vehicleMovementPenalty);
      }
      
      // Special handling for amphibious units or bridges on river
      if (terrain === 'river') {
        const hasAmphibious = startGridData.unit.special === 'amphibious';
        const hasBridge = targetGridData.construction && targetGridData.construction.completed && 
                         targetGridData.construction.type === 'bridge';
        
        if (hasAmphibious || hasBridge) {
          cost = 1; // Amphibious units or bridges treat river as normal terrain
          console.log(' [RIVER DEBUG] River cost reduced to 1 -', hasAmphibious ? 'Amphibious unit' : 'Bridge present');
        }
      }
      
      // Update movement points
      gameState.movementMode.movementPoints -= cost;
      
      // Check if unit has Trample ability and is moving onto a construction
      const hasTrample = startGridData.unit.special === 'trample';
      const hasConstruction = targetGridData.construction && targetGridData.construction.completed;
      const trampleableConstruction = hasConstruction && 
        (targetGridData.construction.type === 'barbedWire' || 
         targetGridData.construction.type === 'minefield' || 
         targetGridData.construction.type === 'tankTrap');
      
      // Move the unit
      console.log(` [MOVEMENT DEBUG] About to move unit from ${startPos} to ${targetPos}`);
      console.log(` [MOVEMENT DEBUG] Unit being moved:`, startGridData.unit);
      
      // Clear road construction bonus if unit was on a road construction tile and is now leaving it
      if (startGridData.construction && startGridData.construction.completed && 
          startGridData.construction.type === 'road' && 
          startGridData.unit.roadMovementBonus) {
        const movementBonus = startGridData.unit.roadMovementBonus;
        startGridData.unit.roadMovementBonus = undefined;
        // Restore defense penalty that was applied on road
        startGridData.unit.defense += 1;
        logZoneMessage(`${startGridData.unit.name} loses +${movementBonus} movement bonus when leaving road construction!`, 'movement');
        console.log(` [ROAD DEBUG] Unit ${startGridData.unit.name} lost +${movementBonus} movement bonus when leaving road construction at position ${startPos}`);
        console.log(` [ROAD DEBUG] Unit base movement: ${startGridData.unit.movement}, road bonus cleared, total movement points: ${gameState.movementMode.movementPoints}`);
      }
      
      // Clear road terrain bonus if unit was on a road terrain tile and is now leaving it
      if (startGridData.terrain === 'road' && startGridData.unit.roadMovementBonus) {
        const movementBonus = startGridData.unit.roadMovementBonus;
        startGridData.unit.roadMovementBonus = undefined;
        // Restore defense penalty that was applied on road
        startGridData.unit.defense += 1;
        logZoneMessage(`${startGridData.unit.name} loses +${movementBonus} movement bonus when leaving road terrain!`, 'movement');
        console.log(` [ROAD DEBUG] Unit ${startGridData.unit.name} lost +${movementBonus} movement bonus when leaving road terrain at position ${startPos}`);
        console.log(` [ROAD DEBUG] Unit base movement: ${startGridData.unit.movement}, road bonus cleared, total movement points: ${gameState.movementMode.movementPoints}`);
      }
      
      // Clear mobile cover road bonus if unit was on a road construction tile and is now leaving it
      if (startGridData.construction && startGridData.construction.completed && 
          startGridData.construction.type === 'road' && 
          startGridData.unit.mobileCoverRoadBonus) {
        const mobileCoverBonus = startGridData.unit.mobileCoverRoadBonus;
        startGridData.unit.mobileCoverRoadBonus = undefined;
        logZoneMessage(`${startGridData.unit.name} loses +${mobileCoverBonus} movement bonus from Mobile Cover when leaving road construction!`, 'movement');
        console.log(` [ROAD DEBUG] Unit ${startGridData.unit.name} lost +${mobileCoverBonus} movement bonus from Mobile Cover when leaving road construction at position ${startPos}`);
      }
      
      // Clear mobile cover road bonus if unit was on a road terrain tile and is now leaving it
      if (startGridData.terrain === 'road' && startGridData.unit.mobileCoverRoadBonus) {
        const mobileCoverBonus = startGridData.unit.mobileCoverRoadBonus;
        startGridData.unit.mobileCoverRoadBonus = undefined;
        logZoneMessage(`${startGridData.unit.name} loses +${mobileCoverBonus} movement bonus from Mobile Cover when leaving road terrain!`, 'movement');
        console.log(` [ROAD DEBUG] Unit ${startGridData.unit.name} lost +${mobileCoverBonus} movement bonus from Mobile Cover when leaving road terrain at position ${startPos}`);
      }
      
      // Clear terrain movement bonus if unit was on infrastructure terrain and is now leaving it
      if (startGridData.terrain === 'infrastructure' && startGridData.unit.terrainMovementBonus) {
        const terrainBonus = startGridData.unit.terrainMovementBonus;
        startGridData.unit.terrainMovementBonus = undefined;
        logZoneMessage(`${startGridData.unit.name} loses +${terrainBonus} movement bonus when leaving infrastructure!`, 'movement');
        console.log(` [TERRAIN DEBUG] Unit ${startGridData.unit.name} lost +${terrainBonus} movement bonus when leaving infrastructure at position ${startPos}`);
      }
      
      // Clear ability movement bonus if unit was on river/beach terrain and is now leaving it (for amphibious units)
      if ((startGridData.terrain === 'river' || startGridData.terrain === 'beach') && 
          startGridData.unit.abilityMovementBonus && startGridData.unit.special === 'amphibious') {
        const abilityBonus = startGridData.unit.abilityMovementBonus;
        startGridData.unit.abilityMovementBonus = undefined;
        logZoneMessage(`${startGridData.unit.name} loses +${abilityBonus} movement bonus when leaving ${startGridData.terrain}!`, 'movement');
        console.log(` [AMPHIBIOUS DEBUG] Unit ${startGridData.unit.name} lost +${abilityBonus} movement bonus when leaving ${startGridData.terrain} at position ${startPos}`);
      }
      
      targetGridData.unit = startGridData.unit;
      targetGridData.unit.position = targetPos;
      targetGridData.unit.justMoved = true; // Flag for All Terrain ability
      startGridData.unit = null;
      
      console.log(` [MOVEMENT DEBUG] Unit moved successfully!`);
      console.log(` [MOVEMENT DEBUG] - Target grid now has unit:`, targetGridData.unit);
      console.log(` [MOVEMENT DEBUG] - Start grid now has unit:`, startGridData.unit);
      
      // Deactivate Siege Mode if unit has it (since it moved)
      if (targetGridData.unit.special === 'siege_mode' && targetGridData.unit.turnsStationary > 0) {
        targetGridData.unit.turnsStationary = 0;
        logZoneMessage(`${targetGridData.unit.name} moved - Siege Mode deactivated!`, 'combat');
      }
      
      // Apply Trample effect - remove construction if trampleable
      if (hasTrample && trampleableConstruction) {
        const constructionName = constructionOptions[targetGridData.construction.type].name;
        targetGridData.construction = null; // Remove the construction
        logZoneMessage(`${targetGridData.unit.name} tramples and destroys the ${constructionName}!`, 'combat');
        logMessage(`INTELLIGENCE: ${targetGridData.unit.name} demonstrated trample capability by destroying ${constructionName}.`, 'intelligence');
      }
      
      // Process special ability effects for movement
      processSpecialAbilityEffects(targetGridData.unit, targetPos, targetGridData, 'movement');
      
      // Apply road construction bonus if unit entered a completed road construction tile
      if (targetGridData.construction && targetGridData.construction.completed && 
          targetGridData.construction.type === 'road' && 
          constructionOptions.road.effects.movementBonus) {
        const movementBonus = constructionOptions.road.effects.movementBonus;
        // Store the road bonus on the unit for this turn only
        targetGridData.unit.roadMovementBonus = movementBonus;
        gameState.movementMode.movementPoints += movementBonus;
        logZoneMessage(`${targetGridData.unit.name} gains +${movementBonus} movement from road construction!`, 'movement');
        console.log(` [ROAD DEBUG] Unit ${targetGridData.unit.name} gained +${movementBonus} movement from road construction at position ${targetPos}`);
        console.log(` [ROAD DEBUG] Unit base movement: ${targetGridData.unit.movement}, road bonus: ${targetGridData.unit.roadMovementBonus}, total movement points: ${gameState.movementMode.movementPoints}`);
        
        // Apply -1 defense penalty for units on road tiles
        targetGridData.unit.defense -= 1;
        logZoneMessage(`${targetGridData.unit.name} suffers -1 defense penalty on road!`, 'combat');
        console.log(` [ROAD DEBUG] Unit ${targetGridData.unit.name} suffered -1 defense penalty on road at position ${targetPos}`);
        
        // Apply mobile cover bonus if unit has that ability (for road construction)
        if (targetGridData.unit.mobileCoverRoadBonus) {
          gameState.movementMode.movementPoints += targetGridData.unit.mobileCoverRoadBonus;
          logZoneMessage(`${targetGridData.unit.name} gains +${targetGridData.unit.mobileCoverRoadBonus} movement from Mobile Cover on road construction!`, 'movement');
          console.log(` [ROAD DEBUG] Unit ${targetGridData.unit.name} gained +${targetGridData.unit.mobileCoverRoadBonus} movement from Mobile Cover on road construction at position ${targetPos}`);
        }
      }
      
      // Apply road terrain bonus if unit entered a road terrain tile
      if (targetGridData.terrain === 'road' && terrainEffects.road.movementBonus) {
        const movementBonus = terrainEffects.road.movementBonus;
        // Store the road bonus on the unit for this turn only
        targetGridData.unit.roadMovementBonus = movementBonus;
        gameState.movementMode.movementPoints += movementBonus;
        logZoneMessage(`${targetGridData.unit.name} gains +${movementBonus} movement from road terrain!`, 'movement');
        console.log(` [ROAD DEBUG] Unit ${targetGridData.unit.name} gained +${movementBonus} movement from road terrain at position ${targetPos}`);
        console.log(` [ROAD DEBUG] Unit base movement: ${targetGridData.unit.movement}, road bonus: ${targetGridData.unit.roadMovementBonus}, total movement points: ${gameState.movementMode.movementPoints}`);
        
        // Apply -1 defense penalty for units on road tiles
        targetGridData.unit.defense -= 1;
        logZoneMessage(`${targetGridData.unit.name} suffers -1 defense penalty on road!`, 'combat');
        console.log(` [ROAD DEBUG] Unit ${targetGridData.unit.name} suffered -1 defense penalty on road at position ${targetPos}`);
        
        // Apply mobile cover bonus if unit has that ability (for road terrain)
        if (targetGridData.unit.mobileCoverRoadBonus) {
          gameState.movementMode.movementPoints += targetGridData.unit.mobileCoverRoadBonus;
          logZoneMessage(`${targetGridData.unit.name} gains +${targetGridData.unit.mobileCoverRoadBonus} movement from Mobile Cover on road terrain!`, 'movement');
          console.log(` [ROAD DEBUG] Unit ${targetGridData.unit.name} gained +${targetGridData.unit.mobileCoverRoadBonus} movement from Mobile Cover on road terrain at position ${targetPos}`);
        }
      }
      
      // Apply terrain movement bonus (for infrastructure terrain tiles) - temporary bonus while on tile
      if (terrainEffect.movementBonus) {
        // Store the terrain bonus on the unit for this turn only
        targetGridData.unit.terrainMovementBonus = terrainEffect.movementBonus;
        gameState.movementMode.movementPoints += terrainEffect.movementBonus;
        logZoneMessage(`${targetGridData.unit.name} gains +${terrainEffect.movementBonus} movement from ${terrain} terrain!`, 'movement');
        console.log(` [TERRAIN DEBUG] Unit ${targetGridData.unit.name} gained +${terrainEffect.movementBonus} movement from ${terrain} terrain at position ${targetPos}`);
      }
      
      // Clear the justMoved flag after processing abilities
      targetGridData.unit.justMoved = false;
      
      // Check for gas damage when entering a position
      console.log(` [MOVEMENT DEBUG] Checking for gas at position ${targetPos}, currentZone=${gameState.currentZone}`);
      console.log(` [MOVEMENT DEBUG] gameState.gasClouds exists: ${!!gameState.gasClouds}`);
      if (gameState.gasClouds && gameState.gasClouds[gameState.currentZone] && gameState.gasClouds[gameState.currentZone][targetPos]) {
        console.log(` [GAS] Unit ${targetGridData.unit.name} entered gas cloud at position ${targetPos}`);
        // Defer gas damage to avoid interrupting movement completion
        setTimeout(() => {
          applyGasDamage(targetGridData.unit, targetPos);
          // Update UI after gas damage is applied
          generateMiniBattlefield();
        }, 100);
      }
      
      // Check if unit is routing and reached the edge (similar to gas logic)
      if (targetGridData.unit.moraleCollapse) {
        const gridSize = gameConfig.gridSize;
        const row = Math.floor(targetPos / gridSize);
        const col = targetPos % gridSize;
        
        // Check if unit is on the edge of the grid
        if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {
          console.log(` [ROUTING] Unit ${targetGridData.unit.name} reached edge while routing, will be destroyed next turn`);
          targetGridData.unit.reachedEdgeWhileRouting = true;
          logZoneMessage(`${targetGridData.unit.name} reached the edge while routing and will be destroyed!`, 'combat');
        }
      }
      console.log(` [MOVEMENT DEBUG] Gas check completed, continuing movement`);
      
      // Ensure movement UI updates properly
      console.log(` [MOVEMENT DEBUG] About to update UI after movement to position ${targetPos}`);
      
      // Check if unit moved into barbed wire
      if (targetGridData.construction && targetGridData.construction.completed && 
          targetGridData.construction.type === 'barbedWire' && 
          constructionOptions.barbedWire.effects.movementBlock) {
        
        // Check if unit has Veteran ability (ignores barbed wire immobilization)
        const veteranAbilities = targetGridData.unit.special && specialAbilities[targetGridData.unit.special] ? 
          specialAbilities[targetGridData.unit.special].apply(targetGridData.unit, targetPos, targetGridData) : {};
        
        if (veteranAbilities.ignoreBarbedWire) {
          // Veteran units are not immobilized by barbed wire
          logZoneMessage(`${targetGridData.unit.name} expertly navigates through the barbed wire!`, 'combat');
          logMessage(`INTELLIGENCE: ${targetGridData.unit.name} demonstrated veteran expertise by safely traversing barbed wire fortification.`, 'intelligence');
        } else {
          // Regular units lose all remaining movement points
          gameState.movementMode.movementPoints = 0;
          logZoneMessage(`${targetGridData.unit.name} is entangled in barbed wire and loses all remaining movement!`, 'combat');
          logMessage(`INTELLIGENCE: ${targetGridData.unit.name} was immobilized by barbed wire fortification.`, 'intelligence');
        }
      }
      
      // Check if unit moved into tank trap
      if (targetGridData.construction && targetGridData.construction.completed && 
          targetGridData.construction.type === 'tankTrap' && 
          constructionOptions.tankTrap.effects.vehicleBlock) {
        
        // Check if unit is a tank or vehicle
        if (targetGridData.unit.type === 'tank' || targetGridData.unit.type === 'vehicle') {
          // Check if unit has Trample ability (ignores tank trap immobilization)
          const trampleAbilities = targetGridData.unit.special && specialAbilities[targetGridData.unit.special] ? 
            specialAbilities[targetGridData.unit.special].apply(targetGridData.unit, targetPos, targetGridData) : {};
          
          if (trampleAbilities.ignoreTankTraps) {
            // Units with Trample are not immobilized by tank traps
            logZoneMessage(`${targetGridData.unit.name} crushes through the tank trap!`, 'combat');
            logMessage(`INTELLIGENCE: ${targetGridData.unit.name} demonstrated trample capability by destroying tank trap fortification.`, 'intelligence');
          } else {
            // Tanks and Vehicles lose all remaining movement points
            gameState.movementMode.movementPoints = 0;
            logZoneMessage(`${targetGridData.unit.name} is immobilized by the tank trap and loses all remaining movement!`, 'combat');
            logMessage(`INTELLIGENCE: ${targetGridData.unit.name} was immobilized by tank trap fortification.`, 'intelligence');
          }
        }
        // Non-tank/vehicle units are not affected by tank traps
      }
      
      // Check if unit moved into minefield
      if (targetGridData.construction && targetGridData.construction.completed && 
          targetGridData.construction.type === 'minefield' && 
          constructionOptions.minefield.effects.damage) {
        
        console.log(` [MINEFIELD] Unit ${targetGridData.unit.name} triggered a minefield at position ${targetPos}`);
        
        // Roll for minefield damage (D6)
        const minefieldDamage = Math.floor(Math.random() * 6) + 1;
        
        // Show minefield dice animation
        showMinefieldDiceAnimation(targetGridData.unit.name, minefieldDamage, () => {
          // Store unit reference before applying damage
          const unit = targetGridData.unit;
          
          // Check if unit will be destroyed by this damage
          const willBeDestroyed = (unit.health - minefieldDamage) <= 0;
          
          // Apply damage after animation
          const damageResult = applyDamage(targetGridData.unit, minefieldDamage, targetPos);
          
          if (damageResult.unitDestroyed) {
            logZoneMessage(`${unit.name} was destroyed by the minefield explosion!`, 'combat');
            logMessage(`INTELLIGENCE: ${unit.name} was eliminated by enemy minefield.`, 'intelligence');
            
            // Remove the minefield after it explodes
            targetGridData.construction = null;
            
            // Perform morale check for survival immediately
            performMoraleCheckForSurvival(unit, targetPos);
          } else {
            logZoneMessage(`${unit.name} takes ${minefieldDamage} damage from the minefield!`, 'combat');
            logMessage(`INTELLIGENCE: ${unit.name} was damaged by enemy minefield.`, 'intelligence');
            
            // Remove the minefield after it explodes
            targetGridData.construction = null;
            
            // Perform morale check for the damaged unit (optional - only if health is low)
            if (unit.health <= 1) {
              performMoraleCheck(unit, targetPos);
            }
          }
          
          // Update UI after minefield damage
          generateMiniBattlefield();
        });
      }
      
      // Check if unit moved into river
      if (targetGridData.terrain === 'river') {
        const hasAmphibious = targetGridData.unit.special === 'amphibious';
        const hasBridge = targetGridData.construction && targetGridData.construction.completed && 
                         targetGridData.construction.type === 'bridge';
        
        if (hasAmphibious) {
          // Amphibious units are not affected by river
          logZoneMessage(`${targetGridData.unit.name} expertly crosses the river!`, 'combat');
          logMessage(`INTELLIGENCE: ${targetGridData.unit.name} demonstrated amphibious expertise crossing river terrain.`, 'intelligence');
        } else if (hasBridge) {
          // Units crossing via bridge are not affected by river
          logZoneMessage(`${targetGridData.unit.name} safely crosses the river using the bridge!`, 'combat');
          logMessage(`INTELLIGENCE: ${targetGridData.unit.name} used bridge infrastructure to cross river terrain.`, 'intelligence');
        } else {
          // Regular units lose all remaining movement points when entering river
          gameState.movementMode.movementPoints = 0;
          logZoneMessage(`${targetGridData.unit.name} becomes stuck crossing the river and loses all remaining movement!`, 'combat');
          logMessage(`INTELLIGENCE: ${targetGridData.unit.name} was immobilized by river crossing.`, 'intelligence');
        }
      }
      
      // Update the selected unit position in movement mode
      gameState.movementMode.selectedUnit.position = targetPos;
      
      // Spend CP for moving unit
      spendCP(gameState.cpCosts.moveUnit);
      
      logZoneMessage(`${targetGridData.unit.name} moved to position ${targetPos + 1} (Cost: ${cost} movement points, ${gameState.cpCosts.moveUnit} CP)`, 'movement');
      
      // If we have no more movement points, end movement
      if (gameState.movementMode.movementPoints <= 0) {
        // Ensure unit action exists before setting hasMoved
        if (!gameState.unitActions[targetGridData.unit.id]) {
          gameState.unitActions[targetGridData.unit.id] = { hasAttacked: false, hasMoved: false };
        }
        gameState.unitActions[targetGridData.unit.id].hasMoved = true;
        resetMovementMode();
      } else {
        // Recalculate valid positions
        gameState.movementMode.validPositions = calculateValidMovementPositions(
          targetPos, 
          gameState.movementMode.movementPoints
        );
      }
      
      // Update UI
      console.log(` [MOVEMENT DEBUG] Updating UI after movement, movementPoints=${gameState.movementMode.movementPoints}`);
      console.log(` [MOVEMENT DEBUG] About to call generateMiniBattlefield()`);
      generateMiniBattlefield();
      console.log(` [MOVEMENT DEBUG] generateMiniBattlefield() completed`);
      console.log(` [MOVEMENT DEBUG] About to call updateMovementInfo()`);
      updateMovementInfo();
      console.log(` [MOVEMENT DEBUG] updateMovementInfo() completed`);
      console.log(` [MOVEMENT DEBUG] Movement function completed successfully`);
    }
    
    function resetMovementMode() {
      gameState.movementMode = {
        active: false,
        selectedUnit: null,
        movementPoints: 0,
        validPositions: []
      };
      updateMovementInfo();
    }
    
    function updateMovementInfo() {
      const infoDiv = document.getElementById('movement-info');
      const unitNameSpan = document.getElementById('movement-unit-name');
      const pointsSpan = document.getElementById('movement-points');
      
      if (!infoDiv || !unitNameSpan || !pointsSpan) return;
      
      if (gameState.movementMode.active) {
        infoDiv.style.display = 'block';
        unitNameSpan.textContent = gameState.movementMode.selectedUnit.name;
        pointsSpan.textContent = gameState.movementMode.movementPoints;
      } else {
        infoDiv.style.display = 'none';
      }
    }
    
    // Deployment zone validation
    function isValidDeploymentPosition(pos) {
      const validRows = getValidDeploymentRows();
      const gridSize = gameConfig.gridSize;
      const targetRow = Math.floor(pos / gridSize);
      return validRows.includes(targetRow);
    }
    
    // Deployment rows based on role in this specific zone
    function getValidDeploymentRows() {
      const gridSize = gameConfig.gridSize;
      const zoneRole = gameState.zoneRoles[gameState.currentZone];
      const isDefender = zoneRole && zoneRole.defender === gameState.currentPlayer;
      
      if (isDefender) {
        // Defenders can deploy in bottom 3 rows (last 3 rows)
        return [gridSize - 3, gridSize - 2, gridSize - 1];
      } else {
        // Attackers can only deploy in top row (row 0)
        return [0];
      }
    }
    
    function placeUnit(unitData, pos) {
      console.log(` [PLACE UNIT DEBUG] placeUnit called with:`, unitData, 'pos:', pos);
      console.log(` [PLACE UNIT DEBUG] currentZoneDetail exists:`, !!currentZoneDetail);
      
      if (!currentZoneDetail) {
        console.log(` [PLACE UNIT DEBUG] No currentZoneDetail, returning`);
        return;
      }
      
      // Check CP cost for placing unit
      if (!canSpendCP(gameState.cpCosts.placeUnit)) {
        console.log(` [PLACE UNIT DEBUG] Not enough CP to place unit`);
        logZoneMessage(`Not enough Command Points to place unit (need ${gameState.cpCosts.placeUnit} CP)`, 'system');
        return;
      }
      
      const gridData = currentZoneDetail.tacticalGrid[pos];
      if (gridData.unit) return; // Position occupied
      
      const unitId = `${gameState.currentPlayer}_${unitData.name}_${pos}_${Date.now()}`;
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      
      gridData.unit = {
        ...unitData,
        position: pos,
        player: gameState.currentPlayer,
        health: 2 + Math.max(0, unitData.defense),
        maxHealth: 2 + Math.max(0, unitData.defense),
        armour: unitData.armour || 0, // Initialize armour stat
        maxArmour: unitData.armour || 0, // Track maximum armour
        morale: unitData.morale,
        moveDelay: 0,
        id: unitId,
        placedThisTurn: true, // Mark as placed this turn
        turnsAlive: 0, // For special abilities that track turns
        turnsStationary: 0, // For Siege Mode ability
        killsThisTurn: 0, // For salvage systems ability
        armorToSalvage: 0, // For salvage systems ability
        targetHistory: {} // Track consecutive attacks on same target for Precision ability
      };
      
      // Initialize special ability effects
      processSpecialAbilityEffects(gridData.unit, pos, gridData, 'movement');
      
      // Check if unit is placed on beach and track beach landing
      if (gridData.terrain === 'beach') {
        const hasAmphibious = gridData.unit.special === 'amphibious';
        
        if (!hasAmphibious) {
          // Only non-amphibious units are affected by beach landing restrictions
          gridData.unit.beachLanding = true;
          gridData.unit.beachLandingTurns = 4; // Cannot move for 4 player turns (2 complete rounds)
          gridData.unit.beachLandingDeployTurn = gameState.currentTurn; // Track when deployed
          logZoneMessage(`${unitData.name} has landed on beach and cannot move for 2 complete rounds!`, 'combat');
          logMessage(`INTELLIGENCE: ${unitData.name} has made a beach landing and is establishing a beachhead.`, 'intelligence');
        } else {
          // Amphibious units are not affected by beach restrictions
          logZoneMessage(`${unitData.name} expertly establishes beachhead immediately!`, 'combat');
          logMessage(`INTELLIGENCE: ${unitData.name} demonstrated amphibious expertise during beach landing.`, 'intelligence');
        }
      }
      
      // Track unit actions
      const zoneRole = gameState.zoneRoles[currentZoneDetail.id] || {};
      const isAttacking = zoneRole.attacker === gameState.currentPlayer;
      const onBeach = gridData.terrain === 'beach' && gridData.unit.special !== 'amphibious';
      const allowMoveThisTurn = isAttacking && !onBeach;
      gameState.unitActions[unitId] = { 
        hasAttacked: false,
        hasMoved: !allowMoveThisTurn // defenders cannot move on deploy; attackers can unless beached
      };
      
      // Ensure deployedUnitInstances is initialized
      if (!gameState.deployedUnitInstances) {
        gameState.deployedUnitInstances = {};
        console.log(` [PLACE UNIT DEBUG] Initialized deployedUnitInstances object`);
      }
      
      // Track unit deployment instance with army index
      const instanceId = `${unitData.armyId}_${unitData.name}_${unitData.deploymentIndex}_${Date.now()}`;
      gameState.deployedUnitInstances[instanceId] = {
        zoneId: currentZoneDetail.id,
        playerId: playerId,
        armyId: unitData.armyId,
        unitData: {
          name: unitData.name,
          id: unitData.id || unitData.name, // Use name as fallback ID
          deploymentIndex: unitData.deploymentIndex // Track the specific unit index
        },
        instanceId: instanceId
      };
      
      // DEBUG: Log unit deployment tracking
      console.log(' [DEPLOYMENT DEBUG] Tracking unit deployment:');
      console.log(' [DEPLOYMENT DEBUG] - instanceId:', instanceId);
      console.log(' [DEPLOYMENT DEBUG] - deployedUnitInstances count:', Object.keys(gameState.deployedUnitInstances).length);
      console.log(' [DEPLOYMENT DEBUG] - deployment data:', gameState.deployedUnitInstances[instanceId]);
      console.log(' [DEPLOYMENT DEBUG] - Full deployedUnitInstances object:', gameState.deployedUnitInstances);
      
      // Remove unit from army pool
      const deployedUnit = {
        ...unitData,
        deploymentIndex: gameState.selectedUnit.deploymentIndex,
        zoneId: currentZoneDetail.id
      };
      gameState.deployedUnits[gameState.currentPlayer].push(deployedUnit);
      
      // DEBUG: Log deployed units tracking
      console.log(' [DEPLOYMENT DEBUG] Added to deployedUnits array:');
      console.log(' [DEPLOYMENT DEBUG] - deployedUnit:', deployedUnit);
      console.log(' [DEPLOYMENT DEBUG] - deployedUnits count for player:', gameState.deployedUnits[gameState.currentPlayer].length);
      
      // Spend CP for placing unit
      spendCP(gameState.cpCosts.placeUnit);
      
      gameState.selectedUnit = null;
      updateSelectedUnitInfo();
      generateMiniBattlefield();
      loadZoneArmyPool();
      updateArmyPoolStats();
      
      // Ensure army pool is properly refreshed after a short delay
      setTimeout(() => {
        loadZoneArmyPool();
        console.log(' [DEPLOYMENT DEBUG] Refreshed army pool after unit deployment');
      }, 100);
      
      logZoneMessage(`${unitData.name} deployed to position ${pos + 1} (Cost: ${gameState.cpCosts.placeUnit} CP)`);
      
      // Track unit deployment for summary
      if (!gameState.campaignStats) {
        gameState.campaignStats = {
          red: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          },
          blue: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          }
        };
      }
      console.log(' [UNIT DEPLOYMENT] Before deployment tracking - Player:', gameState.currentPlayer, 'Stats:', gameState.campaignStats[gameState.currentPlayer]);
      
      gameState.campaignStats[gameState.currentPlayer].unitsDeployed++;
      
      console.log(' [UNIT DEPLOYMENT] After deployment tracking - Player:', gameState.currentPlayer, 'Stats:', gameState.campaignStats[gameState.currentPlayer]);
      
      // Debug: Log the deployment
      console.log(' [UNIT DEPLOYMENT] Unit deployed:', unitData.name, 'from army:', unitData.armyId, 'to zone:', currentZoneDetail.id);
      console.log('Deployed instances:', gameState.deployedUnitInstances);
      
      // Send update to other players in multiplayer (only if not updating from server)
      if (isMultiplayerMode && !isUpdatingFromServer) {
        sendZoneBattleUpdate();
      }
    }
    
    // Carrier System Functions
    function handleBoardingClick(pos) {
      console.log(' [BOARD DEBUG] handleBoardingClick called with pos:', pos);
      console.log(' [BOARD DEBUG] currentZoneDetail exists:', !!currentZoneDetail);
      console.log(' [BOARD DEBUG] deploymentMode:', gameState.deploymentMode);
      
      const gridData = currentZoneDetail.tacticalGrid[pos];
      const unit = gridData.unit;
      
      console.log(' [BOARD DEBUG] gridData:', gridData);
      console.log(' [BOARD DEBUG] unit:', unit);
      console.log(' [BOARD DEBUG] selectedUnit:', gameState.selectedUnit);
      
      if (!gameState.selectedUnit) {
        // First click: Select Infantry unit to board
        console.log(' [BOARD DEBUG] First click - checking unit for boarding');
        console.log(' [BOARD DEBUG] unit exists:', !!unit);
        console.log(' [BOARD DEBUG] unit.player:', unit?.player);
        console.log(' [BOARD DEBUG] gameState.currentPlayer:', gameState.currentPlayer);
        console.log(' [BOARD DEBUG] unit.type:', unit?.type);
        
        if (unit && unit.player === gameState.currentPlayer && unit.type === 'infantry') {
          console.log(' [BOARD DEBUG] Valid infantry unit found, selecting for boarding');
          gameState.selectedUnit = { ...unit, position: pos };
          updateSelectedUnitInfo();
          highlightCarrierTargets(pos);
          logZoneMessage(`Selected ${unit.name} for boarding. Click on a Carrier to board.`);
        } else if (unit && unit.player === gameState.currentPlayer && unit.type !== 'infantry') {
          console.log(' [BOARD DEBUG] Non-infantry unit clicked');
          logZoneMessage('Only Infantry units can board Carriers');
        } else if (!unit) {
          console.log(' [BOARD DEBUG] No unit at position');
          logZoneMessage('Click on an Infantry unit to select it for boarding');
        } else {
          console.log(' [BOARD DEBUG] Enemy unit clicked');
          logZoneMessage('Cannot select enemy units');
        }
      } else {
        // Second click: Select Carrier to board onto
        console.log(' [BOARD DEBUG] Second click - checking for carrier');
        console.log(' [BOARD DEBUG] unit exists:', !!unit);
        console.log(' [BOARD DEBUG] unit.player:', unit?.player);
        console.log(' [BOARD DEBUG] gameState.currentPlayer:', gameState.currentPlayer);
        console.log(' [BOARD DEBUG] unit.special:', unit?.special);
        console.log(' [BOARD DEBUG] unit.type:', unit?.type);
        
        if (unit && unit.player === gameState.currentPlayer && unit.special === 'carrier') {
          console.log(' [BOARD DEBUG] Valid carrier found, attempting boarding');
          attemptBoarding(gameState.selectedUnit.position, pos);
        } else {
          console.log(' [BOARD DEBUG] Not a valid carrier');
          gameState.selectedUnit = null;
          updateSelectedUnitInfo();
          clearHighlights();
          logZoneMessage('Boarding cancelled');
        }
      }
    }
    
    function handleDisembarkClick(pos) {
      const gridData = currentZoneDetail.tacticalGrid[pos];
      const unit = gridData.unit;
      
      if (!gameState.selectedUnit) {
        // First click: Select Carrier with transported units
        if (unit && unit.player === gameState.currentPlayer && unit.special === 'carrier' && 
            unit.transportedUnits && unit.transportedUnits.length > 0) {
          gameState.selectedUnit = { ...unit, position: pos };
          updateSelectedUnitInfo();
          showTransportedUnitsMenu(unit, pos);
          logZoneMessage(`Selected ${unit.name}. Choose a unit to disembark.`);
        } else if (unit && unit.player === gameState.currentPlayer && unit.special === 'carrier') {
          logZoneMessage('This Carrier has no transported units');
        } else if (!unit) {
          logZoneMessage('Click on a Carrier with transported units');
        } else {
          logZoneMessage('Cannot select enemy units');
        }
      } else {
        // Second click: Select position to disembark to
        if (!unit && isAdjacentToCarrier(pos, gameState.selectedUnit.position)) {
          // Valid disembark position
          if (gameState.disembarkingUnit) {
            attemptDisembarking(gameState.selectedUnit.position, pos, gameState.disembarkingUnit);
          } else {
            logZoneMessage('Please select a unit to disembark first');
          }
        } else if (unit) {
          logZoneMessage('Cannot disembark to an occupied position');
        } else {
          logZoneMessage('Units can only disembark to adjacent empty positions');
        }
      }
    }
    
    function attemptBoarding(infantryPos, carrierPos) {
      console.log(' [BOARD DEBUG] attemptBoarding called');
      console.log(' [BOARD DEBUG] infantryPos:', infantryPos);
      console.log(' [BOARD DEBUG] carrierPos:', carrierPos);
      console.log(' [BOARD DEBUG] gameState.cpCosts:', gameState.cpCosts);
      console.log(' [BOARD DEBUG] gameState.cpCosts.embark:', gameState.cpCosts.embark);
      console.log(' [BOARD DEBUG] gameState.commandPoints:', gameState.commandPoints);
      
      // Check CP cost for boarding
      const embarkCost = gameState.cpCosts?.embark || 1; // Fallback to 1 if undefined
      console.log(' [BOARD DEBUG] Using embark cost:', embarkCost);
      if (!canSpendCP(embarkCost)) {
        console.log(' [BOARD DEBUG] CP check failed - not enough CP');
        logZoneMessage(`Not enough Command Points to embark unit (need ${embarkCost} CP)`, 'system');
        return;
      }
      
      const infantryData = currentZoneDetail.tacticalGrid[infantryPos];
      const carrierData = currentZoneDetail.tacticalGrid[carrierPos];
      
      if (!infantryData.unit || !carrierData.unit) {
        logZoneMessage('Invalid boarding attempt');
        return;
      }
      
      const infantry = infantryData.unit;
      const carrier = carrierData.unit;
      
      // Check if Infantry is adjacent to Carrier
      if (!isAdjacentToCarrier(infantryPos, carrierPos)) {
        logZoneMessage('Infantry must be adjacent to the Carrier to board');
        return;
      }
      
      // Check carrier capacity
      if (!carrier.transportedUnits) {
        carrier.transportedUnits = [];
      }
      
      if (carrier.transportedUnits.length >= 2) {
        logZoneMessage('Carrier is at full capacity (2/2 units)');
        return;
      }
      
      // Board the infantry
      carrier.transportedUnits.push({
        ...infantry,
        originalPosition: infantryPos
      });
      
      // Remove infantry from grid
      infantryData.unit = null;
      
      // Spend CP for boarding
      spendCP(embarkCost);
      
      // Clear selection
      gameState.selectedUnit = null;
      updateSelectedUnitInfo();
      clearHighlights();
      generateMiniBattlefield();
      
      logZoneMessage(`${infantry.name} boarded ${carrier.name} (${carrier.transportedUnits.length}/2) (Cost: ${embarkCost} CP)`);
      console.log(' [CARRIER DEBUG] Unit boarded:', infantry.name, 'onto', carrier.name);
    }
    
    function attemptDisembarking(carrierPos, targetPos, unitToDisembark) {
      // Check CP cost for disembarking
      const disembarkCost = gameState.cpCosts?.disembark || 1; // Fallback to 1 if undefined
      if (!canSpendCP(disembarkCost)) {
        logZoneMessage(`Not enough Command Points to disembark unit (need ${disembarkCost} CP)`, 'system');
        return;
      }
      
      const carrierData = currentZoneDetail.tacticalGrid[carrierPos];
      const targetData = currentZoneDetail.tacticalGrid[targetPos];
      
      if (!carrierData.unit || targetData.unit) {
        logZoneMessage('Invalid disembarking attempt');
        return;
      }
      
      const carrier = carrierData.unit;
      
      if (!carrier.transportedUnits || carrier.transportedUnits.length === 0) {
        logZoneMessage('No units to disembark');
        return;
      }
      
      // Find and remove the unit from transported units
      const unitIndex = carrier.transportedUnits.findIndex(u => u.name === unitToDisembark.name);
      if (unitIndex === -1) {
        logZoneMessage('Unit not found in carrier');
        return;
      }
      
      const disembarkingUnit = carrier.transportedUnits.splice(unitIndex, 1)[0];
      
      // Place unit on target position
      targetData.unit = {
        ...disembarkingUnit,
        position: targetPos
      };
      
      // Spend CP for disembarking
      spendCP(disembarkCost);
      
      // Clear selection and UI
      gameState.selectedUnit = null;
      gameState.disembarkingUnit = null;
      updateSelectedUnitInfo();
      clearHighlights();
      hideTransportedUnitsMenu();
      generateMiniBattlefield();
      
      logZoneMessage(`${disembarkingUnit.name} disembarked from ${carrier.name} (${carrier.transportedUnits.length}/2) (Cost: ${disembarkCost} CP)`);
      console.log(' [CARRIER DEBUG] Unit disembarked:', disembarkingUnit.name, 'from', carrier.name);
    }

    // Gas deployment handling
    function handleGasDeploymentClick(pos) {
      const gridData = currentZoneDetail.tacticalGrid[pos];
      const unit = gridData.unit;
      
      // First click: Select a Globadier unit
      if (unit && unit.player === gameState.currentPlayer && unit.special === 'chemical_warfare') {
        gameState.selectedUnit = { ...unit, position: pos };
        
        // Get valid gas deployment positions
        const validPositions = getGasDeploymentPositions(pos, gameState.currentPlayer);
        
        // Highlight valid positions
        clearHighlights();
        validPositions.forEach(targetPos => {
          highlightPosition(targetPos, 'gas-target');
        });
        
        logZoneMessage(`${unit.name} selected for gas deployment. Choose target: front, front-left, or front-right.`);
        updateSelectedUnitInfo();
        return;
      }
      
      // Second click: Deploy gas if we have a selected Globadier
      if (gameState.selectedUnit && gameState.selectedUnit.special === 'chemical_warfare') {
        const validPositions = getGasDeploymentPositions(gameState.selectedUnit.position, gameState.currentPlayer);
        
        if (validPositions.includes(pos)) {
          // Check CP cost for gas deployment
          const gasCost = gameState.cpCosts?.gas || 2; // Default cost of 2 CP
          if (!canSpendCP(gasCost)) {
            logZoneMessage(`Not enough Command Points to deploy gas (need ${gasCost} CP)`, 'system');
            return;
          }
          
          // Deploy the gas
          deployGasCloud(pos, gameState.currentPlayer, gameState.currentZone);
          spendCP(gasCost);
          
          // Clear selection and highlights
          gameState.selectedUnit = null;
          clearHighlights();
          updateSelectedUnitInfo();
          generateMiniBattlefield();
          
          logZoneMessage(`Gas deployed! (Cost: ${gasCost} CP)`, 'combat');
        } else {
          logZoneMessage('Invalid gas deployment position. Choose front, front-left, or front-right.');
        }
        return;
      }
      
      // If clicking on non-Globadier unit
      if (unit && unit.player === gameState.currentPlayer) {
        logZoneMessage('Only Globadier units can deploy gas!');
      }
    }
    
    function isAdjacentToCarrier(pos1, pos2) {
      const gridSize = gameConfig.gridSize;
      const row1 = Math.floor(pos1 / gridSize);
      const col1 = pos1 % gridSize;
      const row2 = Math.floor(pos2 / gridSize);
      const col2 = pos2 % gridSize;
      
      const rowDiff = Math.abs(row1 - row2);
      const colDiff = Math.abs(col1 - col2);
      
      return rowDiff <= 1 && colDiff <= 1 && (rowDiff + colDiff) > 0;
    }
    
    function highlightCarrierTargets(infantryPos) {
      clearHighlights();
      const gridSize = gameConfig.gridSize;
      
      // Highlight all adjacent carriers
      const directions = [
        {row: -1, col: -1}, {row: -1, col: 0}, {row: -1, col: 1},
        {row: 0, col: -1},                     {row: 0, col: 1},
        {row: 1, col: -1},  {row: 1, col: 0},  {row: 1, col: 1}
      ];
      
      const row = Math.floor(infantryPos / gridSize);
      const col = infantryPos % gridSize;
      
      for (const dir of directions) {
        const newRow = row + dir.row;
        const newCol = col + dir.col;
        
        if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
          const pos = newRow * gridSize + newCol;
          const gridData = currentZoneDetail.tacticalGrid[pos];
          
          if (gridData.unit && gridData.unit.special === 'carrier' && 
              gridData.unit.player === gameState.currentPlayer) {
            const capacity = gridData.unit.transportedUnits ? gridData.unit.transportedUnits.length : 0;
            if (capacity < 2) {
              highlightPosition(pos, 'carrier-target');
            }
          }
        }
      }
    }
    
    function clearHighlights() {
      // Remove all highlight classes from mini-battlefield
      const cells = document.querySelectorAll('.mini-zone');
      cells.forEach(cell => {
        cell.classList.remove('selectable', 'attackable', 'carrier-target', 'disembark-target', 'gas-target');
      });
      
      // Clear Anti-Air targeting if active
      if (gameState.antiAirTargeting) {
        hideAerialTargetSelection();
      }
    }
    
    function highlightPosition(pos, className) {
      const cell = document.querySelector(`[data-position="${pos}"]`);
      if (cell) {
        cell.classList.add(className);
      }
    }
    
    // Transported Units Menu Functions
    function showTransportedUnitsMenu(carrier, carrierPos) {
      hideTransportedUnitsMenu(); // Hide any existing menu
      
      const panel = document.getElementById('transported-units-panel');
      const container = document.getElementById('transported-units-container');
      
      if (!panel || !container) return;
      
      container.innerHTML = `
        <div class="units-list">
          ${carrier.transportedUnits.map((unit, index) => `
            <div class="transported-unit-item" onclick="selectUnitForDisembark('${unit.name}', ${index})">
              <span class="unit-name">${unit.name}</span>
              <span class="unit-stats">ATK:${unit.attack} DEF:${unit.defense}</span>
            </div>
          `).join('')}
        </div>
        <div class="menu-instructions">
          Click a unit above, then click an adjacent empty cell to disembark (${carrier.transportedUnits.length}/2)
        </div>
      `;
      
      // Show the panel
      panel.style.display = 'block';
      
      // Highlight adjacent empty positions for disembarking
      highlightDisembarkPositions(carrierPos);
    }
    
    function hideTransportedUnitsMenu() {
      const panel = document.getElementById('transported-units-panel');
      if (panel) {
        panel.style.display = 'none';
      }
      gameState.disembarkingUnit = null;
    }
    
    function selectUnitForDisembark(unitName, unitIndex) {
      const carrier = gameState.selectedUnit;
      if (carrier && carrier.transportedUnits && carrier.transportedUnits[unitIndex]) {
        gameState.disembarkingUnit = carrier.transportedUnits[unitIndex];
        logZoneMessage(`Selected ${unitName} for disembarking. Click an adjacent empty position.`);
        
        // Update menu to show selection
        const items = document.querySelectorAll('.transported-unit-item');
        items.forEach((item, index) => {
          item.classList.toggle('selected', index === unitIndex);
        });
      }
    }
    
    function highlightDisembarkPositions(carrierPos) {
      const gridSize = gameConfig.gridSize;
      const directions = [
        {row: -1, col: -1}, {row: -1, col: 0}, {row: -1, col: 1},
        {row: 0, col: -1},                     {row: 0, col: 1},
        {row: 1, col: -1},  {row: 1, col: 0},  {row: 1, col: 1}
      ];
      
      const row = Math.floor(carrierPos / gridSize);
      const col = carrierPos % gridSize;
      
      for (const dir of directions) {
        const newRow = row + dir.row;
        const newCol = col + dir.col;
        
        if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
          const pos = newRow * gridSize + newCol;
          const gridData = currentZoneDetail.tacticalGrid[pos];
          
          if (!gridData.unit) {
            highlightPosition(pos, 'disembark-target');
          }
        }
      }
    }
    
    function selectUnitForAttack(pos) {
      console.log(' [UNIT SELECT DEBUG] selectUnitForAttack called with pos:', pos);
      if (!currentZoneDetail) return;
      
      const gridData = currentZoneDetail.tacticalGrid[pos];
      if (!gridData.unit || gridData.unit.player !== gameState.currentPlayer) return;
      
      console.log(' [UNIT SELECT DEBUG] Unit being selected:', gridData.unit.name, 'special:', gridData.unit.special);
      console.log(' [UNIT SELECT DEBUG] Current selected unit before:', gameState.selectedUnit?.name);
      console.log(' [UNIT SELECT DEBUG] Anti-Air targeting state before:', gameState.antiAirTargeting);
      
      // Check if this unit is already selected - if so, deselect it
      if (gameState.selectedUnit && gameState.selectedUnit.position === pos) {
        console.log(' [UNIT SELECT DEBUG] Deselecting current unit');
        // Clear Anti-Air targeting if this was an Anti-Air unit
        if (gameState.selectedUnit.special === 'air_defense') {
          console.log(' [UNIT SELECT DEBUG] Clearing Anti-Air targeting for deselection');
          hideAerialTargetSelection();
        }
        
        gameState.selectedUnit = null;
        updateSelectablePositions();
        updateSelectedUnitInfo();
        logZoneMessage(`${gridData.unit.name} deselected`);
        return;
      }
      
      // Check if unit has already attacked this turn
      if (gameState.unitActions[gridData.unit.id]?.hasAttacked) {
        logZoneMessage(`${gridData.unit.name} has already attacked this turn`);
        return;
      }
      
      gameState.selectedUnit = {
        ...gridData.unit,
        position: pos
      };
      
      console.log(' [UNIT SELECT DEBUG] New selected unit:', gameState.selectedUnit.name, 'special:', gameState.selectedUnit.special);
      
      // If this is an Anti-Air unit, automatically show aerial targeting
      if (gridData.unit.special === 'air_defense') {
        console.log(' [UNIT SELECT DEBUG] Showing Anti-Air targeting');
        showAerialTargetSelection();
        logZoneMessage(`${gridData.unit.name} selected for air defense - click on enemy aerial units to attack them`);
      } else {
        console.log(' [UNIT SELECT DEBUG] Showing normal targeting');
        updateSelectablePositions();
        logZoneMessage(`${gridData.unit.name} selected for attack`);
      }
      
      updateSelectedUnitInfo();
    }
    
    function canAttackPosition(fromPos, toPos) {
      if (!currentZoneDetail) return false;
      
      const gridSize = gameConfig.gridSize;
      const fromGridData = currentZoneDetail.tacticalGrid[fromPos];
      const toGridData = currentZoneDetail.tacticalGrid[toPos];
      
      if (!toGridData.unit || toGridData.unit.player === gameState.currentPlayer) return false;
      
      console.log(` [CAN ATTACK DEBUG] Checking attack from ${fromPos} to ${toPos}`);
      console.log(` [CAN ATTACK DEBUG] Attacker: ${fromGridData.unit.name} (${fromGridData.unit.special})`);
      console.log(` [CAN ATTACK DEBUG] Target: ${toGridData.unit.name} (${toGridData.unit.type})`);
      
      const unit = fromGridData.unit;
      const fromRow = Math.floor(fromPos / gridSize);
      const fromCol = fromPos % gridSize;
      const toRow = Math.floor(toPos / gridSize);
      const toCol = toPos % gridSize;
      
      const rowDiff = Math.abs(fromRow - toRow);
      const colDiff = Math.abs(fromCol - toCol);
      const distance = Math.max(rowDiff, colDiff);
      
      // Get actual range including bonuses
      const combatValues = getActualCombatValues(unit, fromPos, fromGridData, toPos, toGridData);
      const actualRange = combatValues.actualRange;
      
      // Check range
      if (distance > actualRange) return false;
      
      // Check line of sight
      if (actualRange > 1 && !hasLineOfSight(fromPos, toPos)) {
        const fromTerrain = fromGridData.terrain;
        const hasSnipersNest = fromGridData.construction && fromGridData.construction.completed && 
                              fromGridData.construction.type === 'snipersNest' && 
                              unit.type === 'infantry';
        
        // Field Guns can fire over other units (artillery-style)
        if (unit.type === 'field_gun') {
          console.log(` [FIELD GUN DEBUG] ${unit.name} can fire over other units - line of sight bypassed`);
        } else if (fromTerrain !== 'hills' && fromTerrain !== 'mountains' && !hasSnipersNest) {
          return false;
        }
      }
      
      // Check Air Defense restriction
      if (unit.special === 'air_defense') {
        const targetType = toGridData.unit.type;
        console.log(` [AIR DEFENSE DEBUG] ${unit.name} (${unit.special}) checking target ${toGridData.unit.name} (${targetType})`);
        if (targetType !== 'fighter' && targetType !== 'bomber') {
          console.log(` [AIR DEFENSE] ${unit.name} can only attack air units, but target is ${targetType} - ATTACK BLOCKED`);
          return false;
        } else {
          console.log(` [AIR DEFENSE] ${unit.name} can attack air unit ${toGridData.unit.name} - ATTACK ALLOWED`);
        }
      }
      
      console.log(` [CAN ATTACK DEBUG] Attack from ${fromPos} to ${toPos} is ALLOWED`);
      return true;
    }
    
    function hasLineOfSight(fromPos, toPos) {
      if (!currentZoneDetail) return false;
      
      const gridSize = gameConfig.gridSize;
      const fromRow = Math.floor(fromPos / gridSize);
      const fromCol = fromPos % gridSize;
      const toRow = Math.floor(toPos / gridSize);
      const toCol = toPos % gridSize;
      
      // For simplicity, only block if unit is directly in line
      if (fromRow === toRow) {
        const minCol = Math.min(fromCol, toCol);
        const maxCol = Math.max(fromCol, toCol);
        for (let col = minCol + 1; col < maxCol; col++) {
          const checkPos = fromRow * gridSize + col;
          if (currentZoneDetail.tacticalGrid[checkPos].unit) return false;
        }
      } else if (fromCol === toCol) {
        const minRow = Math.min(fromRow, toRow);
        const maxRow = Math.max(fromRow, toRow);
        for (let row = minRow + 1; row < maxRow; row++) {
          const checkPos = row * gridSize + fromCol;
          if (currentZoneDetail.tacticalGrid[checkPos].unit) return false;
        }
      }
      
      return true;
    }
    
    // Process combat results (extracted for reuse with evasion)
    function processCombatResult(attacker, defender, fromPos, toPos, attackerAbilities, attackTotal, defenseTotal, attackRoll, defenseRoll) {
      const attackMod = attackerAbilities.attackBonus || 0; // Approximate, for display
      const defenseMod = 0; // Approximate, for display
      
      if (attackTotal > defenseTotal) {
        let damage = attackTotal - defenseTotal;
        
        // Apply damage bonus from special abilities (like Armour Penetrating Round)
        if (attackerAbilities.damageBonus) {
          damage += attackerAbilities.damageBonus;
          console.log(` [DAMAGE BONUS] ${attacker.name} gets +${attackerAbilities.damageBonus} damage bonus, total damage: ${damage}`);
        }
        
        console.log(` [COMBAT DEBUG] ${attacker.name} deals ${damage} damage to ${defender.name}`);
        
                    // Capture defender's MAXIMUM armor for salvage systems (not current armor)
            const defenderMaxArmor = defender.maxArmour || 0;
            const defenderCurrentArmor = defender.armour || 0;
            console.log(` [SALVAGE DEBUG] ${defender.name} has ${defenderCurrentArmor}/${defenderMaxArmor} armor (salvage will be based on max armor)`);
        
        applyDamage(defender, damage, toPos);
        logZoneMessage(`${defender.name} takes ${damage} damage!`, 'combat');
        
        // Process special ability effects on successful attack
        if (attackerAbilities.causesBleeding) {
          defender.bleeding = true;
          defender.bleedingTurns = 2;
          logZoneMessage(`${defender.name} is bleeding! Will take 1 damage over 2 turns.`, 'combat');
        }
        
        if (attackerAbilities.causesSuppression) {
          defender.suppressed = true;
          defender.suppressionTurns = 1;
          logZoneMessage(`${defender.name} is suppressed! -1 Movement & -1 Attack for 1 turn.`, 'combat');
        }
        
        if (attackerAbilities.causesMoraleCollapse) {
          // Apply morale collapse to adjacent units
          const adjacentPositions = getAdjacentPositions(toPos);
          adjacentPositions.forEach(adjPos => {
            const adjUnit = currentZoneDetail.tacticalGrid[adjPos].unit;
            if (adjUnit && adjUnit.player !== attacker.player) {
              adjUnit.moraleCollapse = true;
              logZoneMessage(`${adjUnit.name} suffers morale collapse from nearby bombing!`, 'combat');
            }
          });
        }
        
        // Salvage Systems: +2 Armor when attacking units with armor
        console.log(` [SALVAGE DEBUG] Checking salvage: attacker.special=${attacker.special}, defender.maxArmour=${defender.maxArmour}`);
        if (attacker.special === 'life_steal' && defender.maxArmour > 0) {
          const armorGain = 2;
          const currentArmor = attacker.armour || 0;
          const maxArmor = attacker.maxArmour || 0;
          const actualGain = Math.min(armorGain, maxArmor - currentArmor);
          
          if (actualGain > 0) {
            attacker.armour = currentArmor + actualGain;
            logZoneMessage(`${attacker.name} gains +${actualGain} armor from attacking armored unit! (${currentArmor}  ${attacker.armour}/${maxArmor})`, 'combat');
            console.log(` [SALVAGE] ${attacker.name} gained ${actualGain} armor from attacking ${defender.name} (armored unit)`);
          } else {
            logZoneMessage(`${attacker.name} cannot gain more armor - already at maximum (${currentArmor}/${maxArmor})`, 'combat');
            console.log(` [SALVAGE] ${attacker.name} at max armor, cannot gain from attacking ${defender.name}`);
          }
        }
        
        // Track kills (simplified)
        if (defender.health <= 0) {
          attacker.killsThisTurn = (attacker.killsThisTurn || 0) + 1;
          console.log(` [COMBAT DEBUG] ${defender.name} was destroyed by ${attacker.name}`);
        }
        
        if (defender.health <= 0) {
          console.log(` [MORALE DEBUG] ${defender.name} health reached 0, performing morale check for survival`);
          // Unit is about to be destroyed - check morale for survival
          performMoraleCheckForSurvival(defender, toPos);
        } else {
          console.log(` [MORALE DEBUG] ${defender.name} survived damage (health: ${defender.health}, armour: ${defender.armour}), no morale check needed`);
        }
      } else {
        logZoneMessage('Attack failed!');
      }
      
      gameState.selectedUnit = null;
      updateSelectedUnitInfo();
      generateMiniBattlefield();
      
      console.log(` [PLACE UNIT DEBUG] Unit placement completed successfully`);
      
      // Send update to other players in multiplayer (only if not updating from server)
      if (isMultiplayerMode && !isUpdatingFromServer) {
        sendZoneBattleUpdate();
      }
    }
    
    function attackPosition(fromPos, toPos) {
      if (!currentZoneDetail) return;
      
      // Check CP cost for attacking
      if (!canSpendCP(gameState.cpCosts.attack)) {
        logZoneMessage(`Not enough Command Points to attack (need ${gameState.cpCosts.attack} CP)`, 'system');
        return;
      }
      
      const attacker = currentZoneDetail.tacticalGrid[fromPos].unit;
      const defender = currentZoneDetail.tacticalGrid[toPos].unit;
      
      // Check Air Defense restriction
      if (attacker.special === 'air_defense') {
        if (defender.type !== 'air') {
          logZoneMessage(`${attacker.name} can only attack air units!`, 'system');
          return;
        }
      }
      
      // Spend CP for attacking
      spendCP(gameState.cpCosts.attack);
      
      // Mark unit as having attacked
      gameState.unitActions[attacker.id].hasAttacked = true;
      
      // Update target history for Precision ability
      if (attacker.special === 'precision') {
        if (!attacker.targetHistory) {
          attacker.targetHistory = {};
        }
        
        // Reset all other target counts and increment current target
        Object.keys(attacker.targetHistory).forEach(pos => {
          if (pos !== toPos.toString()) {
            delete attacker.targetHistory[pos];
          }
        });
        
        attacker.targetHistory[toPos.toString()] = (attacker.targetHistory[toPos.toString()] || 0) + 1;
        
        const consecutiveAttacks = attacker.targetHistory[toPos.toString()];
        if (consecutiveAttacks >= 2) {
          const bonus = Math.min(consecutiveAttacks - 1, 3);
          logZoneMessage(`${attacker.name} gains +${bonus} accuracy from Precision (${consecutiveAttacks} consecutive attacks on same target)!`, 'combat');
        }
      }
      
      // Permanently unhide stealth units when they attack
      if (attacker.special === 'stealth') {
        attacker.permanentlyUnhidden = true;
        logZoneMessage(`${attacker.name} is revealed after attacking!`, 'combat');
      }
      
      // Get actual combat values with all modifiers (terrain, construction, special abilities, status effects)
      const attackerGridData = currentZoneDetail.tacticalGrid[fromPos];
      const defenderGridData = currentZoneDetail.tacticalGrid[toPos];
      
      const attackerCombatValues = getActualCombatValues(attacker, fromPos, attackerGridData, toPos, defenderGridData);
      const defenderCombatValues = getActualCombatValues(defender, toPos, defenderGridData, fromPos, attackerGridData, attacker);
      
      // Calculate final modifiers using actual combat values
      let attackMod = attackerCombatValues.actualAttack;
      let defenseMod = defenderCombatValues.actualDefense;
      
      // Log construction bonuses if they exist
      if (attackerGridData.construction && attackerGridData.construction.completed) {
        const constructionData = constructionOptions[attackerGridData.construction.type];
        if (constructionData && constructionData.effects) {
          if (constructionData.effects.attack) {
            logZoneMessage(`${attacker.name} gains +${constructionData.effects.attack} attack from ${constructionData.name}!`, 'combat');
          }
          if (constructionData.effects.defense) {
            logZoneMessage(`${attacker.name} gains +${constructionData.effects.defense} defense from ${constructionData.name}!`, 'combat');
          }
        }
      }
      
      if (defenderGridData.construction && defenderGridData.construction.completed) {
        const constructionData = constructionOptions[defenderGridData.construction.type];
        if (constructionData && constructionData.effects) {
          if (constructionData.effects.attack) {
            logZoneMessage(`${defender.name} gains +${constructionData.effects.attack} attack from ${constructionData.name}!`, 'combat');
          }
          if (constructionData.effects.defense) {
            logZoneMessage(`${defender.name} gains +${constructionData.effects.defense} defense from ${constructionData.name}!`, 'combat');
          }
        }
      }
      
      // Get attacker special abilities for combat effects (pass target info for abilities like Charge)
      const attackerAbilities = applySpecialAbilities(attacker, fromPos, attackerGridData, toPos, defenderGridData);
      
      // Show normal dice animation
      showDiceAnimation(
        attacker.name,
        defender.name,
        attackMod,
        defenseMod,
        (attackTotal, defenseTotal, attackRoll, defenseRoll) => {
          // Process combat results after animation
          logZoneMessage(`${attacker.name} attacks ${defender.name}: ${attackRoll}+${attackMod} vs ${defenseRoll}+${defenseMod}`, 'combat');
          processCombatResult(attacker, defender, fromPos, toPos, attackerAbilities, attackTotal, defenseTotal, attackRoll, defenseRoll);
        }
      );
    }
    
    function getTerrainDefenseBonus(pos) {
      if (!currentZoneDetail) return 0;
      
      const gridData = currentZoneDetail.tacticalGrid[pos];
      return terrainEffects[gridData.terrain].defenseBonus;
    }
    
    // Apply damage to a unit, handling armour absorption
    function applyDamage(unit, damage, pos = null) {
      console.log(` [ARMOUR DEBUG] Starting damage application to ${unit.name}`);
      console.log(` [ARMOUR DEBUG] Initial state - HP: ${unit.health}/${unit.maxHealth}, Armour: ${unit.armour}/${unit.maxArmour || unit.armour || 0}`);
      console.log(` [ARMOUR DEBUG] Incoming damage: ${damage}`);
      
      if (damage <= 0) return false; // No damage to apply
      
      // Evasion is now handled before combat starts, not here
      
      let remainingDamage = damage;
      let damageLog = [];
      
      // If unit has armour, armour absorbs damage first
      if (unit.armour && unit.armour > 0) {
        console.log(` [ARMOUR DEBUG] Unit has armour: ${unit.armour}`);
        const armourDamage = Math.min(remainingDamage, unit.armour);
        console.log(` [ARMOUR DEBUG] Armour will absorb: ${armourDamage} damage`);
        
        unit.armour -= armourDamage;
        remainingDamage -= armourDamage;
        damageLog.push(`Armour absorbed ${armourDamage} damage`);
        
        console.log(` [ARMOUR DEBUG] After armour absorption - Armour: ${unit.armour}, Remaining damage: ${remainingDamage}`);
        
        if (unit.armour < 0) unit.armour = 0; // Prevent negative armour
      } else {
        console.log(` [ARMOUR DEBUG] Unit has no armour or armour is 0`);
      }
      
      // Apply remaining damage to health
      if (remainingDamage > 0) {
        console.log(` [ARMOUR DEBUG] Applying ${remainingDamage} damage to health`);
        const healthBefore = unit.health;
        unit.health -= remainingDamage;
        damageLog.push(`${remainingDamage} damage to health`);
        console.log(` [ARMOUR DEBUG] Health changed from ${healthBefore} to ${unit.health}`);
        
        if (unit.health < 0) unit.health = 0; // Prevent negative health
      }
      
      // Log damage details if significant
      if (damage > 0 && damageLog.length > 0) {
        console.log(` [DAMAGE] ${unit.name} took ${damage} total damage: ${damageLog.join(', ')}`);
      }
      
      console.log(` [ARMOUR DEBUG] Final state - HP: ${unit.health}/${unit.maxHealth}, Armour: ${unit.armour}/${unit.maxArmour || unit.armour || 0}`);
      
      // Check if unit should be eliminated
      if (unit.health <= 0) {
        if (pos !== null) {
          eliminateUnit(unit, pos);
        }
        return { unitDestroyed: true, healthLost: remainingDamage > 0 }; // Unit was destroyed
      }
      
      return { unitDestroyed: false, healthLost: remainingDamage > 0 }; // Unit survived, return if health was actually lost
    }
    
    function eliminateUnit(unit, pos) {
      // Handle Carrier destruction - transported units die instantly
      if (unit.special === 'carrier' && unit.transportedUnits && unit.transportedUnits.length > 0) {
        const transportedCount = unit.transportedUnits.length;
        const transportedNames = unit.transportedUnits.map(u => u.name).join(', ');
        
        // Track losses for all transported units
        unit.transportedUnits.forEach(transportedUnit => {
          trackUnitLoss(transportedUnit);
          console.log(' [CARRIER DEBUG] Transported unit eliminated:', transportedUnit.name);
        });
        
        logZoneMessage(`${unit.name} destroyed! ${transportedCount} transported unit(s) (${transportedNames}) die instantly!`, 'system');
        console.log(' [CARRIER DEBUG] Carrier destroyed with', transportedCount, 'transported units');
      }
      
      // Track the carrier's own loss
      trackUnitLoss(unit);
      
      // Remove unit from grid
      currentZoneDetail.tacticalGrid[pos].unit = null;
    }
    
    function performMoraleCheckForSurvival(unit, pos) {
      // Show morale animation for survival check
      showMoraleAnimation(
        unit,
        unit.morale,
        (success, roll, target) => {
          logZoneMessage(`${unit.name} survival morale check: rolled ${roll}, needed ${target}+`, 'morale');
          
          if (success) {
            // Unit survives with full HP and retreats
            unit.health = unit.maxHealth; // Restore full HP
            logZoneMessage(`${unit.name} survives with full HP!`, 'morale');
            
            // Find retreat position based on role (attacker moves up, defender moves down)
            const retreatPos = findSurvivalRetreatPosition(pos, unit.player);
            if (retreatPos !== -1) {
              currentZoneDetail.tacticalGrid[retreatPos].unit = unit;
              currentZoneDetail.tacticalGrid[pos].unit = null;
              unit.position = retreatPos;
              logZoneMessage(`${unit.name} retreats to position ${retreatPos + 1}!`, 'morale');
            } else {
              // No retreat position - unit is eliminated
              eliminateUnit(unit, pos);
              logZoneMessage(`${unit.name} has nowhere to retreat and is eliminated!`, 'morale');
            }
            
            // Send update to other players in multiplayer
            if (isMultiplayerMode) {
              sendZoneBattleUpdate();
            }
          } else {
            // Unit fails morale check and is eliminated
            eliminateUnit(unit, pos);
            logZoneMessage(`${unit.name} fails morale check and is eliminated!`, 'morale');
          }
          
          // Send update to other players in multiplayer
          if (isMultiplayerMode) {
            sendZoneBattleUpdate();
          }
          
          generateMiniBattlefield();
        }
      );
    }
    
    function performMoraleCheck(unit, pos) {
      // Show morale animation
      showMoraleAnimation(
        unit,
        unit.morale,
        (success, roll, target) => {
          logZoneMessage(`${unit.name} morale check: rolled ${roll}, needed ${target}+`, 'morale');
          
          if (!success) {
            // Unit retreats
            const retreatPos = findRetreatPosition(pos, unit.player);
            if (retreatPos !== -1 && retreatPos !== pos) {
              // Valid retreat position found and it's not the same position
              currentZoneDetail.tacticalGrid[retreatPos].unit = unit;
              currentZoneDetail.tacticalGrid[pos].unit = null;
              unit.position = retreatPos;
              logZoneMessage(`${unit.name} retreats to position ${retreatPos + 1}!`, 'morale');
            } else {
              // No valid retreat position - unit dies instead of retreating to top-left
              currentZoneDetail.tacticalGrid[pos].unit = null;
              logZoneMessage(`${unit.name} is eliminated due to failed morale check!`, 'morale');
              
              // Track unit loss for summary
              trackUnitLoss(unit);
            }
            generateMiniBattlefield();
            
            // Send update to other players in multiplayer (only if not updating from server)
            if (isMultiplayerMode && !isUpdatingFromServer) {
              sendZoneBattleUpdate();
            }
          } else {
            logZoneMessage(`${unit.name} maintains morale!`, 'morale');
            
            // Send update to other players in multiplayer (only if not updating from server)
            if (isMultiplayerMode && !isUpdatingFromServer) {
              sendZoneBattleUpdate();
            }
          }
        }
      );
    }
    
    function findSurvivalRetreatPosition(pos, player) {
      if (!currentZoneDetail) return -1;
      
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      
      // Determine retreat direction based on role
      // Get the zone role to determine if this player is attacker or defender
      const zoneRole = gameState.zoneRoles[gameState.currentZone];
      const isAttacker = zoneRole && zoneRole.attacker === player;
      const isDefender = zoneRole && zoneRole.defender === player;
      
      let targetRow;
      if (isAttacker) {
        // Attacker moves up (towards enemy side)
        targetRow = row - 1;
      } else if (isDefender) {
        // Defender moves down (towards own side)
        targetRow = row + 1;
      } else {
        // Fallback: move towards own side based on player color
        targetRow = player === 'red' ? row + 1 : row - 1;
      }
      
      // Check positions in target row - prioritize straight up/down movement
      if (targetRow >= 0 && targetRow < gridSize) {
        // First try the same column (straight up/down)
        const straightPos = targetRow * gridSize + col;
        if (!currentZoneDetail.tacticalGrid[straightPos].unit) {
          return straightPos;
        }
        
        // If straight movement is blocked, try adjacent columns (diagonal)
        for (let checkCol = Math.max(0, col - 1); checkCol <= Math.min(gridSize - 1, col + 1); checkCol++) {
          if (checkCol === col) continue; // Skip the straight position we already checked
          const checkPos = targetRow * gridSize + checkCol;
          if (!currentZoneDetail.tacticalGrid[checkPos].unit) {
            return checkPos;
          }
        }
      }
      
      // If no retreat position found in target row, try same row
      for (let checkCol = 0; checkCol < gridSize; checkCol++) {
        const checkPos = row * gridSize + checkCol;
        if (checkPos !== pos && !currentZoneDetail.tacticalGrid[checkPos].unit) {
          return checkPos;
        }
      }
      
      return -1; // No retreat position found
    }
    
    function findRetreatPosition(pos, player) {
      if (!currentZoneDetail) return -1;
      
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      
      // Try to retreat towards own side
      const targetRow = player === 'red' ? row + 1 : row - 1;
      
      // Check positions in target row - prioritize straight up/down movement
      if (targetRow >= 0 && targetRow < gridSize) {
        // First try the same column (straight up/down)
        const straightPos = targetRow * gridSize + col;
        if (!currentZoneDetail.tacticalGrid[straightPos].unit) {
          return straightPos;
        }
        
        // If straight movement is blocked, try adjacent columns (diagonal)
        for (let checkCol = Math.max(0, col - 1); checkCol <= Math.min(gridSize - 1, col + 1); checkCol++) {
          if (checkCol === col) continue; // Skip the straight position we already checked
          const checkPos = targetRow * gridSize + checkCol;
          if (!currentZoneDetail.tacticalGrid[checkPos].unit) {
            return checkPos;
          }
        }
      }
      
      // If no retreat position found in target row, try same row but only if it's a meaningful retreat
      // Don't retreat to the same row if we're already at the edge
      const isAtEdge = (player === 'red' && row === gridSize - 1) || (player === 'blue' && row === 0);
      if (!isAtEdge) {
        for (let checkCol = 0; checkCol < gridSize; checkCol++) {
          const checkPos = row * gridSize + checkCol;
          if (checkPos !== pos && !currentZoneDetail.tacticalGrid[checkPos].unit) {
            return checkPos;
          }
        }
      }
      
      return -1; // No retreat position found - unit should die
    }
    
    function updateSelectablePositions() {
      console.log(' [TOOLTIP DEBUG] updateSelectablePositions called');
      console.log(' [TOOLTIP DEBUG] Tooltip state before updateSelectablePositions:');
      if (tooltipElement) {
        console.log(' [TOOLTIP DEBUG] - Display:', tooltipElement.style.display);
        console.log(' [TOOLTIP DEBUG] - Classes:', tooltipElement.className);
        console.log(' [TOOLTIP DEBUG] - Has show class:', tooltipElement.classList.contains('show'));
      }
      
      // Update both mini-battlefield and main battlefield positions
      const allPositions = document.querySelectorAll('.mini-zone, [data-position]');
      console.log(` [UPDATE DEBUG] Found ${allPositions.length} positions to update`);
      
      allPositions.forEach(pos => {
        pos.classList.remove('selectable', 'deployment-zone', 'attacker-zone', 'defender-zone', 'movement-zone', 'air-defense-target');
        
        const posIndex = parseInt(pos.dataset.position);
        if (isNaN(posIndex)) {
          console.log(` [UPDATE DEBUG] Position ${pos.dataset.position} has invalid index`);
          return;
        }
        
        if (gameState.deploymentMode === 'place') {
          // Show valid deployment positions
          if (isValidDeploymentPosition(posIndex) && !currentZoneDetail.tacticalGrid[posIndex].unit) {
            const zoneRole = gameState.zoneRoles[gameState.currentZone];
            const isDefender = zoneRole && zoneRole.defender === gameState.currentPlayer;
            
            if (isDefender) {
              pos.classList.add('defender-zone', 'deployment-zone');
              console.log(` [COLOR DEBUG] Added defender-zone and deployment-zone classes to position ${posIndex}`);
              // Set current player's color for defender zones
              const currentPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player1.color : gameConfig.player2.color;
              pos.style.borderColor = currentPlayerColor;
            } else {
              pos.classList.add('attacker-zone', 'deployment-zone');
              console.log(` [COLOR DEBUG] Added attacker-zone and deployment-zone classes to position ${posIndex}`);
              // Set current player's color for attacker zones
              const currentPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player1.color : gameConfig.player2.color;
              pos.style.borderColor = currentPlayerColor;
            }
          }
        } else if (gameState.deploymentMode === 'move') {
          // Highlight valid movement positions
          if (gameState.movementMode.validPositions.includes(posIndex)) {
            pos.classList.add('movement-zone');
          }
        } else if (gameState.selectedUnit) {
          console.log(` [UPDATE DEBUG] Selected unit: ${gameState.selectedUnit.name}, special: ${gameState.selectedUnit.special}`);
          
          // Skip tactical grid highlighting for Anti-Air units since they target aerial units
          if (gameState.selectedUnit.special === 'air_defense') {
            console.log(` [AIR DEFENSE DEBUG] Anti-Air unit selected - aerial targeting handled separately`);
            return;
          }
          
          if (gameState.deploymentMode === 'attack' && canAttackPosition(gameState.selectedUnit.position, posIndex)) {
            pos.classList.add('selectable');
            console.log(` [UPDATE DEBUG] Position ${posIndex} is selectable for attack`);
          } else if (gameState.deploymentMode === 'attack') {
            console.log(` [UPDATE DEBUG] Position ${posIndex} cannot be attacked: canAttackPosition returned false`);
          }
        }
      });
      
      // Update player color CSS after highlighting zones
      console.log(' [COLOR DEBUG] updateSelectablePositions - About to call updatePlayerColorCSS');
      updatePlayerColorCSS();
      console.log(' [COLOR DEBUG] updateSelectablePositions - updatePlayerColorCSS called');
    }
    
    function setDeploymentMode(mode) {
      console.log(' [BOARD DEBUG] setDeploymentMode called with mode:', mode);
      gameState.deploymentMode = mode;
      console.log(' [BOARD DEBUG] gameState.deploymentMode set to:', gameState.deploymentMode);
      gameState.selectedUnit = null;
      gameState.disembarkingUnit = null;
      updateSelectedUnitInfo();
      setDeploymentModeUI(mode);
      
      // Reset movement mode when switching away from move
      if (mode !== 'move') {
        resetMovementMode();
      }
      
      // Hide carrier menus when switching modes
      if (mode !== 'disembark') {
        hideTransportedUnitsMenu();
      }
      
      // Clear highlights when switching modes
      clearHighlights();
      
      // Clear Anti-Air targeting when switching modes
      if (gameState.antiAirTargeting) {
        hideAerialTargetSelection();
      }
      
      updateSelectablePositions();
      
      // Ensure Intelligence Report panel remains visible when switching modes (preserve original styling)
      const chatPanel = document.querySelector('.chat-panel');
      if (chatPanel) {
        // Only set display if it's currently hidden, otherwise preserve original styling
        if (chatPanel.style.display === 'none') {
          chatPanel.style.display = 'block';
          console.log(' [INTELLIGENCE DEBUG] Ensured Intelligence Report panel is visible when switching to', mode, 'mode');
        } else {
          console.log(' [INTELLIGENCE DEBUG] Intelligence Report panel already visible when switching to', mode, 'mode, preserving styling');
        }
        
        // Ensure scrollbar styling is preserved
        const chatMessages = chatPanel.querySelector('.chat-messages');
        if (chatMessages && chatMessages.style.overflowY === '') {
          chatMessages.style.overflowY = 'auto';
          console.log(' [INTELLIGENCE DEBUG] Restored chat-messages overflow-y styling when switching modes');
        }
      }
      
      // Mode-specific messages
      const modeMessages = {
        'place': 'Deploy mode: Select a unit from the army pool, then click on the battlefield to deploy',
        'attack': 'Assault mode: Select a unit, then click on an enemy to attack',
        'move': 'Advance mode: Select a unit, then click where to move',
        'board': 'Board mode: Select an Infantry unit, then click on an adjacent Carrier to board',
        'disembark': 'Disembark mode: Select a Carrier with transported units, then choose where to disembark',
        'gas': 'Deploy Gas mode: Select a Globadier unit, then choose a target tile (front, front-left, or front-right)'
      };
      
      logZoneMessage(modeMessages[mode] || `Switched to ${mode} mode`);
    }
    
    function setDeploymentModeUI(mode) {
      // Remove active class from all deployment control buttons
      const deploymentButtons = document.querySelectorAll('#deployment-controls .action-button');
      deploymentButtons.forEach(btn => btn.classList.remove('active'));
      
      // Add active class to the correct button by mode
      const primaryButtons = document.querySelectorAll('#deployment-controls .primary-controls .action-button');
      const carrierButtons = document.querySelectorAll('#deployment-controls .carrier-controls .action-button');
      
      switch(mode) {
        case 'place':
          if (primaryButtons[0]) primaryButtons[0].classList.add('active');
          break;
        case 'attack':
          if (primaryButtons[1]) primaryButtons[1].classList.add('active');
          break;
        case 'move':
          if (primaryButtons[2]) primaryButtons[2].classList.add('active');
          break;
        case 'board':
          if (carrierButtons[0]) carrierButtons[0].classList.add('active');
          break;
        case 'disembark':
          if (carrierButtons[1]) carrierButtons[1].classList.add('active');
          break;
        case 'gas':
          if (carrierButtons[2]) carrierButtons[2].classList.add('active');
          break;
      }
    }
    
    function updateSelectedUnitInfo() {
      console.log(' [TOOLTIP DEBUG] updateSelectedUnitInfo called');
      const infoDiv = document.getElementById('selected-unit-info');
      const nameSpan = document.getElementById('selected-unit-name');
      
      if (!infoDiv) return;
      
      // Preserve tooltip state if it's currently showing
      const tooltipWasVisible = tooltipElement && tooltipElement.classList.contains('show');
      console.log(' [TOOLTIP DEBUG] Tooltip was visible before update:', tooltipWasVisible);
      console.log(' [TOOLTIP DEBUG] Tooltip element exists:', !!tooltipElement);
      if (tooltipElement) {
        console.log(' [TOOLTIP DEBUG] Tooltip display style:', tooltipElement.style.display);
        console.log(' [TOOLTIP DEBUG] Tooltip classes:', tooltipElement.className);
      }
      
      // Preserve Intelligence Report panel visibility (but don't interfere with its styling)
      const chatPanel = document.querySelector('.chat-panel');
      const chatPanelWasVisible = chatPanel && chatPanel.style.display !== 'none';
      
      // DEBUG: Log Intelligence Report panel state
      console.log(' [INTELLIGENCE DEBUG] updateSelectedUnitInfo - Panel state:');
      console.log(' [INTELLIGENCE DEBUG] - chatPanel found:', !!chatPanel);
      console.log(' [INTELLIGENCE DEBUG] - chatPanelWasVisible:', chatPanelWasVisible);
      if (chatPanel) {
        console.log(' [INTELLIGENCE DEBUG] - chatPanel.style.display:', chatPanel.style.display);
        console.log(' [INTELLIGENCE DEBUG] - chatPanel.className:', chatPanel.className);
        console.log(' [INTELLIGENCE DEBUG] - chatPanel.innerHTML length:', chatPanel.innerHTML.length);
        console.log(' [INTELLIGENCE DEBUG] - chatPanel.children.length:', chatPanel.children.length);
        
        // Check for chat-messages element specifically
        const chatMessages = chatPanel.querySelector('.chat-messages');
        console.log(' [INTELLIGENCE DEBUG] - chat-messages found:', !!chatMessages);
        if (chatMessages) {
          console.log(' [INTELLIGENCE DEBUG] - chat-messages.style.overflowY:', chatMessages.style.overflowY);
          console.log(' [INTELLIGENCE DEBUG] - chat-messages.scrollHeight:', chatMessages.scrollHeight);
          console.log(' [INTELLIGENCE DEBUG] - chat-messages.clientHeight:', chatMessages.clientHeight);
        }
      }
      
      if (gameState.selectedUnit) {
        infoDiv.style.display = 'block';
        if (nameSpan) nameSpan.textContent = gameState.selectedUnit.name;
        
        if (gameState.deploymentMode === 'place') {
          const validRows = getValidDeploymentRows();
          const rowText = validRows.length === 1 ? `row ${validRows[0] + 1}` : `rows ${validRows.map(r => r + 1).join(', ')}`;
          infoDiv.innerHTML = `
            <strong>Selected Unit: ${gameState.selectedUnit.name}</strong>
            <div style="font-size: 14px; margin-top: 5px;">
              Click on a highlighted position in ${rowText} to deploy
            </div>
          `;
        } else if (gameState.deploymentMode === 'attack') {
          infoDiv.innerHTML = `
            <strong>Selected Unit: ${gameState.selectedUnit.name}</strong>
            <div style="font-size: 14px; margin-top: 5px;">
              Click on a highlighted enemy unit to attack (Range: ${gameState.selectedUnit.range})
            </div>
          `;
        }
      } else {
        if (gameState.deploymentMode === 'place') {
          infoDiv.style.display = 'block';
          const validRows = getValidDeploymentRows();
          const rowText = validRows.length === 1 ? `row ${validRows[0] + 1}` : `rows ${validRows.map(r => r + 1).join(', ')}`;
          infoDiv.innerHTML = `
            <strong>No Unit Selected</strong>
            <div style="font-size: 14px; margin-top: 5px;">
              Select a unit from the army pool, then click on a highlighted position in ${rowText} to deploy
            </div>
          `;
        } else if (gameState.deploymentMode === 'move') {
          infoDiv.style.display = 'block';
          infoDiv.innerHTML = `
            <strong>Movement Mode</strong>
            <div style="font-size: 14px; margin-top: 5px;">
              Click on one of your units that hasn't moved yet to begin moving it
            </div>
          `;
        } else {
          infoDiv.style.display = 'none';
        }
      }
      
      // Restore tooltip state if it was visible before
      if (tooltipWasVisible && tooltipElement) {
        console.log(' [TOOLTIP DEBUG] Restoring tooltip visibility');
        tooltipElement.classList.add('show');
      } else {
        console.log(' [TOOLTIP DEBUG] Not restoring tooltip - wasVisible:', tooltipWasVisible, 'tooltipElement:', !!tooltipElement);
      }
      
      // Ensure Intelligence Report panel remains visible (preserve original styling)
      if (chatPanel && chatPanelWasVisible) {
        // Only set display to block if it was actually hidden, otherwise preserve original styling
        if (chatPanel.style.display === 'none') {
          chatPanel.style.display = 'block';
          console.log(' [INTELLIGENCE DEBUG] Restored Intelligence Report panel visibility');
        } else {
          console.log(' [INTELLIGENCE DEBUG] Intelligence Report panel already visible, preserving styling');
        }
        
        // Ensure scrollbar styling is preserved
        const chatMessages = chatPanel.querySelector('.chat-messages');
        if (chatMessages && chatMessages.style.overflowY === '') {
          chatMessages.style.overflowY = 'auto';
          console.log(' [INTELLIGENCE DEBUG] Restored chat-messages overflow-y styling');
        }
      }
      
      // DEBUG: Log final Intelligence Report panel state
      console.log(' [INTELLIGENCE DEBUG] updateSelectedUnitInfo - Final panel state:');
      if (chatPanel) {
        console.log(' [INTELLIGENCE DEBUG] - Final chatPanel.style.display:', chatPanel.style.display);
        console.log(' [INTELLIGENCE DEBUG] - Final chatPanel.className:', chatPanel.className);
        
        const chatMessages = chatPanel.querySelector('.chat-messages');
        if (chatMessages) {
          console.log(' [INTELLIGENCE DEBUG] - Final chat-messages.style.overflowY:', chatMessages.style.overflowY);
          console.log(' [INTELLIGENCE DEBUG] - Final chat-messages.scrollHeight:', chatMessages.scrollHeight);
          console.log(' [INTELLIGENCE DEBUG] - Final chat-messages.clientHeight:', chatMessages.clientHeight);
        }
      }
    }
    
    function loadZoneArmyPool() {
      console.log('=== LOAD ZONE ARMY POOL ===');
      const container = document.getElementById('zone-army-pool');
      if (!container) {
        console.error('Zone army pool container not found!');
        return;
      }
      
      container.innerHTML = '';
      
      // Get units from selected army
      const selectedArmyData = gameState.selectedArmyInZone[gameState.currentPlayer];
      console.log(' [DEBUG] Selected army data:', selectedArmyData);
      console.log(' [DEBUG] Current player:', gameState.currentPlayer);
      console.log(' [DEBUG] All selected armies in zone:', gameState.selectedArmyInZone);
      
      if (selectedArmyData && selectedArmyData.army) {
        console.log(' [DEBUG] Selected army details:', {
          id: selectedArmyData.army.id,
          name: selectedArmyData.army.name,
          unitsCount: selectedArmyData.army.units ? selectedArmyData.army.units.length : 0,
          units: selectedArmyData.army.units
        });
      }
      
      if (!selectedArmyData) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Please select an army first</div>';
        console.log(' [DEBUG] No army selected, showing message');
        return;
      }
      
      if (!selectedArmyData.army || !selectedArmyData.army.units) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Selected army has no units</div>';
        console.log(' [DEBUG] Selected army has no units:', selectedArmyData);
        return;
      }
      
      // Validate army data structure
      if (!Array.isArray(selectedArmyData.army.units)) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Selected army has invalid unit structure</div>';
        console.log(' [DEBUG] Selected army has invalid unit structure:', selectedArmyData.army.units);
        return;
      }
      
      // Filter out artillery and aerial units since they're handled separately
      // Note: field_gun units are now included for deployment
      const availableUnits = selectedArmyData.army.units.filter(unit => 
        unit.type !== 'artillery' && 
        unit.type !== 'fighter' && 
        unit.type !== 'bomber' &&
        unit.type !== 'airship' &&
        unit.type !== 'air' &&
        unit.type !== 'aircraft'
      );
      console.log('Available units (excluding artillery):', availableUnits);
      
      // Debug: Log all unit types in the army
      console.log(' [DEBUG] All units in army:', selectedArmyData.army.units.map(unit => ({
        name: unit.name,
        type: unit.type
      })));
      console.log(' [DEBUG] Filtered units:', availableUnits.map(unit => ({
        name: unit.name,
        type: unit.type
      })));
      
      if (availableUnits.length === 0) {
        console.log(' [DEBUG] No deployable units found in army');
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">This army contains only artillery, field guns, or aerial units which are handled separately</div>';
        return;
      }
      
      availableUnits.forEach((unit, index) => {
        console.log('Processing unit:', unit.name, 'at index:', index);
        
        // Assign deployment index to the unit for tracking
        const unitWithIndex = { ...unit, deploymentIndex: index };
        
        const unitDiv = document.createElement('div');
        
              // Re-enable deployment checking with better error handling
      let isDeployed = false;
      let deploymentInfo = null;
      
      try {
        // DEBUG: Log the unit data being passed to deployment check
        console.log(' [DEPLOYMENT DEBUG] Checking deployment for unitWithIndex:', unitWithIndex);
        console.log(' [DEPLOYMENT DEBUG] - unitWithIndex.deploymentIndex:', unitWithIndex.deploymentIndex);
        console.log(' [DEPLOYMENT DEBUG] - unitWithIndex.name:', unitWithIndex.name);
        
        isDeployed = isUnitDeployedFromArmy(unitWithIndex, selectedArmyData.army.id);
        deploymentInfo = getUnitDeploymentInfo(unitWithIndex, selectedArmyData.army.id);
        
        // DEBUG: Enhanced deployment status logging
        console.log(' [DEPLOYMENT DEBUG] Unit deployment check for:', unit.name);
        console.log(' [DEPLOYMENT DEBUG] - unitWithIndex:', unitWithIndex);
        console.log(' [DEPLOYMENT DEBUG] - armyId:', selectedArmyData.army.id);
        console.log(' [DEPLOYMENT DEBUG] - isDeployed:', isDeployed);
        console.log(' [DEPLOYMENT DEBUG] - deploymentInfo:', deploymentInfo);
        
        // Debug: Log deployment status
        if (isDeployed) {
          console.log(' [DEPLOYMENT DEBUG] Unit is deployed:', unit.name, 'in zone:', deploymentInfo?.zoneName);
        } else {
          console.log(' [DEPLOYMENT DEBUG] Unit is NOT deployed:', unit.name);
        }
      } catch (error) {
        console.warn(' [DEPLOYMENT DEBUG] Error checking deployment status for unit:', unit.name, error);
        isDeployed = false;
        deploymentInfo = null;
      }
        
        unitDiv.className = `army-unit-card ${gameState.selectedUnit?.name === unitWithIndex.name && gameState.selectedUnit?.deploymentIndex === unitWithIndex.deploymentIndex && gameState.deploymentMode === 'place' ? 'selected' : ''} ${isDeployed ? 'disabled' : ''}`;
        
        // DEBUG: Log unit card creation
        console.log(' [DEPLOYMENT DEBUG] Created unit card for:', unit.name);
        console.log(' [DEPLOYMENT DEBUG] - className:', unitDiv.className);
        console.log(' [DEPLOYMENT DEBUG] - isDeployed:', isDeployed);
        console.log(' [DEPLOYMENT DEBUG] - has disabled class:', unitDiv.className.includes('disabled'));
        unitDiv.id = `army-unit-${index}`;
        unitDiv.style.cursor = 'none';
        unitDiv.onclick = () => selectUnitForDeployment(index);
        
        // Add hover tooltip for deployed units
        if (isDeployed && deploymentInfo) {
          const zoneName = zoneNames[deploymentInfo.zoneName] || deploymentInfo.zoneName;
        unitDiv.title = `Deployed in Zone ${zoneName}`;
        }
        
        unitDiv.innerHTML = `
          <div class="army-unit-name">${unitWithIndex.name}</div>
                      <div class="army-unit-stats">
              <span class="stat attack">ATK: ${unitWithIndex.attack >= 0 ? '+' : ''}${unitWithIndex.attack}</span>
              <span class="stat defend">DEF: ${unitWithIndex.defense >= 0 ? '+' : ''}${unitWithIndex.defense}</span>
              ${unitWithIndex.armour ? `<span class="stat armour">AMR: ${unitWithIndex.armour}</span>` : ''}
              <span class="stat morale">MOR: ${unitWithIndex.morale}</span>
              <span class="stat range">RNG: ${unitWithIndex.range}</span>
              <span class="stat movement">MOV: ${unitWithIndex.movement}</span>
              ${unitWithIndex.type === 'artillery' && unitWithIndex.hitChance ? `<span class="stat hit-chance">HIT: ${unitWithIndex.hitChance}+</span>` : ''}
            </div>
          ${isDeployed ? '<div class="deployed-indicator">Deployed</div>' : ''}
        `;
        
        container.appendChild(unitDiv);
        console.log('Added unit card for:', unit.name);
      });
      
      console.log('Total unit cards created:', container.children.length);
      updateCommandPointsDisplay();
      console.log('=== END LOAD ZONE ARMY POOL ===');
    }
    
    function getAvailableUnits() {
      // Return default units including custom units
      return [...defaultUnits, ...gameData.customUnits];
    }
    
    function isUnitDeployed(unit, unitIndex) {
      // Check if this unit type has been deployed in the current zone
      return gameState.deployedUnits[gameState.currentPlayer].some(deployed => 
        deployed.deploymentIndex === unitIndex && deployed.zoneId === currentZoneDetail.id
      );
    }
    
    function isUnitDeployedFromArmy(unit, armyId) {
      console.log(' [DEPLOYMENT DEBUG] isUnitDeployedFromArmy CALLED with:', unit.name, 'armyId:', armyId);
      
      // Artillery and aerial units are never considered "deployed" since they don't go on the grid
      // Field guns can be deployed on the grid (they have movement values)
      if (unit.type === 'artillery' || unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship') {
        console.log(' [DEPLOYMENT DEBUG] Unit is artillery/fighter/bomber/airship, returning false');
        return false;
      }
      
      // Check if this specific unit instance has been deployed from this army
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      
      // If deployedUnitInstances is not initialized, return false
      if (!gameState.deployedUnitInstances) {
        console.log(' [DEPLOYMENT DEBUG] deployedUnitInstances not initialized');
        return false;
      }
      
      console.log(' [DEPLOYMENT DEBUG] deployedUnitInstances object:', gameState.deployedUnitInstances);
      console.log(' [DEPLOYMENT DEBUG] deployedUnitInstances keys:', Object.keys(gameState.deployedUnitInstances));
      console.log(' [DEPLOYMENT DEBUG] Full deployedUnitInstances object in check:', JSON.stringify(gameState.deployedUnitInstances, null, 2));
      
      // DEBUG: Log deployment check
      console.log(' [DEPLOYMENT DEBUG] Checking if unit is deployed:');
      console.log(' [DEPLOYMENT DEBUG] - unit:', unit.name, 'deploymentIndex:', unit.deploymentIndex);
      console.log(' [DEPLOYMENT DEBUG] - armyId:', armyId);
      console.log(' [DEPLOYMENT DEBUG] - playerId:', playerId);
      console.log(' [DEPLOYMENT DEBUG] - deployedUnitInstances count:', Object.keys(gameState.deployedUnitInstances).length);
      
      // Check if this specific unit instance has been deployed anywhere from this army
      for (const [instanceId, deployment] of Object.entries(gameState.deployedUnitInstances)) {
        console.log(' [DEPLOYMENT DEBUG] Checking deployment:', instanceId);
        console.log(' [DEPLOYMENT DEBUG] - deployment.armyId:', deployment.armyId, 'vs', armyId);
        console.log(' [DEPLOYMENT DEBUG] - deployment.playerId:', deployment.playerId, 'vs', playerId);
        console.log(' [DEPLOYMENT DEBUG] - deployment.unitData.name:', deployment.unitData.name, 'vs', unit.name);
        console.log(' [DEPLOYMENT DEBUG] - deployment.unitData.deploymentIndex:', deployment.unitData.deploymentIndex, 'vs', unit.deploymentIndex);
        console.log(' [DEPLOYMENT DEBUG] - deployment.unitData.deploymentIndex type:', typeof deployment.unitData.deploymentIndex);
        console.log(' [DEPLOYMENT DEBUG] - unit.deploymentIndex type:', typeof unit.deploymentIndex);
        
        // Convert both deploymentIndex values to numbers for comparison to avoid type mismatch issues
        const deploymentIndex1 = Number(deployment.unitData.deploymentIndex);
        const deploymentIndex2 = Number(unit.deploymentIndex);
        
        if (deployment.armyId === armyId && 
            deployment.playerId === playerId && 
            deployment.unitData.name === unit.name &&
            deploymentIndex1 === deploymentIndex2) {
          console.log(' [DEPLOYMENT DEBUG] Unit IS deployed - match found!');
          return true;
        }
      }
      
      console.log(' [DEPLOYMENT DEBUG] Unit is NOT deployed - no match found');
      return false;
    }
    
    function getUnitDeploymentInfo(unit, armyId) {
      // Get information about where this unit is deployed
      const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      
      // If deployedUnitInstances is not initialized, return null
      if (!gameState.deployedUnitInstances) {
        return null;
      }
      
      for (const [instanceId, deployment] of Object.entries(gameState.deployedUnitInstances)) {
        // Convert both deploymentIndex values to numbers for comparison to avoid type mismatch issues
        const deploymentIndex1 = Number(deployment.unitData.deploymentIndex);
        const deploymentIndex2 = Number(unit.deploymentIndex);
        
        if (deployment.armyId === armyId && 
            deployment.playerId === playerId && 
            deployment.unitData.name === unit.name &&
            deploymentIndex1 === deploymentIndex2) {
          
          // Find the zone name
          const zone = zones.find(z => z.id === deployment.zoneId);
          const zoneName = zone ? (zoneNames[zone.name] || zone.name) : (zoneNames[deployment.zoneId] || deployment.zoneId);
          
          return {
            zoneId: deployment.zoneId,
            zoneName: zoneName,
            instanceId: instanceId
          };
        }
      }
      
      return null;
    }
    
    function selectUnitForDeployment(unitIndex) {
      const selectedArmyData = gameState.selectedArmyInZone[gameState.currentPlayer];
      if (!selectedArmyData) {
        logZoneMessage('Please select an army first');
        return;
      }
      
      // Deselect construction if it's currently selected
      if (selectedConstruction) {
        selectedConstruction = null;
        constructionMode = false;
        
        // Update construction UI
        document.querySelectorAll('.construction-option').forEach(option => {
          option.classList.remove('selected');
        });
        
        // Update construction status
        const status = document.getElementById('construction-status');
        if (status) {
          status.textContent = 'Select a structure to build';
        }
        
        // Update construction instructions
        const instructions = document.getElementById('construction-instructions');
        if (instructions) {
          instructions.textContent = 'Click on a structure to select it, then click on the battlefield to place it';
        }
        
        console.log('Construction deselected when selecting unit');
      }
      
      // Filter out artillery and aerial units to match the display
      // Field guns can be deployed on the grid (they have movement values)
      const deployableUnits = selectedArmyData.army.units.filter(unit => 
        unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber'
      );
      const unit = deployableUnits[unitIndex];
      
      // Check if this unit is already selected - if so, deselect it
      if (gameState.selectedUnit && 
          gameState.selectedUnit.deploymentIndex === unitIndex && 
          gameState.selectedUnit.armyId === selectedArmyData.army.id) {
        gameState.selectedUnit = null;
        updateSelectedUnitInfo();
        updateSelectablePositions();
        logZoneMessage(`${unit.name} deselected`);
        return;
      }
      
      // Re-enable deployment checking
      const isDeployed = isUnitDeployedFromArmy(unit, selectedArmyData.army.id);
      
      // DEBUG: Log unit selection attempt
      console.log(' [SELECTION DEBUG] Attempting to select unit for deployment:');
      console.log(' [SELECTION DEBUG] - unit:', unit);
      console.log(' [SELECTION DEBUG] - unitIndex:', unitIndex);
      console.log(' [SELECTION DEBUG] - armyId:', selectedArmyData.army.id);
      console.log(' [SELECTION DEBUG] - isDeployed:', isDeployed);
      
      if (unit && !isDeployed) {
        gameState.selectedUnit = { 
          ...unit, 
          id: `${gameState.currentPlayer}_${unit.name}_${Date.now()}`,
          deploymentIndex: unitIndex,
          armyId: selectedArmyData.army.id
        };
        
        // Update UI to show selection
        loadZoneArmyPool();
        updateSelectedUnitInfo();
        updateSelectablePositions();
        
        // Ensure UI is properly updated after a short delay
        setTimeout(() => {
          loadZoneArmyPool();
          console.log(' [SELECTION DEBUG] Refreshed army pool after unit selection');
        }, 50);
        
        logZoneMessage(`${unit.name} selected for deployment`);
              } else if (unit && isDeployed) {
          try {
            const deploymentInfo = getUnitDeploymentInfo(unit, selectedArmyData.army.id);
            if (deploymentInfo) {
            const zoneName = zoneNames[deploymentInfo.zoneName] || deploymentInfo.zoneName;
            logZoneMessage(`${unit.name} is already deployed in Zone ${zoneName}`, 'system');
            } else {
              logZoneMessage(`${unit.name} is already deployed in another zone`, 'system');
            }
          } catch (error) {
            console.warn('Error getting deployment info for unit:', unit.name, error);
            logZoneMessage(`${unit.name} is already deployed in another zone`, 'system');
          }
        }
    }
    
    function updateCommandPointsDisplay() {
      const cpElement = document.getElementById('zone-command-points');
      if (cpElement) {
        cpElement.textContent = gameState.commandPoints[gameState.currentPlayer];
      }
      
      // Also update the main game CP display
      const mainCpElement = document.getElementById('command-points');
      if (mainCpElement) {
        mainCpElement.textContent = gameState.commandPoints[gameState.currentPlayer];
      }
    }
    
    // CP System Functions
    function canSpendCP(cost) {
      return gameState.commandPoints[gameState.currentPlayer] >= cost;
    }
    
    function spendCP(cost) {
      if (canSpendCP(cost)) {
        gameState.commandPoints[gameState.currentPlayer] -= cost;
        updateCommandPointsDisplay();
        updateUI();
        return true;
      }
      return false;
    }
    
    function addCP(amount) {
      gameState.commandPoints[gameState.currentPlayer] += amount;
      updateCommandPointsDisplay();
      updateUI();
    }
    
    function updateZoneCPBonuses() {
      // Reset CP bonuses
      gameState.contestedZones = { red: [], blue: [] };
      gameState.controlledZones = { red: [], blue: [] };
      
      // Check each zone for control status
      zones.forEach(zone => {
        if (zone.control === 'red') {
          gameState.controlledZones.red.push(zone.id);
        } else if (zone.control === 'blue') {
          gameState.controlledZones.blue.push(zone.id);
        } else if (zone.control === 'contested') {
          // Check if player has units in contested zone
          let redUnits = 0, blueUnits = 0;
          for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
            const unit = zone.tacticalGrid[pos].unit;
            if (unit) {
              if (unit.player === 'red') redUnits++;
              else blueUnits++;
            }
          }
          if (redUnits > 0) gameState.contestedZones.red.push(zone.id);
          if (blueUnits > 0) gameState.contestedZones.blue.push(zone.id);
        }
      });
    }
    
    function calculateTurnStartCP() {
  // Use the correct base CP for the current player
  let baseCP;
  if (gameState.currentPlayer === 'red') {
    baseCP = gameConfig.player1CP || gameConfig.startingCP || 3;
  } else {
    baseCP = gameConfig.player2CP || gameConfig.startingCP || 3;
  }
  
      const contestedBonus = gameState.contestedZones[gameState.currentPlayer].length;
      const controlledBonus = gameState.controlledZones[gameState.currentPlayer].length * 2;
      
      return baseCP + contestedBonus + controlledBonus;
    }
    
    // Artillery System Functions
    function getPlayerArtillery() {
      return gameState.artillery[gameState.currentPlayer] || [];
    }
    
    function getEnemyArtillery() {
      const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
      return gameState.artillery[enemyPlayer] || [];
    }
    
    function addArtilleryToPlayer(artillery) {
      if (!gameState.artillery[gameState.currentPlayer]) {
        gameState.artillery[gameState.currentPlayer] = [];
      }
      
      // Initialize targetHistory for precision ability
      if (artillery.special === 'precision' && !artillery.targetHistory) {
        artillery.targetHistory = {};
      }
      
      gameState.artillery[gameState.currentPlayer].push(artillery);
    }
    
    function removeArtilleryFromPlayer(artilleryId) {
      if (gameState.artillery[gameState.currentPlayer]) {
        gameState.artillery[gameState.currentPlayer] = gameState.artillery[gameState.currentPlayer].filter(a => a.id !== artilleryId);
      }
    }
    
    function canUseArtillery() {
      const artillery = getPlayerArtillery();
      return artillery.length > 0;
    }
    
    // Aerial Combat System Functions
    function initializeAerialSystem() {
      console.log('=== INITIALIZE AERIAL SYSTEM ===');
      console.log(`Initializing aerial system for player: ${gameState.currentPlayer}`);
      console.log('Current gameState.aerial:', gameState.aerial);
      console.log('Current gameData.selectedArmies:', gameData.selectedArmies);
      
      // Only initialize if aerial units don't exist for current player
      if (!gameState.aerial[gameState.currentPlayer] || gameState.aerial[gameState.currentPlayer].length === 0) {
        console.log('No aerial units found for current player, getting new ones...');
        const currentPlayerAerialUnits = getPlayerAerialUnits(gameState.currentPlayer);
        console.log(`Current player aerial units:`, currentPlayerAerialUnits);
        gameState.aerial[gameState.currentPlayer] = currentPlayerAerialUnits;
      } else {
        console.log(`Current player aerial units already exist:`, gameState.aerial[gameState.currentPlayer]);
      }
      
      // Initialize enemy aerial units if not already done
      const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
      console.log(`Checking enemy player (${enemyPlayer}) aerial units...`);
      if (!gameState.aerial[enemyPlayer] || gameState.aerial[enemyPlayer].length === 0) {
        console.log('No aerial units found for enemy player, getting new ones...');
        const enemyAerialUnits = getPlayerAerialUnits(enemyPlayer);
        console.log(`Enemy aerial units:`, enemyAerialUnits);
        gameState.aerial[enemyPlayer] = enemyAerialUnits;
      } else {
        console.log(`Enemy aerial units already exist:`, gameState.aerial[enemyPlayer]);
      }
      
      console.log('Final aerial state:', gameState.aerial);
      console.log('About to call updateAerialUI...');
      updateAerialUI();
      console.log('=== END INITIALIZE AERIAL SYSTEM ===');
    }
    
    function getPlayerAerialUnits(playerColor) {
      console.log('=== GET PLAYER AERIAL UNITS ===');
      const playerId = playerColor === 'red' ? 'player1' : 'player2';
      const armies = gameData.selectedArmies[playerId] || [];
      
      console.log('Player color:', playerColor);
      console.log('Player ID:', playerId);
      console.log('Available armies:', armies);
      
      const aerialUnits = [];
      let unitCounter = 0;
      armies.forEach(army => {
        console.log('Processing army:', army.name);
        console.log('All units in army:', army.units);
        
        const aerialUnitsInArmy = army.units.filter(unit => {
          console.log(`Checking unit: ${unit.name}, type: ${unit.type}`);
          return unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship';
        });
        console.log('Aerial units found in army:', aerialUnitsInArmy);
        console.log('Aerial units count:', aerialUnitsInArmy.length);
        
        aerialUnitsInArmy.forEach(unit => {
          // Generate unique ID - handle case where unit.id might be undefined
          const unitId = unit.id || unit.name || 'unknown';
          const uniqueId = `${unitId}_${playerColor}_${unitCounter}_${Math.random().toString(36).substr(2, 9)}`;
          console.log(`Creating aerial unit ${unit.name} with unique ID: ${uniqueId}`);
          console.log('Unit details:', unit);
          
          // Determine air unit type based on unit name
          let airUnitType = 'fighter'; // Default
          if (unit.name.toLowerCase().includes('bomber')) {
            airUnitType = 'bomber';
          } else if (unit.name.toLowerCase().includes('fighter')) {
            airUnitType = 'fighter';
          } else if (unit.name.toLowerCase().includes('airship')) {
            airUnitType = 'airship';
          }
          
          aerialUnits.push({
            ...unit,
            id: uniqueId, // Unique ID
            player: playerColor,
            armyId: army.id,
            airUnitType: airUnitType, // Add specific air unit type
            health: Math.max(unit.defense, 1), // Initialize health to defense value, minimum 1
            maxHealth: Math.max(unit.defense, 1), // Track maximum health, minimum 1
            armour: unit.armour || 0, // Initialize armour stat
            maxArmour: unit.armour || 0, // Track maximum armour
            killsThisTurn: 0, // For salvage systems ability
            armorToSalvage: 0 // For salvage systems ability
          });
          unitCounter++;
        });
      });
      
      // Track aerial units as deployed
      if (!gameState.campaignStats) {
        gameState.campaignStats = {
          red: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          },
          blue: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          }
        };
      }
      console.log(' [AERIAL DEPLOYMENT] Before aerial deployment tracking - Player:', playerColor, 'Stats:', gameState.campaignStats[playerColor]);
      console.log(' [AERIAL DEPLOYMENT] Aerial units to deploy:', aerialUnits.length);
      
      gameState.campaignStats[playerColor].unitsDeployed += aerialUnits.length;
      
      console.log(' [AERIAL DEPLOYMENT] After aerial deployment tracking - Player:', playerColor, 'Stats:', gameState.campaignStats[playerColor]);
      
      return aerialUnits;
    }
    
    function getAvailableAerial() {
      const currentPlayerAerial = gameState.aerial[gameState.currentPlayer];
      console.log(' [AERIAL DEBUG] getAvailableAerial - currentPlayerAerial:', currentPlayerAerial);
      console.log(' [AERIAL DEBUG] getAvailableAerial - aerialActions:', gameState.aerialActions);
      
      const availableAerial = currentPlayerAerial.filter(unit => {
        console.log(' [AERIAL DEBUG] Checking unit:', unit.name, 'ID:', unit.id);
        
        if (unit.type === 'airship') {
          // Airships can attack once per turn like other aerial units
          const isAvailable = !gameState.aerialActions[unit.id]?.used;
          console.log(' [AERIAL DEBUG] Airship check - actions:', gameState.aerialActions[unit.id], 'isAvailable:', isAvailable);
          return isAvailable;
        } else {
          // For other units, check if used
          const isAvailable = !gameState.aerialActions[unit.id]?.used;
          console.log(' [AERIAL DEBUG] Regular unit check - isAvailable:', isAvailable);
          return isAvailable;
        }
      });
      
      console.log(' [AERIAL DEBUG] getAvailableAerial - availableAerial:', availableAerial);
      return availableAerial;
    }
    
    function getEnemyAerial() {
      const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
      return gameState.aerial[enemyPlayer];
    }
    
    function markAerialAsUsed(unit, targetType = null) {
      console.log(' [AERIAL DEBUG] markAerialAsUsed called for unit:', unit.name, 'ID:', unit.id, 'targetType:', targetType);
      
      if (unit.type === 'airship') {
        // Airships can attack once per turn like other aerial units
        gameState.aerialActions[unit.id] = { used: true };
      } else {
        // For other aerial units, mark as used immediately
        gameState.aerialActions[unit.id] = { used: true };
      }
      
      console.log(' [AERIAL DEBUG] aerialActions after marking:', gameState.aerialActions);
    }
    
    function resetAerialUsage() {
      console.log(' [AERIAL DEBUG] resetAerialUsage called');
      console.log(' [AERIAL DEBUG] aerialActions before reset:', gameState.aerialActions);
      gameState.aerialActions = {};
      console.log(' [AERIAL DEBUG] aerialActions after reset:', gameState.aerialActions);
    }
    
    function clearAerialTargetSelection() {
      console.log(' [AERIAL DEBUG] clearAerialTargetSelection called');
      // Clear aerial targeting mode
      gameState.aerialMode = false;
      gameState.selectedAerialUnit = null;
      
      // Remove highlighting from ground units
      const positions = document.querySelectorAll('.position');
      positions.forEach(pos => {
        pos.classList.remove('aerial-target');
      });
      
      // Hide aerial attack buttons
      const aerialUnitsContainer = document.getElementById('aerial-units-container');
      if (aerialUnitsContainer) {
        const attackBtns = aerialUnitsContainer.querySelectorAll('.aerial-attack-btn');
        attackBtns.forEach(btn => btn.style.display = 'none');
      }
      
      console.log(' [AERIAL DEBUG] Aerial target selection cleared');
    }
    
    function updateAerialUI() {
      console.log('=== UPDATE AERIAL UI ===');
      
      // Only update if we're in the zone-detail screen
      const zoneDetailScreen = document.getElementById('zone-detail');
      if (!zoneDetailScreen || zoneDetailScreen.style.display === 'none') {
        console.log('Not in zone-detail screen, skipping aerial UI update');
        return;
      }
      
      const aerialPanel = document.querySelector('.aerial-panel');
      const aerialContent = document.getElementById('aerial-panel-content');
      const aerialStatus = document.getElementById('aerial-status');
      
      console.log('Aerial panel elements found:', {
        panel: !!aerialPanel,
        content: !!aerialContent,
        status: !!aerialStatus
      });
      
      if (!aerialPanel || !aerialContent || !aerialStatus) {
        console.error('Aerial panel elements not found');
        return;
      }
      
      // Always show the aerial panel, even if no aerial units
      aerialPanel.style.display = 'block';
      
      // Apply player color classes
      aerialPanel.classList.remove('red-player', 'blue-player');
      if (gameState.currentPlayer === 'red') {
        aerialPanel.classList.add('red-player');
      } else {
        aerialPanel.classList.add('blue-player');
      }
      
      const hasAerialUnits = gameState.aerial.red.length > 0 || gameState.aerial.blue.length > 0;
      
      if (hasAerialUnits) {
        updateAerialPanel();
      } else {
        aerialStatus.textContent = 'No aerial units available';
        aerialContent.style.display = 'none';
      }
    }
    
    function updateAerialPanel() {
      try {
      const aerialPanel = document.querySelector('.aerial-panel');
      const aerialContent = document.getElementById('aerial-panel-content');
      const aerialStatus = document.getElementById('aerial-status');
      const aerialUnitsContainer = document.getElementById('aerial-units-container');
      const aerialInstructions = document.getElementById('aerial-instructions');
      
        if (!aerialPanel || !aerialContent || !aerialStatus || !aerialUnitsContainer || !aerialInstructions) {
          console.error(' [AERIAL DEBUG] Missing aerial panel elements');
          return;
        }
      
      // Update panel color based on current player
      aerialPanel.className = `aerial-panel ${gameState.currentPlayer}-player`;
      
      const allFriendlyAerial = gameState.aerial[gameState.currentPlayer];
      const availableAerial = getAvailableAerial();
      const enemyAerial = getEnemyAerial();
      
      console.log(' [AERIAL DEBUG] Friendly aerial:', allFriendlyAerial.length);
      console.log(' [AERIAL DEBUG] Enemy aerial:', enemyAerial.length);
      console.log(' [AERIAL DEBUG] Available aerial:', availableAerial.length);
      
      if (allFriendlyAerial.length > 0 || enemyAerial.length > 0) {
        aerialStatus.textContent = `${availableAerial.length} aerial unit(s) available`;
        aerialContent.style.display = 'block';
        console.log(' [AERIAL DEBUG] Showing aerial content');
        loadAerialUnitsToPanel(allFriendlyAerial, enemyAerial);
        aerialInstructions.textContent = 'Select an aerial unit to attack enemy units';
      } else {
        aerialStatus.textContent = 'No aerial units available';
        aerialContent.style.display = 'none';
        console.log(' [AERIAL DEBUG] Hiding aerial content - no aerial units');
      }
    } catch (error) {
      console.error(' [AERIAL DEBUG] Error in updateAerialPanel:', error);
      }
    }
    
    function loadAerialUnitsToPanel(friendlyAerial, enemyAerial) {
      console.log('=== LOAD AERIAL UNITS TO PANEL ===');
      console.log('Friendly aerial units:', friendlyAerial);
      console.log('Enemy aerial units:', enemyAerial);
      
      const container = document.getElementById('aerial-units-container');
      if (!container) {
        console.error('Aerial units container not found!');
        return;
      }
      
      container.innerHTML = '';
      
      // Set player colors
      const currentPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player1.color : gameConfig.player2.color;
      const enemyPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player2.color : gameConfig.player1.color;
      
      const currentPlayerColorRgb = hexToRgb(currentPlayerColor);
      const enemyPlayerColorRgb = hexToRgb(enemyPlayerColor);
      
      // Add friendly aerial units section
      console.log('Filtering friendly aerial units for alive units...');
      const aliveFriendlyAerial = friendlyAerial.filter(unit => {
        const health = typeof unit.health !== 'undefined' ? unit.health : unit.defense;
        console.log(`Friendly unit ${unit.name}: health=${health}, alive=${health > 0}`);
        return health > 0;
      });
      
      console.log('Alive friendly aerial units:', aliveFriendlyAerial);
      
      if (aliveFriendlyAerial.length > 0) {
        const friendlySection = document.createElement('div');
        friendlySection.className = 'aerial-section';
        friendlySection.style.setProperty('--player-color', currentPlayerColor);
        friendlySection.style.setProperty('--player-color-rgb', currentPlayerColorRgb);
        friendlySection.innerHTML = `<h4>Your Aerial Units</h4>`;
        
        aliveFriendlyAerial.forEach((unit, index) => {
          const aerialDiv = document.createElement('div');
          const isUsed = gameState.aerialActions[unit.id];
          
          if (isUsed) {
            aerialDiv.className = 'artillery-unit-card friendly-aerial used';
            aerialDiv.style.opacity = '0.5';
            aerialDiv.style.cursor = 'none';
          } else {
            aerialDiv.className = 'artillery-unit-card friendly-aerial';
            aerialDiv.onclick = () => selectAerialForAttack(unit);
          }
          
          // Ensure unit has health property
          const currentHealth = typeof unit.health !== 'undefined' ? unit.health : unit.defense;
          const maxHealth = typeof unit.maxHealth !== 'undefined' ? unit.maxHealth : unit.defense;
          
          aerialDiv.innerHTML = `
            <div class="artillery-unit-name">${unit.name}</div>
            <div class="artillery-unit-stats">
              <span>HP: ${currentHealth}/${maxHealth}</span>
              <span>ATK: ${unit.attack >= 0 ? '+' : ''}${unit.attack}</span>
              ${unit.armour ? `<span>Amr: ${unit.armour}/${unit.maxArmour || unit.armour}</span>` : ''}
              <span>Type: ${formatUnitType(unit.type)}</span>
            </div>
            ${isUsed ? '<div class="used-indicator">Used this turn</div>' : ''}
          `;
          
          friendlySection.appendChild(aerialDiv);
        });
        
        container.appendChild(friendlySection);
      }
      
              // Add enemy aerial units section
      console.log('Filtering enemy aerial units for alive units...');
      const aliveEnemyAerial = enemyAerial.filter(unit => {
        const health = typeof unit.health !== 'undefined' ? unit.health : unit.defense;
        console.log(`Enemy unit ${unit.name}: health=${health}, alive=${health > 0}`);
        return health > 0;
      });
      
      console.log('Alive enemy aerial units:', aliveEnemyAerial);
      
      if (aliveEnemyAerial.length > 0) {
        const enemySection = document.createElement('div');
        enemySection.className = 'aerial-section';
        enemySection.style.setProperty('--enemy-color', enemyPlayerColor);
        enemySection.style.setProperty('--enemy-color-rgb', enemyPlayerColorRgb);
        enemySection.innerHTML = `<h4>Enemy Aerial Units</h4>`;
        
        aliveEnemyAerial.forEach((unit, index) => {
          const aerialDiv = document.createElement('div');
          aerialDiv.className = 'artillery-unit-card enemy-aerial';
          aerialDiv.dataset.unitId = unit.id;
          
          // Ensure unit has health property
          const currentHealth = typeof unit.health !== 'undefined' ? unit.health : unit.defense;
          const maxHealth = typeof unit.maxHealth !== 'undefined' ? unit.maxHealth : unit.defense;
          
          aerialDiv.innerHTML = `
            <div class="artillery-unit-name">${unit.name}</div>
            <div class="artillery-unit-stats">
              <span>HP: ${currentHealth}/${maxHealth}</span>
              <span>ATK: ${unit.attack >= 0 ? '+' : ''}${unit.attack}</span>
              ${unit.armour ? `<span>Amr: ${unit.armour}/${unit.maxArmour || unit.armour}</span>` : ''}
              <span>Type: ${formatUnitType(unit.type)}</span>
            </div>
          `;
          
          // Add click handler for targeting
          aerialDiv.onclick = () => {
            if (gameState.selectedAerialUnit) {
              fireAerialAtUnit(unit);
            }
          };
          
          enemySection.appendChild(aerialDiv);
        });
        
        container.appendChild(enemySection);
      }
    }
    
    function selectAerialForAttack(unit) {
      console.log('selectAerialForAttack called with unit:', unit);
      
      // Check if this is a friendly unit (only friendly units can be selected for attacking)
      const friendlyAerial = getAvailableAerial();
      const isFriendlyUnit = friendlyAerial.some(friendlyUnit => friendlyUnit.id === unit.id);
      
      if (!isFriendlyUnit) {
        logZoneMessage('You can only select your own aerial units to attack with');
        return;
      }
      
      // If clicking on the same unit that's already selected, deselect it
      if (gameState.selectedAerialUnit && gameState.selectedAerialUnit.id === unit.id) {
        deselectAerialUnit();
        return;
      }
      
      gameState.selectedAerialUnit = unit;
      gameState.aerialMode = true;
      
      // Update instructions based on air unit type
      const aerialInstructions = document.getElementById('aerial-instructions');
      if (aerialInstructions) {
        if (unit.airUnitType === 'bomber') {
          aerialInstructions.textContent = `Selected: ${unit.name}. Click on enemy artillery or ground units to attack them. (Click unit again to deselect)`;
        } else if (unit.airUnitType === 'fighter') {
        aerialInstructions.textContent = `Selected: ${unit.name}. Click on enemy aerial units to attack them. (Click unit again to deselect)`;
        } else {
          aerialInstructions.textContent = `Selected: ${unit.name}. Click on target to attack. (Click unit again to deselect)`;
        }
      }
      
      // Highlight selected unit and show targetable enemy units
      const aerialUnitsContainer = document.getElementById('aerial-units-container');
      if (aerialUnitsContainer) {
        // Remove previous selections
        const unitCards = aerialUnitsContainer.querySelectorAll('.artillery-unit-card');
        unitCards.forEach(card => {
          card.classList.remove('selected', 'aerial-unit-targetable');
        });
        
        // Highlight the selected friendly unit
        const selectedCard = aerialUnitsContainer.querySelector(`[data-unit-id="${unit.id}"]`);
        if (selectedCard) {
          selectedCard.classList.add('selected');
        }
        
        // Add targeting border to enemy units based on air unit type
        if (unit.airUnitType === 'bomber') {
          // Bombers can target enemy artillery and ground units
        const enemyCards = aerialUnitsContainer.querySelectorAll('.enemy-aerial');
        enemyCards.forEach(card => {
            card.classList.remove('aerial-unit-targetable');
          });
          
          // Highlight enemy artillery in the artillery panel
          const artilleryContainer = document.getElementById('artillery-units-container');
          if (artilleryContainer) {
            const enemyArtilleryCards = artilleryContainer.querySelectorAll('.enemy-artillery');
            enemyArtilleryCards.forEach(card => {
          card.classList.add('aerial-unit-targetable');
        });
          }
          
          // Highlight enemy ground units on the tactical grid
          highlightGroundUnitsForBomber();
        } else if (unit.airUnitType === 'fighter') {
          // Fighters can only target enemy aerial units
          const enemyCards = aerialUnitsContainer.querySelectorAll('.enemy-aerial');
          enemyCards.forEach(card => {
            card.classList.add('aerial-unit-targetable');
          });
          
          // Remove targeting from artillery panel
          const artilleryContainer = document.getElementById('artillery-units-container');
          if (artilleryContainer) {
            const enemyArtilleryCards = artilleryContainer.querySelectorAll('.enemy-artillery');
            enemyArtilleryCards.forEach(card => {
              card.classList.remove('aerial-unit-targetable');
            });
          }
        } else if (unit.airUnitType === 'airship') {
          // Airships can target both enemy aerial units AND ground units
          const enemyCards = aerialUnitsContainer.querySelectorAll('.enemy-aerial');
          enemyCards.forEach(card => {
            card.classList.add('aerial-unit-targetable');
          });
          
          // Highlight enemy artillery in the artillery panel
          const artilleryContainer = document.getElementById('artillery-units-container');
          if (artilleryContainer) {
            const enemyArtilleryCards = artilleryContainer.querySelectorAll('.enemy-artillery');
            enemyArtilleryCards.forEach(card => {
              card.classList.add('aerial-unit-targetable');
            });
          }
          
          // Highlight enemy ground units on the tactical grid
          highlightGroundUnitsForBomber();
        }
      }
    }
    
    function deselectAerialUnit() {
      // Clear aerial selection
      gameState.selectedAerialUnit = null;
      gameState.aerialMode = false;
      gameState.antiAirTargeting = false;
      
      // Update instructions
      const aerialInstructions = document.getElementById('aerial-instructions');
      if (aerialInstructions) {
        aerialInstructions.textContent = 'Select an aerial unit to attack enemy units';
      }
      
      // Clear all highlights and hide attack buttons
      const aerialUnitsContainer = document.getElementById('aerial-units-container');
      if (aerialUnitsContainer) {
        const unitCards = aerialUnitsContainer.querySelectorAll('.aerial-unit-card');
        unitCards.forEach(card => {
          card.classList.remove('selected', 'aerial-unit-targetable');
          const attackBtn = card.querySelector('.aerial-attack-btn');
          if (attackBtn) {
            attackBtn.style.display = 'none';
          }
        });
      }
      
      // Clear Anti-Air targeting mode
      if (gameState.antiAirTargeting) {
        gameState.antiAirTargeting = false;
        hideAerialTargetSelection();
      }
      
      // Clear airship highlights (both ground and aerial targets)
      clearAirshipHighlights();
    }
    
    function showAerialTargetSelection() {
      console.log(' [ANTI-AIR] Showing aerial target selection');
      console.log(' [TOOLTIP DEBUG] Tooltip state before showAerialTargetSelection:');
      if (tooltipElement) {
        console.log(' [TOOLTIP DEBUG] - Display:', tooltipElement.style.display);
        console.log(' [TOOLTIP DEBUG] - Classes:', tooltipElement.className);
        console.log(' [TOOLTIP DEBUG] - Has show class:', tooltipElement.classList.contains('show'));
      }
      gameState.antiAirTargeting = true;
      
      // Update instructions
      const aerialInstructions = document.getElementById('aerial-instructions');
      if (aerialInstructions) {
        aerialInstructions.textContent = 'Anti-Air unit selected. Click on an enemy aerial unit to attack it.';
      }
      
      // Highlight enemy aerial units as targets
      const aerialUnitsContainer = document.getElementById('aerial-units-container');
      console.log(' [ANTI-AIR] Aerial units container found:', !!aerialUnitsContainer);
      
      if (aerialUnitsContainer) {
        const enemyCards = aerialUnitsContainer.querySelectorAll('.enemy-aerial');
        console.log(' [ANTI-AIR] Found enemy aerial cards:', enemyCards.length);
        
        enemyCards.forEach((card, index) => {
          console.log(` [ANTI-AIR] Processing enemy card ${index}:`, card);
          card.classList.add('anti-air-targetable');
          card.style.cursor = 'pointer';
          
          // Add click handler for Anti-Air attack
          card.onclick = () => {
            console.log(' [ANTI-AIR] Enemy aerial card clicked!');
            const unitId = card.getAttribute('data-unit-id');
            console.log(' [ANTI-AIR] Unit ID from card:', unitId);
            const targetUnit = findAerialUnitById(unitId);
            console.log(' [ANTI-AIR] Found target unit:', targetUnit);
            if (targetUnit) {
              fireAntiAirAtAerial(targetUnit);
            }
          };
        });
      } else {
        console.log(' [ANTI-AIR] ERROR: Could not find aerial-units-container');
      }
    }
    
    function hideAerialTargetSelection() {
      console.log(' [ANTI-AIR] Hiding aerial target selection');
      console.log(' [TOOLTIP DEBUG] Tooltip state before hideAerialTargetSelection:');
      if (tooltipElement) {
        console.log(' [TOOLTIP DEBUG] - Display:', tooltipElement.style.display);
        console.log(' [TOOLTIP DEBUG] - Classes:', tooltipElement.className);
        console.log(' [TOOLTIP DEBUG] - Has show class:', tooltipElement.classList.contains('show'));
      }
      gameState.antiAirTargeting = false;
      
      // Update instructions
      const aerialInstructions = document.getElementById('aerial-instructions');
      if (aerialInstructions) {
        aerialInstructions.textContent = 'Launch air strikes against enemy formations';
      }
      
      // Remove highlights and click handlers
      const aerialUnitsContainer = document.getElementById('aerial-units-container');
      if (aerialUnitsContainer) {
        const enemyCards = aerialUnitsContainer.querySelectorAll('.enemy-aerial');
        enemyCards.forEach(card => {
          card.classList.remove('aerial-unit-targetable', 'anti-air-targetable');
          card.style.cursor = '';
          card.onclick = null;
        });
      }
    }
    
    function findAerialUnitById(unitId) {
      const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
      console.log(' [ANTI-AIR] Finding aerial unit by ID:', unitId);
      console.log(' [ANTI-AIR] Enemy player:', enemyPlayer);
      console.log(' [ANTI-AIR] Enemy aerial units:', gameState.aerial[enemyPlayer]);
      
      const foundUnit = gameState.aerial[enemyPlayer].find(unit => unit.id === unitId);
      console.log(' [ANTI-AIR] Found unit:', foundUnit);
      return foundUnit;
    }
    
    function fireAntiAirAtAerial(targetAerialUnit) {
      console.log(' [ANTI-AIR] Firing Anti-Air at aerial unit:', targetAerialUnit);
      
      if (!gameState.selectedUnit || gameState.selectedUnit.special !== 'air_defense') {
        console.log(' [ANTI-AIR] No Anti-Air unit selected');
        return;
      }
      
      // Check CP cost for Anti-Air attack
      if (!canSpendCP(gameState.cpCosts.attack)) {
        logZoneMessage(`Not enough Command Points to attack with Anti-Air unit (need ${gameState.cpCosts.attack} CP)`, 'system');
        return;
      }
      
      const antiAirUnit = gameState.selectedUnit;
      const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
      
      // Show aerial combat animation for Anti-Air attack
      showAerialAnimation(antiAirUnit, targetAerialUnit, null, (success, attackTotal, defenseTotal) => {
        console.log(` [ANTI-AIR] Combat: ${antiAirUnit.name} (${attackTotal}) vs ${targetAerialUnit.name} (${defenseTotal})`);
        
        if (success) {
          // Anti-Air unit wins - calculate damage using new grid battle system
          // Only apply damage if attacker wins (attackTotal > defenseTotal)
          const damage = Math.max(0, attackTotal - defenseTotal);
          console.log(` [ANTI-AIR] ${antiAirUnit.name} deals ${damage} damage to ${targetAerialUnit.name}`);
          
          // Apply damage to aerial unit
          if (targetAerialUnit.health === undefined) {
            targetAerialUnit.health = targetAerialUnit.defense;
          }
          
          targetAerialUnit.health -= damage;
          
          if (targetAerialUnit.health <= 0) {
            // Destroy aerial unit
            console.log(` [ANTI-AIR] ${targetAerialUnit.name} has been destroyed!`);
            gameState.aerial[enemyPlayer] = gameState.aerial[enemyPlayer].filter(unit => unit.id !== targetAerialUnit.id);
            
            // Track unit loss for campaign stats
            trackUnitLoss(targetAerialUnit);
            
            // Update aerial UI
            updateAerialPanel();
            
            logZoneMessage(`${targetAerialUnit.name} has been shot down by ${antiAirUnit.name}! (Cost: ${gameState.cpCosts.attack} CP)`, 'combat');
            logMessage(`INTELLIGENCE: ${antiAirUnit.name} successfully engaged and destroyed ${targetAerialUnit.name}. The enemy's aerial superiority has been reduced.`, 'intelligence');
          } else {
            logZoneMessage(`${antiAirUnit.name} damages ${targetAerialUnit.name} (${targetAerialUnit.health} HP remaining) (Cost: ${gameState.cpCosts.attack} CP)`, 'combat');
          }
        } else {
          // Aerial unit wins or ties
          logZoneMessage(`${antiAirUnit.name} misses ${targetAerialUnit.name} (Cost: ${gameState.cpCosts.attack} CP)`, 'combat');
        }
        
        // Spend CP for the attack
        spendCP(gameState.cpCosts.attack);
        
        // Mark Anti-Air unit as used (prevent multiple attacks)
        markAerialAsUsed(antiAirUnit);
        
        // Clear Anti-Air targeting mode
        hideAerialTargetSelection();
        gameState.selectedUnit = null;
        updateSelectedUnitInfo();
        updateSelectablePositions();
      });
    }
    
    function highlightGroundUnitsForBomber() {
      console.log(' [BOMBER] Highlighting ground units for bomber targeting');
      
      // Clear previous highlights
      const positions = document.querySelectorAll('.position');
      positions.forEach(pos => {
        pos.classList.remove('bomber-targetable');
      });
      
      // Highlight enemy ground units on the tactical grid
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const gridData = currentZoneDetail.tacticalGrid[pos];
        if (gridData.unit && gridData.unit.player !== gameState.currentPlayer) {
          // Check if it's a ground unit (not aerial)
          if (gridData.unit.type !== 'fighter' && gridData.unit.type !== 'bomber' && gridData.unit.type !== 'airship') {
            const positionElement = document.querySelector(`[data-position="${pos}"]`);
            if (positionElement) {
              positionElement.classList.add('bomber-targetable');
              console.log(' [BOMBER] Highlighted ground unit:', gridData.unit.name, 'at position:', pos);
            }
          }
        }
      }
    }
    
    function clearBomberHighlights() {
      const positions = document.querySelectorAll('.position');
      positions.forEach(pos => {
        pos.classList.remove('bomber-targetable');
      });
    }
    
    function clearAirshipHighlights() {
      // Clear both bomber highlights (ground units) and aerial unit highlights
      clearBomberHighlights();
      
      // Clear aerial unit targeting highlights
      const aerialUnitsContainer = document.getElementById('aerial-units-container');
      if (aerialUnitsContainer) {
        const enemyCards = aerialUnitsContainer.querySelectorAll('.enemy-aerial');
        enemyCards.forEach(card => {
          card.classList.remove('aerial-unit-targetable');
        });
      }
      
      // Clear artillery targeting highlights
      const artilleryContainer = document.getElementById('artillery-units-container');
      if (artilleryContainer) {
        const enemyArtilleryCards = artilleryContainer.querySelectorAll('.enemy-artillery');
        enemyArtilleryCards.forEach(card => {
          card.classList.remove('aerial-unit-targetable');
        });
      }
    }
    
    function handleAerialAttackOnUnit(targetUnit) {
      console.log(' [AERIAL ATTACK] ===== START AERIAL ATTACK =====');
      console.log(' [AERIAL ATTACK] Handling aerial attack on unit:', targetUnit.name);
      console.log(' [AERIAL ATTACK] Target unit type:', targetUnit.type);
      console.log(' [AERIAL ATTACK] Target unit ID:', targetUnit.id);
      console.log(' [AERIAL ATTACK] Selected aerial unit:', gameState.selectedAerialUnit);
      console.log(' [AERIAL ATTACK] Current aerialActions:', gameState.aerialActions);
      
      if (!gameState.selectedAerialUnit) {
        console.log(' [AERIAL ATTACK] No aerial unit selected');
        return;
      }
      
      console.log(' [AERIAL ATTACK] Selected aerial unit ID:', gameState.selectedAerialUnit.id);
      console.log(' [AERIAL ATTACK] Is aerial unit already used?', gameState.aerialActions[gameState.selectedAerialUnit.id]);
      
      // Check if aerial unit has already been used this turn
      if (gameState.aerialActions[gameState.selectedAerialUnit.id]) {
        console.log(' [AERIAL ATTACK] Aerial unit already used this turn - BLOCKING ATTACK');
        logZoneMessage(`${gameState.selectedAerialUnit.name} has already been used this turn`, 'system');
        return;
      }
      
      // Additional check: ensure aerial unit is still available
      const availableAerial = getAvailableAerial();
      const isStillAvailable = availableAerial.some(unit => unit.id === gameState.selectedAerialUnit.id);
      console.log(' [AERIAL ATTACK] Available aerial units:', availableAerial);
      console.log(' [AERIAL ATTACK] Is selected unit still available?', isStillAvailable);
      
      if (!isStillAvailable) {
        console.log(' [AERIAL ATTACK] Aerial unit no longer available - BLOCKING ATTACK');
        logZoneMessage(`${gameState.selectedAerialUnit.name} is no longer available for attack`, 'system');
        return;
      }
      
      console.log(' [AERIAL ATTACK] All checks passed - proceeding with attack');
      // Call the existing aerial attack function
      fireAerialAtUnit(targetUnit);
    }
    
    function fireAerialAtUnit(targetUnit) {
      console.log('fireAerialAtUnit called with target:', targetUnit);
      console.log('Selected aerial:', gameState.selectedAerialUnit);
      
      if (!gameState.selectedAerialUnit) return;
      
      const aerialUnit = gameState.selectedAerialUnit;
      
      // Check weather restrictions for aerial units
      if (!applyWeatherRestrictions(aerialUnit, 'aerial')) {
        logZoneMessage(`${aerialUnit.name} cannot attack due to adverse weather conditions!`, 'system');
        return;
      }
      
      // Check if this is an Airship and if it has already attacked
      if (aerialUnit.type === 'airship') {
        console.log(' [AIRSHIP DEBUG] Checking airship attack availability for:', aerialUnit.name);
        const actions = gameState.aerialActions[aerialUnit.id];
        if (actions && actions.used) {
          console.log(' [AIRSHIP DEBUG] Airship has already attacked this turn!');
          logZoneMessage(`${aerialUnit.name} has already attacked this turn!`, 'system');
          return;
        }
        console.log(' [AIRSHIP DEBUG] Airship can attack, proceeding');
      }
      
      // Find target position in tactical grid
      let targetPos = null;
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        if (currentZoneDetail.tacticalGrid[pos].unit && currentZoneDetail.tacticalGrid[pos].unit.id === targetUnit.id) {
          targetPos = pos;
          console.log(` [AERIAL ATTACK] Found target at position ${pos}`);
          break;
        }
      }
      
      // If not found in tactical grid, it might be artillery or aerial unit
      if (targetPos === null) {
        console.log(` [AERIAL ATTACK] Target not found in tactical grid, using null position`);
      }
      
      // Check if target is in a bunker (immune to bomber and airship attacks)
      if (aerialUnit.airUnitType === 'bomber' || aerialUnit.airUnitType === 'airship') {
        // Find the target's position in the tactical grid
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const gridData = currentZoneDetail.tacticalGrid[pos];
          if (gridData.unit && gridData.unit.id === targetUnit.id) {
            // Check if unit is in a bunker
            if (gridData.construction && gridData.construction.completed && 
                gridData.construction.type === 'bunker' && 
                (constructionOptions.bunker.effects.bomberImmune || constructionOptions.bunker.effects.airshipImmune)) {
              const unitType = aerialUnit.airUnitType === 'bomber' ? 'bomber' : 'airship';
              logZoneMessage(`${targetUnit.name} is protected by bunker - ${unitType} attack blocked!`, 'combat');
              logMessage(`INTELLIGENCE: ${aerialUnit.name} attempted to attack ${targetUnit.name} but the target is protected by a bunker. Bunker provides complete immunity to aerial bombardment.`, 'intelligence');
              return;
            }
            break;
          }
        }
      }
      
      // Check if unit can attack this target
      const isGroundUnit = targetUnit.type !== 'fighter' && targetUnit.type !== 'bomber' && targetUnit.type !== 'airship';
      const isAerialUnit = !isGroundUnit;

      if (aerialUnit.type === 'bomber') {
        // Bombers can ONLY target ground units
        if (!isGroundUnit) {
          logZoneMessage(`Bombers cannot attack aerial units!`);
          return;
        }
        console.log(' [BOMBER] Bomber targeting valid ground target:', targetUnit.name, 'type:', targetUnit.type);
      } else if (aerialUnit.type === 'fighter') {
        // Fighters can ONLY target aerial units
        if (!isAerialUnit) {
          logZoneMessage(`Fighters can only attack aerial units!`);
          return;
        }
        console.log(' [FIGHTER] Fighter targeting valid aerial target:', targetUnit.name, 'type:', targetUnit.type);
      } else if (aerialUnit.type === 'airship') {
        // Airships can target both ground and aerial units
        console.log(' [AIRSHIP] Airship targeting:', targetUnit.name, 'type:', targetUnit.type, 'is ground unit:', isGroundUnit);
      }
      
      // Check CP cost for aerial attack
      if (!canSpendCP(gameState.cpCosts.attack)) {
        logZoneMessage(`Not enough Command Points for aerial attack (need ${gameState.cpCosts.attack} CP)`, 'system');
        return;
      }
      
      // Show aerial combat animation
      showAerialAnimation(aerialUnit, targetUnit, targetPos, (success, attackTotal, defenseTotal) => {
        if (success) {
          // Calculate damage using new grid battle system: total attack - total defense
          // Use the total values (dice + bonuses) for damage calculation
          const damage = Math.max(0, attackTotal - defenseTotal);
          const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
          
          console.log(' [AERIAL ATTACK] Combat results:', {
            attackerRoll: aerialAnimationState.attackerRoll,
            defenderRoll: aerialAnimationState.defenderRoll,
            attackTotal: attackTotal,
            defenseTotal: defenseTotal,
            damage: damage
          });
          
          // For aerial units, handle damage differently since they're not in tactical grid
          if (targetUnit.type === 'fighter' || targetUnit.type === 'bomber' || targetUnit.type === 'airship') {
            // Apply damage directly to aerial unit with proper armor handling
            if (targetUnit.health === undefined) {
              targetUnit.health = targetUnit.defense;
            }
            
            // Handle armor for airships (similar to ground units)
            let remainingDamage = damage;
            if (targetUnit.armour && targetUnit.armour > 0) {
              const armourDamage = Math.min(remainingDamage, targetUnit.armour);
              targetUnit.armour -= armourDamage;
              remainingDamage -= armourDamage;
              console.log(` [AERIAL ATTACK] ${targetUnit.name} armour absorbed ${armourDamage} damage, remaining armour: ${targetUnit.armour}`);
            }
            
            // Apply remaining damage to health
            if (remainingDamage > 0) {
              targetUnit.health -= remainingDamage;
              console.log(` [AERIAL ATTACK] ${targetUnit.name} health reduced by ${remainingDamage}, new health: ${targetUnit.health}`);
            }
            
            console.log(' [AERIAL ATTACK] Aerial unit health after damage:', targetUnit.health);
            
            if (targetUnit.health <= 0) {
              console.log(' [AERIAL ATTACK] Aerial unit was destroyed! Processing destruction...');
              logZoneMessage(`${targetUnit.name} has been destroyed by aerial attack! (Cost: ${gameState.cpCosts.attack} CP)`, 'combat');
              spendCP(gameState.cpCosts.attack);
              
      // Aerial vs aerial combat - remove from aerial pool
              console.log(`Before removal: ${enemyPlayer} has ${gameState.aerial[enemyPlayer].length} aerial units`);
              gameState.aerial[enemyPlayer] = gameState.aerial[enemyPlayer].filter(unit => unit.id !== targetUnit.id);
              console.log(`After removal: ${enemyPlayer} has ${gameState.aerial[enemyPlayer].length} aerial units`);
              
      // Track unit loss in campaign stats
      trackUnitLoss(targetUnit);

              // Update aerial UI immediately after removal
              updateAerialPanel();
            } else {
              // Target damaged but not destroyed
              // Initialize health if not set (for artillery units)
              if (targetUnit.health === undefined) {
                targetUnit.health = targetUnit.defense;
              }
              const healthStatus = targetUnit.armour && targetUnit.armour > 0 ? 
                `(${targetUnit.health}/${targetUnit.defense} HP, ${targetUnit.armour} Armour remaining)` : 
                `(${targetUnit.health}/${targetUnit.defense} HP remaining)`;
              logZoneMessage(`${targetUnit.name} takes ${damage} damage! ${healthStatus}`, 'combat');
            }
          } else {
            // For non-aerial units (including artillery), use the normal applyDamage function
            // Initialize health for artillery units if not set
            if (targetUnit.type === 'artillery' && targetUnit.health === undefined) {
              targetUnit.health = targetUnit.defense;
            }
            const damageResult = applyDamage(targetUnit, damage, targetPos);
            console.log(' [AERIAL ATTACK] Unit destroyed result:', damageResult);
            console.log(' [AERIAL ATTACK] Target unit health after damage:', targetUnit.health);
            if (damageResult && damageResult.unitDestroyed) {
              console.log(' [AERIAL ATTACK] Unit was destroyed! Processing destruction...');
              logZoneMessage(`${targetUnit.name} has been destroyed by aerial attack! (Cost: ${gameState.cpCosts.attack} CP)`, 'combat');
              spendCP(gameState.cpCosts.attack);
              
              // Track unit loss for campaign stats (only once)
              trackUnitLoss(targetUnit);
              
              // Handle different target types
              if (targetUnit.type === 'artillery') {
              console.log(` [AERIAL DEBUG] Artillery unit destroyed: ${targetUnit.name} (ID: ${targetUnit.id})`);
              console.log(` [AERIAL DEBUG] Enemy player: ${enemyPlayer}`);
              console.log(` [AERIAL DEBUG] Artillery before removal:`, gameState.artillery[enemyPlayer]);
              
              // Aerial vs artillery combat - remove from artillery pool
              gameState.artillery[enemyPlayer] = gameState.artillery[enemyPlayer].filter(unit => unit.id !== targetUnit.id);
              console.log(` [AERIAL DEBUG] Artillery after removal:`, gameState.artillery[enemyPlayer]);
              
              // Also remove from tactical grid if present
              console.log(` [AERIAL DEBUG] Current zone detail:`, currentZoneDetail);
              console.log(` [AERIAL DEBUG] Searching tactical grid for artillery unit...`);
              let foundInGrid = false;
              for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
                if (currentZoneDetail.tacticalGrid[pos].unit && currentZoneDetail.tacticalGrid[pos].unit.id === targetUnit.id) {
                  console.log(` [AERIAL DEBUG] Found artillery in tactical grid at position ${pos}`);
                  currentZoneDetail.tacticalGrid[pos].unit = null;
                  foundInGrid = true;
                  console.log(` [AERIAL FIX] Removed destroyed artillery ${targetUnit.name} from tactical grid`);
                  break;
                }
              }
              if (!foundInGrid) {
                console.log(` [AERIAL DEBUG] Artillery unit ${targetUnit.name} was not found in tactical grid`);
              }
              
              // Update artillery UI
              updateArtilleryPanel();
              
              // Force battlefield update to ensure artillery is removed from display
              setTimeout(() => {
                console.log(' [AERIAL DEBUG] Forcing battlefield update after artillery destruction');
                generateMiniBattlefield();
                renderBattlefield();
              }, 50);
            } else {
              // Aerial vs ground combat - check if bomber or airship destroyed the unit
              if (aerialUnit.airUnitType === 'bomber' || aerialUnit.airUnitType === 'airship') {
                console.log(' [AERIAL] Bomber/Airship destroyed ground unit - checking for morale check');
                console.log(' [AERIAL] Target position:', targetPos);
                
                // Use the targetPos that was passed to applyDamage, or find it if not available
                let unitPosition = targetPos;
                if (unitPosition === null) {
                  // Find the unit's position in the tactical grid
                  for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
                    if (currentZoneDetail.tacticalGrid[pos].unit === targetUnit) {
                      unitPosition = pos;
                      console.log(' [AERIAL] Found destroyed unit at position', pos);
                      break;
                    }
                  }
                }
                
                if (unitPosition !== null) {
                  console.log(' [AERIAL] Performing morale check at position', unitPosition);
                  // Perform morale check for survival
                  performMoraleCheckForSurvival(targetUnit, unitPosition);
                } else {
                  console.log(' [AERIAL] Could not find unit position for morale check');
                  // Fallback: just remove from grid and update display
                  for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
                    if (currentZoneDetail.tacticalGrid[pos].unit === targetUnit) {
                      currentZoneDetail.tacticalGrid[pos].unit = null;
                      break;
                    }
                  }
                  
                  // Track unit loss for campaign stats
                  trackUnitLoss(targetUnit);
                  
                  generateMiniBattlefield();
                }
              } else {
                // Non-bomber aerial attack - just remove from grid
                for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
                  if (currentZoneDetail.tacticalGrid[pos].unit === targetUnit) {
                    currentZoneDetail.tacticalGrid[pos].unit = null;
                    break;
                  }
                }
                
                // Track unit loss for campaign stats
                trackUnitLoss(targetUnit);
                
                // Update battlefield display
                generateMiniBattlefield();
              }
            }
          } else {
            // Target damaged but not destroyed
            logZoneMessage(`${targetUnit.name} takes ${damage} damage! (${targetUnit.health}/${targetUnit.defense} HP remaining)`, 'combat');
          }
        }
      } else {
        logZoneMessage(`${targetUnit.name} survives the aerial attack! (Cost: ${gameState.cpCosts.attack} CP)`, 'combat');
        spendCP(gameState.cpCosts.attack);
      }
      
      // Mark aerial unit as used (prevent multiple attacks)
      const targetType = (targetUnit.type === 'fighter' || targetUnit.type === 'bomber' || targetUnit.type === 'airship') ? 'aerial' : 'ground';
      console.log(' [AIRSHIP DEBUG] Final target type determination:', targetType);
      console.log(' [AIRSHIP DEBUG] Target unit type:', targetUnit.type);
      markAerialAsUsed(aerialUnit, targetType);
      
      // Clear aerial targeting mode
      clearAerialTargetSelection();
      gameState.selectedAerialUnit = null;
      updateAerialPanel();
      
      // If a fighter was destroyed, check if bombers can now attack artillery
      if (targetUnit.type === 'fighter') {
        updateBomberArtilleryCapability();
      }
    });
  }
    

    
    function canUseAerial() {
      return getAvailableAerial().length > 0;
    }
    
    function updateBomberArtilleryCapability() {
      // Check if any bomber is currently selected
      if (gameState.selectedAerial && gameState.selectedAerial.type === 'bomber') {
        const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
        const enemyFighters = gameState.aerial[enemyPlayer].filter(unit => unit.type === 'fighter');
        
        const artilleryContainer = document.getElementById('artillery-units-container');
        if (artilleryContainer) {
          const artilleryUnits = artilleryContainer.querySelectorAll('.artillery-unit-card');
          artilleryUnits.forEach(card => {
            const attackBtn = card.querySelector('.aerial-attack-btn');
            if (attackBtn) {
              if (enemyFighters.length === 0) {
                attackBtn.style.display = 'block';
                console.log('Bomber can now attack artillery - no enemy fighters remain');
              } else {
                attackBtn.style.display = 'none';
              }
            }
          });
        }
        
        // Update instructions
        const aerialInstructions = document.getElementById('aerial-instructions');
        if (aerialInstructions) {
          let instructionText = `Selected: ${gameState.selectedAerial.name} (${gameState.selectedAerial.type}). Click attack buttons on enemy aerial units.`;
          
          if (enemyFighters.length === 0) {
            instructionText += ' Bombers can now attack artillery!';
          }
          
          aerialInstructions.textContent = instructionText;
        }
      }
    }
    
    // Separate Artillery Management System
    function initializeArtillerySystem() {
      console.log(' [ARTILLERY DEBUG] ==========================================');
      console.log(' [ARTILLERY DEBUG] INITIALIZE ARTILLERY SYSTEM CALLED');
      console.log(' [ARTILLERY DEBUG] ==========================================');
      
      // Initialize artillery for current player
      const currentPlayerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
      const currentPlayerArmies = gameData.selectedArmies[currentPlayerId] || [];
      
      console.log('Current Player ID:', currentPlayerId);
      console.log('Current Player armies:', currentPlayerArmies);
      
      // Only initialize artillery if it hasn't been initialized for this player yet
      if (!gameState.artillery[gameState.currentPlayer] || gameState.artillery[gameState.currentPlayer].length === 0) {
        console.log(' [ARTILLERY DEBUG] Initializing artillery for current player (not previously initialized)');
        
        // Clear existing artillery for current player
      gameState.artillery[gameState.currentPlayer] = [];
      
              // Extract artillery units from current player's selected armies
        let currentPlayerArtilleryCount = 0;
        currentPlayerArmies.forEach(army => {
          console.log('Processing current player army:', army.name);
        const artilleryUnits = army.units.filter(unit => unit.type === 'artillery');
          console.log('Artillery units in current player army:', artilleryUnits);
        
        artilleryUnits.forEach(artillery => {
            console.log('Adding artillery unit to current player:', artillery.name, 'with hitChance:', artillery.hitChance);
          addArtilleryToPlayer({
            ...artillery,
            id: `${artillery.id}_${Date.now()}_${Math.random()}`, // Unique ID
            player: gameState.currentPlayer,
            armyId: army.id
          });
            currentPlayerArtilleryCount++;
        });
      });
      
        console.log('Current player artillery count:', currentPlayerArtilleryCount);
        console.log('Current player artillery state:', gameState.artillery[gameState.currentPlayer]);
      } else {
        console.log(' [ARTILLERY DEBUG] Artillery already initialized for current player, preserving existing state');
      }
      
      // Initialize artillery for enemy player
      const enemyPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
      const enemyPlayerId = enemyPlayer === 'red' ? 'player1' : 'player2';
      const enemyPlayerArmies = gameData.selectedArmies[enemyPlayerId] || [];
      
      console.log('Enemy Player ID:', enemyPlayerId);
      console.log('Enemy Player armies:', enemyPlayerArmies);
      
      // Only initialize artillery if it hasn't been initialized for this enemy player yet
      if (!gameState.artillery[enemyPlayer] || gameState.artillery[enemyPlayer].length === 0) {
        console.log(' [ARTILLERY DEBUG] Initializing artillery for enemy player (not previously initialized)');
        
        // Clear existing artillery for enemy player
        gameState.artillery[enemyPlayer] = [];
      
              // Extract artillery units from enemy player's selected armies
        let enemyPlayerArtilleryCount = 0;
        enemyPlayerArmies.forEach(army => {
          console.log('Processing enemy player army:', army.name);
          const artilleryUnits = army.units.filter(unit => unit.type === 'artillery');
          console.log('Artillery units in enemy player army:', artilleryUnits);
          
          artilleryUnits.forEach(artillery => {
            console.log('Adding artillery unit to enemy player:', artillery.name, 'with hitChance:', artillery.hitChance);
            // Add to enemy player's artillery pool
            if (!gameState.artillery[enemyPlayer]) {
              gameState.artillery[enemyPlayer] = [];
            }
            // Initialize targetHistory for precision ability
            const artilleryWithHistory = {
              ...artillery,
              id: `${artillery.id}_${Date.now()}_${Math.random()}`, // Unique ID
              player: enemyPlayer,
              armyId: army.id
            };
            
            if (artilleryWithHistory.special === 'precision' && !artilleryWithHistory.targetHistory) {
              artilleryWithHistory.targetHistory = {};
            }
            
            gameState.artillery[enemyPlayer].push(artilleryWithHistory);
            enemyPlayerArtilleryCount++;
          });
        });
        
        console.log('Enemy player artillery count:', enemyPlayerArtilleryCount);
        console.log('Enemy player artillery state:', gameState.artillery[enemyPlayer]);
      } else {
        console.log(' [ARTILLERY DEBUG] Artillery already initialized for enemy player, preserving existing state');
      }
      
      // Track artillery units as deployed (only if we actually initialized new artillery)
      if (!gameState.campaignStats) {
        gameState.campaignStats = {
          red: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          },
          blue: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          }
        };
      }
      
      // Only add to campaign stats if we actually initialized new artillery
      if (gameState.artillery[gameState.currentPlayer] && gameState.artillery[gameState.currentPlayer].length > 0) {
        const currentPlayerArtilleryCount = gameState.artillery[gameState.currentPlayer].length;
        console.log(' [ARTILLERY DEPLOYMENT] Before artillery deployment tracking - Current Player:', gameState.currentPlayer, 'Stats:', gameState.campaignStats[gameState.currentPlayer]);
        console.log(' [ARTILLERY DEPLOYMENT] Artillery units to deploy:', currentPlayerArtilleryCount);
        
        gameState.campaignStats[gameState.currentPlayer].unitsDeployed += currentPlayerArtilleryCount;
        
        console.log(' [ARTILLERY DEPLOYMENT] After artillery deployment tracking - Current Player:', gameState.currentPlayer, 'Stats:', gameState.campaignStats[gameState.currentPlayer]);
      }
      if (gameState.artillery[enemyPlayer] && gameState.artillery[enemyPlayer].length > 0) {
        const enemyPlayerArtilleryCount = gameState.artillery[enemyPlayer].length;
        console.log(' [ARTILLERY DEPLOYMENT] Before artillery deployment tracking - Enemy Player:', enemyPlayer, 'Stats:', gameState.campaignStats[enemyPlayer]);
        console.log(' [ARTILLERY DEPLOYMENT] Artillery units to deploy:', enemyPlayerArtilleryCount);
        
        gameState.campaignStats[enemyPlayer].unitsDeployed += enemyPlayerArtilleryCount;
        
        console.log(' [ARTILLERY DEPLOYMENT] After artillery deployment tracking - Enemy Player:', enemyPlayer, 'Stats:', gameState.campaignStats[enemyPlayer]);
      }
      
      // Update artillery UI immediately
      updateArtilleryPanel();
      console.log('=== END INITIALIZE ARTILLERY SYSTEM ===');
      
      // Add click handler to deselect artillery when clicking outside
      const zoneDetailScreen = document.getElementById('zone-detail');
      if (zoneDetailScreen) {
        zoneDetailScreen.addEventListener('click', (e) => {
          // If clicking on the zone detail screen but not on artillery or aerial elements, deselect artillery
          // Don't deselect if clicking on artillery panel elements or aerial panel elements
          if (!e.target.closest('.artillery-panel') && !e.target.closest('.aerial-panel') && !e.target.closest('.mini-battlefield')) {
            deselectArtillery();
          }
        });
      }
    }
    
    function getAvailableArtillery() {
      // Ensure artilleryActions is initialized
      if (!gameState.artilleryActions) {
        gameState.artilleryActions = {};
      }
      
      return getPlayerArtillery().filter(artillery => {
        return !gameState.artilleryActions[artillery.id]?.usedThisTurn;
      });
    }
    
    function markArtilleryAsUsed(artilleryId) {
      if (!gameState.artilleryActions) {
        gameState.artilleryActions = {};
      }
      if (!gameState.artilleryActions[artilleryId]) {
        gameState.artilleryActions[artilleryId] = {};
      }
      gameState.artilleryActions[artilleryId].usedThisTurn = true;
    }
    
    function resetArtilleryUsage() {
      if (gameState.artilleryActions) {
        Object.keys(gameState.artilleryActions).forEach(artilleryId => {
          if (gameState.artilleryActions[artilleryId]) {
            gameState.artilleryActions[artilleryId].usedThisTurn = false;
          }
        });
      }
    }
    
    function useArtilleryAttack(targetZoneId) {
      const artillery = getPlayerArtillery();
      if (artillery.length === 0) {
        logMessage('No artillery available', 'system');
        return;
      }
      
      if (!canSpendCP(gameState.cpCosts.artilleryAttack)) {
        logMessage(`Not enough Command Points for artillery attack (need ${gameState.cpCosts.artilleryAttack} CP)`, 'system');
        return;
      }
      
      const targetZone = zones.find(z => z.id === targetZoneId);
      if (!targetZone) {
        logMessage('Target zone not found', 'system');
        return;
      }
      
      // Use the first available artillery
      const selectedArtillery = artillery[0];
      const hitChance = selectedArtillery.hitChance || 9; // Default hit chance is 9+
      
      // Check weather restrictions for artillery
      if (!applyWeatherRestrictions(selectedArtillery, 'artillery')) {
        logMessage('Artillery cannot fire due to adverse weather conditions!', 'system');
        return;
      }
      
      // Spend CP
      spendCP(gameState.cpCosts.artilleryAttack);
      
      // Show artillery animation with new "Rains of Hell" system
      showArtilleryAnimation(selectedArtillery, targetZone, hitChance, (success, roll, target, damage) => {
        if (success) {
          // Artillery hits - damage all enemy units in the zone
          let damageDealt = 0;
          let hiddenUnitsRevealed = 0;
          
          for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
            const unit = targetZone.tacticalGrid[pos].unit;
            if (unit && unit.player !== gameState.currentPlayer) {
              // Reveal hidden stealth units when artillery hits
              if (unit.special === 'stealth' && !unit.permanentlyUnhidden) {
                unit.permanentlyUnhidden = true;
                hiddenUnitsRevealed++;
                logMessage(`${unit.name} is revealed by "The Rains of Hell"!`, 'combat');
              }
              
              // Use the calculated damage from the combat system
              const artilleryDamage = damage || selectedArtillery.attack || 2;
              damageDealt += artilleryDamage;
              
              const damageResult = applyDamage(unit, artilleryDamage, pos);
              if (damageResult && damageResult.unitDestroyed) {
                logMessage(`${unit.name} eliminated by "The Rains of Hell"!`, 'combat');
                // Track unit loss for summary
                trackUnitLoss(unit);
                
                // Perform morale check for survival if unit was destroyed
                if (unit.health <= 0) {
                  performMoraleCheckForSurvival(unit, pos);
                }
              } else {
                logMessage(`${unit.name} takes ${artilleryDamage} damage from "The Rains of Hell"!`, 'combat');
              }
            }
          }
          
          if (hiddenUnitsRevealed > 0) {
            logMessage(`"The Rains of Hell" revealed ${hiddenUnitsRevealed} hidden unit(s)!`, 'combat');
          }
          
          if (damageDealt > 0) {
            const zoneName = zoneNames[targetZone.name] || targetZone.name;
            logMessage(`"The Rains of Hell" devastates Zone ${zoneName} for ${damageDealt} total damage!`, 'combat');
          } else {
            const zoneName = zoneNames[targetZone.name] || targetZone.name;
            logMessage(`"The Rains of Hell" strikes Zone ${zoneName} but no enemy units were present!`, 'combat');
          }
          
          // Update battlefield display
          renderBattlefield();
        } else {
          // Artillery misses
          const zoneName = zoneNames[targetZone.name] || targetZone.name;
          logMessage(`"The Rains of Hell" misses Zone ${zoneName}!`, 'combat');
        }
        
        // Mark artillery as used
        selectedArtillery.used = true;
        
        // Update artillery UI
        updateArtilleryPanel();
        
        // Clear artillery selection
        gameState.artilleryMode = false;
        gameState.selectedArtillery = null;
      });
    }
  
    
    // Update Artillery UI
    function updateArtilleryUI() {
      const artillery = getPlayerArtillery();
      const artillerySection = document.getElementById('artillery-section');
      const artilleryCount = document.getElementById('artillery-count');
      
      if (artillerySection && artilleryCount) {
        if (artillery.length > 0 && canUseArtillery()) {
          artillerySection.style.display = 'block';
          artilleryCount.textContent = artillery.length;
        } else {
          artillerySection.style.display = 'none';
        }
      }
      
      // Update the new artillery panel
      updateArtilleryPanel();
    }
    
    // Update the new artillery panel
    function updateArtilleryPanel() {
      console.log(' [ARTILLERY DEBUG] ==========================================');
      console.log(' [ARTILLERY DEBUG] UPDATE ARTILLERY PANEL CALLED');
      console.log(' [ARTILLERY DEBUG] ==========================================');
      
      try {
      // Only update if we're in the zone-detail screen
      const zoneDetailScreen = document.getElementById('zone-detail');
        console.log(' [ARTILLERY DEBUG] Zone detail screen found:', !!zoneDetailScreen);
        console.log(' [ARTILLERY DEBUG] Zone detail screen display:', zoneDetailScreen?.style.display);
        
      if (!zoneDetailScreen || zoneDetailScreen.style.display === 'none') {
          console.log(' [ARTILLERY DEBUG] Not in zone-detail screen, skipping artillery panel update');
        return;
      }
      
      const artilleryPanel = document.querySelector('.artillery-panel');
      const artilleryStatus = document.getElementById('artillery-status');
      const artilleryContent = document.getElementById('artillery-panel-content');
      const artilleryContainer = document.getElementById('artillery-units-container');
      const artilleryInstructions = document.getElementById('artillery-instructions');
      
      console.log(' [ARTILLERY DEBUG] Artillery panel elements found:');
      console.log(' [ARTILLERY DEBUG] - Panel:', !!artilleryPanel);
      console.log(' [ARTILLERY DEBUG] - Status:', !!artilleryStatus);
      console.log(' [ARTILLERY DEBUG] - Content:', !!artilleryContent);
      console.log(' [ARTILLERY DEBUG] - Container:', !!artilleryContainer);
      console.log(' [ARTILLERY DEBUG] - Instructions:', !!artilleryInstructions);
      
      if (artilleryPanel) {
        console.log(' [ARTILLERY DEBUG] Artillery panel display:', artilleryPanel.style.display);
        console.log(' [ARTILLERY DEBUG] Artillery panel classes:', artilleryPanel.className);
      }
      
      if (!artilleryPanel) {
        console.error('Artillery panel not found!');
        return;
      }
      
      // Always show the artillery panel, even if no artillery is available
      artilleryPanel.style.display = 'block';
      
      // Apply player color classes
      artilleryPanel.classList.remove('red-player', 'blue-player');
      if (gameState.currentPlayer === 'red') {
        artilleryPanel.classList.add('red-player');
      } else {
        artilleryPanel.classList.add('blue-player');
      }
      
      const availableArtillery = getAvailableArtillery();
      const totalArtillery = getPlayerArtillery();
      const enemyArtillery = getEnemyArtillery();
      
      console.log(' [ARTILLERY DEBUG] Artillery data:');
      console.log(' [ARTILLERY DEBUG] - Total artillery:', totalArtillery.length);
      console.log(' [ARTILLERY DEBUG] - Available artillery:', availableArtillery.length);
      console.log(' [ARTILLERY DEBUG] - Enemy artillery:', enemyArtillery.length);
      console.log(' [ARTILLERY DEBUG] - Total artillery details:', totalArtillery);
      console.log(' [ARTILLERY DEBUG] - Enemy artillery details:', enemyArtillery);
      
      // Update status
      if (artilleryStatus) {
        if (totalArtillery.length === 0) {
          artilleryStatus.textContent = 'No artillery available';
        } else if (availableArtillery.length === 0) {
          artilleryStatus.textContent = 'All artillery used this turn';
        } else {
          artilleryStatus.textContent = `${availableArtillery.length}/${totalArtillery.length} artillery available`;
        }
      }
      
      // Show/hide content based on artillery availability (including enemy artillery)
      if (artilleryContent) {
        console.log(' [ARTILLERY DEBUG] Total artillery:', totalArtillery.length);
        console.log(' [ARTILLERY DEBUG] Available artillery:', availableArtillery.length);
        console.log(' [ARTILLERY DEBUG] Enemy artillery:', enemyArtillery.length);
        console.log(' [ARTILLERY DEBUG] Artillery content element found:', !!artilleryContent);
        console.log(' [ARTILLERY DEBUG] Artillery content display:', artilleryContent.style.display);
        
        // Show panel if there's any artillery (friendly or enemy)
        if (totalArtillery.length > 0 || enemyArtillery.length > 0) {
          artilleryContent.style.display = 'block';
          console.log(' [ARTILLERY DEBUG] Showing artillery content');
          loadArtilleryUnitsToPanel();
        } else {
          artilleryContent.style.display = 'none';
          console.log(' [ARTILLERY DEBUG] Hiding artillery content - no artillery');
        }
      } else {
        console.error(' [ARTILLERY DEBUG] Artillery content element not found!');
      }
      
      // Update instructions
      if (artilleryInstructions) {
        if (gameState.artilleryMode && gameState.selectedArtillery) {
          artilleryInstructions.textContent = `Selected: ${gameState.selectedArtillery.name}. Click on a zone to fire!`;
        } else if (availableArtillery.length > 0) {
          artilleryInstructions.textContent = 'Click an artillery unit to select it for firing';
        } else {
          artilleryInstructions.textContent = 'All artillery has been used this turn';
        }
      }
    } catch (error) {
      console.error(' [ARTILLERY DEBUG] Error in updateArtilleryPanel:', error);
      }
    }
    
    // Load artillery units to the new panel
    function loadArtilleryUnitsToPanel() {
      console.log(' [ARTILLERY DEBUG] ==========================================');
      console.log(' [ARTILLERY DEBUG] LOAD ARTILLERY UNITS TO PANEL CALLED');
      console.log(' [ARTILLERY DEBUG] ==========================================');
      
      const container = document.getElementById('artillery-units-container');
      console.log(' [ARTILLERY DEBUG] Artillery container found:', !!container);
      
      if (!container) {
        console.error(' [ARTILLERY DEBUG] Artillery container not found!');
        return;
      }
      
      const totalArtillery = getPlayerArtillery();
      const availableArtillery = getAvailableArtillery();
      const enemyArtillery = getEnemyArtillery();
      
      console.log('Loading artillery units to panel:', totalArtillery);
      console.log('Enemy artillery units:', enemyArtillery);
      
      container.innerHTML = '';
      
      // Set player colors
      const currentPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player1.color : gameConfig.player2.color;
      const enemyPlayerColor = gameState.currentPlayer === 'red' ? gameConfig.player2.color : gameConfig.player1.color;
      
      const currentPlayerColorRgb = hexToRgb(currentPlayerColor);
      const enemyPlayerColorRgb = hexToRgb(enemyPlayerColor);
      
      // Add friendly artillery units section
      if (totalArtillery.length > 0) {
        const friendlySection = document.createElement('div');
        friendlySection.className = 'artillery-section';
        friendlySection.style.setProperty('--player-color', currentPlayerColor);
        friendlySection.style.setProperty('--player-color-rgb', currentPlayerColorRgb);
        friendlySection.innerHTML = `<h4>Your Artillery</h4>`;
      
      totalArtillery.forEach((artillery, index) => {
        const isAvailable = availableArtillery.some(a => a.id === artillery.id);
        const isSelected = gameState.selectedArtillery && gameState.selectedArtillery.id === artillery.id;
          
          console.log(` [ARTILLERY DEBUG] Artillery ${artillery.name} (ID: ${artillery.id}): isAvailable=${isAvailable}, isSelected=${isSelected}`);
        
        const artilleryDiv = document.createElement('div');
          artilleryDiv.className = 'artillery-unit-card friendly-artillery';
        artilleryDiv.id = `artillery-panel-${index}`;
        
        if (!isAvailable) {
          artilleryDiv.classList.add('used');
        }
        if (isSelected) {
          artilleryDiv.classList.add('selected');
        }
        
        artilleryDiv.innerHTML = `
          <div class="artillery-unit-name">${artillery.name}</div>
          <div class="artillery-unit-stats">
            <div>ATK: ${artillery.attack >= 0 ? '+' : ''}${artillery.attack}</div>
            <div>HP: ${artillery.defense}</div>
            <div>HIT: ${artillery.hitChance || 9}+</div>
            <div style="font-size: 10px; color: ${isAvailable ? '#32CD32' : '#FF4500'};">
              ${isAvailable ? 'Available' : 'Used'}
            </div>
          </div>
          <button class="aerial-attack-btn" data-artillery-id="${artillery.id}" style="display: none;">Attack</button>
        `;
        
        if (isAvailable) {
          artilleryDiv.onclick = (e) => {
            console.log(' [ARTILLERY DEBUG] Artillery clicked:', artillery.name, 'ID:', artillery.id);
            e.stopPropagation(); // Prevent event from bubbling up to global handler
            
            // If this artillery is already selected, deselect it
            if (gameState.selectedArtillery && gameState.selectedArtillery.id === artillery.id) {
              console.log(' [ARTILLERY DEBUG] Deselecting artillery');
              gameState.selectedArtillery = null;
              gameState.artilleryMode = false;
              updateArtilleryPanel();
              logZoneMessage('Artillery deselected', 'system');
            } else {
              // Otherwise, select it for firing
              console.log(' [ARTILLERY DEBUG] Selecting artillery for firing');
              selectArtilleryForFiring(index);
            }
          };
        } else {
          console.log(' [ARTILLERY DEBUG] Artillery not available, no click handler set');
        }
        
        // Add click handler for aerial attack button
        const attackBtn = artilleryDiv.querySelector('.aerial-attack-btn');
        if (attackBtn) {
          attackBtn.onclick = (e) => {
            e.stopPropagation();
            fireAerialAtUnit(artillery);
          };
        }
        
        friendlySection.appendChild(artilleryDiv);
        });
        
        container.appendChild(friendlySection);
      }
      
      // Add enemy artillery units section
      if (enemyArtillery.length > 0) {
        const enemySection = document.createElement('div');
        enemySection.className = 'artillery-section';
        enemySection.style.setProperty('--enemy-color', enemyPlayerColor);
        enemySection.style.setProperty('--enemy-color-rgb', enemyPlayerColorRgb);
        enemySection.innerHTML = `<h4>Enemy Artillery</h4>`;
        
        enemyArtillery.forEach((artillery, index) => {
          const artilleryDiv = document.createElement('div');
          artilleryDiv.className = 'artillery-unit-card enemy-artillery';
          artilleryDiv.id = `enemy-artillery-panel-${index}`;
          
          // Ensure unit has health property
          const currentHealth = typeof artillery.health !== 'undefined' ? artillery.health : artillery.defense;
          const maxHealth = typeof artillery.maxHealth !== 'undefined' ? artillery.maxHealth : artillery.defense;
          
          artilleryDiv.innerHTML = `
            <div class="artillery-unit-name">${artillery.name}</div>
            <div class="artillery-unit-stats">
              <div>ATK: ${artillery.attack >= 0 ? '+' : ''}${artillery.attack}</div>
              <div>HP: ${currentHealth}/${maxHealth}</div>
              <div>HIT: ${artillery.hitChance || 9}+</div>
              <div style="font-size: 10px; color: #FF4500;">
                Enemy Unit
              </div>
            </div>
          `;
          
          // Add click handler for aerial attacks on enemy artillery
          artilleryDiv.onclick = () => {
            if (gameState.selectedAerialUnit && (gameState.selectedAerialUnit.airUnitType === 'bomber' || gameState.selectedAerialUnit.airUnitType === 'airship')) {
              console.log(' [AERIAL] Bomber/Airship targeting enemy artillery:', artillery.name);
              // Trigger aerial attack on this artillery unit
              handleAerialAttackOnUnit(artillery);
            }
          };
          
          enemySection.appendChild(artilleryDiv);
        });
        
        container.appendChild(enemySection);
      }
    }
    
    // Select artillery for firing
    function selectArtilleryForFiring(index) {
      console.log(' [ARTILLERY DEBUG] selectArtilleryForFiring called with index:', index);
      
      const totalArtillery = getPlayerArtillery();
      console.log(' [ARTILLERY DEBUG] Total artillery:', totalArtillery.length);
      
      if (index >= totalArtillery.length) {
        console.log(' [ARTILLERY DEBUG] Index out of range');
        return;
      }
      
      const selectedArtillery = totalArtillery[index];
      console.log(' [ARTILLERY DEBUG] Selected artillery:', selectedArtillery.name, 'ID:', selectedArtillery.id);
      
      // Check if artillery is available
      const availableArtillery = getAvailableArtillery();
      console.log(' [ARTILLERY DEBUG] Available artillery:', availableArtillery.length);
      console.log(' [ARTILLERY DEBUG] Artillery actions:', gameState.artilleryActions);
      
      if (!availableArtillery.some(a => a.id === selectedArtillery.id)) {
        console.log(' [ARTILLERY DEBUG] Artillery not available - already used this turn');
        logZoneMessage(`${selectedArtillery.name} has already been used this turn`, 'system');
        return;
      }
      
      // Check CP cost
      if (!canSpendCP(gameState.cpCosts.artilleryAttack)) {
        console.log(' [ARTILLERY DEBUG] Not enough CP');
        logZoneMessage(`Not enough Command Points for artillery attack (need ${gameState.cpCosts.artilleryAttack} CP)`, 'system');
        return;
      }
      
      // Set artillery mode
      gameState.selectedArtillery = selectedArtillery;
      gameState.artilleryMode = true;
      
      console.log(' [ARTILLERY DEBUG] Artillery mode set:', gameState.artilleryMode);
      console.log(' [ARTILLERY DEBUG] Selected artillery:', gameState.selectedArtillery);
      
      // Update UI
      updateArtilleryPanel();
      
      logZoneMessage(`${selectedArtillery.name} selected for artillery barrage. Click on any zone to fire!`, 'system');
    }
    

    
    // Deselect artillery
    function deselectArtillery() {
      if (gameState.selectedArtillery) {
        gameState.selectedArtillery = null;
        gameState.artilleryMode = false;
        updateArtilleryPanel();
        logZoneMessage('Artillery deselected', 'system');
      }
    }
    
    // Fire artillery at a specific zone
    function fireArtilleryAtZone(zoneId, targetPos) {
      console.log(' [ARTILLERY DEBUG] fireArtilleryAtZone called with zoneId:', zoneId, 'targetPos:', targetPos);
      console.log(' [ARTILLERY DEBUG] Selected artillery:', gameState.selectedArtillery);
      console.log(' [ARTILLERY DEBUG] Artillery mode:', gameState.artilleryMode);
      
      if (!gameState.selectedArtillery) {
        console.log(' [ARTILLERY DEBUG] No artillery selected');
        logZoneMessage('No artillery selected', 'system');
        return;
      }
      
      const targetZone = zones.find(z => z.id === zoneId);
      if (!targetZone) {
        logZoneMessage('Target zone not found', 'system');
        return;
      }
      
      let hitChance = gameState.selectedArtillery.hitChance || 9;
      
              // Apply precision ability for artillery
        if (gameState.selectedArtillery.special === 'precision') {
          console.log(` [PRECISION DEBUG] Starting precision check for artillery:`, gameState.selectedArtillery.name);
          console.log(` [PRECISION DEBUG] Initial hitChance:`, hitChance);
          
          if (!gameState.selectedArtillery.targetHistory) {
            console.log(` [PRECISION DEBUG] No target history found, initializing empty object`);
            gameState.selectedArtillery.targetHistory = {};
          }
          
          // Create a unique target identifier using zone ID + tile position
          const targetKey = `${zoneId}_${targetPos}`;
          console.log(` [PRECISION DEBUG] Target key:`, targetKey);
          
          // Reset all other target counts and increment current target
          console.log(` [PRECISION DEBUG] Before reset - targetHistory:`, JSON.stringify(gameState.selectedArtillery.targetHistory, null, 2));
          Object.keys(gameState.selectedArtillery.targetHistory).forEach(existingTargetKey => {
            if (existingTargetKey !== targetKey) {
              console.log(` [PRECISION DEBUG] Deleting target history for ${existingTargetKey} (different from current target ${targetKey})`);
              delete gameState.selectedArtillery.targetHistory[existingTargetKey];
            }
          });
          
          const previousCount = gameState.selectedArtillery.targetHistory[targetKey] || 0;
          gameState.selectedArtillery.targetHistory[targetKey] = previousCount + 1;
          console.log(` [PRECISION DEBUG] Previous attacks on this target:`, previousCount);
          console.log(` [PRECISION DEBUG] New attack count:`, gameState.selectedArtillery.targetHistory[targetKey]);
          console.log(` [PRECISION DEBUG] After reset - targetHistory:`, JSON.stringify(gameState.selectedArtillery.targetHistory, null, 2));
        
        const consecutiveAttacks = gameState.selectedArtillery.targetHistory[targetKey];
        console.log(` [PRECISION DEBUG] Consecutive attacks on target ${targetKey}: ${consecutiveAttacks}`);
        if (consecutiveAttacks >= 2) {
          const bonus = Math.min(consecutiveAttacks - 1, 3);
          const originalHitChance = hitChance;
          hitChance -= bonus; // Lower hitChance means easier to hit (e.g., 9 becomes 8, then 7, etc.)
          console.log(` [PRECISION DEBUG] Precision bonus calculation:`);
          console.log(`  - Original hitChance: ${originalHitChance}`);
          console.log(`  - Consecutive attacks: ${consecutiveAttacks}`);
          console.log(`  - Raw bonus (attacks - 1): ${consecutiveAttacks - 1}`);
          console.log(`  - Capped bonus (min of raw, 3): ${bonus}`);
          console.log(`  - Final hitChance (original - bonus): ${hitChance}`);
          logZoneMessage(`${gameState.selectedArtillery.name} gains +${bonus} accuracy from Precision (${consecutiveAttacks} consecutive attacks on same target)!`, 'combat');
        } else {
          console.log(` [PRECISION DEBUG] No precision bonus applied (consecutive attacks: ${consecutiveAttacks})`);
        }
      }
      
      console.log('Firing artillery:', gameState.selectedArtillery.name, 'with hitChance:', hitChance, 'from unit:', gameState.selectedArtillery);
      
      // Check if the specific target tile has a unit in a bunker
      const targetUnit = targetZone.tacticalGrid[targetPos].unit;
      const targetGridData = targetZone.tacticalGrid[targetPos];
      
      if (targetUnit && targetUnit.player !== gameState.currentPlayer) {
        if (targetGridData.construction && targetGridData.construction.completed && 
            targetGridData.construction.type === 'bunker' && 
            constructionOptions.bunker.effects.artilleryImmune) {
          const zoneName = zoneNames[targetZone.name] || targetZone.name;
          logZoneMessage(`Artillery attack blocked - ${targetUnit.name} in Zone ${zoneName} is protected by bunker!`, 'combat');
          logMessage(`INTELLIGENCE: ${gameState.selectedArtillery.name} attempted to shell ${targetUnit.name} but it is protected by bunker fortification.`, 'intelligence');
          
          // Reset artillery mode without spending CP or marking as used
          gameState.selectedArtillery = null;
          gameState.artilleryMode = false;
          updateArtilleryPanel();
          return;
        }
      }
      
      // Check weather restrictions for artillery
      if (!applyWeatherRestrictions(gameState.selectedArtillery, 'artillery')) {
        logZoneMessage('Artillery cannot fire due to adverse weather conditions!', 'system');
        // Reset artillery mode without spending CP or marking as used
        gameState.selectedArtillery = null;
        gameState.artilleryMode = false;
        updateArtilleryPanel();
        return;
      }
      
      // Spend CP
      spendCP(gameState.cpCosts.artilleryAttack);
      
      // Mark artillery as used this turn
      markArtilleryAsUsed(gameState.selectedArtillery.id);
      
      // Show artillery animation with new "Rains of Hell" system
      showArtilleryAnimation(gameState.selectedArtillery, targetZone, hitChance, targetPos, (success, roll, target, damage) => {
        console.log(' [ARTILLERY DEBUG] Artillery callback executed with success:', success, 'roll:', roll, 'target:', target, 'damage:', damage);
        
        if (success) {
          // Artillery hits - damage only the specific tile targeted
          let damageDealt = 0;
          let hiddenUnitsRevealed = 0;
          
          // Only target the specific tile position
          const unit = targetZone.tacticalGrid[targetPos].unit;
          if (unit && unit.player !== gameState.currentPlayer) {
            // Check if unit is in a bunker (immune to artillery)
            const gridData = targetZone.tacticalGrid[targetPos];
            if (gridData.construction && gridData.construction.completed && 
                gridData.construction.type === 'bunker' && 
                constructionOptions.bunker.effects.artilleryImmune) {
              logZoneMessage(`${unit.name} is protected by bunker - "The Rains of Hell" blocked!`, 'combat');
              logMessage(`INTELLIGENCE: ${unit.name} was protected from "The Rains of Hell" by bunker fortification.`, 'intelligence');
            } else {
              // Reveal hidden stealth units when artillery hits
              if (unit.special === 'stealth' && !unit.permanentlyUnhidden) {
                unit.permanentlyUnhidden = true;
                hiddenUnitsRevealed++;
                logZoneMessage(`${unit.name} is revealed by "The Rains of Hell"!`, 'combat');
              }
              
              // Use the calculated damage from the combat system
              const artilleryDamage = damage || 2;
              console.log(` [ARTILLERY DEBUG] "The Rains of Hell" deals ${artilleryDamage} damage to ${unit.name} at tile ${targetPos}`);
              const damageResult = applyDamage(unit, artilleryDamage, targetPos);
              damageDealt += artilleryDamage;
              
              if (damageResult && damageResult.unitDestroyed) {
                logZoneMessage(`${unit.name} eliminated by "The Rains of Hell"!`, 'combat');
                // Track unit loss for summary
                trackUnitLoss(unit);
                
                // Perform morale check for survival if unit was destroyed
                if (unit.health <= 0) {
                  performMoraleCheckForSurvival(unit, targetPos);
                }
              } else {
                logZoneMessage(`${unit.name} takes ${artilleryDamage} damage from "The Rains of Hell"!`, 'combat');
              }
            }
          } else if (!unit) {
            logZoneMessage(`"The Rains of Hell" strikes an empty position!`, 'combat');
          } else {
            logZoneMessage(`"The Rains of Hell" strikes a friendly unit - no damage dealt!`, 'combat');
          }
          
          if (hiddenUnitsRevealed > 0) {
            logZoneMessage(`"The Rains of Hell" revealed ${hiddenUnitsRevealed} hidden unit(s)!`, 'combat');
          }
          
            const zoneName = zoneNames[targetZone.name] || targetZone.name;
          
          if (damageDealt > 0) {
            logZoneMessage(`"The Rains of Hell" devastates the target position for ${damageDealt} damage!`, 'combat');
          } else {
            logZoneMessage(`"The Rains of Hell" strikes the target position but no enemy units were present!`, 'combat');
          }
        } else {
          logZoneMessage(`"The Rains of Hell" misses the target!`, 'combat');
        }
        
        // Reset artillery mode
        gameState.selectedArtillery = null;
        gameState.artilleryMode = false;
        
        // Update UI
        updateArtilleryPanel();
        generateMiniBattlefield();
      });
    }
    
    // Update artillery selection UI
    function updateArtillerySelection() {
      // Clear previous selections
      const artilleryCards = document.querySelectorAll('.artillery-unit-card');
      artilleryCards.forEach(card => card.classList.remove('selected'));
      
      // Highlight selected artillery
      if (gameState.selectedArtillery) {
        const artillery = getPlayerArtillery();
        const index = artillery.findIndex(a => a.id === gameState.selectedArtillery.id);
        if (index >= 0) {
          const selectedCard = document.getElementById(`artillery-${index}`);
          if (selectedCard) {
            selectedCard.classList.add('selected');
          }
        }
      }
    }
    
    function updateArmyPoolStats() {
      const statsElement = document.getElementById('army-pool-count');
      if (statsElement) {
        const selectedArmyData = gameState.selectedArmyInZone[gameState.currentPlayer];
        if (!selectedArmyData) {
          statsElement.textContent = '0';
          return;
        }
        
        // Count only non-artillery and non-aerial units
        // Field guns can be deployed on the grid (they have movement values)
        const deployableUnits = selectedArmyData.army.units.filter(unit => 
          unit.type !== 'artillery' && unit.type !== 'fighter' && unit.type !== 'bomber'
        );
        const totalUnits = deployableUnits.length;
        const deployedFromArmy = getDeployedUnitsFromArmy(selectedArmyData.army.id, gameState.currentPlayer === 'red' ? 'player1' : 'player2').length;
        const availableInZone = totalUnits - deployedFromArmy;
        
        statsElement.textContent = availableInZone;
      }
    }
    

    
    function resolveTacticalCombat() {
      logZoneMessage('Resolving tactical combat...');
      
      // Count remaining units for each side
      let redUnits = 0, blueUnits = 0;
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = currentZoneDetail.tacticalGrid[pos].unit;
        if (unit) {
          if (unit.player === 'red') redUnits++;
          else blueUnits++;
        }
      }
      
      // Determine zone control
      if (redUnits > blueUnits) {
        currentZoneDetail.control = 'red';
        const zoneName = zoneNames[currentZoneDetail.name] || currentZoneDetail.name;
        logMessage(`Zone ${zoneName} captured by ${gameConfig.player1.name}!`, 'combat');
      } else if (blueUnits > redUnits) {
        currentZoneDetail.control = 'blue';
        logMessage(`Zone ${zoneName} captured by ${gameConfig.player2.name}!`, 'combat');
      } else {
        currentZoneDetail.control = 'contested';
        logMessage(`Zone ${zoneName} remains contested!`, 'combat');
      }
      
      // Unlock zone and return to main battlefield
      currentZoneDetail.locked = false;
      
      // Remove zone from locked zones for both players
      gameState.lockedZones.red = gameState.lockedZones.red.filter(z => z !== currentZoneDetail.id);
      gameState.lockedZones.blue = gameState.lockedZones.blue.filter(z => z !== currentZoneDetail.id);
      
      // Update zone CP bonuses after zone control change
      updateZoneCPBonuses();
      
      // Don't reset current player - let the normal turn progression continue
      // The current player should remain as it was when the zone battle started
      
      showScreen('game');
      renderBattlefield();
      checkWinCondition();
      
      // Send update to other players in multiplayer (only if not updating from server)
      if (isMultiplayerMode && !isUpdatingFromServer) {
        sendBattlefieldUpdate();
      }
    }
    
    function logZoneMessage(message, type = 'system') {
      const log = document.getElementById('zone-log');
      if (!log) {
        console.log(' [INTELLIGENCE DEBUG] zone-log element not found');
        return;
      }
      
      // DEBUG: Log Intelligence Report panel state before adding message
      const chatPanel = document.querySelector('.chat-panel');
      if (chatPanel) {
        console.log(' [INTELLIGENCE DEBUG] logZoneMessage - Panel state before adding message:');
        console.log(' [INTELLIGENCE DEBUG] - chatPanel.style.display:', chatPanel.style.display);
        console.log(' [INTELLIGENCE DEBUG] - log.children.length:', log.children.length);
      }
      
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.innerHTML = `<small>${new Date().toLocaleTimeString()}</small> ${message}`;
      log.insertBefore(entry, log.firstChild);
      
      // Limit log entries
      while (log.children.length > 10) {
        log.removeChild(log.lastChild);
      }
      
      // DEBUG: Log Intelligence Report panel state after adding message
      if (chatPanel) {
        console.log(' [INTELLIGENCE DEBUG] logZoneMessage - Panel state after adding message:');
        console.log(' [INTELLIGENCE DEBUG] - chatPanel.style.display:', chatPanel.style.display);
        console.log(' [INTELLIGENCE DEBUG] - log.children.length:', log.children.length);
        console.log(' [INTELLIGENCE DEBUG] - log.scrollHeight:', log.scrollHeight);
        console.log(' [INTELLIGENCE DEBUG] - log.clientHeight:', log.clientHeight);
      }
    }
    
    // Function to clear zone log when entering a new zone
    function clearZoneLog() {
      console.log(' [ZONE LOG DEBUG] ===== CLEARING ZONE LOG =====');
      const log = document.getElementById('zone-log');
      if (log) {
        console.log(' [ZONE LOG DEBUG] Found zone-log element, clearing content');
        console.log(' [ZONE LOG DEBUG] Current log content length:', log.children.length);
        log.innerHTML = '';
        console.log(' [ZONE LOG DEBUG] Zone log cleared successfully');
      } else {
        console.log(' [ZONE LOG DEBUG] zone-log element not found!');
      }
    }
    
    // Function to clear zone log only when it's a new player's turn
    function clearZoneLogOnNewTurn() {
      console.log(' [ZONE LOG DEBUG] ===== CLEARING ZONE LOG ON NEW TURN =====');
      const log = document.getElementById('zone-log');
      if (log) {
        console.log(' [ZONE LOG DEBUG] Found zone-log element, clearing content for new turn');
        log.innerHTML = '';
        console.log(' [ZONE LOG DEBUG] Zone log cleared for new turn');
      } else {
        console.log(' [ZONE LOG DEBUG] zone-log element not found!');
      }
    }
    
    // Function to handle intelligence report input (flavor text only)
    function handleIntelligenceInput(event) {
      if (event.key === 'Enter') {
        const input = event.target;
        const message = input.value.trim();
        
        if (message) {
          // Add the message to the intelligence log
          const log = document.getElementById('zone-log');
          if (log) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry intelligence-entry';
            logEntry.textContent = `INTEL: ${message}`;
            log.appendChild(logEntry);
            
            // Scroll to bottom
            log.scrollTop = log.scrollHeight;
          }
          
          // Clear the input
          input.value = '';
        }
      }
    }
    
    // Test function to simulate victory condition
    function testVictoryCondition() {
      console.log(' ===== TESTING DOMINANCE VICTORY CONDITION =====');
      
      if (!isMultiplayerMode) {
        console.log(' Running in single-player mode');
      }
      
      // Simulate Player 1 (Red) capturing a majority of zones to achieve dominance victory
      const zonesToCapture = zones.slice(0, Math.floor(zones.length / 2) + 1).map(z => z.id);
      
      zonesToCapture.forEach((zoneId, index) => {
        const zone = zones.find(z => z.id === zoneId);
        if (zone) {
          console.log(` Capturing zone ${zoneId} for Red player`);
          zone.control = 'red';
          
          // Add some units to make it look realistic
          for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
            if (pos < 3) { // Add 3 units to each captured zone
              zone.tacticalGrid[pos].unit = {
                name: 'Infantry',
                player: 'red',
                attack: 2,
                defense: 1,
                morale: 3,
                range: 1,
                movement: 2,
                type: 'infantry',
                targetHistory: {}
              };
            }
          }
        }
      });
      
      // Set remaining zones to blue for contrast
      const remainingZones = zones.filter(z => !zonesToCapture.includes(z.id));
      remainingZones.forEach(zone => {
        zone.control = 'blue';
        // Add some blue units
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          if (pos < 2) { // Add 2 units to each blue zone
            zone.tacticalGrid[pos].unit = {
              name: 'Infantry',
              player: 'blue',
              attack: 2,
              defense: 1,
              morale: 3,
              range: 1,
              movement: 2,
              type: 'infantry',
              targetHistory: {}
            };
          }
        }
      });
      
      console.log(' Victory condition setup complete');
      console.log(` Red controls ${zonesToCapture.length} zones`);
      console.log(' Red should achieve dominance victory (>50% control)');
      
      // Render the battlefield to show the changes
      renderBattlefield();
      
      // Trigger victory check
      console.log(' Checking win condition...');
      checkWinCondition();
      
      console.log(' ===== DOMINANCE VICTORY TEST COMPLETED =====');
      console.log(' Summary screen should now be displayed automatically');
    }
    
    // Test function to simulate elimination victory
    function testEliminationVictory() {
      console.log(' ===== TESTING ELIMINATION VICTORY =====');
      
      if (!isMultiplayerMode) {
        console.log(' Running in single-player mode');
      }
      
      // First, change win condition to elimination
      gameConfig.winCondition = 'elimination';
      console.log(' Changed win condition to: elimination');
      
      // Clear all blue units from all zones (simulate elimination)
      zones.forEach(zone => {
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const unit = zone.tacticalGrid[pos].unit;
          if (unit && unit.player === 'blue') {
            console.log(` Eliminating blue unit from zone ${zone.id}`);
            zone.tacticalGrid[pos].unit = null;
          }
        }
      });
      
      console.log(' All blue units eliminated');
      console.log(' Red should achieve elimination victory');
      
      // Render the battlefield to show the changes
      renderBattlefield();
      
      // Trigger victory check
      console.log(' Checking win condition...');
      checkWinCondition();
      
      console.log(' ===== ELIMINATION VICTORY TEST COMPLETED =====');
      console.log(' Summary screen should now be displayed automatically');
    }
    
    // Game Logic
    function renderBattlefield() {
      const battlefield = document.getElementById('battlefield');
      if (!battlefield) return;
      
      battlefield.innerHTML = '';
      
      console.log('Rendering battlefield with zones:', zones);
      
      // Calculate dynamic grid layout
      const zoneCount = zones.length;
      let columns = 6; // Default
      let rows = Math.ceil(zoneCount / columns);
      
      // Adjust for better layouts
      if (zoneCount <= 4) {
        columns = zoneCount;
        rows = 1;
      } else if (zoneCount <= 6) {
        columns = 3;
        rows = 2;
      } else if (zoneCount <= 8) {
        columns = 4;
        rows = Math.ceil(zoneCount / 4);
      } else if (zoneCount <= 10) {
        columns = 5;
        rows = 2;
      } else if (zoneCount <= 12) {
        columns = 6;
        rows = 2;
      } else if (zoneCount <= 16) {
        columns = 4;
        rows = 4;
      } else if (zoneCount <= 20) {
        columns = 5;
        rows = 4;
      } else {
        columns = 6;
        rows = Math.ceil(zoneCount / 6);
      }
      
      // Set grid template
      battlefield.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
      // Remove gridTemplateRows to prevent stretching
      battlefield.style.gridTemplateRows = 'auto';
      
      // Ensure battlefield has proper display and dimensions
      battlefield.style.display = 'grid';
      battlefield.style.gap = '10px';
      battlefield.style.minHeight = '300px'; // Ensure minimum height
      
      // Debug logging
      console.log('=== GRID LAYOUT DEBUG ===');
      console.log('Zone count:', zoneCount);
      console.log('Columns:', columns);
      console.log('Rows:', rows);
      console.log('Battlefield class:', battlefield.className);
      console.log('Grid template columns:', battlefield.style.gridTemplateColumns);
      console.log('Grid template rows:', battlefield.style.gridTemplateRows);
      console.log('Battlefield height:', battlefield.offsetHeight);
      console.log('Battlefield min-height:', battlefield.style.minHeight);
      

      
      zones.forEach(zone => {
        console.log(`Rendering zone: ${zone.id}, name: ${zone.name}, demon name: ${zoneNames[zone.name] || 'NOT FOUND'}`);
        const div = document.createElement('div');
        div.className = `zone ${zone.control}`;
        
              if (zone.locked) {
        div.classList.add('locked');
        // Removed LOCKED icon display - keeping functionality
      }
        
        // Count units in zone and list them
        let redCount = 0, blueCount = 0;
        const redUnits = [];
        const blueUnits = [];
        
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const unit = zone.tacticalGrid[pos].unit;
          if (unit) {
            if (unit.player === 'red') {
              redCount++;
              redUnits.push(unit.name);
            } else {
              blueCount++;
              blueUnits.push(unit.name);
            }
          }
        }
        
        const conditionsText = zone.conditions.length ? 
          `<div class="zone-conditions">${zone.conditions.join(', ')}</div>` : '';
        
        const defensesText = zone.defenses.length ?
          `<div class="zone-conditions">DEF ${zone.defenses.join(', ')}</div>` : '';
        
        // Create unit lists
        const redUnitList = redUnits.length ? 
          `<div class="zone-unit-list">${redUnits.map(u => `<div class="zone-unit-item red">${u}</div>`).join('')}</div>` : '';
        const blueUnitList = blueUnits.length ? 
          `<div class="zone-unit-list">${blueUnits.map(u => `<div class="zone-unit-item blue">${u}</div>`).join('')}</div>` : '';
        
        const displayName = zoneNames[zone.name] || zone.name;
        console.log(`Creating zone header for ${zone.name} -> ${displayName}`);
        div.innerHTML += `
          <div class="zone-header">Zone ${displayName}</div>
          <div class="zone-units">
            <span style="color: ${gameConfig.player1.color};">${gameConfig.player1.name.split(' ')[0]}: ${redCount}</span>
            <span style="color: ${gameConfig.player2.color};">${gameConfig.player2.name.split(' ')[0]}: ${blueCount}</span>
          </div>
          ${redUnitList}
          ${blueUnitList}
          <div style="font-size: 10px; color: #ccc;">${zone.terrain}</div>
          ${conditionsText}
          ${defensesText}
        `;
        
        // Add edit button separately to ensure proper positioning
        const editButton = document.createElement('button');
        editButton.className = 'rename-zone';
        editButton.onclick = () => renameZone(zone.id);
        editButton.textContent = '';
        div.appendChild(editButton);
        
        // Debug zone dimensions after it's added to DOM
        setTimeout(() => {
          console.log(`Zone ${zone.id} dimensions:`, {
            offsetHeight: div.offsetHeight,
            offsetWidth: div.offsetWidth,
            clientHeight: div.clientHeight,
            clientWidth: div.clientWidth,
            styleHeight: div.style.height,
            computedHeight: window.getComputedStyle(div).height,
            computedWidth: window.getComputedStyle(div).width,
            innerHTML: div.innerHTML.substring(0, 100) + '...' // Show first 100 chars of content
          });
        }, 100);
        
        // Apply dynamic colors to zone borders and glow by controller
        if (zone.control === 'red') {
          div.style.borderColor = gameConfig.player1.color;
          div.style.background = `${gameConfig.player1.color}33`;
          div.style.boxShadow = `0 0 20px ${gameConfig.player1.color}99`;
        } else if (zone.control === 'blue') {
          div.style.borderColor = gameConfig.player2.color;
          div.style.background = `${gameConfig.player2.color}33`;
          div.style.boxShadow = `0 0 20px ${gameConfig.player2.color}99`;
        } else if (gameState.zoneRoles[zone.id]) {
          // Zone has been chosen but not yet locked
          const zoneRole = gameState.zoneRoles[zone.id];
          const chosenPlayerColor = zoneRole.attacker === 'red' ? gameConfig.player1.color : gameConfig.player2.color;
          div.style.borderColor = chosenPlayerColor;
          div.style.background = `${chosenPlayerColor}22`;
        }
        
        if (!zone.locked && gameState.gamePhase === 'selection') {
          // Check if this zone has already been chosen by any player
          const zoneRole = gameState.zoneRoles[zone.id];
          if (zoneRole) {
            // Zone has already been chosen - allow entry but no re-choice
            div.onclick = () => enterZone(zone.id);
            div.style.opacity = '0.8';
            div.style.cursor = 'none';
          } else {
            // Zone is available for selection
            div.onclick = () => showZoneActionChoice(zone.id);
          }
        } else if (zone.locked) {
          div.onclick = () => enterZone(zone.id);
        }
        
        battlefield.appendChild(div);
        
        // Debug: Check if zone was added properly
        console.log(` [ZONE DEBUG] Added zone ${zone.id} to battlefield. Battlefield children count: ${battlefield.children.length}`);
        
        // Debug battlefield dimensions after adding zones
        if (zones.indexOf(zone) === zones.length - 1) {
          setTimeout(() => {
            console.log('=== FINAL BATTLEFIELD DEBUG ===');
            console.log('Battlefield final height:', battlefield.offsetHeight);
            console.log('Battlefield final width:', battlefield.offsetWidth);
            console.log('Battlefield computed height:', window.getComputedStyle(battlefield).height);
            console.log('Battlefield computed width:', window.getComputedStyle(battlefield).width);
            console.log('Battlefield grid template:', window.getComputedStyle(battlefield).gridTemplateColumns);
            console.log('Battlefield grid template rows:', window.getComputedStyle(battlefield).gridTemplateRows);
            console.log('Battlefield gap:', window.getComputedStyle(battlefield).gap);
            console.log('Battlefield display:', window.getComputedStyle(battlefield).display);
            console.log('Battlefield min-height:', window.getComputedStyle(battlefield).minHeight);
            
            // Log all zone heights
            const allZones = battlefield.querySelectorAll('.zone');
            console.log('All zone heights:');
            allZones.forEach((zoneEl, index) => {
              console.log(`Zone ${index + 1}: ${zoneEl.offsetHeight}px`);
            });
            
            // Force a reflow to ensure proper rendering
            battlefield.offsetHeight; // Trigger reflow
            console.log('After reflow - Battlefield height:', battlefield.offsetHeight);
          }, 200);
        }
      });
      
      updateUI();
      updateTurnIndicator();
      
      // Force update turn validation in multiplayer
      if (isMultiplayerMode) {
        disableActionsForNonCurrentPlayer();
      }
      
      // Send battlefield update to other players in multiplayer (only if not updating from server)
      if (isMultiplayerMode && !isUpdatingFromServer) {
        sendBattlefieldUpdate();
      }
    }
    
    function renameZone(zoneId) {
      const zone = zones.find(z => z.id === zoneId);
      if (!zone) return;
      
      const newName = prompt("Enter new name for this zone:", zone.name);
      if (newName && newName.trim() !== '') {
        zone.name = newName.trim();
        gameState.zoneNames[zoneId] = zone.name;
        renderBattlefield();
      }
    }
    
    function updateTurnIndicator() {
      const indicator = document.getElementById('turn-indicator');
      if (!indicator) return;
      
      const currentPlayerName = gameState.currentPlayer === 'red' ? 
        gameConfig.player1.name : gameConfig.player2.name;
      
      // Check if it's AI turn
      if (isAITurn()) {
        indicator.textContent = `${currentPlayerName} (AI) - Thinking...`;
        return;
      }
      
      if (gameState.gamePhase === 'selection') {
        indicator.textContent = `${currentPlayerName}'s Turn - Choose zones to attack`;
      } else if (gameState.gamePhase === 'tactical') {
        indicator.textContent = `${currentPlayerName}'s Turn - Tactical Phase`;
      } else {
        indicator.textContent = `${currentPlayerName}'s Turn`;
      }
    }
    
    function updateUI() {
      const currentPlayerName = gameState.currentPlayer === 'red' ? 
        gameConfig.player1.name : gameConfig.player2.name;
      const currentPlayerElement = document.getElementById('current-player');
      if (currentPlayerElement) {
        if (isAITurn()) {
          currentPlayerElement.textContent = `${currentPlayerName} (AI) - Thinking...`;
        } else {
          currentPlayerElement.textContent = `${currentPlayerName}'s Turn`;
        }
      }
      
      const commandPointsElement = document.getElementById('command-points');
      if (commandPointsElement) {
        commandPointsElement.textContent = gameState.commandPoints[gameState.currentPlayer];
      }
      
      // Update artillery UI
      updateArtilleryUI();
    }
    
    function endTurn() {
      if (isAITurn()) return; // Prevent manual turn ending during AI turn
      if (!isMyTurn()) {
        alert('It\'s not your turn! Please wait for your opponent.');
        return; // Prevent turn ending when it's not your turn
      }
      
      // Process turn end effects
      processTerrainEffects();
      
      // Process special ability turn-based effects
      processTurnBasedEffects();
      
      // Update weather for the new turn
      updateWeatherForTurn();
      
      // Update construction progress
      console.log('=== END TURN - ABOUT TO UPDATE CONSTRUCTION PROGRESS ===');
      console.log('Current player before update:', gameState.currentPlayer);
      updateConstructionProgress();
      
      // Clear "placed this turn" flags
      resetPlacedThisTurnFlags();
      
      // Update stationary turn tracking for all units
      updateStationaryTurnTracking();
      
              // Switch players after a short delay
        setTimeout(() => {
          gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
          gameState.turnCount++;
          
          // Clear zone log for new player's turn
          clearZoneLogOnNewTurn();
          
          // Update player color CSS
          updatePlayerColorCSS();
          
          // Update zone CP bonuses
          updateZoneCPBonuses();
          
          // Calculate and set CP for new player
          const newCP = calculateTurnStartCP();
          gameState.commandPoints[gameState.currentPlayer] = newCP;
          // Update Build Points UI for the new current player (zone detail header)
          updateBuildPointsDisplay();
        
        // Reset turn state
        gameState.selectedDice = { attack: 0, defend: 0, morale: 0 };
        gameState.diceAugmented = false;
        gameState.gamePhase = 'selection';
        
        // Clear locked zones for new player
        gameState.lockedZones = { red: [], blue: [] };
        
                          // Clear all temporary movement bonuses at the end of turn
            clearTemporaryMovementBonuses();
      
        // Reset unit actions for the new player if we are in a zone (guard against null)
        if (currentZoneDetail && currentZoneDetail.tacticalGrid) {
          resetUnitActions();
        }
        
        // Clear artillery actions for the new player (since artillery IDs change)
        gameState.artilleryActions = {};
        
        // Reset artillery usage for the new player
        resetArtilleryUsage();
        
        // Clear aerial actions for the new player
        gameState.aerialActions = {};
        
        // Reset aerial usage for the new player
        resetAerialUsage();
        
        // Reset aerial and artillery selection
        gameState.selectedArtillery = null;
        gameState.artilleryMode = false;
        gameState.selectedAerial = null;
        gameState.aerialMode = false;
        gameState.antiAirTargeting = false;
        
        // Hide all attack buttons
        const aerialUnitsContainer = document.getElementById('aerial-units-container');
        if (aerialUnitsContainer) {
          const attackBtns = aerialUnitsContainer.querySelectorAll('.aerial-attack-btn');
          attackBtns.forEach(btn => btn.style.display = 'none');
        }
        
        // Update artillery and aerial panels for the new player if we're in zone detail view
        const zoneDetailScreen = document.getElementById('zone-detail');
        if (zoneDetailScreen && zoneDetailScreen.classList.contains('active')) {
          initializeArtillerySystem();
          initializeAerialSystem();
        }
        
        // Initialize weather displays
        updateWeatherDisplay();
        updateGameWeatherDisplay();
        
        const currentPlayerName = gameState.currentPlayer === 'red' ? 
          gameConfig.player1.name : gameConfig.player2.name;
        
        // Log CP bonuses
        const contestedBonus = gameState.contestedZones[gameState.currentPlayer].length;
        const controlledBonus = gameState.controlledZones[gameState.currentPlayer].length * 2;
        
        logMessage(`Turn ${gameState.turnCount}: ${currentPlayerName}'s turn begins`, 'system');
        if (contestedBonus > 0) {
          logMessage(`${currentPlayerName} gains +${contestedBonus} CP for contesting ${contestedBonus} zone(s)`, 'system');
        }
        if (controlledBonus > 0) {
          logMessage(`${currentPlayerName} gains +${controlledBonus} CP for controlling ${controlledBonus/2} zone(s)`, 'system');
        }
        logMessage(`${currentPlayerName} starts with ${newCP} Command Points`, 'system');
        
              // Update weather displays
      updateWeatherDisplay();
      updateGameWeatherDisplay();
      
              console.log('[WEATHER DISPLAY] Weather displays updated after turn change');
        
        // Check if it's AI turn (in singleplayer only)
        console.log('=== TURN SWITCH DEBUG ===');
        console.log('Opponent type:', gameConfig.opponentType);
        console.log('Current player:', gameState.currentPlayer);
        console.log('AI player:', gameState.aiState.aiPlayer);
        console.log('AI thinking:', gameState.aiState.aiThinking);
        console.log('Should be AI turn:', gameConfig.opponentType === 'ai' && gameState.currentPlayer === gameState.aiState.aiPlayer && !gameState.aiState.aiThinking);
        
      if (!isMultiplayerMode && gameConfig.opponentType === 'ai' && gameState.currentPlayer === gameState.aiState.aiPlayer && !gameState.aiState.aiThinking) {
          gameState.aiState.isAITurn = true;
          console.log('AI turn activated');
          logMessage(`AI turn begins - ${gameConfig.player2.name} is thinking...`, 'system');
          
          // Process AI turn after a short delay
          setTimeout(() => {
            processAITurn();
          }, 1500);
        } else {
          gameState.aiState.isAITurn = false;
          console.log('AI turn deactivated - human turn');
        }
        
        renderBattlefield();
        // Check win condition after turn switch to advance hold trackers and detect wins
        checkWinCondition();
        
        // Send turn change to other players in multiplayer (only if not updating from server)
        if (isMultiplayerMode && !isUpdatingFromServer) {
          // Share full updated game state (includes weather/day-night/turn counters)
          sendGameStateUpdate();
          sendTurnChange();
        }
      }, 1000);
    }
    
    function resetPlacedThisTurnFlags() {
      // Clear the "placed this turn" flag for all units
      for (const zone of zones) {
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const unit = zone.tacticalGrid[pos].unit;
          if (unit) {
            unit.placedThisTurn = false;
          }
        }
      }
    }
    
    function updateStationaryTurnTracking() {
      // Update stationary turn tracking for all units
      for (const zone of zones) {
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const unit = zone.tacticalGrid[pos].unit;
          if (unit) {
            // Check if unit moved this turn (before hasMoved gets reset)
            const unitAction = gameState.unitActions[unit.id];
            
            // Only count stationary turns when it's the unit's own player's turn
            if (unit.player === gameState.currentPlayer) {
              if (unitAction && unitAction.hasMoved) {
                // Unit moved this turn, reset stationary counter (deactivates Siege Mode)
                unit.turnsStationary = 0;
              } else {
                // Unit didn't move this turn, increment stationary counter
                if (!unit.turnsStationary) unit.turnsStationary = 0;
                unit.turnsStationary++;
              }
            }
          }
        }
      }
    }
    
    function processTerrainEffects() {
      // Process movement delays and other terrain effects
      zones.forEach(zone => {
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const unit = zone.tacticalGrid[pos].unit;
          if (unit && unit.moveDelay > 0) {
            unit.moveDelay--;
            if (unit.moveDelay === 0) {
              const zoneName = zoneNames[zone.name] || zone.name;
        logMessage(`${unit.name} in Zone ${zoneName} can now move freely`, 'system');
            }
          }
          
          // Process volcanic damage
          if (unit) {
            const terrain = zone.tacticalGrid[pos].terrain;
            const terrainEffect = terrainEffects[terrain];
            if (terrainEffect && terrainEffect.damagePerTurn) {
              // Apply volcanic damage (minimum 1 health remains)
              const damageAmount = terrainEffect.damagePerTurn;
              const originalHealth = unit.health;
              applyDamage(unit, damageAmount);
              // Ensure unit survives volcanic damage (minimum 1 health)
              if (unit.health <= 0) {
                unit.health = 1;
              }
              logMessage(`${unit.name} in Zone ${zoneName} takes ${damageAmount} damage from volcanic terrain!`, 'combat');
              
              // Check if unit is critically damaged
              if (unit.health <= 1) {
                logMessage(`${unit.name} is critically damaged from volcanic exposure!`, 'combat');
              }
            }
          }
        }
      });
    }
    
    // ===== SIMPLE WORKING AI SYSTEM =====
    
    // AI system removed - will be rebuilt from scratch
    
    function checkWinCondition() {
      const redZones = zones.filter(z => z.control === 'red').length;
      const blueZones = zones.filter(z => z.control === 'blue').length;
      const totalZones = zones.length;
      
      let winner = null;
      let endCondition = '';
      
      if (gameConfig.winCondition === 'dominance') {
        // Two-complete-round hold requirement per zone
        zones.forEach(zone => {
          if (!zone.holdTracker) zone.holdTracker = { holder: null, streak: 0, lastPlayer: null };
          const occupants = [];
          for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
            const u = zone.tacticalGrid[pos].unit;
            if (u) occupants.push(u.player);
          }
          const hasRed = occupants.includes('red');
          const hasBlue = occupants.includes('blue');
          const currentHolder = hasRed && !hasBlue ? 'red' : hasBlue && !hasRed ? 'blue' : null;
          if (currentHolder && zone.holdTracker.holder === currentHolder) {
            // Increment streak per player-turn change. We approximate by incrementing each time checkWinCondition is called after turn swap
            zone.holdTracker.streak = (zone.holdTracker.streak || 0) + 1;
          } else if (currentHolder && zone.holdTracker.holder !== currentHolder) {
            zone.holdTracker.holder = currentHolder;
            zone.holdTracker.streak = 1;
          } else if (!currentHolder) {
            zone.holdTracker.holder = null;
            zone.holdTracker.streak = 0;
          }
          if (zone.holdTracker.holder && zone.holdTracker.streak >= 4) {
            zone.control = zone.holdTracker.holder;
            const zoneName = zoneNames[zone.id] || zone.id;
            const winnerName = zone.control === 'red' ? gameConfig.player1.name : gameConfig.player2.name;
            logMessage(`Zone ${zoneName} secured by ${winnerName} after sustained control.`, 'system');
          }
        });
        const newRedZones = zones.filter(z => z.control === 'red').length;
        const newBlueZones = zones.filter(z => z.control === 'blue').length;
        if (newRedZones > totalZones / 2) {
          winner = 'red';
          endCondition = 'Dominance Victory';
        } else if (newBlueZones > totalZones / 2) {
          winner = 'blue';
          endCondition = 'Dominance Victory';
        }
      } else if (gameConfig.winCondition === 'elimination') {
        let redUnits = 0, blueUnits = 0;
        zones.forEach(zone => {
          for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
            const unit = zone.tacticalGrid[pos].unit;
            if (unit) {
              if (unit.player === 'red') redUnits++;
              else blueUnits++;
            }
          }
        });
        if (redUnits === 0) {
          winner = 'blue';
          endCondition = 'Elimination Victory';
        } else if (blueUnits === 0) {
          winner = 'red';
          endCondition = 'Elimination Victory';
        }
      }
      
      if (winner) {
        const winnerName = winner === 'red' ? gameConfig.player1.name : gameConfig.player2.name;
        const result = `${winnerName} Wins!`;
        
        logMessage(` ${winnerName} ACHIEVES VICTORY!`, 'system');
                    

                    
                    // Show victory overlay for both multiplayer and single-player
                    console.log(' Victory achieved - showing victory overlay');
                    
                    // Store victory data for summary screen
                    window.lastVictoryData = {
                      result: winnerName,
                      endCondition: endCondition
                    };
                    
                    if (isMultiplayerMode) {
                      // In multiplayer, show victory overlay first
                      const currentPlayerRole = getCurrentPlayerRole();
                      const isWinner = (currentPlayerRole === 'player1' && winner === 'red') || 
                                     (currentPlayerRole === 'player2' && winner === 'blue');
                      
                      showVictoryOverlay(isWinner, winnerName, endCondition);
                    } else {
                      // In single-player, show victory overlay (player always wins against AI)
                      showVictoryOverlay(true, winnerName, endCondition);
                    }
        
        // In multiplayer, notify other players about the victory
        if (isMultiplayerMode && !isUpdatingFromServer) {
          console.log(' Broadcasting victory to other players');
          console.log(' Socket connected:', socket.connected);
          console.log(' Socket ID:', socket.id);
          console.log(' Lobby code:', lobbyCode);
          console.log(' Victory data:', {
            lobbyCode: lobbyCode,
            winner: winner,
            winnerName: winnerName,
            endCondition: endCondition,
            gameState: gameState,
            zones: zones
          });
          
          // Test if socket is still working by sending a simple event first
          socket.emit('testVictory', { test: true });
          console.log(' Test event sent');
          
          socket.emit('gameVictory', {
            lobbyCode: lobbyCode,
            winner: winner,
            winnerName: winnerName,
            endCondition: endCondition,
            gameState: gameState,
            zones: zones // Include current zones state
          });
          
          console.log(' Victory event emitted to server');
        }
      }
    }
    
    function logMessage(message, type = 'system') {
      const log = document.getElementById('log');
      if (!log) return;
      
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.innerHTML = `<small>${new Date().toLocaleTimeString()}</small> ${message}`;
      log.insertBefore(entry, log.firstChild);
      
      // Limit log entries
      while (log.children.length > 15) {
        log.removeChild(log.lastChild);
      }
    }
    
    // Army Builder Functions
    function loadArmyBuilder() {
      loadAvailableUnitsPool();
      loadSavedArmies();
      updateArmyComposition();
    }
    
    function switchUnitTab(tabType) {
      currentUnitTab = tabType;
      
      // Update tab buttons
      document.getElementById('regular-tab').classList.remove('active');
      document.getElementById('aerial-tab').classList.remove('active');
      document.getElementById(`${tabType}-tab`).classList.add('active');
      
      // Load appropriate units
      loadAvailableUnitsPool(tabType);
    }
    
    function loadAvailableUnitsPool(tabType = 'regular') {
      const container = document.getElementById('available-units-pool');
      if (!container) return;
      
      container.innerHTML = '';
      
      // Get all available units (default + custom)
      const allUnits = [...defaultUnits, ...gameData.customUnits];
      
      // Filter units based on tab type
      const filteredUnits = tabType === 'aerial' 
        ? allUnits.filter(unit => unit.type === 'air')
        : allUnits.filter(unit => unit.type !== 'air');
      
      if (filteredUnits.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #cc4444; opacity: 0.7; padding: 20px; font-style: italic;">No forces available...</div>';
        return;
      }
      
      filteredUnits.forEach((unit, index) => {
        const isAtLimit = gameData.currentArmy.length >= 10;
        const icon = getUnitIcon(unit.type);
        
        const unitDiv = document.createElement('div');
        unitDiv.className = 'available-unit';
        
        unitDiv.innerHTML = `
          <div class="unit-header">
            <div class="unit-info">
              <div class="unit-icon">${icon}</div>
              <div class="unit-details">
                <div class="unit-name">${unit.name}</div>
                <div class="unit-type">${formatUnitType(unit.type)}</div>
              </div>
            </div>
          </div>
          <div class="unit-stats">
            <span class="stat">ATK: ${unit.attack >= 0 ? '+' : ''}${unit.attack}</span>
            ${unit.type === 'air' || unit.type === 'artillery' ? 
              `<span class="stat">HP: ${unit.defense}</span>` : 
              `<span class="stat">DEF: ${unit.defense >= 0 ? '+' : ''}${unit.defense}</span>`
            }
            ${unit.type !== 'artillery' && unit.type !== 'air' ? 
              `<span class="stat">MOR: ${unit.morale}</span>` : ''
            }
            ${unit.type !== 'artillery' && unit.type !== 'air' ? 
              `<span class="stat">RNG: ${unit.range}</span>` : ''
            }
            ${unit.type !== 'artillery' && unit.type !== 'air' ? 
              `<span class="stat">MOV: ${unit.movement}</span>` : ''
            }
            ${unit.type === 'artillery' && unit.hitChance ? `<span class="stat">HIT: ${unit.hitChance}+</span>` : ''}
          </div>
          <button class="add-unit-btn" onclick="addUnitToArmy(${JSON.stringify(unit).replace(/"/g, '&quot;')}, ${index})" ${isAtLimit ? 'disabled' : ''}>
            ${isAtLimit ? 'Legion Full' : 'Recruit Unit'}
          </button>
        `;
        
        container.appendChild(unitDiv);
      });
    }
    
    function addUnitToArmy(unit, unitIndex) {
      if (gameData.currentArmy.length >= 10) {
        alert('Your legion is at maximum capacity!');
        return;
      }
      
      // Add unit to current army with a unique ID
      const armyUnit = {
        ...unit,
        armyId: `${Date.now()}_${Math.random()}`,
        originalIndex: unitIndex
      };
      
      gameData.currentArmy.push(armyUnit);
      updateArmyComposition();
      updateSaveButton();
      loadAvailableUnitsPool(currentUnitTab || 'regular'); // Refresh to update button states
    }
    
    function removeUnitFromArmy(armyId) {
      console.log('Removing unit with armyId:', armyId);
      console.log('Current army before removal:', gameData.currentArmy);
      
      if (!gameData.currentArmy) {
        console.error('gameData.currentArmy is not initialized!');
        gameData.currentArmy = [];
        return;
      }
      
      const initialLength = gameData.currentArmy.length;
      gameData.currentArmy = gameData.currentArmy.filter(unit => {
        console.log(`Comparing unit.armyId (${unit.armyId}) with armyId (${armyId})`);
        return unit.armyId !== armyId;
      });
      
      console.log('Current army after removal:', gameData.currentArmy);
      console.log(`Removed ${initialLength - gameData.currentArmy.length} unit(s)`);
      
      updateArmyComposition();
      updateSaveButton();
    }
    
    function updateArmyComposition() {
      const container = document.getElementById('current-army-list');
      const countElement = document.getElementById('army-unit-count');
      
      if (!container || !countElement) return;
      
      countElement.textContent = `${gameData.currentArmy.length}/10`;
      
      if (gameData.currentArmy.length === 0) {
        container.innerHTML = `
          <div style="text-align: center; color: #cc4444; opacity: 0.7; padding: 20px; font-style: italic;">
            No forces assembled yet...
          </div>
        `;
        return;
      }
      
      container.innerHTML = '';
      
      gameData.currentArmy.forEach(unit => {
        const icon = getUnitIcon(unit.type);
        
        const unitDiv = document.createElement('div');
        unitDiv.className = 'army-unit';
        
        unitDiv.innerHTML = `
          <div class="unit-info">
            <div class="unit-icon">${icon}</div>
            <div class="unit-details">
              <div class="unit-name">${unit.name}</div>
              <div class="unit-type">${formatUnitType(unit.type)}</div>
            </div>
          </div>
          <button class="remove-unit-btn" onclick="removeUnitFromArmy('${unit.armyId}')">
            Remove
          </button>
        `;
        
        container.appendChild(unitDiv);
      });
    }
    
    function updateSaveButton() {
      const saveBtn = document.getElementById('save-army-btn');
      const armyNameInput = document.getElementById('army-name');
      
      if (!saveBtn || !armyNameInput) return;
      
      const hasName = armyNameInput.value.trim() !== '';
      const hasUnits = gameData.currentArmy.length > 0;
      
      saveBtn.disabled = !(hasName && hasUnits);
    }
    
    function saveArmy() {
      const armyNameInput = document.getElementById('army-name');
      if (!armyNameInput) return;
      
      const armyName = armyNameInput.value.trim();
      if (!armyName) {
        alert('Please enter a legion name');
        return;
      }
      
      if (gameData.currentArmy.length === 0) {
        alert('Cannot save an empty legion');
        return;
      }
      
      // Check if army name already exists
      const existingArmy = gameData.savedArmies.find(army => army.name === armyName);
      if (existingArmy) {
        if (!confirm(`Legion "${armyName}" already exists. Overwrite?`)) {
          return;
        }
        // Remove existing army
        gameData.savedArmies = gameData.savedArmies.filter(army => army.name !== armyName);
      }
      
      // Create army object with unique unit IDs
      const newArmy = {
        id: Date.now(),
        name: armyName,
        units: gameData.currentArmy.map((unit, index) => ({
          id: `${armyName}_${unit.name}_${index}_${Date.now()}`, // Unique unit ID
          name: unit.name,
          type: unit.type,
          attack: unit.attack,
          defense: unit.defense,
          morale: unit.morale,
          range: unit.range,
          movement: unit.movement,
          special: unit.special,
          originalIndex: unit.originalIndex
        })),
        created: new Date().toISOString()
      };
      
      gameData.savedArmies.push(newArmy);
      
      // Save to localStorage
      saveArmiesToStorage();
      
      // Clear current army and form
      gameData.currentArmy = [];
      armyNameInput.value = '';
      
      // Update UI
      updateArmyComposition();
      updateSaveButton();
      loadSavedArmies();
      loadArmyDropdowns(); // Update army selection dropdowns to include the new army
      
      alert(`Legion "${armyName}" saved successfully to the archives of war!`);
    }
    
    function clearArmy() {
      if (gameData.currentArmy.length > 0) {
        if (confirm('Disband all forces from your legion?')) {
          gameData.currentArmy = [];
          updateArmyComposition();
          updateSaveButton();
        }
      }
    }
    
    function getUnitIcon(unitType) {
      // Use the same icons as the unit creator
      const unitTypeIcons = {
        infantry: '', // dagger/cross
        vehicle: '', // double arrow
        tank: '', // spade
        mech: '', // cross
        support: '', // heart
        field_gun: '', // up arrow
        artillery: '', // bullet point
        fighter: '', // fighter plane
        bomber: '', // bomber plane
        airship: '', // airship
        cavalry: '', // knight
        aircraft: '' // bomber plane (for compatibility)
      };
      return unitTypeIcons[unitType] || '';
    }
    
    function loadSavedArmies() {
      const container = document.getElementById('saved-armies-list');
      if (!container) return;
      
      container.innerHTML = '';
      
      if (gameData.savedArmies.length === 0) {
        container.innerHTML = `
          <div style="text-align: center; color: #cc4444; opacity: 0.7; padding: 20px; font-style: italic;">
            No legions saved yet...
          </div>
        `;
        return;
      }
      
      gameData.savedArmies.forEach(army => {
        const armyDiv = document.createElement('div');
        armyDiv.className = 'saved-army';
        
        // Calculate army composition summary
        const unitTypes = {};
        army.units.forEach(unit => {
          unitTypes[unit.type] = (unitTypes[unit.type] || 0) + 1;
        });
        
        const compositionText = Object.entries(unitTypes)
          .map(([type, count]) => `${count} ${formatUnitType(type)}`)
          .join(', ');
        
        armyDiv.innerHTML = `
          <div class="army-header">
            <div class="army-name">${army.name}</div>
            <div class="army-count">${army.units.length} units</div>
          </div>
          <div style="font-size: 12px; color: #cc4444; margin-bottom: 10px;">
            ${compositionText}
          </div>
          <div style="font-size: 11px; color: #888; margin-bottom: 10px;">
            Created: ${new Date(army.created).toLocaleDateString()}
          </div>
          <div class="army-actions">
            <button class="small-button" onclick="loadArmyToBuilder('${army.id}')">Load</button>
            <button class="small-button delete" onclick="deleteArmy('${army.id}')">Destroy</button>
          </div>
        `;
        
        container.appendChild(armyDiv);
      });
    }
    
    function loadArmyToBuilder(armyId) {
      const army = gameData.savedArmies.find(a => a.id == armyId);
      if (!army) return;
      
      // Load army into current composition
      gameData.currentArmy = army.units.map(unit => ({
        ...unit,
        armyId: Date.now() + Math.random()
      }));
      
      // Set army name
      const armyNameInput = document.getElementById('army-name');
      if (armyNameInput) {
        armyNameInput.value = army.name + ' (Copy)';
      }
      
      updateArmyComposition();
      updateSaveButton();
      
      alert('Legion loaded and ready for modification!');
    }
    
    function deleteArmy(armyId) {
      const army = gameData.savedArmies.find(a => a.id == armyId);
      if (!army) return;
      
      if (confirm(`Are you sure you want to destroy the legion "${army.name}" forever?`)) {
              gameData.savedArmies = gameData.savedArmies.filter(a => a.id != armyId);
      saveArmiesToStorage();
      loadSavedArmies();
      loadArmyDropdowns(); // Update army selection dropdowns to reflect the deletion
      }
    }
    
    function deleteArmyFromBattle(armyId) {
      const army = gameData.savedArmies.find(a => a.id == armyId);
      if (!army) return;
      
      if (confirm(`Delete army "${army.name}"?`)) {
        gameData.savedArmies = gameData.savedArmies.filter(a => a.id != armyId);
        saveArmiesToStorage();
        // Reload army selection cards to reflect the deletion
        loadArmySelectionCards();
        loadArmyDropdowns(); // Update army selection dropdowns to reflect the deletion
      }
    }
    
    // Army Selection Functions (removed duplicate - using the updated version below)
    
    function getSelectedArmyUnits(playerId) {
      // Check if player has selected armies
      const selectedArmies = gameData.selectedArmies[playerId];
      if (!selectedArmies || selectedArmies.length === 0) {
        return [...defaultUnits, ...gameData.customUnits];
      }
      
      // For now, return units from the first selected army
      // In a more advanced system, you might want to combine units from multiple armies
      const firstArmy = selectedArmies[0];
      if (firstArmy.id === 'default') {
        return [...defaultUnits, ...gameData.customUnits];
      }
      
      return firstArmy.units;
    }
    
    // Update getAvailableUnits to use selected army
    function getAvailableUnits() {
      // Check if we're in zone detail and have a current player
      if (gameState.currentPlayer) {
        const playerId = gameState.currentPlayer === 'red' ? 'player1' : 'player2';
        return getSelectedArmyUnits(playerId);
      }
      
      // Fallback to default units
      return [...defaultUnits, ...gameData.customUnits];
    }
    
    // Multi-Army Selection Functions
    function addArmyToPlayer(playerId) {
      console.log(' [DEBUG] addArmyToPlayer called for:', playerId);
      console.log(' [DEBUG] gameData.selectedArmies:', gameData.selectedArmies);
      
      const selectedArmyId = getDropdownValue(`${playerId}ArmyDropdown`);
      console.log(' [DEBUG] Selected army ID:', selectedArmyId);
      
      if (!selectedArmyId) {
        console.log(' [DEBUG] No army selected, showing alert');
        alert('Please select an army first');
        return;
      }
      
      // Check if player already has 5 armies
      if (gameData.selectedArmies[playerId].length >= 5) {
        alert('Maximum 5 armies per player');
        return;
      }
      
      // Check if army is already selected
      const alreadySelected = gameData.selectedArmies[playerId].some(army => String(army.id) === String(selectedArmyId));
      if (alreadySelected) {
        alert('Army already selected');
        return;
      }
      
      // Get army data
      let armyData;
      if (selectedArmyId === 'default') {
        armyData = {
          id: 'default',
          name: 'Default Army',
          units: [...defaultUnits, ...gameData.customUnits]
        };
      } else {
        armyData = gameData.savedArmies.find(army => army.id == selectedArmyId);
        if (!armyData) {
          alert('Army not found');
          return;
        }
      }
      
      // Add army to player's selection
      console.log('Adding army to player:', playerId, 'army data:', armyData);
      gameData.selectedArmies[playerId].push(armyData);
      console.log('Player armies after adding:', gameData.selectedArmies[playerId]);
      
      // Reset dropdown
      const dropdown = document.getElementById(`${playerId}ArmyDropdown`);
      if (dropdown) {
        const selected = dropdown.querySelector('.dropdown-selected');
        selected.textContent = 'Select Legion Type';
        dropdown.querySelectorAll('.dropdown-option').forEach(opt => {
          opt.classList.remove('selected');
        });
      }
      
      // Update UI
      updateSelectedArmiesList(playerId);
    }
    
    function removeArmyFromPlayer(playerId, armyId) {
      console.log('Removing army with ID:', armyId, 'from player:', playerId);
      console.log('Selected armies before removal:', gameData.selectedArmies[playerId]);
      gameData.selectedArmies[playerId] = gameData.selectedArmies[playerId].filter(army => String(army.id) !== String(armyId));
      console.log('Selected armies after removal:', gameData.selectedArmies[playerId]);
      updateSelectedArmiesList(playerId);
    }
    
    function updateSelectedArmiesList(playerId) {
      console.log(` [DEBUG] updateSelectedArmiesList called for ${playerId}`);
      const container = document.getElementById(`${playerId}-selected-armies`);
      console.log(` [DEBUG] Container found:`, !!container);
      
      if (!container) {
        console.error(` [DEBUG] Container not found for ${playerId}-selected-armies`);
        return;
      }
      
      const selectedArmies = gameData.selectedArmies[playerId];
      console.log(` [DEBUG] Selected armies for ${playerId}:`, selectedArmies);
      console.log(` [DEBUG] Number of selected armies:`, selectedArmies.length);
      
      if (selectedArmies.length === 0) {
        console.log(` [DEBUG] No armies selected, showing default message`);
        container.innerHTML = '<div class="no-armies-message">No armies selected. Click "Conscript Legion" to select armies for battle.</div>';
        
        // Also ensure the dropdown selected text is reset
        const player1Selected = document.getElementById('player1ArmySelected');
        const player2Selected = document.getElementById('player2ArmySelected');
        
        if (player1Selected && playerId === 'player1') {
          player1Selected.textContent = 'Select Legion Type';
          console.log(' [DEBUG] Reset player1 dropdown to "Select Legion Type"');
        }
        
        if (player2Selected && playerId === 'player2') {
          player2Selected.textContent = 'Select Legion Type';
          console.log(' [DEBUG] Reset player2 dropdown to "Select Legion Type"');
        }
        
        return;
      }
      
      console.log(` [DEBUG] Clearing container and adding ${selectedArmies.length} armies`);
      container.innerHTML = '';
      
      selectedArmies.forEach((army, index) => {
        console.log(` [DEBUG] Creating army div for army ${index + 1}:`, army.name);
        const armyDiv = document.createElement('div');
        armyDiv.className = 'selected-army-item';
        
        // Calculate army composition
        const unitTypes = {};
        army.units.forEach(unit => {
          unitTypes[unit.type] = (unitTypes[unit.type] || 0) + 1;
        });
        
        const compositionText = Object.entries(unitTypes)
          .map(([type, count]) => `${count} ${formatUnitType(type)}`)
          .join(', ');
        
        console.log(` [DEBUG] Army composition for ${army.name}:`, compositionText);
        
        armyDiv.innerHTML = `
          <div class="selected-army-info">
            <div class="selected-army-name">${army.name}</div>
            <div class="selected-army-composition">${army.units.length} units: ${compositionText}</div>
          </div>
          <button class="small-button delete" onclick="removeArmyFromPlayer('${playerId}', '${army.id}')">Remove</button>
        `;
        
        container.appendChild(armyDiv);
        console.log(` [DEBUG] Added army div to container for ${army.name}`);
      });
      
      // Add army limit indicator
      const limitDiv = document.createElement('div');
      limitDiv.className = 'army-limit-indicator';
      limitDiv.textContent = `${selectedArmies.length}/5 armies selected`;
      container.appendChild(limitDiv);
      console.log(` [DEBUG] Added army limit indicator: ${selectedArmies.length}/5`);
      
      // Update the "Unleash Hell" button state
      updateUnleashHellButton();
    }
    
    // Function to update the "Unleash Hell" button state based on army selection
    function updateUnleashHellButton() {
      const unleashHellButton = document.querySelector('.bottom-action-buttons .menu-button.large-button');
      if (!unleashHellButton) {
        console.log(' [DEBUG] Unleash Hell button not found');
        return;
      }
      
      // Check if both players have selected at least one army
      const player1Armies = gameData.selectedArmies.player1 || [];
      const player2Armies = gameData.selectedArmies.player2 || [];
      
      const player1HasArmies = player1Armies.length > 0;
      const player2HasArmies = player2Armies.length > 0;
      
      console.log(` [DEBUG] Player 1 has armies: ${player1HasArmies} (${player1Armies.length} armies)`);
      console.log(` [DEBUG] Player 2 has armies: ${player2HasArmies} (${player2Armies.length} armies)`);
      
      if (player1HasArmies && player2HasArmies) {
        // Both players have armies - enable the button
        unleashHellButton.disabled = false;
        unleashHellButton.classList.remove('disabled');
        unleashHellButton.style.opacity = '1';
        unleashHellButton.style.cursor = 'pointer';
        unleashHellButton.textContent = 'Unleash Hell';
        unleashHellButton.title = 'Start the battle!';
        console.log(' [DEBUG] Unleash Hell button ENABLED - both players have armies');
      } else {
        // One or both players don't have armies - disable the button
        unleashHellButton.disabled = true;
        unleashHellButton.classList.add('disabled');
        unleashHellButton.style.opacity = '0.5';
        unleashHellButton.style.cursor = 'not-allowed';
        unleashHellButton.textContent = 'Both Armies Have To Be Chosen To Begin';
        unleashHellButton.title = 'Select armies for both players to start the battle';
        
        console.log(' [DEBUG] Unleash Hell button DISABLED - missing armies');
      }
    }
    
    // Update loadArmyDropdowns to populate the multi-army selects
    function loadArmyDropdowns() {
      console.log(' [DEBUG] loadArmyDropdowns called');
      console.log(' [DEBUG] gameData.savedArmies:', gameData.savedArmies);
      
      // Ensure no armies are pre-selected for new games
      if (gameData && gameData.selectedArmies) {
        gameData.selectedArmies.player1 = [];
        gameData.selectedArmies.player2 = [];
        console.log(' [DEBUG] Cleared selected armies to ensure no pre-selection');
      }
      
      // Try to find the custom dropdown containers for single player
      const player1Options = document.getElementById('player1ArmyOptions');
      const player2Options = document.getElementById('player2ArmyOptions');
      
      console.log(' [DEBUG] player1ArmyOptions found:', !!player1Options);
      console.log(' [DEBUG] player2ArmyOptions found:', !!player2Options);
      
      if (player1Options && player2Options) {
        console.log(' [DEBUG] Using custom dropdown structure for single player');
        
        // Clear existing options except the first "Select Legion Type" option
        player1Options.innerHTML = '<div class="dropdown-option" data-value="">Select Legion Type</div>';
        player2Options.innerHTML = '<div class="dropdown-option" data-value="">Select Legion Type</div>';
        
        // Add default army option
        const defaultOption1 = document.createElement('div');
        defaultOption1.className = 'dropdown-option';
        defaultOption1.setAttribute('data-value', 'default');
        defaultOption1.textContent = 'Default Army';
        player1Options.appendChild(defaultOption1);
        
        const defaultOption2 = document.createElement('div');
        defaultOption2.className = 'dropdown-option';
        defaultOption2.setAttribute('data-value', 'default');
        defaultOption2.textContent = 'Default Army';
        player2Options.appendChild(defaultOption2);
        
        // Add saved armies to both dropdowns
        if (gameData.savedArmies && gameData.savedArmies.length > 0) {
          console.log(' [DEBUG] Adding', gameData.savedArmies.length, 'saved armies to dropdowns');
          gameData.savedArmies.forEach((army, index) => {
            console.log(' [DEBUG] Adding army:', army.name, 'with ID:', army.id);
            
            const option1 = document.createElement('div');
            option1.className = 'dropdown-option';
            option1.setAttribute('data-value', army.id);
            option1.textContent = `${army.name} (${army.units.length} units)`;
            player1Options.appendChild(option1);
            
            const option2 = document.createElement('div');
            option2.className = 'dropdown-option';
            option2.setAttribute('data-value', army.id);
            option2.textContent = `${army.name} (${army.units.length} units)`;
            player2Options.appendChild(option2);
          });
        } else {
          console.log(' [DEBUG] No saved armies found in gameData.savedArmies');
        }
        
        console.log(' [DEBUG] Army dropdowns loaded. Player 1 options:', player1Options.children.length, 'Player 2 options:', player2Options.children.length);
        
        // Re-initialize dropdown event listeners after adding new options
        console.log(' [DEBUG] Re-initializing dropdown event listeners...');
        initializeGameSetupDropdowns();
        
        // Update selected armies lists
        updateSelectedArmiesList('player1');
        updateSelectedArmiesList('player2');
        return;
      }
      
      // Try to find select elements for multiplayer (fallback)
      const player1Select = document.getElementById('player1-army-select');
      const player2Select = document.getElementById('player2-army-select');
      
      console.log(' [DEBUG] player1-army-select found:', !!player1Select);
      console.log(' [DEBUG] player2-army-select found:', !!player2Select);
      
      if (player1Select && player2Select) {
        console.log(' [DEBUG] Using select element structure for multiplayer');
      
      // Clear existing options except placeholder and default
      player1Select.innerHTML = '<option value="">Select an army...</option><option value="default">Default Army</option>';
      player2Select.innerHTML = '<option value="">Select an army...</option><option value="default">Default Army</option>';
      
      // Add saved armies to both dropdowns
        if (gameData.savedArmies && gameData.savedArmies.length > 0) {
      gameData.savedArmies.forEach(army => {
        const option1 = document.createElement('option');
        option1.value = army.id;
        option1.textContent = `${army.name} (${army.units.length} units)`;
        player1Select.appendChild(option1);
        
        const option2 = document.createElement('option');
        option2.value = army.id;
        option2.textContent = `${army.name} (${army.units.length} units)`;
        player2Select.appendChild(option2);
      });
        }
      
      // Update selected armies lists
      updateSelectedArmiesList('player1');
      updateSelectedArmiesList('player2');
        return;
      }
      
      // Try to find multiplayer army select elements
      const mpPlayer1Select = document.getElementById('mp-player1-army-select');
      const mpPlayer2Select = document.getElementById('mp-player2-army-select');
      
      console.log(' [DEBUG] mp-player1-army-select found:', !!mpPlayer1Select);
      console.log(' [DEBUG] mp-player2-army-select found:', !!mpPlayer2Select);
      
      if (mpPlayer1Select && mpPlayer2Select) {
        console.log(' [DEBUG] Using multiplayer select element structure');
      
      // Clear existing options except placeholder and default
      mpPlayer1Select.innerHTML = '<option value="">Select an army...</option><option value="default">Default Army</option>';
      mpPlayer2Select.innerHTML = '<option value="">Select an army...</option><option value="default">Default Army</option>';
      
      // Add saved armies to both dropdowns
        if (gameData.savedArmies && gameData.savedArmies.length > 0) {
      gameData.savedArmies.forEach(army => {
        const option1 = document.createElement('option');
        option1.value = army.id;
        option1.textContent = `${army.name} (${army.units.length} units)`;
        mpPlayer1Select.appendChild(option1);
        
        const option2 = document.createElement('option');
        option2.value = army.id;
        option2.textContent = `${army.name} (${army.units.length} units)`;
        mpPlayer2Select.appendChild(option2);
      });
        }
      
      // Update selected armies lists for multiplayer
      updateSelectedArmiesListMP('mp-player1');
      updateSelectedArmiesListMP('mp-player2');
        return;
      }
      
      console.error(' [DEBUG] No army dropdown elements found!');
      console.error(' [DEBUG] Available elements with "army" in ID:');
      document.querySelectorAll('[id*="army"]').forEach(el => {
        console.error(' [DEBUG] -', el.id, ':', el.tagName);
      });
    }
    
    // Unit tracking functions
    function trackUnitLoss(unit) {
      console.log(' [UNIT TRACKING] trackUnitLoss called for unit:', unit.name, 'Player:', unit.player);
      console.log(' [UNIT TRACKING] Unit details:', {
        name: unit.name,
        type: unit.type,
        player: unit.player,
        health: unit.health,
        maxHealth: unit.maxHealth
      });
      
      // Ensure campaignStats exists
      if (!gameState.campaignStats) {
        console.log(' [UNIT TRACKING] campaignStats not found, initializing...');
        gameState.campaignStats = {
          red: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          },
          blue: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          }
        };
      }
      
      const player = unit.player;
      // Normalize air and artillery types to readable labels
      const unitLabel = unit.type === 'air' ? `${unit.name} (Air)` : (unit.type === 'artillery' ? `${unit.name} (Artillery)` : unit.name);
      console.log(' [UNIT TRACKING] Before tracking - Player:', player, 'Stats:', gameState.campaignStats[player]);
      
      // Only count units that actually died (removed from grid)
      gameState.campaignStats[player].unitsLost++;
      gameState.campaignStats[player].unitsLostDetails.push(unitLabel);
      
      console.log(' [UNIT TRACKING] After tracking - Player:', player, 'Stats:', gameState.campaignStats[player]);
      console.log(' [UNIT TRACKING] Total campaign stats:', gameState.campaignStats);
    }
    
    function updateZoneControlStats() {
      console.log(' [ZONE CONTROL] updateZoneControlStats called');
      
      // Ensure campaignStats exists
      if (!gameState.campaignStats) {
        console.log(' [ZONE CONTROL] campaignStats not found, initializing...');
        gameState.campaignStats = {
          red: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          },
          blue: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          }
        };
      }
      
      console.log(' [ZONE CONTROL] Current zones:', zones.map(z => ({ id: z.id, control: z.control })));
      
      const redZonesControlled = zones.filter(zone => zone.control === 'red').length;
      const blueZonesControlled = zones.filter(zone => zone.control === 'blue').length;
      
      console.log(' [ZONE CONTROL] Red zones controlled:', redZonesControlled);
      console.log(' [ZONE CONTROL] Blue zones controlled:', blueZonesControlled);
      
      gameState.campaignStats.red.zonesControlled = redZonesControlled;
      gameState.campaignStats.blue.zonesControlled = blueZonesControlled;
      
      console.log(' [ZONE CONTROL] Updated campaign stats:', gameState.campaignStats);
    }
    
    // Summary Screen Functions
    function showSummaryScreen(result, endCondition = 'Victory') {
              console.log('===== SHOWING SUMMARY SCREEN =====');
        console.log('Result:', result);
        console.log('End condition:', endCondition);
      
      // If no result provided, this is called from accept buttons - skip overlay
      if (!result) {
        // Use stored victory data if available
        if (window.lastVictoryData) {
          result = window.lastVictoryData.result;
          endCondition = window.lastVictoryData.endCondition;
        } else {
          result = 'Victory!';
          endCondition = 'Victory';
        }
      } else {
        // Store victory data for later use
        window.lastVictoryData = { result, endCondition };
      }
      
      // Ensure campaignStats exists
      if (!gameState.campaignStats) {
        gameState.campaignStats = {
          red: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          },
          blue: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          }
        };
      }
      
      // Update zone control stats
      updateZoneControlStats();
      
              console.log('[SUMMARY] Campaign stats before displaying:', gameState.campaignStats);
      
      // Update summary screen content
      document.getElementById('summary-result').textContent = result;
      document.getElementById('summary-subtitle').textContent = 'Strategic Campaign Complete';
      
      // Update player names
      document.getElementById('red-player-name').textContent = gameConfig.player1.name;
      document.getElementById('blue-player-name').textContent = gameConfig.player2.name;
      document.getElementById('red-player-name-detailed').textContent = `${gameConfig.player1.name} - Detailed`;
      document.getElementById('blue-player-name-detailed').textContent = `${gameConfig.player2.name} - Detailed`;
      
              console.log('[SUMMARY DISPLAY] Updating summary screen with stats:', {
        red: gameState.campaignStats.red,
        blue: gameState.campaignStats.blue
      });
      
      // Update red player stats
      document.getElementById('red-zones-controlled').textContent = gameState.campaignStats.red.zonesControlled;
      document.getElementById('red-units-deployed').textContent = gameState.campaignStats.red.unitsDeployed;
      document.getElementById('red-units-lost').textContent = gameState.campaignStats.red.unitsLost;
      
              console.log('[SUMMARY DISPLAY] Red player stats updated:', {
        zonesControlled: gameState.campaignStats.red.zonesControlled,
        unitsDeployed: gameState.campaignStats.red.unitsDeployed,
        unitsLost: gameState.campaignStats.red.unitsLost,
        unitsLostDetails: gameState.campaignStats.red.unitsLostDetails
      });
      
      // Update blue player stats
      document.getElementById('blue-zones-controlled').textContent = gameState.campaignStats.blue.zonesControlled;
      document.getElementById('blue-units-deployed').textContent = gameState.campaignStats.blue.unitsDeployed;
      document.getElementById('blue-units-lost').textContent = gameState.campaignStats.blue.unitsLost;
      
              console.log('[SUMMARY DISPLAY] Blue player stats updated:', {
        zonesControlled: gameState.campaignStats.blue.zonesControlled,
        unitsDeployed: gameState.campaignStats.blue.unitsDeployed,
        unitsLost: gameState.campaignStats.blue.unitsLost,
        unitsLostDetails: gameState.campaignStats.blue.unitsLostDetails
      });
      
      // Update campaign info
      document.getElementById('total-turns').textContent = gameState.turnCount;
      document.getElementById('winner-name').textContent = result === 'Victory!' ? gameConfig.player1.name : gameConfig.player2.name;
      document.getElementById('end-condition').textContent = endCondition;
      
      // Populate detailed view
      populateDetailedView();
      

      
      // Show the summary screen
      console.log('[SUMMARY] Showing summary screen now');
      showScreen('summary');
    }
    
    function populateDetailedView() {
              console.log('[DETAILED VIEW] populateDetailedView called');
        console.log('[DETAILED VIEW] Campaign stats:', gameState.campaignStats);
      
      // Populate red player's lost units
      const redLostList = document.getElementById('red-units-lost-list');
              console.log('[DETAILED VIEW] Red lost list element:', redLostList);
      
      if (redLostList) {
        redLostList.innerHTML = '';
        
        console.log('[DETAILED VIEW] Red units lost details:', gameState.campaignStats.red.unitsLostDetails);
        
        if (gameState.campaignStats.red.unitsLostDetails.length === 0) {
          redLostList.innerHTML = '<div class="unit-lost-item">No units lost</div>';
          console.log('[DETAILED VIEW] Red player: No units lost');
        } else {
          gameState.campaignStats.red.unitsLostDetails.forEach((unitName, index) => {
            const unitDiv = document.createElement('div');
            unitDiv.className = 'unit-lost-item';
            unitDiv.textContent = unitName;
            redLostList.appendChild(unitDiv);
            console.log(`[DETAILED VIEW] Added red lost unit ${index + 1}: ${unitName}`);
          });
        }
      } else {
        console.error('[DETAILED VIEW] Red lost list element not found!');
      }
      
      // Populate blue player's lost units
      const blueLostList = document.getElementById('blue-units-lost-list');
              console.log('[DETAILED VIEW] Blue lost list element:', blueLostList);
      
      if (blueLostList) {
        blueLostList.innerHTML = '';
        
        console.log('[DETAILED VIEW] Blue units lost details:', gameState.campaignStats.blue.unitsLostDetails);
        
        if (gameState.campaignStats.blue.unitsLostDetails.length === 0) {
          blueLostList.innerHTML = '<div class="unit-lost-item">No units lost</div>';
          console.log('[DETAILED VIEW] Blue player: No units lost');
        } else {
          gameState.campaignStats.blue.unitsLostDetails.forEach((unitName, index) => {
            const unitDiv = document.createElement('div');
            unitDiv.className = 'unit-lost-item';
            unitDiv.textContent = unitName;
            blueLostList.appendChild(unitDiv);
            console.log(`[DETAILED VIEW] Added blue lost unit ${index + 1}: ${unitName}`);
          });
        }
      } else {
        console.error('[DETAILED VIEW] Blue lost list element not found!');
      }
    }
    
    function switchSummaryTab(tabName) {
      // Hide all tab contents
      const tabContents = document.querySelectorAll('.summary-tab-content');
      tabContents.forEach(content => content.classList.remove('active'));
      
      // Remove active class from all tab buttons
      const tabButtons = document.querySelectorAll('.tab-button');
      tabButtons.forEach(button => button.classList.remove('active'));
      
      // Show selected tab content
      const selectedTab = document.getElementById(`${tabName}-tab`);
      if (selectedTab) {
        selectedTab.classList.add('active');
      }
      
      // Add active class to clicked button
      const clickedButton = event.target;
      clickedButton.classList.add('active');
    }
    
    function surrenderGame() {
      if (confirm('Are you sure you want to surrender the campaign?')) {
        console.log(' Surrender confirmed by user');
        
        if (isMultiplayerMode) {
          // Multiplayer surrender - notify server
          console.log(' Player surrendering in multiplayer game');
          console.log(' Socket connected:', socket?.connected);
          console.log(' Lobby code:', lobbyCode);
          console.log(' Current player role:', getCurrentPlayerRole());
          
          if (socket && socket.connected) {
            const surrenderData = {
              lobbyCode: lobbyCode,
              surrenderingPlayer: getCurrentPlayerRole(),
              gameState: gameState
            };
            console.log(' Emitting surrender data:', surrenderData);
            socket.emit('playerSurrender', surrenderData);
            console.log(' Surrender event emitted successfully');
          } else {
            console.error(' Cannot surrender - socket not connected');
          }
        } else {
          // Single player surrender
          console.log(' Single player surrender initiated');
          const surrenderingPlayer = gameState.currentPlayer;
          const winner = surrenderingPlayer === 'red' ? gameConfig.player2.name : gameConfig.player1.name;
          const result = `${winner} Wins!`;
          
          console.log(' Surrendering player:', surrenderingPlayer);
          console.log(' Winner:', winner);
          console.log(' Result:', result);
          
          showSummaryScreen(result, 'Surrender');
        }
      } else {
        console.log(' Surrender cancelled by user');
      }
    }
    
    function returnToMainMenu() {
  console.log(' ===== RETURNING TO MAIN MENU =====');
  
  if (isMultiplayerMode) {
    // Multiplayer main menu - disconnect from server
    console.log(' Returning to main menu from multiplayer game');
    
    // Reset multiplayer state first
    isMultiplayerMode = false;
    isInGameSetup = false;
    lobbyCode = null;
    myPlayerId = null;
    playerRole = null;
    lobbyPlayers = [];
    armySelectionStatus = { player1: false, player2: false };
    multiplayerGameData = null;
    
    // Clear selected armies
    gameData.selectedArmies = { player1: [], player2: [] };
    
    // Reset game state
    gameState = {
      currentPlayer: 'red',
      commandPoints: { red: 3, blue: 3 },
      selectedDice: { attack: 0, defend: 0, morale: 0 },
      turnCount: 0,
      diceAugmented: false,
      currentZone: null,
      gamePhase: 'selection',
      lockedZones: { red: [], blue: [] },
      currentZonePhase: 'defense',
      selectedUnit: null,
      deploymentMode: 'place',
      deployedUnits: { red: [], blue: [] },
      zoneRoles: {},
      unitActions: {},
      zoneNames: {},
      movementMode: {
        active: false,
        selectedUnit: null,
        movementPoints: 0,
        validPositions: []
      },
      unitDeployments: {},
      selectedArmyInZone: {
        red: null,
        blue: null
      },
      armySelectionMode: false,
      deployedUnitInstances: {},
      artillery: { red: [], blue: [] },
      aerial: { red: [], blue: [] },
      artilleryActions: {},
      aerialActions: {},
      // AI system state
      aiState: {
        isAITurn: false,
        aiPlayer: null,
        aiThinking: false,
        aiDifficulty: 4
      },
      campaignStats: {
        red: {
          unitsDeployed: 0,
          unitsLost: 0,
          unitsLostDetails: [],
          zonesControlled: 0
        },
        blue: {
          unitsDeployed: 0,
          unitsLost: 0,
          unitsLostDetails: [],
          zonesControlled: 0
        }
      }
    };
    
    // Reset zones
    zones.forEach(zone => {
      zone.control = 'contested';
      zone.locked = false;
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        zone.tacticalGrid[pos].unit = null;
      }
    });
    
    // Show the main menu screen immediately
    console.log(' Showing main menu screen immediately');
    showScreen('main-menu');
    
    // Then handle the disconnection in the background
    setTimeout(() => {
      if (socket && socket.connected) {
        // Disconnect from the current lobby
        if (lobbyCode) {
          console.log(' Leaving lobby:', lobbyCode);
          socket.emit('leaveLobby', { lobbyCode: lobbyCode });
        }
        
        // Disconnect from server
        console.log(' Disconnecting from server');
        socket.disconnect();
      }
      
      console.log(' Multiplayer state reset completed');
      console.log(' ===== RETURN TO MAIN MENU COMPLETED =====');
    }, 100);
  } else {
    // Single player - just go to main menu
    console.log(' Single player - showing main menu screen');
    showScreen('main-menu');
    console.log(' ===== RETURN TO MAIN MENU COMPLETED =====');
      }
    }
    
    function startNewGame() {
  console.log(' [START NEW GAME DEBUG] startNewGame() called');
  console.log(' [START NEW GAME DEBUG] isMultiplayerMode:', isMultiplayerMode);
  console.log(' [START NEW GAME DEBUG] Current screen:', document.querySelector('.screen.active')?.id);
  
  if (isMultiplayerMode) {
    // Multiplayer new game - request from server
    console.log(' Requesting new multiplayer game...');
    
    // Check if button is already disabled (prevent multiple clicks)
    let newGameButton = document.querySelector('button[onclick="startNewGame()"]');
    if (!newGameButton) {
      // Try finding by text content
      const buttons = document.querySelectorAll('button');
      for (const button of buttons) {
        if (button.textContent.includes('New Game') || button.textContent.includes('Waiting for opponent')) {
          newGameButton = button;
          break;
        }
      }
    }
    
    if (newGameButton && newGameButton.disabled) {
      console.log(' Button already disabled, ignoring click');
      return;
    }
    
    if (socket && socket.connected && lobbyCode) {
      // Send new game request to server
      socket.emit('requestNewGame', { lobbyCode: lobbyCode });
      
      // Show waiting message (button already found above)
      
      if (newGameButton) {
        console.log(' Updating New Game button to waiting state');
        newGameButton.textContent = 'Waiting for opponent...';
        newGameButton.disabled = true;
        newGameButton.style.opacity = '0.6';
        newGameButton.style.cursor = 'not-allowed';
      } else {
        console.warn(' Could not find New Game button to update');
      }
      
      // Remove any existing notification since we're now requesting
      const notification = document.getElementById('new-game-notification');
      if (notification) {
        notification.remove();
      }
      
      console.log(' New game request sent to server');
    } else {
      console.error(' No socket available for new game request');
    }
  } else {
    // Single player new game
    // Hide victory overlay if it's showing
    hideVictoryOverlay();
    
      // Reset game state
      gameState = {
        currentPlayer: 'red',
        commandPoints: { red: 3, blue: 3 },
        // Reset build points to defaults for a new game
        buildPoints: { red: 10, blue: 10 },
        selectedDice: { attack: 0, defend: 0, morale: 0 },
        turnCount: 0,
        diceAugmented: false,
        currentZone: null,
        gamePhase: 'selection',
        lockedZones: { red: [], blue: [] },
        currentZonePhase: 'defense',
        selectedUnit: null,
        deploymentMode: 'place',
        deployedUnits: { red: [], blue: [] },
        zoneRoles: {},
        unitActions: {},
        zoneNames: {},
        gasClouds: {}, // Format: { zoneId: { position: { player, turnsRemaining, deployedOnTurn } } }
        movementMode: {
          active: false,
          selectedUnit: null,
          movementPoints: 0,
          validPositions: []
        },
        unitDeployments: {},
        selectedArmyInZone: {
          red: null,
          blue: null
        },
        armySelectionMode: false,
        deployedUnitInstances: {},
        artillery: { red: [], blue: [] },
        aerial: { red: [], blue: [] },
        artilleryActions: {},
        aerialActions: {},
        // AI system state
        aiState: {
          isAITurn: false,
          aiPlayer: null,
          aiThinking: false,
          aiDifficulty: 4
        },
        campaignStats: {
          red: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          },
          blue: {
            unitsDeployed: 0,
            unitsLost: 0,
            unitsLostDetails: [],
            zonesControlled: 0
          }
        }
      };
      
      // Reset zones
      zones.forEach(zone => {
        zone.control = 'contested';
        zone.locked = false;
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          zone.tacticalGrid[pos].unit = null;
        }
      });
      
      // Reset legion selection UI for new game
      console.log(' [NEW GAME DEBUG] Starting legion selection reset...');
      const armySelectorText = document.getElementById('army-selector-text');
      const armyInfo = document.getElementById('selected-army-info');
      const armySelectionContainer = document.getElementById('army-selection-container');
      const armyPoolContainer = document.getElementById('army-pool-container');
      
      console.log(' [NEW GAME DEBUG] Found elements:', {
        armySelectorText: !!armySelectorText,
        armyInfo: !!armyInfo,
        armySelectionContainer: !!armySelectionContainer,
        armyPoolContainer: !!armyPoolContainer
      });
      
      if (armySelectorText) {
        console.log(' [NEW GAME DEBUG] Current army selector text:', armySelectorText.textContent);
        armySelectorText.textContent = 'Choose legion...';
        console.log(' [NEW GAME DEBUG] Legion selection reset for new game');
      } else {
        console.log(' [NEW GAME DEBUG] army-selector-text element not found!');
      }
      
      if (armyInfo) {
        console.log(' [NEW GAME DEBUG] Hiding army info');
        armyInfo.style.display = 'none';
      } else {
        console.log(' [NEW GAME DEBUG] selected-army-info element not found!');
      }
      
      if (armySelectionContainer) {
        console.log(' [NEW GAME DEBUG] Showing army selection container');
        armySelectionContainer.style.display = 'block';
      } else {
        console.log(' [NEW GAME DEBUG] army-selection-container element not found!');
      }
      
      if (armyPoolContainer) {
        console.log(' [NEW GAME DEBUG] Hiding army pool container');
        armyPoolContainer.style.display = 'none';
      } else {
        console.log(' [NEW GAME DEBUG] army-pool-container element not found!');
      }
      
      // Reset army selection dropdowns in game setup screen
      console.log(' [NEW GAME DEBUG] Resetting army selection dropdowns...');
      const player1ArmySelected = document.getElementById('player1ArmySelected');
      const player2ArmySelected = document.getElementById('player2ArmySelected');
      
      if (player1ArmySelected) {
        console.log(' [NEW GAME DEBUG] Resetting player1 army selection to "Select Legion Type"');
        player1ArmySelected.textContent = 'Select Legion Type';
      } else {
        console.log(' [NEW GAME DEBUG] player1ArmySelected element not found!');
      }
      
      if (player2ArmySelected) {
        console.log(' [NEW GAME DEBUG] Resetting player2 army selection to "Select Legion Type"');
        player2ArmySelected.textContent = 'Select Legion Type';
      } else {
        console.log(' [NEW GAME DEBUG] player2ArmySelected element not found!');
      }
      
      // Clear selected armies from gameData
      console.log(' [NEW GAME DEBUG] Clearing selected armies from gameData...');
      if (gameData && gameData.selectedArmies) {
        gameData.selectedArmies.player1 = [];
        gameData.selectedArmies.player2 = [];
        console.log(' [NEW GAME DEBUG] Cleared selected armies from gameData');
      }
      
      // Go to game setup
      console.log(' [START NEW GAME DEBUG] About to show game-setup screen');
      showScreen('game-setup');
      // Also reset the singleplayer build point sliders to defaults when starting a new game
      resetSingleplayerBuildPoints();
      
      // Add a delay to check if elements are available after screen change
      setTimeout(() => {
        console.log(' [START NEW GAME DEBUG] Checking elements after screen change...');
        const armySelectorText = document.getElementById('army-selector-text');
        const armyInfo = document.getElementById('selected-army-info');
        const armySelectionContainer = document.getElementById('army-selection-container');
        const armyPoolContainer = document.getElementById('army-pool-container');
        
        console.log(' [START NEW GAME DEBUG] Elements after screen change:', {
          armySelectorText: !!armySelectorText,
          armyInfo: !!armyInfo,
          armySelectionContainer: !!armySelectionContainer,
          armyPoolContainer: !!armyPoolContainer
        });
        
        if (armySelectorText) {
          console.log(' [START NEW GAME DEBUG] Final army selector text:', armySelectorText.textContent);
        }
        
        // Also check if we're on the game-setup screen and if legion selection elements exist there
        const gameSetupScreen = document.getElementById('game-setup');
        if (gameSetupScreen && gameSetupScreen.classList.contains('active')) {
          console.log(' [START NEW GAME DEBUG] On game-setup screen, checking for legion elements...');
          const setupArmySelectorText = document.querySelector('#game-setup #army-selector-text');
          if (setupArmySelectorText) {
            console.log(' [START NEW GAME DEBUG] Found army selector text on game-setup screen:', setupArmySelectorText.textContent);
          } else {
            console.log(' [START NEW GAME DEBUG] No army selector text found on game-setup screen');
          }
          
          // Reset army selection dropdowns on game setup screen
          const player1ArmySelected = document.getElementById('player1ArmySelected');
          const player2ArmySelected = document.getElementById('player2ArmySelected');
          
          if (player1ArmySelected) {
            console.log(' [START NEW GAME DEBUG] Resetting player1 army selection on game-setup screen');
            player1ArmySelected.textContent = 'Select Legion Type';
          }
          
          if (player2ArmySelected) {
            console.log(' [START NEW GAME DEBUG] Resetting player2 army selection on game-setup screen');
            player2ArmySelected.textContent = 'Select Legion Type';
          }
          
          // Update the selected armies list display
          if (typeof updateSelectedArmiesList === 'function') {
            console.log(' [START NEW GAME DEBUG] Updating selected armies list display...');
            updateSelectedArmiesList('player1');
            updateSelectedArmiesList('player2');
          }
        }
      }, 100);
  }
    }
    
    // AI System Functions
    function toggleAISettings() {
      console.log(' Toggling AI settings...');
      
      try {
        const opponentType = getDropdownValue('opponentDropdown');
        console.log(' Opponent type from dropdown:', opponentType);
        
        const aiSettings = document.getElementById('ai-settings');
        if (!aiSettings) {
          console.error(' AI settings element not found');
          return;
        }
        
        if (opponentType === 'ai') {
          console.log(' Showing AI settings');
          aiSettings.style.display = 'block';
          aiSettings.style.animation = 'fadeIn 0.3s ease';
        } else {
          console.log(' Hiding AI settings');
          aiSettings.style.display = 'none';
        }
      } catch (error) {
        console.error(' Error in toggleAISettings:', error);
      }
    }
    
    // Update Color Display
    function updateColorDisplay(colorInputId) {
      const colorDisplay = document.getElementById(colorInputId + '-display');
      if (colorDisplay) {
        // Get the current color value from the display element
        const currentColor = colorDisplay.style.getPropertyValue('--color-value') || '#ff0000';
        colorDisplay.style.setProperty('--color-value', currentColor);
      }
    }
    
    // Game Setup Dropdown Management - Using the exact same pattern as music dropdown
    function initializeGameSetupDropdowns() {
      console.log(' Initializing game setup dropdowns...');
      
      // Check if we're on the game setup screen
      const gameSetupScreen = document.getElementById('game-setup');
      if (!gameSetupScreen || !gameSetupScreen.classList.contains('active')) {
        console.log(' Game setup screen not active, but continuing with dropdown initialization anyway...');
        // Don't return - continue with initialization even if screen check fails
      }
      
      const dropdowns = [
        { id: 'opponentDropdown', selectedId: 'opponentSelected', optionsId: 'opponentOptions' },
        { id: 'player1ArmyDropdown', selectedId: 'player1ArmySelected', optionsId: 'player1ArmyOptions' },
        { id: 'player2ArmyDropdown', selectedId: 'player2ArmySelected', optionsId: 'player2ArmyOptions' },
        { id: 'winConditionDropdown', selectedId: 'winConditionSelected', optionsId: 'winConditionOptions' },
        { id: 'terrainDropdown', selectedId: 'terrainSelected', optionsId: 'terrainOptions' },
        { id: 'dayNightDropdown', selectedId: 'dayNightSelected', optionsId: 'dayNightOptions' },
        { id: 'weatherDropdown', selectedId: 'weatherSelected', optionsId: 'weatherOptions' }
      ];
      
      dropdowns.forEach(dropdownConfig => {
        const dropdown = document.getElementById(dropdownConfig.id);
        const selected = document.getElementById(dropdownConfig.selectedId);
        const options = document.getElementById(dropdownConfig.optionsId);
        
        if (!dropdown || !selected || !options) {
          console.error(` Dropdown elements not found: ${dropdownConfig.id}`);
          return;
        }
        
        console.log(` Initializing dropdown: ${dropdownConfig.id}`);
        
        // Remove existing event listeners by cloning and replacing elements
        const newSelected = selected.cloneNode(true);
        selected.parentNode.replaceChild(newSelected, selected);
        
        // Re-get the elements after cloning
        const freshSelected = document.getElementById(dropdownConfig.selectedId);
        const freshOptions = document.getElementById(dropdownConfig.optionsId);
        const freshDropdownOptionElements = freshOptions.querySelectorAll('.dropdown-option');
        
        // Add click event to selected element (exact same as music dropdown)
        freshSelected.addEventListener('click', function(e) {
          e.stopPropagation();
          
          // Close all other dropdowns first
          dropdowns.forEach(otherConfig => {
            if (otherConfig.id !== dropdownConfig.id) {
              const otherDropdown = document.getElementById(otherConfig.id);
              const otherOptions = document.getElementById(otherConfig.optionsId);
              if (otherDropdown && otherOptions) {
                otherDropdown.classList.remove('open');
                otherOptions.classList.remove('open');
              }
            }
          });
          
          // Toggle current dropdown (exact same as music dropdown)
          dropdown.classList.toggle('open');
          freshOptions.classList.toggle('open');
        });
        
        // Handle option selection (exact same as music dropdown)
        freshDropdownOptionElements.forEach(option => {
          console.log(` [DEBUG] Adding click listener to option: ${option.textContent} (${option.getAttribute('data-value')})`);
          
          option.addEventListener('click', function(e) {
            e.stopPropagation();
            
            const value = this.getAttribute('data-value');
            const text = this.textContent;
            
            console.log(` Selected ${dropdownConfig.id}: ${text} (${value})`);
            console.log(` [DEBUG] Option clicked - value: ${value}, text: ${text}`);
            
            // Update selected display
            freshSelected.textContent = text;
            
            // Update selected state
            freshDropdownOptionElements.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            
            console.log(` [DEBUG] Updated dropdown display to: ${text}`);
            console.log(` [DEBUG] Added 'selected' class to option with value: ${value}`);
            
            // Close dropdown (exact same as music dropdown)
            dropdown.classList.remove('open');
            freshOptions.classList.remove('open');
            
            // Handle special cases
            if (dropdownConfig.id === 'opponentDropdown') {
              toggleAISettings();
            }
            
            // Debug: Check if this is an army dropdown and log the current state
            if (dropdownConfig.id === 'player1ArmyDropdown' || dropdownConfig.id === 'player2ArmyDropdown') {
              console.log(` [DEBUG] Army dropdown ${dropdownConfig.id} selection complete`);
              console.log(` [DEBUG] Current selected value: ${value}`);
              console.log(` [DEBUG] Current selected text: ${text}`);
              console.log(` [DEBUG] Selected option has 'selected' class:`, this.classList.contains('selected'));
            }
          });
        });
        
        console.log(` Dropdown ${dropdownConfig.id} initialized successfully`);
      });
      
      // Close dropdowns when clicking outside (exact same as music dropdown)
      document.addEventListener('click', function(e) {
        dropdowns.forEach(dropdownConfig => {
          const dropdown = document.getElementById(dropdownConfig.id);
          if (dropdown && !dropdown.contains(e.target)) {
            dropdown.classList.remove('open');
            const options = document.getElementById(dropdownConfig.optionsId);
            if (options) {
              options.classList.remove('open');
            }
          }
        });
      });
      
      console.log(' All game setup dropdowns initialized');
    }
    
    function getDropdownValue(dropdownId) {
      console.log(` Getting value for dropdown: ${dropdownId}`);
      
      try {
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) {
          console.error(` Dropdown not found: ${dropdownId}`);
          return '';
        }
        
        const selectedOption = dropdown.querySelector('.dropdown-option.selected');
        const value = selectedOption ? selectedOption.dataset.value : '';
        
        console.log(` Dropdown ${dropdownId} value:`, value);
        return value;
      } catch (error) {
        console.error(` Error getting dropdown value for ${dropdownId}:`, error);
        return '';
      }
    }
    
    function updateAICPDisplay() {
      const aiCpSlider = document.getElementById('ai-cp');
      const aiCpDisplay = document.getElementById('ai-cp-display');
      
      if (aiCpSlider && aiCpDisplay) {
        aiCpDisplay.textContent = aiCpSlider.value;
      }
    }
    
    // Update Starting CP Display
    function updateCPDisplay() {
      const startingCP = document.getElementById('starting-cp');
      const cpDisplay = document.getElementById('cp-display');
      
      if (startingCP && cpDisplay) {
        cpDisplay.textContent = startingCP.value;
      }
    }
    
    // Update Player 1 CP Display
    function updatePlayer1CPDisplay() {
      const player1CP = document.getElementById('player1-cp');
      const player1CPDisplay = document.getElementById('player1-cp-display');
      
      if (player1CP && player1CPDisplay) {
        player1CPDisplay.textContent = player1CP.value;
      }
    }
    
    // Update Player 2 CP Display
    function updatePlayer2CPDisplay() {
      const player2CP = document.getElementById('player2-cp');
      const player2CPDisplay = document.getElementById('player2-cp-display');
      
      if (player2CP && player2CPDisplay) {
        player2CPDisplay.textContent = player2CP.value;
      }
    }

    // Update Player 1 Build Points Display
    function updatePlayer1BuildPointsDisplay() {
      const player1BuildPoints = document.getElementById('player1-build-points');
      const player1BuildPointsDisplay = document.getElementById('player1-build-points-display');
      
      if (player1BuildPoints && player1BuildPointsDisplay) {
        player1BuildPointsDisplay.textContent = player1BuildPoints.value;
      }
    }

    // Update Player 2 Build Points Display
    function updatePlayer2BuildPointsDisplay() {
      const player2BuildPoints = document.getElementById('player2-build-points');
      const player2BuildPointsDisplay = document.getElementById('player2-build-points-display');
      
      if (player2BuildPoints && player2BuildPointsDisplay) {
        player2BuildPointsDisplay.textContent = player2BuildPoints.value;
      }
    }
    
    // Update Build Points Display
    function updateBuildPointsDisplay() {
      const buildPoints = document.getElementById('build-points');
      const buildPointsDisplay = document.getElementById('build-points-display');
      
      if (buildPoints && buildPointsDisplay) {
        buildPointsDisplay.textContent = buildPoints.value;
      }
    }
    
    function setupOpponentToggle() {
      console.log(' Setting up opponent toggle...');
      
      try {
        // Initialize AI settings visibility
        console.log(' Toggling AI settings...');
        toggleAISettings();
        
        // Initialize dropdowns
        console.log(' Initializing dropdowns...');
        initializeGameSetupDropdowns();
        
        // Setup AI CP slider
        console.log(' Setting up AI CP slider...');
        const aiCpSlider = document.getElementById('ai-cp');
        const aiCpDisplay = document.getElementById('ai-cp-display');
        if (aiCpSlider && aiCpDisplay) {
          aiCpSlider.addEventListener('input', function() {
            aiCpDisplay.textContent = this.value;
          });
          console.log(' AI CP slider setup complete');
        } else {
          console.warn(' AI CP slider elements not found');
        }
        
        // Initialize displays
        console.log(' Initializing displays...');
        updateAICPDisplay();
        updateZoneDisplay();
        updateCPDisplay();
        
        // Initialize Unit Creator if screen is active
        const currentScreen = document.querySelector('.screen.active');
        if (currentScreen && currentScreen.id === 'unit-creator') {
          initializeUnitCreator();
        }
        
        console.log(' Setup opponent toggle complete');
      } catch (error) {
        console.error(' Error in setupOpponentToggle:', error);
      }
    }
    
    // Initialize Unit Creator
    function initializeUnitCreator() {
      try {
        // Load custom units
        loadCustomUnitsFromStorage();
        
        // Initialize custom dropdowns
        console.log(' About to call initializeUnitCreatorDropdowns()...');
        
        // Check if DOM elements exist before initializing
        const checkElements = () => {
          const unitTypeDropdown = document.getElementById('unit-type-dropdown');
          const unitTypeSelected = document.getElementById('unit-type-selected');
          const unitTypeOptions = document.getElementById('unit-type-options');
          
          console.log(' DOM check - elements found:', {
            dropdown: !!unitTypeDropdown,
            selected: !!unitTypeSelected,
            options: !!unitTypeOptions
          });
          
          if (unitTypeDropdown && unitTypeSelected && unitTypeOptions) {
            console.log(' All elements found, initializing dropdowns...');
            initializeUnitCreatorDropdowns();
            console.log(' initializeUnitCreatorDropdowns() called successfully');
            
            // Now that dropdowns are initialized, update stat displays
            updateStatDisplays();
          } else {
            console.log(' Elements not ready yet, retrying in 100ms...');
            setTimeout(checkElements, 100);
          }
        };
        
        checkElements();
        
        // Add event listeners for real-time preview
        const nameInput = document.getElementById('unit-name');
        
        if (nameInput) {
          nameInput.addEventListener('input', updatePreview);
        }
        
        // Add glow effects to sliders when interacting
         const sliders = document.querySelectorAll('#unit-creator .volume-slider');
         sliders.forEach(slider => {
           slider.addEventListener('input', function() {
             this.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6), inset 0 0 15px rgba(0, 0, 0, 0.8)';
             setTimeout(() => {
               this.style.boxShadow = '0 0 15px rgba(255, 0, 0, 0.3), inset 0 0 10px rgba(0, 0, 0, 0.6)';
             }, 200);
           });
         });
        
        // Start atmospheric effects
        setTimeout(startAtmosphericEffects, 1000);
      } catch (error) {
        console.error(' Error in initializeUnitCreator:', error);
      }
    }
    
    // Initialize Unit Creator Dropdowns
    function initializeUnitCreatorDropdowns() {
      try {
        console.log(' Starting Unit Creator dropdown initialization...');
        
        // Unit Type Dropdown
        const unitTypeDropdown = document.getElementById('unit-type-dropdown');
        const unitTypeSelected = document.getElementById('unit-type-selected');
        const unitTypeOptions = document.getElementById('unit-type-options');
        
        console.log(' Unit Type elements found:', {
          dropdown: unitTypeDropdown,
          selected: unitTypeSelected,
          options: unitTypeOptions
        });
        
        if (unitTypeDropdown && unitTypeSelected && unitTypeOptions) {
          console.log(' Unit Type dropdown elements found, adding event listeners...');
          
          // Toggle dropdown
          unitTypeSelected.addEventListener('click', function(e) {
            console.log(' Unit Type dropdown clicked!');
            console.log(' Before toggle - dropdown open:', unitTypeDropdown.classList.contains('open'));
            console.log(' Before toggle - options open:', unitTypeOptions.classList.contains('open'));
            console.log(' Before toggle - dropdown computed styles:', window.getComputedStyle(unitTypeDropdown));
            console.log(' Before toggle - options computed styles:', window.getComputedStyle(unitTypeOptions));
            
            unitTypeDropdown.classList.toggle('open');
            unitTypeOptions.classList.toggle('open');
            
            console.log(' After toggle - dropdown open:', unitTypeDropdown.classList.contains('open'));
            console.log(' After toggle - options open:', unitTypeOptions.classList.contains('open'));
            console.log(' After toggle - dropdown classes:', unitTypeDropdown.className);
            console.log(' After toggle - options classes:', unitTypeOptions.className);
            console.log(' After toggle - dropdown computed styles:', window.getComputedStyle(unitTypeDropdown));
            console.log(' After toggle - options computed styles:', window.getComputedStyle(unitTypeOptions));
            
            // Force a repaint
            unitTypeOptions.offsetHeight;
            
            // Additional debugging
            console.log(' Dropdown position:', unitTypeDropdown.getBoundingClientRect());
            console.log(' Options position:', unitTypeOptions.getBoundingClientRect());
            console.log(' Options display:', window.getComputedStyle(unitTypeOptions).display);
            console.log(' Options visibility:', window.getComputedStyle(unitTypeOptions).visibility);
            console.log(' Options opacity:', window.getComputedStyle(unitTypeOptions).opacity);
          });
          
          // Handle option selection
          const unitTypeOptionElements = unitTypeOptions.querySelectorAll('.dropdown-option');
          unitTypeOptionElements.forEach(option => {
            option.addEventListener('click', function(e) {
              e.stopPropagation();
              
              const value = this.getAttribute('data-value');
              const text = this.textContent;
              
              // Update selected display
              unitTypeSelected.textContent = text;
             // Keep data-value in sync so preview updates correctly
             unitTypeSelected.setAttribute('data-value', value);
              
              // Update selected state
              unitTypeOptionElements.forEach(opt => opt.classList.remove('selected'));
              this.classList.add('selected');
              
              // Close dropdown
              unitTypeDropdown.classList.remove('open');
              unitTypeOptions.classList.remove('open');
              
              // Add selection effect
              unitTypeSelected.style.transform = 'scale(1.02)';
              unitTypeSelected.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6)';
              
              setTimeout(() => {
                unitTypeSelected.style.transform = '';
                unitTypeSelected.style.boxShadow = '';
              }, 200);
              
              // Call the original function
              updateUnitTypeFields();
              updatePreview();
            });
          });
        }
        
        // Unit Select Dropdown
        const unitSelectDropdown = document.getElementById('unit-select-dropdown');
        const unitSelectSelected = document.getElementById('unit-select-selected');
        const unitSelectOptions = document.getElementById('unit-select-options');
        
        console.log(' Unit Select elements found:', {
          dropdown: unitSelectDropdown,
          selected: unitSelectSelected,
          options: unitSelectOptions
        });
        
        if (unitSelectDropdown && unitSelectSelected && unitSelectOptions) {
          console.log(' Unit Select dropdown elements found, adding event listeners...');
          
          // Toggle dropdown
          unitSelectSelected.addEventListener('click', function(e) {
            console.log(' Unit Select dropdown clicked!');
            console.log(' Before toggle - dropdown open:', unitSelectDropdown.classList.contains('open'));
            console.log(' Before toggle - options open:', unitSelectOptions.classList.contains('open'));
            
            unitSelectDropdown.classList.toggle('open');
            unitSelectOptions.classList.toggle('open');
            
            console.log(' After toggle - dropdown open:', unitSelectDropdown.classList.contains('open'));
            console.log(' After toggle - options open:', unitSelectOptions.classList.contains('open'));
            console.log(' Dropdown classes:', unitSelectDropdown.className);
            console.log(' Options classes:', unitSelectOptions.className);
            
            // Additional debugging
            console.log(' Dropdown position:', unitSelectDropdown.getBoundingClientRect());
            console.log(' Options position:', unitSelectOptions.getBoundingClientRect());
            console.log(' Options display:', window.getComputedStyle(unitSelectOptions).display);
            console.log(' Options visibility:', window.getComputedStyle(unitSelectOptions).visibility);
            console.log(' Options opacity:', window.getComputedStyle(unitSelectOptions).opacity);
          });
          
          // Handle option selection
          const unitSelectOptionElements = unitSelectOptions.querySelectorAll('.dropdown-option');
          unitSelectOptionElements.forEach(option => {
            option.addEventListener('click', function(e) {
              e.stopPropagation();
              
              const value = this.getAttribute('data-value');
              const text = this.textContent;
              
              // Update selected display
              unitSelectSelected.textContent = text;
             // Keep data-value in sync so load/edit works
             unitSelectSelected.setAttribute('data-value', value);
              
              // Update selected state
              unitSelectOptionElements.forEach(opt => opt.classList.remove('selected'));
              this.classList.add('selected');
              
              // Close dropdown
              unitSelectDropdown.classList.remove('open');
              unitSelectOptions.classList.remove('open');
              
              // Add selection effect
              unitSelectSelected.style.transform = 'scale(1.02)';
              unitSelectSelected.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6)';
              
              setTimeout(() => {
                unitSelectSelected.style.transform = '';
                unitSelectSelected.style.boxShadow = '';
              }, 200);
              
              // Call the original function
              loadUnitForEditing();
            });
          });
        }
        
        // Special Ability Dropdown
        const specialAbilityDropdown = document.getElementById('special-ability-dropdown');
        const specialAbilitySelected = document.getElementById('special-ability-selected');
        const specialAbilityOptions = document.getElementById('special-ability-options');
        
        console.log(' Special Ability elements found:', {
          dropdown: specialAbilityDropdown,
          selected: specialAbilitySelected,
          options: specialAbilityOptions
        });
        
        if (specialAbilityDropdown && specialAbilitySelected && specialAbilityOptions) {
          console.log(' Special Ability dropdown elements found, adding event listeners...');
          
          // Toggle dropdown
          specialAbilitySelected.addEventListener('click', function(e) {
            console.log(' Special Ability dropdown clicked!');
            console.log(' Before toggle - dropdown open:', specialAbilityDropdown.classList.contains('open'));
            console.log(' Before toggle - options open:', specialAbilityOptions.classList.contains('open'));
            
            specialAbilityDropdown.classList.toggle('open');
            specialAbilityOptions.classList.toggle('open');
            
            console.log(' After toggle - dropdown open:', specialAbilityDropdown.classList.contains('open'));
            console.log(' After toggle - options open:', specialAbilityOptions.classList.contains('open'));
            console.log(' Dropdown classes:', specialAbilityDropdown.className);
            console.log(' Options classes:', specialAbilityOptions.className);
            
            // Additional debugging
            console.log(' Dropdown position:', specialAbilityDropdown.getBoundingClientRect());
            console.log(' Options position:', specialAbilityOptions.getBoundingClientRect());
            console.log(' Options display:', window.getComputedStyle(specialAbilityOptions).display);
            console.log(' Options visibility:', window.getComputedStyle(specialAbilityOptions).visibility);
            console.log(' Options opacity:', window.getComputedStyle(specialAbilityOptions).opacity);
          });
          
          // Handle option selection
          const specialAbilityOptionElements = specialAbilityOptions.querySelectorAll('.dropdown-option');
          specialAbilityOptionElements.forEach(option => {
            option.addEventListener('click', function(e) {
              e.stopPropagation();
              
              const value = this.getAttribute('data-value');
              const text = this.textContent;
              
              // Update selected display
              specialAbilitySelected.textContent = text;
             // Keep data-value in sync so preview updates correctly
             specialAbilitySelected.setAttribute('data-value', value);
              
              // Update selected state
              specialAbilityOptionElements.forEach(opt => opt.classList.remove('selected'));
              this.classList.add('selected');
              
              // Close dropdown
              specialAbilityDropdown.classList.remove('open');
              specialAbilityOptions.classList.remove('open');
              
              // Add selection effect
              specialAbilitySelected.style.transform = 'scale(1.02)';
              specialAbilitySelected.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6)';
              
              setTimeout(() => {
                specialAbilitySelected.style.transform = '';
                specialAbilitySelected.style.boxShadow = '';
              }, 200);
              
              // Call the original function
              updatePreview();
            });
          });
        }
        
        // Ensure dynamically populated Unit Select options work (event delegation)
        if (unitSelectOptions && unitSelectSelected && unitSelectDropdown) {
          unitSelectOptions.addEventListener('click', function(e) {
            const option = e.target && e.target.closest('.dropdown-option');
            if (!option || !this.contains(option)) return;
            e.stopPropagation();
            const value = option.getAttribute('data-value');
            const text = option.textContent;
            unitSelectSelected.textContent = text;
            unitSelectSelected.setAttribute('data-value', value);
            // Update selected visual state
            const all = this.querySelectorAll('.dropdown-option');
            all.forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            // Close dropdown
            unitSelectDropdown.classList.remove('open');
            this.classList.remove('open');
            // Selection effect
            unitSelectSelected.style.transform = 'scale(1.02)';
            unitSelectSelected.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6)';
            setTimeout(() => {
              unitSelectSelected.style.transform = '';
              unitSelectSelected.style.boxShadow = '';
            }, 200);
            // Load unit and update UI
            loadUnitForEditing();
          });
        }

        // Ensure dynamically populated Special Ability options work (event delegation)
        if (specialAbilityOptions && specialAbilitySelected && specialAbilityDropdown) {
          specialAbilityOptions.addEventListener('click', function(e) {
            const option = e.target && e.target.closest('.dropdown-option');
            if (!option || !this.contains(option)) return;
            e.stopPropagation();
            const value = option.getAttribute('data-value');
            const text = option.textContent;
            specialAbilitySelected.textContent = text;
            specialAbilitySelected.setAttribute('data-value', value);
            // Update selected visual state
            const all = this.querySelectorAll('.dropdown-option');
            all.forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            // Close dropdown
            specialAbilityDropdown.classList.remove('open');
            this.classList.remove('open');
            // Selection effect
            specialAbilitySelected.style.transform = 'scale(1.02)';
            specialAbilitySelected.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6)';
            setTimeout(() => {
              specialAbilitySelected.style.transform = '';
              specialAbilitySelected.style.boxShadow = '';
            }, 200);
            // Update preview
            updatePreview();
          });
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
          const dropdowns = [unitTypeDropdown, unitSelectDropdown, specialAbilityDropdown];
          dropdowns.forEach(dropdown => {
            if (dropdown && !dropdown.contains(e.target)) {
              dropdown.classList.remove('open');
              const options = dropdown.querySelector('.dropdown-options');
              if (options) options.classList.remove('open');
            }
          });
        });
        
        console.log(' Unit Creator dropdowns initialized');
        console.log(' Final check - all dropdowns should have event listeners');
        
        // Test if elements exist and have event listeners
        setTimeout(() => {
          console.log(' Delayed check - verifying dropdown functionality...');
          const testDropdown = document.getElementById('unit-type-dropdown');
          if (testDropdown) {
            console.log(' Unit Type dropdown exists:', testDropdown);
            console.log(' Unit Type dropdown classes:', testDropdown.className);
            console.log(' Unit Type dropdown HTML:', testDropdown.outerHTML);
            
            // Test manual toggle
            console.log(' Testing manual toggle...');
            testDropdown.classList.add('open');
            console.log(' After manual add open - classes:', testDropdown.className);
            testDropdown.classList.remove('open');
            console.log(' After manual remove open - classes:', testDropdown.className);
          } else {
            console.error(' Unit Type dropdown not found!');
          }
        }, 1000);
        
        // Add global test function
        window.testUnitCreatorDropdowns = function() {
          console.log(' Manual test function called');
          const dropdown = document.getElementById('unit-type-dropdown');
          if (dropdown) {
            console.log(' Found dropdown, toggling open...');
            dropdown.classList.toggle('open');
            console.log(' Classes after toggle:', dropdown.className);
            return dropdown.classList.contains('open');
          } else {
            console.error(' Dropdown not found!');
            return false;
          }
        };
        
        // Add function to test all dropdowns
        window.testAllDropdowns = function() {
          console.log(' Testing all dropdowns...');
          
          const dropdowns = [
            { id: 'unit-type-dropdown', name: 'Unit Type' },
            { id: 'unit-select-dropdown', name: 'Unit Select' },
            { id: 'special-ability-dropdown', name: 'Special Ability' }
          ];
          
          dropdowns.forEach(dropdown => {
            const element = document.getElementById(dropdown.id);
            if (element) {
              console.log(` ${dropdown.name} dropdown found:`, element);
              console.log(` ${dropdown.name} classes:`, element.className);
              console.log(` ${dropdown.name} z-index:`, window.getComputedStyle(element).zIndex);
              
              const options = element.querySelector('.dropdown-options');
              if (options) {
                console.log(` ${dropdown.name} options found:`, options);
                console.log(` ${dropdown.name} options classes:`, options.className);
                console.log(` ${dropdown.name} options z-index:`, window.getComputedStyle(options).zIndex);
                console.log(` ${dropdown.name} options visibility:`, window.getComputedStyle(options).visibility);
                console.log(` ${dropdown.name} options opacity:`, window.getComputedStyle(options).opacity);
              } else {
                console.error(` ${dropdown.name} options not found!`);
              }
            } else {
              console.error(` ${dropdown.name} dropdown not found!`);
            }
          });
        };
        
        // Add function to manually toggle dropdowns
        window.toggleDropdown = function(dropdownId) {
          const dropdown = document.getElementById(dropdownId);
          if (dropdown) {
            const options = dropdown.querySelector('.dropdown-options');
            if (options) {
              dropdown.classList.toggle('open');
              options.classList.toggle('open');
              console.log(` Toggled ${dropdownId}:`, dropdown.classList.contains('open'));
              return dropdown.classList.contains('open');
            }
          }
          console.error(` Dropdown ${dropdownId} not found or has no options!`);
          return false;
        };
        
        // Add function to check dropdown data values
        window.checkDropdownValues = function() {
          console.log(' Checking dropdown data values...');
          
          const dropdowns = [
            { id: 'unit-type-selected', name: 'Unit Type' },
            { id: 'unit-select-selected', name: 'Unit Select' },
            { id: 'special-ability-selected', name: 'Special Ability' }
          ];
          
          dropdowns.forEach(dropdown => {
            const element = document.getElementById(dropdown.id);
            if (element) {
              const dataValue = element.getAttribute('data-value');
              const textContent = element.textContent;
              console.log(` ${dropdown.name}: data-value="${dataValue}", text="${textContent}"`);
            } else {
              console.error(` ${dropdown.name} element not found!`);
            }
          });
        };
        
      } catch (error) {
        console.error(' Error in initializeUnitCreatorDropdowns:', error);
      }
    }
    
    // Construction System Functions
    let selectedConstruction = null;
    let constructionMode = false;
    
    function initializeConstructionPanel() {
      console.log('=== INITIALIZE CONSTRUCTION PANEL ===');
      
      try {
      // Only initialize if we're in the zone-detail screen
      const zoneDetailScreen = document.getElementById('zone-detail');
      if (!zoneDetailScreen || zoneDetailScreen.style.display === 'none') {
        console.log('Not in zone-detail screen, skipping construction panel initialization');
        return;
      }
      
      const constructionPanel = document.querySelector('.construction-panel');
      const constructionContent = document.getElementById('construction-panel-content');
      const constructionOptionsContainer = document.getElementById('construction-options');
      
      console.log('Construction panel element:', constructionPanel);
      console.log('Construction content element:', constructionContent);
      console.log('Construction options container:', constructionOptionsContainer);
      
      if (!constructionPanel || !constructionContent || !constructionOptionsContainer) {
        console.error('Construction panel elements not found');
        console.error('constructionPanel:', constructionPanel);
        console.error('constructionContent:', constructionContent);
        console.error('constructionOptionsContainer:', constructionOptionsContainer);
        return;
      }
      
      // Update panel color based on current player
      constructionPanel.className = `construction-panel ${gameState.currentPlayer}-player`;
      
      console.log('Panel class set to:', constructionPanel.className);
      console.log('Current display state - Panel:', constructionPanel.style.display, 'Content:', constructionContent.style.display);
      
      // Populate construction options
      console.log('Initializing construction panel...');
      populateConstructionOptions();
      
      // Show the panel
      constructionContent.style.display = 'block';
      constructionPanel.style.display = 'block';
      console.log('Construction panel should now be visible');
      console.log('Final display state - Panel:', constructionPanel.style.display, 'Content:', constructionContent.style.display);
    } catch (error) {
      console.error(' [CONSTRUCTION DEBUG] Error in initializeConstructionPanel:', error);
    }
    }
    
    function populateConstructionOptions() {
      const constructionOptionsContainer = document.getElementById('construction-options');
      if (!constructionOptionsContainer) {
        console.error('Construction options container not found');
        return;
      }
      
      console.log('Populating construction options...');
      constructionOptionsContainer.innerHTML = '';
      
      // Use the global constructionOptions object (not the DOM element)
      const constructionData = {
        trenches: {
          name: 'Trenches',
          cost: 2,
          duration: 2,
          description: '+2 Defense for Infantry/Support/Field Guns',
          icon: '',
          effects: { defense: 2 }
        },
        sandbags: {
          name: 'Sandbags',
          cost: 1,
          duration: 1,
          description: '+1 Defense',
          icon: '',
          effects: { defense: 1 }
        },
        bunker: {
          name: 'Bunker',
          cost: 5,
          duration: 3,
          description: 'Immune to Artillery, Bomber, and Airship attacks',
          icon: '',
          effects: { artilleryImmune: true, bomberImmune: true, airshipImmune: true }
        },
        barbedWire: {
          name: 'Barbed Wire',
          cost: 1,
          duration: 1,
          description: 'Stops Infantry/Support/Field Guns',
          icon: '',
          effects: { movementBlock: true }
        },
        minefield: {
          name: 'Minefield',
          cost: 2,
          duration: 1,
          description: 'Hidden, deals D6 damage when stepped on',
          icon: '',
          effects: { hidden: true, damage: 'D6' }
        },
        tankTrap: {
          name: 'Tank Trap',
          cost: 3,
          duration: 2,
          description: 'Stops armored/vehicles',
          icon: '',
          effects: { vehicleBlock: true }
        },
        bridge: {
          name: 'Bridge',
          cost: 3,
          duration: 2,
          description: 'Removes river movement penalty',
          icon: '',
          effects: { riverCrossing: true },
          placement: 'river'
        },
        road: {
          name: 'Road',
          cost: 2,
          duration: 2,
          description: '+1 Movement when unit enters tile. -1 To Defense For Units On This Tile.',
          icon: '',
          effects: { movementBonus: 1 }
        },
        snipersNest: {
          name: 'Snipers Nest',
          cost: 4,
          duration: 2,
          description: '+1 Range for Infantry. Can also fire over other units',
          icon: '',
          effects: { range: 1, lineOfSight: true }
        },
        mortarPit: {
          name: 'Mortar Pit',
          cost: 6,
          duration: 3,
          description: '+2 Attack for Field Guns',
          icon: '',
          effects: { fieldGunAttack: 2 }
        },
        barricade: {
          name: 'Barricade',
          cost: 2,
          duration: 1,
          description: '+2 Defense for units in ruins/infrastructure',
          icon: '',
          effects: { barricadeDefense: 2 },
          placement: 'ruins_infrastructure'
        },
        machineGunNest: {
          name: 'Machine Gun Nest',
          cost: 5,
          duration: 3,
          description: '+2 Attack for Infantry',
          icon: '',
          effects: { infantryAttack: 2 }
        },
        antiTankPit: {
          name: 'Anti Tank Pit',
          cost: 5,
          duration: 3,
          description: '+4 Attack for Field Guns vs Armoured Units',
          icon: '',
          effects: { antiTankAttack: 4 }
        }
      };
      
      Object.entries(constructionData).forEach(([key, option]) => {
        console.log(`Creating construction option: ${key} - ${option.name}`);
        
        const optionDiv = document.createElement('div');
        optionDiv.className = 'construction-option';
        optionDiv.onclick = () => selectConstruction(key);
        
        optionDiv.innerHTML = `
          <div class="construction-option-name">${option.icon} ${option.name}</div>
          <div class="construction-option-cost">Cost: ${option.cost} BP</div>
          <div class="construction-option-duration">Duration: ${option.duration} turn(s)</div>
          <div style="font-size: 10px; color: #aaa; margin-top: 4px;">${option.description}</div>
        `;
        
        constructionOptionsContainer.appendChild(optionDiv);
        console.log(`Added construction option: ${key} to DOM`);
      });
      
      console.log(`Created ${Object.keys(constructionData).length} construction options`);
      console.log('Final construction options container children:', constructionOptionsContainer.children.length);
      console.log('Construction options container HTML:', constructionOptionsContainer.innerHTML.substring(0, 200) + '...');
    }
    
    function selectConstruction(constructionType) {
      console.log('=== SELECT CONSTRUCTION DEBUG ===');
      console.log('constructionType:', constructionType);
      console.log('current selectedConstruction:', selectedConstruction);
      console.log('current constructionMode:', constructionMode);
      
      // If clicking the same construction type, deselect it
      if (selectedConstruction === constructionType) {
        selectedConstruction = null;
        constructionMode = false;
        
        // Update UI
        document.querySelectorAll('.construction-option').forEach(option => {
          option.classList.remove('selected');
        });
        
        // Update status
        const status = document.getElementById('construction-status');
        if (status) {
          status.textContent = 'Select a structure to build';
        }
        
        // Update instructions
        const instructions = document.getElementById('construction-instructions');
        if (instructions) {
          instructions.textContent = 'Click on a structure to select it, then click on the battlefield to place it';
        }
        
        console.log(`Deselected construction: ${constructionType}`);
        return;
      }
      
      selectedConstruction = constructionType;
      constructionMode = true;
      
      // Update UI
      document.querySelectorAll('.construction-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      const selectedOption = event.target.closest('.construction-option');
      if (selectedOption) {
        selectedOption.classList.add('selected');
      }
      
      // Update status
      const status = document.getElementById('construction-status');
      if (status) {
        const constructionData = {
          trenches: { name: 'Trenches' },
          sandbags: { name: 'Sandbags' },
          bunker: { name: 'Bunker' },
          barbedWire: { name: 'Barbed Wire' },
          minefield: { name: 'Minefield' },
          tankTrap: { name: 'Tank Trap' },
          bridge: { name: 'Bridge' },
          road: { name: 'Road' },
          snipersNest: { name: 'Snipers Nest' },
          mortarPit: { name: 'Mortar Pit' },
          barricade: { name: 'Barricade' },
          machineGunNest: { name: 'Machine Gun Nest' },
          antiTankPit: { name: 'Anti Tank Pit' }
        };
        status.textContent = `Selected: ${constructionData[constructionType].name}`;
      }
      
      // Update instructions
      const instructions = document.getElementById('construction-instructions');
      if (instructions) {
        const constructionData = {
          trenches: { name: 'Trenches' },
          sandbags: { name: 'Sandbags' },
          bunker: { name: 'Bunker' },
          barbedWire: { name: 'Barbed Wire' },
          minefield: { name: 'Minefield' },
          tankTrap: { name: 'Tank Trap' },
          bridge: { name: 'Bridge' },
          road: { name: 'Road' },
          snipersNest: { name: 'Snipers Nest' },
          mortarPit: { name: 'Mortar Pit' },
          barricade: { name: 'Barricade' },
          machineGunNest: { name: 'Machine Gun Nest' },
          antiTankPit: { name: 'Anti Tank Pit' }
        };
        instructions.textContent = `Click on the battlefield to place ${constructionData[constructionType].name}`;
      }
      
      console.log(`Selected construction: ${constructionType}`);
    }
    
    function placeConstruction(position) {
      console.log('=== PLACE CONSTRUCTION DEBUG ===');
      console.log('position:', position);
      console.log('selectedConstruction:', selectedConstruction);
      console.log('constructionMode:', constructionMode);
      console.log('currentZoneDetail:', currentZoneDetail);
      
      if (!selectedConstruction || !constructionMode) {
        console.log('Construction placement blocked - missing selection or mode');
        return;
      }
      
      if (!currentZoneDetail) {
        console.log('Construction placement blocked - no current zone detail');
        return;
      }
      
      const constructionData = {
        trenches: { cost: 2, duration: 2, placement: null },
        sandbags: { cost: 1, duration: 1, placement: null },
        bunker: { cost: 5, duration: 3, placement: null },
        barbedWire: { cost: 1, duration: 1, placement: null },
        minefield: { cost: 2, duration: 1, placement: null },
        tankTrap: { cost: 3, duration: 2, placement: null },
        bridge: { cost: 3, duration: 2, placement: 'river' },
        road: { cost: 2, duration: 2, placement: null },
        snipersNest: { cost: 4, duration: 2, placement: null },
        mortarPit: { cost: 6, duration: 3, placement: null },
        barricade: { cost: 2, duration: 1, placement: 'ruins_infrastructure' },
        machineGunNest: { cost: 5, duration: 3, placement: null },
        antiTankPit: { cost: 5, duration: 3, placement: null },
        observationPost: { cost: 3, duration: 2, placement: null },
        supplyDepot: { cost: 4, duration: 2, placement: null },
        commandCenter: { cost: 8, duration: 4, placement: null },
        antiAirBattery: { cost: 6, duration: 3, placement: null },
        radarStation: { cost: 5, duration: 3, placement: null }
      };
      
      const construction = constructionData[selectedConstruction];
      const currentPlayer = gameState.currentPlayer;
      
      // Check if player has enough build points
      if (gameState.buildPoints[currentPlayer] < construction.cost) {
        alert(`Not enough build points! You need ${construction.cost} BP but have ${gameState.buildPoints[currentPlayer]} BP.`);
        return;
      }
      
      // Check placement restrictions
      if (construction.placement === 'river' && currentZoneDetail.tacticalGrid[position].terrain !== 'river') {
        alert('Bridges can only be placed on rivers!');
        return;
      }
      
      if (construction.placement === 'ruins_infrastructure' && !['ruins', 'infrastructure'].includes(currentZoneDetail.tacticalGrid[position].terrain)) {
        alert('Barricades can only be placed in ruins or infrastructure!');
        return;
      }
      
      // Check restricted terrain for construction placement
      const constructionOption = constructionOptions[selectedConstruction];
      if (constructionOption && constructionOption.restrictedTerrain) {
        const currentTerrain = currentZoneDetail.tacticalGrid[position].terrain;
        if (constructionOption.restrictedTerrain.includes(currentTerrain)) {
          const restrictedList = constructionOption.restrictedTerrain.join(', ');
          alert(`${constructionOption.name} cannot be placed on ${currentTerrain} terrain! Restricted terrains: ${restrictedList}`);
          return;
        }
      }
      
      // Check if position exists in tactical grid
      if (!currentZoneDetail.tacticalGrid || !currentZoneDetail.tacticalGrid[position]) {
        console.log('Position does not exist in tactical grid:', position);
        console.log('Tactical grid:', currentZoneDetail.tacticalGrid);
        alert('Invalid position for construction placement!');
        return;
      }
      
      // Check if position is already occupied
      if (currentZoneDetail.tacticalGrid[position].construction) {
        alert('This position already has a structure!');
        return;
      }
      
      // Calculate final duration with sapper bonus
      let constructionSpeedBonus = 0;
      const adjacentPositions = getAdjacentPositions(position);
      adjacentPositions.forEach(adjPos => {
        const adjUnit = currentZoneDetail.tacticalGrid[adjPos]?.unit;
        if (adjUnit && adjUnit.player === currentPlayer && adjUnit.special === 'sapper') {
          constructionSpeedBonus = 1;
          logZoneMessage(`${adjUnit.name} (Sapper) reduces construction time by 1 turn!`, 'system');
        }
      });
      
      const finalDuration = Math.max(1, construction.duration - constructionSpeedBonus);
      
      // Place the construction in current zone detail
      currentZoneDetail.tacticalGrid[position].construction = {
        type: selectedConstruction,
        player: currentPlayer,
        turnsRemaining: finalDuration,
        completed: false,
        placedThisTurn: true
      };
      

      
      // Also place the construction in the main zones array
      const mainZone = zones.find(zone => zone.id === currentZoneDetail.id);
      if (mainZone) {
        mainZone.tacticalGrid[position].construction = {
          type: selectedConstruction,
          player: currentPlayer,
          turnsRemaining: finalDuration,
          completed: false,
          placedThisTurn: true
        };
      }
      
      // Deduct build points
      gameState.buildPoints[currentPlayer] -= construction.cost;
      
      // Update UI
      updateBuildPointsDisplay();
      generateMiniBattlefield();
      
      // Reset selection
      selectedConstruction = null;
      constructionMode = false;
      
      // Update UI
      document.querySelectorAll('.construction-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      const status = document.getElementById('construction-status');
      if (status) {
        status.textContent = 'Construction placed! Select another structure to build.';
      }
      
      const instructions = document.getElementById('construction-instructions');
      if (instructions) {
        instructions.textContent = 'Click on a structure to select it, then click on the battlefield to place it';
      }
      
      console.log(`Placed ${construction.name} at position ${position}`);
    }
    
    function updateConstructionProgress() {
      // Update construction progress at the start of each turn
      // Only update constructions for the current player
      console.log('=== UPDATING CONSTRUCTION PROGRESS ===');
      console.log('Current player:', gameState.currentPlayer);
      
      let totalConstructions = 0;
      let updatedConstructions = 0;
      
      // Update all zones, but only for the current player's constructions
      zones.forEach(zone => {
        Object.entries(zone.tacticalGrid).forEach(([pos, tile]) => {
          if (tile.construction) {
            totalConstructions++;
            console.log(`Found construction: ${tile.construction.type} in zone ${zone.id}, player: ${tile.construction.player}, completed: ${tile.construction.completed}, turns: ${tile.construction.turnsRemaining}, placedThisTurn: ${tile.construction.placedThisTurn || false}`);
            
            // Only update if not completed, belongs to current player, and was NOT placed this turn
            if (!tile.construction.completed && tile.construction.player === gameState.currentPlayer && !tile.construction.placedThisTurn) {
              updatedConstructions++;
              console.log(`Updating ${gameState.currentPlayer} construction ${tile.construction.type} in zone ${zone.id}, turns remaining: ${tile.construction.turnsRemaining} -> ${tile.construction.turnsRemaining - 1}`);
              tile.construction.turnsRemaining--;
              
              if (tile.construction.turnsRemaining <= 0) {
                tile.construction.completed = true;
                console.log(`Construction ${tile.construction.type} completed in zone ${zone.id}!`);
                logMessage(`Construction ${tile.construction.type} completed in Zone ${zoneNames[zone.id] || zone.id}!`, 'system');
                
                // Apply road movement bonus if a unit is on the completed road tile (temporary bonus while on tile)
                if (tile.construction.type === 'road' && tile.unit && constructionOptions.road.effects.movementBonus) {
                  const movementBonus = constructionOptions.road.effects.movementBonus;
                  // Store the road bonus on the unit for this turn only
                  tile.unit.roadMovementBonus = movementBonus;
                  logZoneMessage(`${tile.unit.name} gains +${movementBonus} movement from completed road!`, 'movement');
                  console.log(` [ROAD DEBUG] Unit ${tile.unit.name} gained +${movementBonus} movement from completed road at position ${pos}`);
                  
                  // Apply mobile cover bonus if unit has that ability
                  if (tile.unit.mobileCoverRoadBonus) {
                    logZoneMessage(`${tile.unit.name} gains +${tile.unit.mobileCoverRoadBonus} movement from Mobile Cover on completed road!`, 'movement');
                    console.log(` [ROAD DEBUG] Unit ${tile.unit.name} gained +${tile.unit.mobileCoverRoadBonus} movement from Mobile Cover on completed road at position ${pos}`);
                  }
                }
              }
            }
            
            // Clear the "placed this turn" flag for all constructions
            if (tile.construction.placedThisTurn) {
              tile.construction.placedThisTurn = false;
              console.log(`Cleared placedThisTurn flag for ${tile.construction.type} in zone ${zone.id}`);
            }
          }
        });
      });
      
      console.log(`Total constructions found: ${totalConstructions}, Updated: ${updatedConstructions}`);
      
      // Sync current zone detail with the main zones data (don't update twice!)
      if (currentZoneDetail) {
        // Find the corresponding zone in the main zones array
        const mainZone = zones.find(zone => zone.id === currentZoneDetail.id);
        if (mainZone) {
          // Copy the construction data from main zone to current zone detail
          Object.keys(mainZone.tacticalGrid).forEach(pos => {
            const mainTile = mainZone.tacticalGrid[pos];
            const detailTile = currentZoneDetail.tacticalGrid[pos];
            
            if (mainTile.construction && detailTile.construction) {
              detailTile.construction.turnsRemaining = mainTile.construction.turnsRemaining;
              detailTile.construction.completed = mainTile.construction.completed;
              detailTile.construction.placedThisTurn = mainTile.construction.placedThisTurn;
            }
          });
        }
      }
    }
    
    function updateBuildPointsDisplay() {
      const buildPointsDisplay = document.getElementById('zone-build-points');
      if (buildPointsDisplay) {
        const currentPlayer = gameState.currentPlayer;
        buildPointsDisplay.textContent = gameState.buildPoints[currentPlayer];
      }
    }
    
    // Enhanced atmospheric effects
    function createForgeEmber() {
      const ember = document.createElement('div');
      ember.style.position = 'absolute';
      ember.style.width = (Math.random() * 6 + 3) + 'px';
      ember.style.height = ember.style.width;
      ember.style.background = 'radial-gradient(circle, rgba(255, 100, 0, 0.9) 0%, rgba(255, 0, 0, 0.6) 50%, rgba(139, 0, 0, 0.3) 80%, transparent 100%)';
      ember.style.borderRadius = '50%';
      ember.style.left = Math.random() * window.innerWidth + 'px';
      ember.style.bottom = '-10px';
      ember.style.pointerEvents = 'none';
      ember.style.boxShadow = '0 0 15px rgba(255, 100, 0, 0.8)';
      ember.style.zIndex = '1';
      
      const randomX = Math.random() * 300 - 150;
      ember.style.setProperty('--random-x', randomX + 'px');
      ember.style.animation = `emberRise ${Math.random() * 10 + 8}s linear forwards`;
      
      const container = document.querySelector('.unit-creator-container');
      if (container) {
        container.appendChild(ember);
        
        setTimeout(() => {
          if (ember.parentNode) {
            ember.remove();
          }
        }, 18000);
      }
    }
    
    function startAtmosphericEffects() {
      // Generate embers periodically
      setInterval(createForgeEmber, 2500);
      
      // Create initial burst of embers
      for (let i = 0; i < 5; i++) {
        setTimeout(createForgeEmber, i * 500);
      }
    }
    

    

    
    function initializeAI() {
      // Set AI player and difficulty based on game config
      if (gameConfig.opponentType === 'ai') {
        gameState.aiState.aiPlayer = 'blue'; // AI is always player 2 (blue)
        gameState.aiState.aiDifficulty = gameConfig.aiCommandPoints;
        
        // Set AI CP for the game
        gameState.commandPoints.blue = gameConfig.aiCommandPoints;
        
        // Initialize AI aerial units
        initializeAIAerialUnits();
        
        logMessage(`AI opponent initialized with ${gameConfig.aiCommandPoints} Command Points`, 'system');
      }
    }
    
    function initializeAIAerialUnits() {
      const aiPlayer = gameState.aiState.aiPlayer;
      
      // Get AI aerial units from selected armies
      const aiAerialUnits = [];
      
      console.log(`Initializing AI aerial units for player: ${aiPlayer}`);
      console.log(`gameData.selectedArmies:`, gameData.selectedArmies);
      
      // Wait for armies to be selected before initializing
      if (!gameData.selectedArmies || !gameData.selectedArmies.player2) {
        console.log(`AI armies not yet selected, will initialize later`);
        return false;
      }
      
      const aiArmy = gameData.selectedArmies.player2;
      console.log(`AI army found:`, aiArmy);
      
      if (aiArmy && aiArmy.units) {
        // Filter aerial units from the army
        const aerialUnitsInArmy = aiArmy.units.filter(unit =>
          unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship'
        );
        
        console.log(`Aerial units found in AI army:`, aerialUnitsInArmy);
        
        // Create aerial unit objects
        aerialUnitsInArmy.forEach((unit, index) => {
          const aerialUnit = {
            id: unit.id,
            name: unit.name,
            type: unit.type,
            attack: unit.attack,
            defense: unit.defense,
            health: Math.max(unit.defense, 1), // Health starts at defense value, minimum 1
            maxHealth: Math.max(unit.defense, 1), // Track maximum health, minimum 1
            armour: unit.armour || 0, // Initialize armour stat
            maxArmour: unit.armour || 0, // Track maximum armour
            killsThisTurn: 0, // For salvage systems ability
            armorToSalvage: 0, // For salvage systems ability
            player: aiPlayer,
            armyId: aiArmy.id,
            armyName: aiArmy.name
          };
          
          aiAerialUnits.push(aerialUnit);
        });
      }
      
      // Store AI aerial units in gameState
      gameState.aerial[aiPlayer] = aiAerialUnits;
      
      console.log(`AI aerial units initialized:`, aiAerialUnits);
      console.log(`AI aerial units count: ${aiAerialUnits.length}`);
      
      return aiAerialUnits.length > 0;
    }
    
    function ensureAIAerialUnitsInitialized() {
      const aiPlayer = gameState.aiState.aiPlayer;
      
      // Check if AI aerial units are already initialized
      if (gameState.aerial[aiPlayer] && gameState.aerial[aiPlayer].length > 0) {
        console.log(`AI aerial units already initialized: ${gameState.aerial[aiPlayer].length} units`);
        return true;
      }
      
      // Try to initialize AI aerial units
      console.log('Attempting to initialize AI aerial units...');
      return initializeAIAerialUnits();
    }
    
    function ensureAerialUnitsHaveHealth() {
      // Ensure all aerial units have proper health tracking
      ['red', 'blue'].forEach(player => {
        if (gameState.aerial[player]) {
          gameState.aerial[player].forEach(unit => {
            if (typeof unit.health === 'undefined') {
              unit.health = Math.max(unit.defense, 1);
              unit.maxHealth = Math.max(unit.defense, 1);
              console.log(`Initialized health for ${unit.name}: ${unit.health}/${unit.maxHealth}`);
            }
          });
        }
      });
    }
    
    function isAITurn() {
      const result = gameState.aiState.isAITurn && gameState.currentPlayer === gameState.aiState.aiPlayer;
      console.log('=== AI TURN CHECK ===');
      console.log('isAITurn state:', gameState.aiState.isAITurn);
      console.log('currentPlayer:', gameState.currentPlayer);
      console.log('aiPlayer:', gameState.aiState.aiPlayer);
      console.log('aiThinking:', gameState.aiState.aiThinking);
      console.log('gamePhase:', gameState.gamePhase);
      console.log('Result:', result);
      console.log('=====================');
      return result;
    }
    
    function showAITurnIndicator() {
      const aiIndicator = document.getElementById('ai-turn-indicator');
      if (aiIndicator) {
        aiIndicator.style.display = 'block';
      }
    }
    
    function hideAITurnIndicator() {
      const aiIndicator = document.getElementById('ai-turn-indicator');
      if (aiIndicator) {
        aiIndicator.style.display = 'none';
      }
    }
    
    function updateAIAnalysisIndicator(message) {
      const aiIndicator = document.getElementById('ai-turn-indicator');
      if (aiIndicator) {
        const messageSpan = aiIndicator.querySelector('span');
        if (messageSpan) {
          messageSpan.textContent = message;
        }
      }
    }

    function updateAIPersonalityDisplay() {
      const personalityElement = document.getElementById('ai-personality');
      const typeElement = document.getElementById('personality-type');
      const moodElement = document.getElementById('personality-mood');
      const confidenceBar = document.getElementById('confidence-bar');
      const aggressionBar = document.getElementById('aggression-bar');

      if (personalityElement && typeElement && moodElement && confidenceBar && aggressionBar) {
        // Show personality display
        personalityElement.style.display = 'block';
        
        // Update personality type
        typeElement.textContent = aiPersonality.type.charAt(0).toUpperCase() + aiPersonality.type.slice(1);
        
        // Update mood
        moodElement.textContent = aiPersonality.mood.charAt(0).toUpperCase() + aiPersonality.mood.slice(1);
        
        // Update stat bars
        confidenceBar.style.width = (aiPersonality.confidence * 100) + '%';
        aggressionBar.style.width = (aiPersonality.aggression * 100) + '%';
      }
    }
    
    function preventPlayerActions() {
      // Disable all interactive elements during AI turn
      const battlefield = document.getElementById('battlefield');
      if (battlefield) {
        battlefield.style.pointerEvents = 'none';
        battlefield.style.opacity = '0.7';
      }
      
      // Disable end turn button
      const endTurnBtn = document.querySelector('button[onclick="endTurn()"]');
      if (endTurnBtn) {
        endTurnBtn.disabled = true;
        endTurnBtn.style.opacity = '0.5';
      }
    }
    
    function enablePlayerActions() {
      // Re-enable all interactive elements
      const battlefield = document.getElementById('battlefield');
      if (battlefield) {
        battlefield.style.pointerEvents = 'auto';
        battlefield.style.opacity = '1';
      }
      
      // Re-enable end turn button
      const endTurnBtn = document.querySelector('button[onclick="endTurn()"]');
      if (endTurnBtn) {
        endTurnBtn.disabled = false;
        endTurnBtn.style.opacity = '1';
      }
    }
    
    function processAITurn() {
      console.log('=== AI TURN PROCESSING START ===');
      console.log('Current game state:', {
        currentPlayer: gameState.currentPlayer,
        aiPlayer: gameState.aiState.aiPlayer,
        turnCount: gameState.turnCount,
        commandPoints: gameState.commandPoints
      });
      
      if (!isAITurn()) {
        console.log(' Not AI turn, returning');
        return;
      }
      
      console.log(' Starting AI turn processing');
      gameState.aiState.aiThinking = true;
      showAITurnIndicator();
      preventPlayerActions();
      
      // Add error handling wrapper
      try {
        // Ensure AI aerial units are initialized
        ensureAIAerialUnitsInitialized();
        
        // Ensure all aerial units have proper health tracking
        ensureAerialUnitsHaveHealth();
        
        console.log('AI turn processing initialized successfully');
      } catch (error) {
        console.error(' Error in AI turn initialization:', error);
        completeAITurn(); // Ensure turn completes even on error
        return;
      }
      
              // Simulate AI thinking time
        setTimeout(() => {
          logMessage(`${gameConfig.player2.name} (AI) is analyzing the battlefield...`, 'system');
          
          // Update AI indicator to show analysis
          updateAIAnalysisIndicator('Analyzing battlefield...');
          
          // Phase 2: Strategic AI Decision Making
          console.log('=== PHASE 2: STRATEGIC DECISION MAKING ===');
          let aiDecisions;
          try {
            aiDecisions = makeStrategicDecisions();
            console.log(' Strategic decisions made:', aiDecisions);
            
            // Validate decisions
            if (!aiDecisions) {
              throw new Error('AI decisions are null or undefined');
            }
            if (!aiDecisions.zonesToAttack && !aiDecisions.zonesToDefend) {
              console.warn(' AI made no zone selections - this might be intentional');
            }
            
          } catch (error) {
            console.error(' Error in strategic decision making:', error);
            aiDecisions = { zonesToAttack: [], zonesToDefend: [], cpAllocation: { attack: 0, defense: 0 } };
            logMessage(`${gameConfig.player2.name} (AI) encountered error in strategic planning`, 'system');
          }
        
                  // Simulate AI decision making time
          setTimeout(() => {
            // Update AI indicator to show decision making
            updateAIAnalysisIndicator('Making strategic decisions...');
            
            // Execute AI decisions
            console.log('=== EXECUTING STRATEGIC DECISIONS ===');
            try {
              executeAIStrategicDecisions(aiDecisions);
              console.log(' Strategic decisions executed successfully');
              logMessage(`${gameConfig.player2.name} (AI) completes strategic planning`, 'system');
            } catch (error) {
              console.error(' Error executing strategic decisions:', error);
              logMessage(`${gameConfig.player2.name} (AI) encountered error in strategic execution`, 'system');
            }
            
            // Phase 1: AIR COMBAT (PRIORITY) - Establish air superiority first
            setTimeout(() => {
              updateAIAnalysisIndicator('Establishing air superiority...');
              console.log('=== PHASE 1: AIR COMBAT (PRIORITY) ===');
              
              try {
                executeAIAerialCombat(aiDecisions);
                console.log(' Air combat completed successfully');
                logMessage(`${gameConfig.player2.name} (AI) establishes air superiority`, 'system');
              } catch (error) {
                console.error(' Error in air combat:', error);
                logMessage(`${gameConfig.player2.name} (AI) encountered error in air combat`, 'system');
              }
              
              // Phase 2: Artillery strikes (after air superiority)
              setTimeout(() => {
                updateAIAnalysisIndicator('Conducting artillery strikes...');
                console.log('=== PHASE 2: ARTILLERY STRIKES ===');
                
                try {
                  executeAIArtilleryStrikes(aiDecisions);
                  console.log(' Artillery strikes completed successfully');
                  logMessage(`${gameConfig.player2.name} (AI) completes artillery operations`, 'system');
                } catch (error) {
                  console.error(' Error in artillery strikes:', error);
                  logMessage(`${gameConfig.player2.name} (AI) encountered error in artillery operations`, 'system');
                }
                
                // Phase 3: Morale and retreat logic
                setTimeout(() => {
                  updateAIAnalysisIndicator('Assessing morale and retreat...');
                  console.log('=== PHASE 3: MORALE & RETREAT ===');
                  
                  try {
                    executeAIMoraleAndRetreat();
                    console.log(' Morale assessment completed successfully');
                    logMessage(`${gameConfig.player2.name} (AI) completes morale assessment`, 'system');
                  } catch (error) {
                    console.error(' Error in morale assessment:', error);
                    logMessage(`${gameConfig.player2.name} (AI) encountered error in morale operations`, 'system');
                  }
                  
                  // Phase 4: Enhanced strategic AI
                  setTimeout(() => {
                    updateAIAnalysisIndicator('Executing enhanced strategy...');
                    console.log('=== PHASE 4: ENHANCED STRATEGIC AI ===');
                    
                    try {
                      executeEnhancedStrategicAI(aiDecisions);
                      console.log(' Enhanced strategic AI completed successfully');
                      logMessage(`${gameConfig.player2.name} (AI) completes enhanced strategy`, 'system');
                    } catch (error) {
                      console.error(' Error in enhanced strategic AI:', error);
                      logMessage(`${gameConfig.player2.name} (AI) encountered error in enhanced strategy`, 'system');
                    }
                    
                    // Phase 5: Master AI - Execute advanced AI features
                    setTimeout(() => {
                      updateAIAnalysisIndicator('Executing master AI operations...');
                      console.log('=== PHASE 5: MASTER AI ===');
                      
                      try {
                        executePhase5AI(aiDecisions);
                        console.log(' Master AI operations completed successfully');
                        logMessage(`${gameConfig.player2.name} (AI) completes master AI operations`, 'system');
                      } catch (error) {
                        console.error(' Error in master AI operations:', error);
                        logMessage(`${gameConfig.player2.name} (AI) encountered error in master AI operations`, 'system');
                      }
                      
                      // Phase 6: Tactical AI - Execute tactical actions in selected zones (LAST)
                      setTimeout(() => {
                        console.log('=== PHASE 6: TACTICAL OPERATIONS ===');
                        updateAIAnalysisIndicator('Executing tactical operations...');
                        
                        try {
                          executeAITacticalActions(aiDecisions);
                          console.log(' Tactical operations completed successfully');
                          logMessage(`${gameConfig.player2.name} (AI) completes tactical operations`, 'system');
                        } catch (error) {
                          console.error(' Error in tactical operations:', error);
                          logMessage(`${gameConfig.player2.name} (AI) encountered error in tactical operations`, 'system');
                        }
                        
                        // Complete AI turn
                        setTimeout(() => {
                          logMessage(`${gameConfig.player2.name} (AI) completes all operations`, 'system');
                          completeAITurn();
                        }, 1000);
                      }, 1500);
                    }, 1000);
                  }, 1000);
                }, 1000);
              }, 1000);
            }, 1000);
          
          // Remove the old turn completion code - it's now handled by completeAITurn()
        }, 2000);
      }, 1000);
    }
    
    // Phase 2: Strategic AI Functions
    function makeStrategicDecisions() {
      console.log('AI making strategic decisions...');
      
      const aiPlayer = gameState.aiState.aiPlayer;
      const availableCP = gameState.commandPoints[aiPlayer];
      const decisions = {
        zonesToAttack: [],
        zonesToDefend: [],
        artilleryTargets: [],
        cpAllocation: {
          attack: 0,
          defense: 0,
          artillery: 0
        }
      };
      
      // Analyze battlefield state
      const battlefieldAnalysis = analyzeBattlefield();
      logAIAnalysis(battlefieldAnalysis);
      
      // Determine zone priorities
      const zonePriorities = determineZonePriorities(battlefieldAnalysis);
      
      // Allocate CP based on priorities and available CP
      console.log('Zone priorities determined:', zonePriorities);
      console.log('Available CP for AI:', availableCP);
      
      decisions.cpAllocation = allocateCommandPoints(zonePriorities, availableCP);
      
      // Select zones based on CP allocation
      decisions.zonesToAttack = selectZonesForAttack(zonePriorities, decisions.cpAllocation.attack);
      decisions.zonesToDefend = selectZonesForDefense(zonePriorities, decisions.cpAllocation.defense);
      
      console.log('Zones selected for attack:', decisions.zonesToAttack);
      console.log('Zones selected for defense:', decisions.zonesToDefend);
      
      // Select artillery targets
      decisions.artilleryTargets = selectArtilleryTargets(battlefieldAnalysis, decisions.cpAllocation.artillery);
      
      // Fallback: If no zones selected but we have CP, force selection of at least one neutral zone
      if (decisions.zonesToAttack.length === 0 && decisions.zonesToDefend.length === 0 && availableCP > 0) {
        console.warn(' No zones selected - using fallback selection');
        
        // Find neutral zones that can be attacked
        const neutralZones = battlefieldAnalysis.neutralZones;
        if (neutralZones.length > 0) {
          const fallbackZone = neutralZones[0];
          console.log(`Fallback: Selecting neutral zone ${fallbackZone} for attack`);
          decisions.zonesToAttack.push(fallbackZone);
          decisions.cpAllocation.attack = 1;
          logMessage(`${gameConfig.player2.name} (AI) uses fallback to select Zone ${fallbackZone} for attack`, 'system');
        }
      }
      
      console.log('AI strategic decisions:', decisions);
      return decisions;
    }
    
    function analyzeBattlefield() {
      const aiPlayer = gameState.aiState.aiPlayer;
      const humanPlayer = aiPlayer === 'red' ? 'blue' : 'red';
      
      const analysis = {
        contestedZones: [],
        aiControlledZones: [],
        humanControlledZones: [],
        neutralZones: [],
        zoneValues: {},
        strategicThreats: []
      };
      
      // Analyze each zone
      zones.forEach(zone => {
        const zoneAnalysis = analyzeZone(zone, aiPlayer, humanPlayer);
        analysis.zoneValues[zone.id] = zoneAnalysis;
        
        if (zone.control === 'contested') {
          analysis.contestedZones.push(zone.id);
        } else if (zone.control === aiPlayer) {
          analysis.aiControlledZones.push(zone.id);
        } else if (zone.control === humanPlayer) {
          analysis.humanControlledZones.push(zone.id);
        } else {
          analysis.neutralZones.push(zone.id);
        }
      });
      
      // Identify strategic threats
      analysis.strategicThreats = identifyStrategicThreats(analysis);
      
      return analysis;
    }
    
    function analyzeZone(zone, aiPlayer, humanPlayer) {
      const analysis = {
        strategicValue: 0,
        unitCount: { ai: 0, human: 0 },
        unitStrength: { ai: 0, human: 0 },
        terrainValue: 0,
        positionValue: 0
      };
      
      // Count units and calculate strength
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = zone.tacticalGrid[pos].unit;
        if (unit) {
          if (unit.player === aiPlayer) {
            analysis.unitCount.ai++;
            analysis.unitStrength.ai += unit.attack + unit.defense;
          } else {
            analysis.unitCount.human++;
            analysis.unitStrength.human += unit.attack + unit.defense;
          }
        }
      }
      
      // Calculate terrain value
      const terrainValue = {
        plains: 1,
        forest: 2,
        hills: 3,
        mountains: 4,
        river: 2,
        swamp: 1,
        desert: 1,
        ruins: 3,
        road: 2,
        infrastructure: 4,
        snow: 2
      };
      analysis.terrainValue = terrainValue[zone.terrain] || 1;
      
      // Calculate position value (center zones are more valuable)
      const zoneIndex = zones.findIndex(z => z.id === zone.id);
      const centerDistance = Math.abs(zoneIndex - (zones.length / 2));
      analysis.positionValue = Math.max(1, 5 - centerDistance);
      
      // Calculate overall strategic value
      analysis.strategicValue = 
        analysis.terrainValue * 2 +
        analysis.positionValue * 3 +
        (analysis.unitCount.ai - analysis.unitCount.human) * 5 +
        (analysis.unitStrength.ai - analysis.unitStrength.human) * 0.5;
      
      return analysis;
    }
    
    function identifyStrategicThreats(analysis) {
      const threats = [];
      
      // Check for zones where human player has significant advantage
      Object.entries(analysis.zoneValues).forEach(([zoneId, zoneAnalysis]) => {
        if (zoneAnalysis.unitCount.human > zoneAnalysis.unitCount.ai + 2) {
          threats.push({
            zoneId: zoneId,
            type: 'unitAdvantage',
            severity: zoneAnalysis.unitCount.human - zoneAnalysis.unitCount.ai,
            description: `Human has ${zoneAnalysis.unitCount.human - zoneAnalysis.unitCount.ai} more units in Zone ${zoneId}`
          });
        }
      });
      
      // Check for zones near AI-controlled zones that are under threat
      analysis.aiControlledZones.forEach(aiZoneId => {
        const adjacentZones = getAdjacentZones(aiZoneId);
        adjacentZones.forEach(adjZoneId => {
          if (analysis.humanControlledZones.includes(adjZoneId)) {
            threats.push({
              zoneId: adjZoneId,
              type: 'adjacentThreat',
              severity: 3,
              description: `Human controls adjacent zone ${adjZoneId}`
            });
          }
        });
      });
      
      return threats;
    }
    
    function getAdjacentZones(zoneId) {
      const zoneIndex = zones.findIndex(z => z.id === zoneId);
      const adjacent = [];
      
      if (zoneIndex > 0) {
        adjacent.push(zones[zoneIndex - 1].id);
      }
      if (zoneIndex < zones.length - 1) {
        adjacent.push(zones[zoneIndex + 1].id);
      }
      
      return adjacent;
    }
    
    function determineZonePriorities(analysis) {
      const priorities = [];
      
      // Priority 1: Defend contested zones where AI has advantage
      analysis.contestedZones.forEach(zoneId => {
        const zoneAnalysis = analysis.zoneValues[zoneId];
        if (zoneAnalysis.unitCount.ai > zoneAnalysis.unitCount.human) {
          priorities.push({
            zoneId: zoneId,
            action: 'defend',
            priority: 10 + zoneAnalysis.strategicValue,
            reason: 'Defend contested zone with advantage'
          });
        }
      });
      
      // Priority 2: Attack contested zones where human has advantage
      analysis.contestedZones.forEach(zoneId => {
        const zoneAnalysis = analysis.zoneValues[zoneId];
        if (zoneAnalysis.unitCount.human > zoneAnalysis.unitCount.ai) {
          priorities.push({
            zoneId: zoneId,
            action: 'attack',
            priority: 9 + zoneAnalysis.strategicValue,
            reason: 'Attack contested zone to gain advantage'
          });
        }
      });
      
      // Priority 3: Attack human-controlled zones
      analysis.humanControlledZones.forEach(zoneId => {
        const zoneAnalysis = analysis.zoneValues[zoneId];
        priorities.push({
          zoneId: zoneId,
          action: 'attack',
          priority: 8 + zoneAnalysis.strategicValue,
          reason: 'Attack human-controlled zone'
        });
      });
      
      // Priority 4: Defend AI-controlled zones under threat
      analysis.aiControlledZones.forEach(zoneId => {
        const zoneAnalysis = analysis.zoneValues[zoneId];
        const isUnderThreat = analysis.strategicThreats.some(threat => 
          threat.zoneId === zoneId && threat.type === 'adjacentThreat'
        );
        
        if (isUnderThreat) {
          priorities.push({
            zoneId: zoneId,
            action: 'defend',
            priority: 7 + zoneAnalysis.strategicValue,
            reason: 'Defend AI-controlled zone under threat'
          });
        }
      });
      
      // Priority 5: Attack neutral zones
      analysis.neutralZones.forEach(zoneId => {
        const zoneAnalysis = analysis.zoneValues[zoneId];
        priorities.push({
          zoneId: zoneId,
          action: 'attack',
          priority: 6 + zoneAnalysis.strategicValue,
          reason: 'Attack neutral zone'
        });
      });
      
      // Sort by priority (highest first)
      priorities.sort((a, b) => b.priority - a.priority);
      
      return priorities;
    }
    
    function logAIAnalysis(analysis) {
      console.log('=== AI BATTLEFIELD ANALYSIS ===');
      console.log('Contested zones:', analysis.contestedZones);
      console.log('AI controlled zones:', analysis.aiControlledZones);
      console.log('Human controlled zones:', analysis.humanControlledZones);
      console.log('Neutral zones:', analysis.neutralZones);
      console.log('Strategic threats:', analysis.strategicThreats);
      
      // Log zone values
      Object.entries(analysis.zoneValues).forEach(([zoneId, zoneAnalysis]) => {
        console.log(`Zone ${zoneId}:`, {
          strategicValue: zoneAnalysis.strategicValue,
          unitCount: zoneAnalysis.unitCount,
          unitStrength: zoneAnalysis.unitStrength,
          terrainValue: zoneAnalysis.terrainValue,
          positionValue: zoneAnalysis.positionValue
        });
      });
    }
    
    function allocateCommandPoints(priorities, availableCP) {
      console.log('=== ALLOCATING COMMAND POINTS ===');
      console.log('Available CP:', availableCP);
      console.log('Priorities:', priorities);
      
      const allocation = {
        attack: 0,
        defense: 0,
        artillery: 0
      };
      
      if (availableCP <= 0) {
        console.warn(' No CP available for allocation');
        return allocation;
      }
      
      // Reserve some CP for artillery (20% of available CP, minimum 1)
      const artilleryCP = Math.max(1, Math.floor(availableCP * 0.2));
      allocation.artillery = artilleryCP;
      availableCP -= artilleryCP;
      
      console.log('CP reserved for artillery:', artilleryCP);
      console.log('Remaining CP for attack/defense:', availableCP);
      
      // Allocate remaining CP based on priorities
      const attackPriorities = priorities.filter(p => p.action === 'attack');
      const defensePriorities = priorities.filter(p => p.action === 'defend');
      
      console.log('Attack priorities:', attackPriorities.length);
      console.log('Defense priorities:', defensePriorities.length);
      
      // Allocate 60% to attack, 40% to defense (adjustable based on priorities)
      const attackCP = Math.floor(availableCP * 0.6);
      const defenseCP = availableCP - attackCP;
      
      allocation.attack = Math.min(attackCP, attackPriorities.length);
      allocation.defense = Math.min(defenseCP, defensePriorities.length);
      
      console.log('Final allocation:', allocation);
      return allocation;
    }
    
    function selectZonesForAttack(priorities, attackCP) {
      const attackPriorities = priorities.filter(p => p.action === 'attack');
      return attackPriorities.slice(0, attackCP).map(p => p.zoneId);
    }
    
    function selectZonesForDefense(priorities, defenseCP) {
      const defensePriorities = priorities.filter(p => p.action === 'defend');
      return defensePriorities.slice(0, defenseCP).map(p => p.zoneId);
    }

    function selectArtilleryTargets(battlefieldAnalysis, artilleryCP) {
      const targets = [];
      
      if (artilleryCP <= 0) return targets;
      
      // Priority 1: Zones with high human unit concentration
      const zonesWithHumanUnits = Object.entries(battlefieldAnalysis.zoneValues)
        .filter(([zoneId, analysis]) => analysis.unitCount.human > 0)
        .sort((a, b) => b[1].unitCount.human - a[1].unitCount.human);
      
      // Priority 2: Contested zones where human has advantage
      const contestedWithHumanAdvantage = battlefieldAnalysis.contestedZones
        .filter(zoneId => {
          const analysis = battlefieldAnalysis.zoneValues[zoneId];
          return analysis.unitCount.human > analysis.unitCount.ai;
        });
      
      // Priority 3: Human-controlled zones near AI zones
      const humanControlledNearAI = battlefieldAnalysis.humanControlledZones
        .filter(zoneId => {
          const adjacentZones = getAdjacentZones(zoneId);
          return adjacentZones.some(adjZoneId => 
            battlefieldAnalysis.aiControlledZones.includes(adjZoneId)
          );
        });
      
      // Combine and select targets
      const allTargets = [
        ...contestedWithHumanAdvantage,
        ...humanControlledNearAI,
        ...zonesWithHumanUnits.map(([zoneId]) => zoneId)
      ];
      
      // Remove duplicates and limit to available CP
      const uniqueTargets = [...new Set(allTargets)];
      return uniqueTargets.slice(0, artilleryCP);
    }
    
    function executeAIStrategicDecisions(decisions) {
      console.log('Executing AI strategic decisions:', decisions);
      
      const aiPlayer = gameState.aiState.aiPlayer;
      
      console.log('AI zones to attack:', decisions.zonesToAttack);
      console.log('AI zones to defend:', decisions.zonesToDefend);
      console.log('AI CP allocation:', decisions.cpAllocation);
      
      // Execute zone selections using AI-specific functions
      decisions.zonesToAttack.forEach(zoneId => {
        logMessage(`${gameConfig.player2.name} (AI) selects Zone ${zoneId} for attack`, 'system');
        aiSelectZoneForAttack(zoneId);
      });
      
      decisions.zonesToDefend.forEach(zoneId => {
        logMessage(`${gameConfig.player2.name} (AI) selects Zone ${zoneId} for defense`, 'system');
        aiSelectZoneForDefense(zoneId);
      });
      
      // Log CP allocation
      logMessage(`${gameConfig.player2.name} (AI) allocates CP: ${decisions.cpAllocation.attack} attack, ${decisions.cpAllocation.defense} defense, ${decisions.cpAllocation.artillery} artillery`, 'system');
    }
    
    // AI-specific zone selection functions (bypass AI turn checks)
    function aiSelectZoneForAttack(zoneId) {
      if (gameState.gamePhase !== 'selection') return;
      
      const zone = zones.find(z => z.id === zoneId);
      if (!zone || zone.locked) return;
      
      // Set zone roles - AI player is attacker
      gameState.zoneRoles[zoneId] = {
        attacker: gameState.aiState.aiPlayer,
        defender: gameState.aiState.aiPlayer === 'red' ? 'blue' : 'red'
      };
      
      // Lock zone for AI player
      zone.locked = true;
      gameState.lockedZones[gameState.aiState.aiPlayer].push(zoneId);
      
      renderBattlefield();
    }
    
    function aiSelectZoneForDefense(zoneId) {
      if (gameState.gamePhase !== 'selection') return;
      
      const zone = zones.find(z => z.id === zoneId);
      if (!zone || zone.locked) return;
      
      console.log('AI selecting zone for defense:', zoneId);
      console.log('AI player:', gameState.aiState.aiPlayer);
      
      // Set zone roles - AI player is defender
      gameState.zoneRoles[zoneId] = {
        attacker: gameState.aiState.aiPlayer === 'red' ? 'blue' : 'red',
        defender: gameState.aiState.aiPlayer
      };
      
      console.log('Zone roles set:', gameState.zoneRoles[zoneId]);
      
      // Lock zone for AI player
      zone.locked = true;
      gameState.lockedZones[gameState.aiState.aiPlayer].push(zoneId);
      
      renderBattlefield();
    }
    
    // Phase 3: Tactical AI Functions
    function executeAITacticalActions(strategicDecisions) {
      console.log('=== EXECUTING AI TACTICAL ACTIONS ===');
      console.log('Strategic decisions received:', strategicDecisions);
      
      try {
        const aiPlayer = gameState.aiState.aiPlayer;
        const selectedZones = [...strategicDecisions.zonesToAttack, ...strategicDecisions.zonesToDefend];
        
        console.log('Selected zones for tactical operations:', selectedZones);
        console.log('Attack zones:', strategicDecisions.zonesToAttack);
        console.log('Defense zones:', strategicDecisions.zonesToDefend);
        
        if (selectedZones.length === 0) {
          console.warn(' No zones selected for tactical operations');
          logMessage(`${gameConfig.player2.name} (AI) has no zones to operate in`, 'system');
          return;
        }
        
        // Process each selected zone
        selectedZones.forEach((zoneId, index) => {
          console.log(`Scheduling tactical operations for Zone ${zoneId} (index ${index})`);
          setTimeout(() => {
            try {
              processAITacticalZone(zoneId, strategicDecisions);
            } catch (error) {
              console.error(` Error processing Zone ${zoneId}:`, error);
              logMessage(`${gameConfig.player2.name} (AI) encountered error in Zone ${zoneId}`, 'system');
            }
          }, index * 1000); // Stagger zone processing
        });
        
        console.log(' Tactical actions scheduled successfully');
      } catch (error) {
        console.error(' Error in executeAITacticalActions:', error);
        logMessage(`${gameConfig.player2.name} (AI) encountered error in tactical planning`, 'system');
      }
    }
    
    function processAITacticalZone(zoneId, strategicDecisions) {
      console.log(`=== PROCESSING AI TACTICAL ZONE ${zoneId} ===`);
      console.log('Strategic decisions for this zone:', strategicDecisions);
      
      try {
        const zone = zones.find(z => z.id === zoneId);
        if (!zone) {
          console.error(` Zone ${zoneId} not found in zones array`);
          console.log('Available zones:', zones.map(z => z.id));
          return;
        }
        
        console.log(' Zone found:', zone);
        console.log('Zone control:', zone.control);
        console.log('Zone tactical grid:', zone.tacticalGrid);
        
        // Enter the zone for tactical operations
        enterZoneForAI(zoneId);
        
        // Determine if this zone is for attack or defense
        const isAttackZone = strategicDecisions.zonesToAttack.includes(zoneId);
        const isDefenseZone = strategicDecisions.zonesToDefend.includes(zoneId);
        
        console.log(`Zone ${zoneId} - Attack: ${isAttackZone}, Defense: ${isDefenseZone}`);
        
        if (isAttackZone) {
          logMessage(`${gameConfig.player2.name} (AI) enters Zone ${zoneId} for attack`, 'system');
          executeAIAttackTactics(zoneId);
        } else if (isDefenseZone) {
          logMessage(`${gameConfig.player2.name} (AI) enters Zone ${zoneId} for defense`, 'system');
          executeAIDefenseTactics(zoneId);
        } else {
          console.warn(` Zone ${zoneId} is neither attack nor defense zone`);
        }
      } catch (error) {
        console.error(` Error processing tactical zone ${zoneId}:`, error);
        logMessage(`${gameConfig.player2.name} (AI) encountered error in Zone ${zoneId}`, 'system');
      }
    }
    
    function enterZoneForAI(zoneId) {
      // Set up zone for AI tactical operations
      currentZoneDetail = zones.find(z => z.id === zoneId);
      gameState.currentZone = zoneId;
      
      // Determine zone phase based on roles
      const zoneRole = gameState.zoneRoles[zoneId];
      const isAIDefender = zoneRole && zoneRole.defender === gameState.aiState.aiPlayer;
      gameState.currentZonePhase = isAIDefender ? 'defense' : 'attack';
      
      // Reset unit actions for AI
      resetUnitActionsForAI();
      
      console.log(`AI entered Zone ${zoneId} in ${gameState.currentZonePhase} mode`);
    }
    
    function resetUnitActionsForAI() {
      // Reset actions for all AI units in the current zone
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = currentZoneDetail.tacticalGrid[pos].unit;
        if (unit && unit.player === gameState.aiState.aiPlayer) {
          gameState.unitActions[unit.id] = { 
            hasAttacked: false,
            hasMoved: false
          };
        }
      }
    }
    
    function executeAIAttackTactics(zoneId) {
      console.log(`=== EXECUTING AI ATTACK TACTICS IN ZONE ${zoneId} ===`);
      
      try {
        // Get AI's available units from armies
        const aiUnits = getAIAvailableUnits();
        console.log(`Available units for attack in Zone ${zoneId}:`, aiUnits.length);
        console.log('Available units:', aiUnits.map(u => `${u.name} (${u.type})`));
        
        if (aiUnits.length === 0) {
          console.warn(` No units available for attack in Zone ${zoneId}`);
          logMessage(`${gameConfig.player2.name} (AI) has no units to deploy for attack`, 'system');
          return;
        }
        
        // Deploy units for attack
        deployAIUnitsForAttack(aiUnits);
        
        // Execute tactical movements and attacks
        executeAITacticalMoves();
        executeAITacticalAttacks();
        
        console.log(` Attack tactics completed in Zone ${zoneId}`);
      } catch (error) {
        console.error(` Error in attack tactics for Zone ${zoneId}:`, error);
        logMessage(`${gameConfig.player2.name} (AI) encountered error in attack tactics`, 'system');
      }
    }
    
    function executeAIDefenseTactics(zoneId) {
      console.log(`=== EXECUTING AI DEFENSE TACTICS IN ZONE ${zoneId} ===`);
      
      try {
        // Get AI's available units from armies
        const aiUnits = getAIAvailableUnits();
        console.log(`Available units for defense in Zone ${zoneId}:`, aiUnits.length);
        console.log('Available units:', aiUnits.map(u => `${u.name} (${u.type})`));
        
        if (aiUnits.length === 0) {
          console.warn(` No units available for defense in Zone ${zoneId}`);
          logMessage(`${gameConfig.player2.name} (AI) has no units to deploy for defense`, 'system');
          return;
        }
        
        // Deploy units for defense
        deployAIUnitsForDefense(aiUnits);
        
        // Execute defensive positioning
        executeAIDefensiveMoves();
        
        console.log(` Defense tactics completed in Zone ${zoneId}`);
      } catch (error) {
        console.error(` Error in defense tactics for Zone ${zoneId}:`, error);
        logMessage(`${gameConfig.player2.name} (AI) encountered error in defense tactics`, 'system');
      }
    }
    
    function getAIAvailableUnits() {
      const aiPlayer = gameState.aiState.aiPlayer;
      const playerId = aiPlayer === 'red' ? 'player1' : 'player2';
      const availableUnits = [];
      
      console.log('AI getting available units for player:', playerId);
      console.log('AI armies:', gameData.selectedArmies[playerId]);
      
      // Get units from all AI armies
      gameData.selectedArmies[playerId].forEach(army => {
        console.log('Checking army:', army.name, 'with units:', army.units.length);
        army.units.forEach((unit, unitIndex) => {
          // Skip aerial and artillery units - they don't deploy on the tactical grid
          // Field guns can be deployed on the grid (they have movement values)
          if (unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship' || unit.type === 'artillery') {
            console.log(`Skipping ${unit.name} (${unit.type}) - aerial/artillery units don't deploy on grid`);
            return;
          }
          
          // Create unit with deployment index for proper tracking
          const unitWithIndex = { ...unit, deploymentIndex: unitIndex };
          
          // Check if unit is already deployed using AI player context
          const isDeployed = isUnitDeployedFromArmyForAI(unitWithIndex, army.id, aiPlayer);
          console.log(`Unit ${unit.name} deployed: ${isDeployed}`);
          
          if (!isDeployed) {
            availableUnits.push({
              ...unit,
              armyId: army.id,
              deploymentIndex: unitIndex
            });
          }
        });
      });
      
      console.log('AI available units for tactical deployment:', availableUnits.length);
      console.log('Available units:', availableUnits.map(u => `${u.name} (${u.type})`));
      
      // Fallback: if no units are available but we have armies, force some units to be available
      if (availableUnits.length === 0) {
        console.warn(' No units available - checking for fallback units');
        const fallbackUnits = getFallbackUnits(aiPlayer);
        if (fallbackUnits.length > 0) {
          console.log(`Using ${fallbackUnits.length} fallback units`);
          return fallbackUnits;
        }
      }
      
      return availableUnits;
    }

    function isUnitDeployedFromArmyForAI(unit, armyId, aiPlayer) {
      // Artillery and aerial units are never considered "deployed" since they don't go on the grid
      // Field guns can be deployed on the grid (they have movement values)
      if (unit.type === 'artillery' || unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship') {
        return false;
      }
      
      // Check if this specific unit instance has been deployed from this army
      const playerId = aiPlayer === 'red' ? 'player1' : 'player2';
      
      // If deployedUnitInstances is not initialized, return false
      if (!gameState.deployedUnitInstances) {
        return false;
      }
      
      // Check if this specific unit instance has been deployed in the CURRENT ZONE from this army
      const currentZoneId = gameState.currentZone;
      console.log(`Checking if ${unit.name} is deployed in current zone ${currentZoneId}`);
      
      for (const [instanceId, deployment] of Object.entries(gameState.deployedUnitInstances)) {
        if (deployment.armyId === armyId && 
            deployment.playerId === playerId && 
            deployment.unitData.name === unit.name &&
            deployment.unitData.deploymentIndex === unit.deploymentIndex &&
            deployment.zoneId === currentZoneId) {
          console.log(`Unit ${unit.name} is already deployed in zone ${currentZoneId}`);
          return true;
        }
      }
      
      console.log(`Unit ${unit.name} is NOT deployed in current zone ${currentZoneId}`);
      return false;
    }

    function getFallbackUnits(aiPlayer) {
      console.log('=== GETTING FALLBACK UNITS ===');
      const playerId = aiPlayer === 'red' ? 'player1' : 'player2';
      const fallbackUnits = [];
      
      // Get first available army and use its units
      if (gameData.selectedArmies[playerId] && gameData.selectedArmies[playerId].length > 0) {
        const army = gameData.selectedArmies[playerId][0];
        console.log(`Using fallback army: ${army.name}`);
        
        army.units.forEach((unit, unitIndex) => {
          // Skip aerial and artillery units
          // Field guns can be deployed on the grid (they have movement values)
          if (unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship' || unit.type === 'artillery') {
            return;
          }
          
          // Add first 3 ground units as fallback
          if (fallbackUnits.length < 3) {
            fallbackUnits.push({
              ...unit,
              armyId: army.id,
              deploymentIndex: unitIndex
            });
            console.log(`Added fallback unit: ${unit.name}`);
          }
        });
      }
      
      console.log(`Fallback units available: ${fallbackUnits.length}`);
      return fallbackUnits;
    }
    
    function deployAIUnitsForAttack(aiUnits) {
      console.log('AI deploying units for attack');
      console.log('Available units for attack:', aiUnits.length);
      
      const gridSize = gameConfig.gridSize;
      
      // Get available CP for this zone
      const availableCP = gameState.commandPoints[gameState.aiState.aiPlayer];
      console.log(`Available CP for deployment: ${availableCP}`);
      
      // Analyze the battlefield for intelligent deployment
      const battlefieldAnalysis = analyzeZoneForDeployment();
      console.log('Battlefield analysis for attack:', battlefieldAnalysis);
      
      // Sort units by strategic value (attack power + special abilities)
      const sortedUnits = aiUnits.sort((a, b) => calculateUnitStrategicValue(b, 'attack') - calculateUnitStrategicValue(a, 'attack'));
      console.log('Sorted units for attack:', sortedUnits.map(u => `${u.name} (value: ${calculateUnitStrategicValue(u, 'attack')})`));
      
      // Limit deployment based on available CP (each unit costs 1 CP)
      const maxUnitsToDeploy = Math.min(sortedUnits.length, availableCP);
      console.log(`Deploying ${maxUnitsToDeploy} units out of ${sortedUnits.length} available (CP limit: ${availableCP})`);
      
      // Deploy units intelligently (limited by CP)
      for (let i = 0; i < maxUnitsToDeploy; i++) {
        const unit = sortedUnits[i];
        
        // Safety check: never deploy aerial or artillery units on the grid
        if (unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship' || unit.type === 'artillery') {
          console.log(`Skipping deployment of ${unit.name} (${unit.type}) - aerial/artillery units don't deploy on tactical grid`);
          continue;
        }
        
        const bestPosition = findBestDeploymentPosition(unit, 'attack', battlefieldAnalysis);
        
        if (bestPosition !== null) {
          console.log(`Deploying ${unit.name} at optimal position ${bestPosition}`);
          placeAIUnit(unit, bestPosition);
          logMessage(`${gameConfig.player2.name} (AI) deploys ${unit.name} at strategic position ${bestPosition + 1}`, 'system');
          
          // Update battlefield analysis after deployment
          battlefieldAnalysis.occupiedPositions.push(bestPosition);
          
          // Consume CP for this deployment
          gameState.commandPoints[gameState.aiState.aiPlayer]--;
          console.log(`CP consumed. Remaining CP: ${gameState.commandPoints[gameState.aiState.aiPlayer]}`);
        } else {
          console.log(`No optimal position found for ${unit.name}`);
        }
      }
    }
    
    function deployAIUnitsForDefense(aiUnits) {
      console.log('AI deploying units for defense');
      console.log('Available units for defense:', aiUnits.length);
      
      const gridSize = gameConfig.gridSize;
      
      // Get available CP for this zone
      const availableCP = gameState.commandPoints[gameState.aiState.aiPlayer];
      console.log(`Available CP for defense deployment: ${availableCP}`);
      
      // Analyze the battlefield for intelligent deployment
      const battlefieldAnalysis = analyzeZoneForDeployment();
      console.log('Battlefield analysis for defense:', battlefieldAnalysis);
      
      // Sort units by strategic value (defense power + special abilities)
      const sortedUnits = aiUnits.sort((a, b) => calculateUnitStrategicValue(b, 'defense') - calculateUnitStrategicValue(a, 'defense'));
      console.log('Sorted units for defense:', sortedUnits.map(u => `${u.name} (value: ${calculateUnitStrategicValue(u, 'defense')})`));
      
      // Limit deployment based on available CP (each unit costs 1 CP)
      const maxUnitsToDeploy = Math.min(sortedUnits.length, availableCP);
      console.log(`Deploying ${maxUnitsToDeploy} units out of ${sortedUnits.length} available (CP limit: ${availableCP})`);
      
      // Deploy units intelligently (limited by CP)
      for (let i = 0; i < maxUnitsToDeploy; i++) {
        const unit = sortedUnits[i];
        
        // Safety check: never deploy aerial or artillery units on the grid
        if (unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship' || unit.type === 'artillery') {
          console.log(`Skipping deployment of ${unit.name} (${unit.type}) - aerial/artillery units don't deploy on tactical grid`);
          continue;
        }
        
        const bestPosition = findBestDeploymentPosition(unit, 'defense', battlefieldAnalysis);
        
        if (bestPosition !== null) {
          console.log(`Deploying ${unit.name} at optimal defensive position ${bestPosition}`);
          placeAIUnit(unit, bestPosition);
          logMessage(`${gameConfig.player2.name} (AI) deploys ${unit.name} at strategic defensive position ${bestPosition + 1}`, 'system');
          
          // Update battlefield analysis after deployment
          battlefieldAnalysis.occupiedPositions.push(bestPosition);
          
          // Consume CP for this deployment
          gameState.commandPoints[gameState.aiState.aiPlayer]--;
          console.log(`CP consumed. Remaining CP: ${gameState.commandPoints[gameState.aiState.aiPlayer]}`);
        } else {
          console.log(`No optimal defensive position found for ${unit.name}`);
        }
      }
    }
    
    // Intelligent Deployment Analysis Functions
    function analyzeZoneForDeployment() {
      const gridSize = gameConfig.gridSize;
      const analysis = {
        enemyUnits: [],
        enemyPositions: [],
        threatLevels: {},
        terrainAdvantages: {},
        chokepoints: [],
        highGround: [],
        occupiedPositions: [],
        availablePositions: []
      };
      
      // Analyze current battlefield state
      for (let pos = 0; pos < gridSize * gridSize; pos++) {
        const cell = currentZoneDetail.tacticalGrid[pos];
        
        if (cell.unit) {
          if (cell.unit.player !== gameState.aiState.aiPlayer) {
            // Enemy unit
            analysis.enemyUnits.push(cell.unit);
            analysis.enemyPositions.push(pos);
            analysis.threatLevels[pos] = calculateThreatLevel(cell.unit);
          } else {
            // AI unit
            analysis.occupiedPositions.push(pos);
          }
        } else {
          // Empty position
          analysis.availablePositions.push(pos);
        }
        
        // Analyze terrain advantages
        analysis.terrainAdvantages[pos] = calculateTerrainAdvantage(pos, cell.terrain);
      }
      
      // Find chokepoints and high ground
      analysis.chokepoints = findChokepoints(analysis);
      analysis.highGround = findHighGround(analysis);
      
      console.log('Zone deployment analysis:', analysis);
      return analysis;
    }

    function calculateUnitStrategicValue(unit, mode) {
      let value = 0;
      
      if (mode === 'attack') {
        value = unit.attack * 2 + unit.movement + unit.range;
        
        // Bonus for special unit types
        if (unit.type === 'Heavy') value += 3;
        if (unit.type === 'Elite') value += 5;
        if (unit.type === 'Scout') value += 2;
        if (unit.type === 'Support') value += 1;
      } else if (mode === 'defense') {
        value = unit.defense * 2 + unit.health + unit.morale;
        
        // Bonus for defensive unit types
        if (unit.type === 'Heavy') value += 4;
        if (unit.type === 'Elite') value += 3;
        if (unit.type === 'Support') value += 2;
      }
      
      return value;
    }

    function findBestDeploymentPosition(unit, mode, analysis) {
      const gridSize = gameConfig.gridSize;
      let bestPosition = null;
      let bestScore = -Infinity;
      
      // Filter out already occupied positions
      const availablePositions = analysis.availablePositions.filter(pos => {
        return !analysis.occupiedPositions.includes(pos);
      });
      
      if (availablePositions.length === 0) {
        console.warn(` No available positions for ${unit.name}`);
        return 0;
      }
      
      // Evaluate each available position
      availablePositions.forEach(pos => {
        const score = evaluatePositionForUnit(pos, unit, mode, analysis);
        
        if (score > bestScore) {
          bestScore = score;
          bestPosition = pos;
        }
      });
      
      console.log(`Best position for ${unit.name} (${mode}): ${bestPosition} with score ${bestScore}`);
      
      // Mark this position as occupied for future deployments
      analysis.occupiedPositions.push(bestPosition);
      
      return bestPosition;
    }

    function evaluatePositionForUnit(pos, unit, mode, analysis) {
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      let score = 0;
      
      if (mode === 'attack') {
        // Attack positioning logic
        score += evaluateAttackPosition(pos, unit, analysis);
      } else if (mode === 'defense') {
        // Defense positioning logic
        score += evaluateDefensePosition(pos, unit, analysis);
      }
      
      // Terrain bonus
      score += analysis.terrainAdvantages[pos] * 2;
      
      // Distance to enemies (closer is better for attack, further is better for defense)
      const distanceToEnemies = calculateAverageDistanceToEnemies(pos, analysis.enemyPositions);
      if (mode === 'attack') {
        score += Math.max(0, 10 - distanceToEnemies); // Closer is better
      } else {
        score += Math.max(0, distanceToEnemies - 5); // Further is better
      }
      
      return score;
    }

    function evaluateAttackPosition(pos, unit, analysis) {
      let score = 0;
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      
      // Prefer forward positions for attack
      score += (gridSize - row) * 3; // Higher score for lower rows (closer to enemy)
      
      // Prefer positions that can reach multiple enemies
      const reachableEnemies = analysis.enemyUnits.filter(enemy => {
        const distance = calculateDistance(pos, enemy.position);
        return distance <= unit.range;
      });
      score += reachableEnemies.length * 5;
      
      // Prefer positions that can attack weak enemies
      reachableEnemies.forEach(enemy => {
        if (enemy.health < enemy.maxHealth * 0.5) {
          score += 3; // Bonus for targeting damaged enemies
        }
        if (unit.attack > enemy.defense) {
          score += 2; // Bonus for favorable matchups
        }
      });
      
      return score;
    }

    function evaluateDefensePosition(pos, unit, analysis) {
      let score = 0;
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      
      // Prefer back positions for defense
      score += row * 3; // Higher score for higher rows (back positions)
      
      // Prefer positions that can protect multiple areas
      const protectedPositions = getProtectedPositions(pos, unit);
      score += protectedPositions.length * 2;
      
      // Prefer positions that can counter-attack
      const counterAttackTargets = analysis.enemyUnits.filter(enemy => {
        const distance = calculateDistance(pos, enemy.position);
        return distance <= unit.range;
      });
      score += counterAttackTargets.length * 3;
      
      return score;
    }

    function calculateThreatLevel(unit) {
      return unit.attack + unit.defense + unit.health;
    }

    function calculateTerrainAdvantage(pos, terrain) {
      const advantages = {
        'mountains': 3, // High ground advantage
        'hills': 2,     // Elevated position
        'forest': 1,    // Cover
        'ruins': 2,     // Defensive position
        'plains': 0,    // Neutral
        'swamp': -1,    // Difficult terrain
        'desert': 0     // Neutral
      };
      
      return advantages[terrain] || 0;
    }

    function findChokepoints(analysis) {
      // Find positions that control access to important areas
      const chokepoints = [];
      const gridSize = gameConfig.gridSize;
      
      // Center positions are often chokepoints
      const centerRow = Math.floor(gridSize / 2);
      const centerCol = Math.floor(gridSize / 2);
      const centerPos = centerRow * gridSize + centerCol;
      
      if (analysis.availablePositions.includes(centerPos)) {
        chokepoints.push(centerPos);
      }
      
      return chokepoints;
    }

    function findHighGround(analysis) {
      // Find elevated positions
      const highGround = [];
      const gridSize = gameConfig.gridSize;
      
      for (let pos = 0; pos < gridSize * gridSize; pos++) {
        const cell = currentZoneDetail.tacticalGrid[pos];
        if (cell.terrain === 'mountains' || cell.terrain === 'hills') {
          highGround.push(pos);
        }
      }
      
      return highGround;
    }

    function calculateAverageDistanceToEnemies(pos, enemyPositions) {
      if (enemyPositions.length === 0) return 0;
      
      const totalDistance = enemyPositions.reduce((sum, enemyPos) => {
        return sum + calculateDistance(pos, enemyPos);
      }, 0);
      
      return totalDistance / enemyPositions.length;
    }

    function getProtectedPositions(pos, unit) {
      const gridSize = gameConfig.gridSize;
      const protected = [];
      const unitRow = Math.floor(pos / gridSize);
      const unitCol = pos % gridSize;
      
      // Positions behind this unit (for defense)
      for (let row = unitRow + 1; row < gridSize; row++) {
        const protectedPos = row * gridSize + unitCol;
        protected.push(protectedPos);
      }
      
      return protected;
    }

    function placeAIUnit(unitData, pos) {
      // Final safety check: never place aerial or artillery units on the tactical grid
      if (unitData.type === 'fighter' || unitData.type === 'bomber' || unitData.type === 'airship' || unitData.type === 'artillery') {
        console.error(`CRITICAL ERROR: Attempted to place ${unitData.name} (${unitData.type}) on tactical grid at position ${pos}!`);
        console.error('Aerial and artillery units should never be placed on the tactical grid.');
        return;
      }
      
      const unitId = `${gameState.aiState.aiPlayer}_${unitData.name}_${pos}_${Date.now()}`;
      const playerId = gameState.aiState.aiPlayer === 'red' ? 'player1' : 'player2';
      
      const unit = {
        ...unitData,
        id: unitId,
        player: gameState.aiState.aiPlayer,
        position: pos,
        health: unitData.defense,
        maxHealth: unitData.defense,
        armyId: unitData.armyId,
        deploymentIndex: unitData.deploymentIndex,
        placedThisTurn: true,
        targetHistory: {}
      };
      
      // Place unit on grid
      currentZoneDetail.tacticalGrid[pos].unit = unit;
      
      // Track deployment
      gameState.deployedUnitInstances[unitId] = {
        zoneId: currentZoneDetail.id,
        playerId: playerId,
        armyId: unitData.armyId,
        unitData: {
          ...unitData,
          deploymentIndex: unitData.deploymentIndex
        }
      };
      
      // Initialize unit actions
      gameState.unitActions[unitId] = {
        hasAttacked: false,
        hasMoved: false
      };
      
      console.log(`AI placed unit ${unitData.name} at position ${pos} in zone ${currentZoneDetail.id}`);
    }
    
    function executeAITacticalMoves() {
      console.log('AI executing tactical moves');
      
      const aiUnits = getAIUnitsInZone();
      console.log('AI units in zone for movement:', aiUnits.length);
      
      aiUnits.forEach(unit => {
        console.log(`Checking unit ${unit.name} for movement`);
        if (!gameState.unitActions[unit.id]?.hasMoved && unit.movement > 0) {
          const bestMove = calculateBestMove(unit);
          if (bestMove) {
            moveAIUnit(unit, bestMove);
          } else {
            console.log(`No valid move found for ${unit.name}`);
          }
        } else {
          console.log(`Unit ${unit.name} cannot move (moved: ${gameState.unitActions[unit.id]?.hasMoved}, movement: ${unit.movement})`);
        }
      });
    }
    
    function executeAITacticalAttacks() {
      console.log('AI executing tactical attacks');
      
      const aiUnits = getAIUnitsInZone();
      
      aiUnits.forEach(unit => {
        if (!gameState.unitActions[unit.id]?.hasAttacked && unit.attack > 0) {
          const bestTarget = findBestTarget(unit);
          if (bestTarget) {
            attackWithAIUnit(unit, bestTarget);
          }
        }
      });
    }
    
    function executeAIDefensiveMoves() {
      console.log('AI executing defensive moves');
      
      const aiUnits = getAIUnitsInZone();
      
      aiUnits.forEach(unit => {
        if (!gameState.unitActions[unit.id]?.hasMoved && unit.movement > 0) {
          const defensivePosition = calculateDefensivePosition(unit);
          if (defensivePosition) {
            moveAIUnit(unit, defensivePosition);
          }
        }
      });
    }
    
    function getAIUnitsInZone() {
      const aiUnits = [];
      
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = currentZoneDetail.tacticalGrid[pos].unit;
        if (unit && unit.player === gameState.aiState.aiPlayer) {
          aiUnits.push(unit);
        }
      }
      
      return aiUnits;
    }
    
    function calculateBestMove(unit) {
      // Advanced AI movement with tactical intelligence
      const gridSize = gameConfig.gridSize;
      const currentPos = unit.position;
      const currentRow = Math.floor(currentPos / gridSize);
      const currentCol = currentPos % gridSize;
      
      // Determine if we're in attack or defense mode
      const isAttackMode = gameState.currentZonePhase === 'attack';
      
      // Analyze battlefield for intelligent movement
      const movementAnalysis = analyzeMovementOptions(unit, currentPos);
      console.log(`Movement analysis for ${unit.name}:`, movementAnalysis);
      
      // Find best movement option
      const bestMove = findBestMovementOption(unit, movementAnalysis, isAttackMode);
      
      if (bestMove) {
        console.log(`AI unit ${unit.name} moving to optimal position ${bestMove} (${isAttackMode ? 'attack' : 'defense'} mode)`);
        return bestMove;
      }
      
      return null;
    }

    function analyzeMovementOptions(unit, currentPos) {
      const gridSize = gameConfig.gridSize;
      const analysis = {
        currentPos: currentPos,
        possibleMoves: [],
        moveScores: {},
        threats: [],
        opportunities: [],
        terrainAdvantages: {}
      };
      
      // Find all possible moves within unit's movement range
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const targetPos = row * gridSize + col;
          const distance = calculateDistance(currentPos, targetPos);
          
          if (distance <= unit.movement && distance > 0) {
            const cell = currentZoneDetail.tacticalGrid[targetPos];
            
            if (!cell.unit) { // Position is empty
              // Check terrain movement restrictions
              const terrain = cell.terrain;
              let canMove = true;
              
              // Vehicles can't move in Swamp or Jungle terrain
              if (unit.type === 'vehicle' && (terrain === 'swamp' || terrain === 'jungle')) {
                canMove = false;
              }
              
              // Tanks can't move in Swamp, Jungle, or Forest terrain unless they have All Terrain ability
              if (unit.type === 'tank' && (terrain === 'swamp' || terrain === 'jungle' || terrain === 'forest')) {
                if (unit.special !== 'all_terrain') {
                  canMove = false;
                }
                // All Terrain tanks can move through but will take damage (handled by special ability)
              }
              
              // Only Mechs and units with "Those Who Dare" can move on Mountain terrain
              if (terrain === 'mountain' && unit.type !== 'mech' && unit.special !== 'those_who_dare') {
                canMove = false;
              }
              
              if (canMove) {
              analysis.possibleMoves.push(targetPos);
              analysis.moveScores[targetPos] = 0;
              analysis.terrainAdvantages[targetPos] = calculateTerrainAdvantage(targetPos, cell.terrain);
              }
            }
          }
        }
      }
      
      // Analyze threats and opportunities
      analysis.threats = findThreats(unit, currentPos);
      analysis.opportunities = findOpportunities(unit, currentPos);
      
      return analysis;
    }

    function findBestMovementOption(unit, analysis, isAttackMode) {
      let bestMove = null;
      let bestScore = -Infinity;
      
      analysis.possibleMoves.forEach(pos => {
        const score = evaluateMovementPosition(pos, unit, analysis, isAttackMode);
        analysis.moveScores[pos] = score;
        
        if (score > bestScore) {
          bestScore = score;
          bestMove = pos;
        }
      });
      
      console.log(`Movement scores for ${unit.name}:`, analysis.moveScores);
      return bestMove;
    }

    function evaluateMovementPosition(pos, unit, analysis, isAttackMode) {
      let score = 0;
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      
      if (isAttackMode) {
        score += evaluateAttackMovement(pos, unit, analysis);
      } else {
        score += evaluateDefenseMovement(pos, unit, analysis);
      }
      
      // Terrain advantage
      score += analysis.terrainAdvantages[pos] * 3;
      
      // Distance to enemies (tactical positioning)
      const enemyPositions = getAllEnemyPositions();
      const avgDistanceToEnemies = calculateAverageDistanceToEnemies(pos, enemyPositions);
      
      if (isAttackMode) {
        // In attack mode, prefer positions closer to enemies but not too close
        if (avgDistanceToEnemies <= unit.range && avgDistanceToEnemies > 1) {
          score += 10; // Perfect attack range
        } else if (avgDistanceToEnemies < unit.range) {
          score += 5; // Can attack
        } else {
          score += Math.max(0, 10 - avgDistanceToEnemies); // Moving towards enemies
        }
      } else {
        // In defense mode, prefer positions that can counter-attack but maintain distance
        if (avgDistanceToEnemies <= unit.range && avgDistanceToEnemies > 2) {
          score += 8; // Can counter-attack safely
        } else if (avgDistanceToEnemies > unit.range) {
          score += 3; // Safe distance
        }
      }
      
      return score;
    }

    function evaluateAttackMovement(pos, unit, analysis) {
      let score = 0;
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      
      // Prefer forward movement
      score += (gridSize - row) * 2; // Higher score for lower rows (closer to enemy)
      
      // Prefer positions that can attack multiple enemies
      const reachableEnemies = findReachableEnemies(pos, unit);
      score += reachableEnemies.length * 5;
      
      // Prefer positions that can attack weak enemies
      reachableEnemies.forEach(enemy => {
        if (enemy.health < enemy.maxHealth * 0.6) {
          score += 4; // Bonus for targeting damaged enemies
        }
        if (unit.attack > enemy.defense) {
          score += 3; // Bonus for favorable matchups
        }
      });
      
      // Avoid moving into dangerous positions
      const threats = findThreats(unit, pos);
      score -= threats.length * 3;
      
      return score;
    }

    function evaluateDefenseMovement(pos, unit, analysis) {
      let score = 0;
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      
      // Prefer defensive positions (back rows)
      score += row * 2; // Higher score for higher rows (back positions)
      
      // Prefer positions that can protect allies
      const protectedAllies = findProtectedAllies(pos, unit);
      score += protectedAllies.length * 3;
      
      // Prefer positions that can counter-attack
      const counterTargets = findReachableEnemies(pos, unit);
      score += counterTargets.length * 4;
      
      // Avoid moving into exposed positions
      const exposure = calculateExposure(pos);
      score -= exposure * 2;
      
      return score;
    }

    function findThreats(unit, pos) {
      const threats = [];
      const gridSize = gameConfig.gridSize;
      
      // Find enemy units that can attack this position
      for (let enemyPos = 0; enemyPos < gridSize * gridSize; enemyPos++) {
        const enemyCell = currentZoneDetail.tacticalGrid[enemyPos];
        if (enemyCell.unit && enemyCell.unit.player !== gameState.aiState.aiPlayer) {
          const distance = calculateDistance(pos, enemyPos);
          if (distance <= enemyCell.unit.range) {
            threats.push(enemyCell.unit);
          }
        }
      }
      
      return threats;
    }

    function findOpportunities(unit, pos) {
      const opportunities = [];
      const gridSize = gameConfig.gridSize;
      
      // Find enemy units this unit can attack
      for (let enemyPos = 0; enemyPos < gridSize * gridSize; enemyPos++) {
        const enemyCell = currentZoneDetail.tacticalGrid[enemyPos];
        if (enemyCell.unit && enemyCell.unit.player !== gameState.aiState.aiPlayer) {
          const distance = calculateDistance(pos, enemyPos);
          if (distance <= unit.range) {
            opportunities.push(enemyCell.unit);
          }
        }
      }
      
      return opportunities;
    }

    function findReachableEnemies(pos, unit) {
      const reachable = [];
      const gridSize = gameConfig.gridSize;
      
      for (let enemyPos = 0; enemyPos < gridSize * gridSize; enemyPos++) {
        const enemyCell = currentZoneDetail.tacticalGrid[enemyPos];
        if (enemyCell.unit && enemyCell.unit.player !== gameState.aiState.aiPlayer) {
          const distance = calculateDistance(pos, enemyPos);
          if (distance <= unit.range) {
            reachable.push(enemyCell.unit);
          }
        }
      }
      
      return reachable;
    }

    function findProtectedAllies(pos, unit) {
      const protected = [];
      const gridSize = gameConfig.gridSize;
      const unitRow = Math.floor(pos / gridSize);
      const unitCol = pos % gridSize;
      
      // Find allies behind this unit
      for (let row = unitRow + 1; row < gridSize; row++) {
        const allyPos = row * gridSize + unitCol;
        const allyCell = currentZoneDetail.tacticalGrid[allyPos];
        if (allyCell.unit && allyCell.unit.player === gameState.aiState.aiPlayer) {
          protected.push(allyCell.unit);
        }
      }
      
      return protected;
    }

    function calculateExposure(pos) {
      const gridSize = gameConfig.gridSize;
      const row = Math.floor(pos / gridSize);
      const col = pos % gridSize;
      let exposure = 0;
      
      // Check if position is exposed from multiple directions
      const directions = [
        [-1, 0], [1, 0], [0, -1], [0, 1], // Adjacent
        [-1, -1], [-1, 1], [1, -1], [1, 1] // Diagonal
      ];
      
      directions.forEach(([dRow, dCol]) => {
        const checkRow = row + dRow;
        const checkCol = col + dCol;
        
        if (checkRow >= 0 && checkRow < gridSize && checkCol >= 0 && checkCol < gridSize) {
          const checkPos = checkRow * gridSize + checkCol;
          const checkCell = currentZoneDetail.tacticalGrid[checkPos];
          
          if (checkCell.unit && checkCell.unit.player !== gameState.aiState.aiPlayer) {
            exposure += 1;
          }
        }
      });
      
      return exposure;
    }

    function getAllEnemyPositions() {
      const enemyPositions = [];
      const gridSize = gameConfig.gridSize;
      
      for (let pos = 0; pos < gridSize * gridSize; pos++) {
        const cell = currentZoneDetail.tacticalGrid[pos];
        if (cell.unit && cell.unit.player !== gameState.aiState.aiPlayer) {
          enemyPositions.push(pos);
        }
      }
      
      return enemyPositions;
    }
    
    function findNearestEnemy(unit) {
      const gridSize = gameConfig.gridSize;
      let nearestEnemy = null;
      let nearestDistance = Infinity;
      
      for (let pos = 0; pos < gridSize * gridSize; pos++) {
        const targetUnit = currentZoneDetail.tacticalGrid[pos].unit;
        if (targetUnit && targetUnit.player !== gameState.aiState.aiPlayer) {
          // Check if unit should be hidden due to stealth
          const stealthAbilities = applySpecialAbilities(targetUnit, pos, currentZoneDetail.tacticalGrid[pos]);
          const shouldHide = stealthAbilities.hidden;
          
          if (!shouldHide) {
          const distance = calculateDistance(unit.position, pos);
          if (distance < nearestDistance) {
            nearestDistance = distance;
            nearestEnemy = targetUnit;
            }
          }
        }
      }
      
      return nearestEnemy;
    }
    
    function calculateDistance(pos1, pos2) {
      const gridSize = gameConfig.gridSize;
      const row1 = Math.floor(pos1 / gridSize);
      const col1 = pos1 % gridSize;
      const row2 = Math.floor(pos2 / gridSize);
      const col2 = pos2 % gridSize;
      
      return Math.abs(row1 - row2) + Math.abs(col1 - col2);
    }
    
    function findBestTarget(unit) {
      // Find weakest enemy unit in range
      const gridSize = gameConfig.gridSize;
      let bestTarget = null;
      let bestValue = -Infinity;
      
      for (let pos = 0; pos < gridSize * gridSize; pos++) {
        const targetUnit = currentZoneDetail.tacticalGrid[pos].unit;
        if (targetUnit && targetUnit.player !== gameState.aiState.aiPlayer) {
          // Check if unit should be hidden due to stealth
          const stealthAbilities = applySpecialAbilities(targetUnit, pos, currentZoneDetail.tacticalGrid[pos]);
          const shouldHide = stealthAbilities.hidden;
          
          if (!shouldHide) {
          const distance = calculateDistance(unit.position, pos);
          if (distance <= unit.range) {
            // Target value: prioritize weak units (low health/defense)
            const targetValue = -(targetUnit.health + targetUnit.defense);
            if (targetValue > bestValue) {
              bestValue = targetValue;
              bestTarget = targetUnit;
              }
            }
          }
        }
      }
      
      return bestTarget;
    }
    
    function calculateDefensivePosition(unit) {
      // Move towards back rows for defense
      const gridSize = gameConfig.gridSize;
      const currentPos = unit.position;
      const currentRow = Math.floor(currentPos / gridSize);
      
      // Try to move to back row
      const backRow = gridSize - 1;
      if (currentRow < backRow) {
        const newPos = backRow * gridSize + (currentPos % gridSize);
        if (!currentZoneDetail.tacticalGrid[newPos].unit) {
          return newPos;
        }
      }
      
      return null;
    }
    
    function moveAIUnit(unit, newPos) {
      const oldPos = unit.position;
      
      // Update unit position
      unit.position = newPos;
      unit.justMoved = true; // Flag for All Terrain ability
      
      // Update grid
      currentZoneDetail.tacticalGrid[oldPos].unit = null;
      currentZoneDetail.tacticalGrid[newPos].unit = unit;
      
      // Process special ability effects for movement
      const gridData = currentZoneDetail.tacticalGrid[newPos];
      processSpecialAbilityEffects(unit, newPos, gridData, 'movement');
      
      // Clear the justMoved flag after processing abilities
      unit.justMoved = false;
      
      // Mark as moved
      gameState.unitActions[unit.id].hasMoved = true;
      
      logMessage(`${gameConfig.player2.name} (AI) moves ${unit.name} to position ${newPos + 1}`, 'system');
    }
    
    function attackWithAIUnit(unit, target) {
      // Perform attack
      const attackResult = performAIAttack(unit, target);
      
      // Mark as attacked
      gameState.unitActions[unit.id].hasAttacked = true;
      
      logMessage(`${gameConfig.player2.name} (AI) attacks with ${unit.name}`, 'system');
      
      return attackResult;
    }
    
    function checkGameState() {
      console.log('=== CURRENT GAME STATE ===');
      console.log('Current Player:', gameState.currentPlayer);
      console.log('Game Phase:', gameState.gamePhase);
      console.log('AI Player:', gameState.aiState.aiPlayer);
      console.log('AI isAITurn:', gameState.aiState.isAITurn);
      console.log('AI aiThinking:', gameState.aiState.aiThinking);
      console.log('Opponent Type:', gameConfig.opponentType);
      console.log('=======================');
    }
    
    function performAIAttack(attacker, target) {
      // Get actual combat values with modifiers
      const attackerPos = attacker.position;
      const targetPos = target.position;
      const attackerGridData = currentZoneDetail.tacticalGrid[attackerPos];
      const targetGridData = currentZoneDetail.tacticalGrid[targetPos];
      
              const attackerCombatValues = getActualCombatValues(attacker, attackerPos, attackerGridData, targetPos, targetGridData);
        const targetCombatValues = getActualCombatValues(target, targetPos, targetGridData);
      
      // Combat calculation with actual values
      const attackRoll = Math.floor(Math.random() * 6) + 1 + attackerCombatValues.actualAttack;
      const defenseRoll = Math.floor(Math.random() * 6) + 1 + targetCombatValues.actualDefense;
      
      if (attackRoll > defenseRoll) {
        const damage = attackRoll - defenseRoll;
        target.health = Math.max(0, target.health - damage);
        
        if (target.health <= 0) {
          // Unit destroyed
          const targetPos = target.position;
          eliminateUnit(target, targetPos);
          logMessage(`${gameConfig.player2.name} (AI) destroys ${target.name}!`, 'combat');
        } else {
          logMessage(`${gameConfig.player2.name} (AI) damages ${target.name} (${damage} damage)`, 'combat');
        }
        
        return { success: true, damage: damage };
      } else {
        logMessage(`${gameConfig.player2.name} (AI) attack misses ${target.name}`, 'combat');
        return { success: false, damage: 0 };
      }
    }

    // ========================================
    // PHASE 4: ADVANCED AI FEATURES
    // ========================================

    // AI Artillery Usage
    function executeAIArtilleryStrikes(aiDecisions) {
      console.log('=== AI ARTILLERY STRIKES ===');
      
      try {
        if (!aiDecisions.artilleryTargets || aiDecisions.artilleryTargets.length === 0) {
          console.log('No artillery targets selected');
          return;
        }

        aiDecisions.artilleryTargets.forEach((target, index) => {
          setTimeout(() => {
            try {
              executeSingleArtilleryStrike(target);
            } catch (error) {
              console.error('Error in artillery strike:', error);
            }
          }, index * 1000); // Stagger artillery strikes
        });
      } catch (error) {
        console.error('Error in artillery strikes:', error);
      }
    }

    function executeSingleArtilleryStrike(targetZone) {
      console.log(`AI conducting artillery strike on zone ${targetZone}`);
      
      // Get the zone and check for hidden units
      const zone = zones.find(z => z.id === targetZone);
      if (!zone || !zone.tacticalGrid) {
        logMessage(`${gameConfig.player2.name} (AI) artillery strike on Zone ${targetZone} - zone not found`, 'artillery');
        return;
      }
      
      // Check for hidden units and reveal them
      let hiddenUnitsRevealed = 0;
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        const unit = zone.tacticalGrid[pos].unit;
        if (unit && unit.player === 'red' && unit.special === 'stealth' && !unit.permanentlyUnhidden) {
          unit.permanentlyUnhidden = true;
          hiddenUnitsRevealed++;
          logMessage(`${gameConfig.player2.name} (AI) artillery reveals hidden ${unit.name}!`, 'artillery');
        }
      }
      
      // Get human units in target zone (now including newly revealed units)
      const humanUnits = getHumanUnitsInZone(targetZone);
      
      if (humanUnits.length === 0) {
        if (hiddenUnitsRevealed > 0) {
          logMessage(`${gameConfig.player2.name} (AI) artillery strike on Zone ${targetZone} - revealed ${hiddenUnitsRevealed} hidden unit(s)`, 'artillery');
        } else {
        logMessage(`${gameConfig.player2.name} (AI) artillery strike on Zone ${targetZone} - no targets found`, 'artillery');
        }
        return;
      }

      // Calculate artillery damage
      const artilleryDamage = calculateArtilleryDamage(humanUnits.length);
      
      // Apply damage to units
      let unitsHit = 0;
      humanUnits.forEach(unit => {
        if (Math.random() < 0.7) { // 70% chance to hit each unit
          const damage = Math.floor(Math.random() * artilleryDamage) + 1;
          unitsHit++;
          
          const unitDestroyed = applyDamage(unit, damage, unit.position);
          if (unitDestroyed) {
            // Unit destroyed by artillery - applyDamage already handled elimination
            logMessage(`${gameConfig.player2.name} (AI) artillery destroys ${unit.name}!`, 'artillery');
          } else {
            logMessage(`${gameConfig.player2.name} (AI) artillery damages ${unit.name} (${damage} damage)`, 'artillery');
          }
        }
      });

      logMessage(`${gameConfig.player2.name} (AI) artillery strike on Zone ${targetZone} - ${unitsHit} units hit, ${hiddenUnitsRevealed} hidden units revealed`, 'artillery');
    }

    function calculateArtilleryDamage(unitCount) {
      // Artillery damage scales with number of units in zone
      return Math.min(5, Math.max(2, Math.floor(unitCount / 2)));
    }

    // NEW SEPARATE AI AERIAL COMBAT SYSTEM
    function executeAIAerialCombat(aiDecisions) {
      console.log('=== NEW AI AERIAL COMBAT SYSTEM ===');
      
      try {
        // Get AI aerial units from selected armies (separate from gameState.aerial)
        const aiAerialUnits = getAIAerialUnitsFromArmies();
        const humanAerialUnits = getHumanAerialUnitsFromArmies();
        
        console.log('AI aerial units from armies:', aiAerialUnits);
        console.log('Human aerial units from armies:', humanAerialUnits);
        
        // Separate fighters and bombers
        const aiFighters = aiAerialUnits.filter(unit => unit.type === 'fighter');
        const aiBombers = aiAerialUnits.filter(unit => unit.type === 'bomber');
        const humanFighters = humanAerialUnits.filter(unit => unit.type === 'fighter');
        const humanBombers = humanAerialUnits.filter(unit => unit.type === 'bomber');
        
        console.log('AI fighters:', aiFighters.length, 'AI bombers:', aiBombers.length);
        console.log('Human fighters:', humanFighters.length, 'Human bombers:', humanBombers.length);

        // Phase 1: Fighter Combat (NEW SYSTEM)
        executeNewAIFighterCombat(aiFighters, humanFighters, humanBombers);
        
        // Phase 2: Bomber Operations (NEW SYSTEM)
        setTimeout(() => {
          try {
            executeNewAIBomberOperations(aiBombers, humanFighters);
          } catch (error) {
            console.error('Error in new bomber operations:', error);
          }
        }, 2000);
      } catch (error) {
        console.error('Error in new aerial combat system:', error);
      }
    }

    // Get AI aerial units directly from selected armies
    function getAIAerialUnitsFromArmies() {
      const aiPlayer = gameState.aiState.aiPlayer;
      const aiAerialUnits = [];
      
      if (gameData.selectedArmies && gameData.selectedArmies.player2) {
        const aiArmy = gameData.selectedArmies.player2;
        
        if (aiArmy && aiArmy.units) {
          const aerialUnitsInArmy = aiArmy.units.filter(unit =>
            unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship'
          );
          
          aerialUnitsInArmy.forEach((unit, index) => {
            const aerialUnit = {
              id: `ai_${unit.id}_${index}`,
              name: unit.name,
              type: unit.type,
              attack: unit.attack,
              defense: unit.defense,
              health: Math.max(unit.defense, 1),
              maxHealth: Math.max(unit.defense, 1),
              player: aiPlayer,
              armyId: aiArmy.id,
              armyName: aiArmy.name,
              isAI: true
            };
            
            aiAerialUnits.push(aerialUnit);
          });
        }
      }
      
      return aiAerialUnits;
    }
    
    // Get human aerial units directly from selected armies
    function getHumanAerialUnitsFromArmies() {
      const humanPlayer = gameState.aiState.aiPlayer === 'red' ? 'blue' : 'red';
      const humanAerialUnits = [];
      
      if (gameData.selectedArmies && gameData.selectedArmies.player1) {
        const humanArmy = gameData.selectedArmies.player1;
        
        if (humanArmy && humanArmy.units) {
          const aerialUnitsInArmy = humanArmy.units.filter(unit =>
            unit.type === 'fighter' || unit.type === 'bomber' || unit.type === 'airship'
          );
          
          aerialUnitsInArmy.forEach((unit, index) => {
            const aerialUnit = {
              id: `human_${unit.id}_${index}`,
              name: unit.name,
              type: unit.type,
              attack: unit.attack,
              defense: unit.defense,
              health: Math.max(unit.defense, 1),
              maxHealth: Math.max(unit.defense, 1),
              player: humanPlayer,
              armyId: humanArmy.id,
              armyName: humanArmy.name,
              isAI: false
            };
            
            humanAerialUnits.push(aerialUnit);
          });
        }
      }
      
      return humanAerialUnits;
    }
    
    // NEW AI Fighter Combat System
    function executeNewAIFighterCombat(aiFighters, humanFighters, humanBombers) {
      console.log('=== NEW AI FIGHTER COMBAT SYSTEM ===');
      console.log(`AI fighters: ${aiFighters.length}, Human fighters: ${humanFighters.length}, Human bombers: ${humanBombers.length}`);
      
      if (aiFighters.length === 0) {
        console.log(' AI has no fighters for air combat');
        logMessage(`${gameConfig.player2.name} (AI) has no fighters for air superiority`, 'aerial');
        return;
      }
      
      logMessage(`${gameConfig.player2.name} (AI) launches ${aiFighters.length} fighters to establish air superiority`, 'aerial');
      
      // Priority 1: Destroy enemy fighters first (air superiority)
      if (humanFighters.length > 0) {
        console.log(' AI prioritizing enemy fighters for air superiority');
        logMessage(`${gameConfig.player2.name} (AI) prioritizes enemy fighters for air superiority`, 'aerial');
        
        aiFighters.forEach((fighter, index) => {
          setTimeout(() => {
            if (humanFighters.length > 0) {
              // Find the most dangerous enemy fighter (highest attack)
              const target = humanFighters.reduce((best, current) => 
                current.attack > best.attack ? current : best
              );
              
              const wasDestroyed = performNewAIAerialAttack(fighter, target, 'fighter');
              
              // Remove destroyed fighter from array
              if (wasDestroyed) {
                const targetIndex = humanFighters.indexOf(target);
                if (targetIndex > -1) {
                  humanFighters.splice(targetIndex, 1);
                  console.log(`Removed destroyed fighter ${target.name} from humanFighters array`);
                  console.log(`Remaining human fighters: ${humanFighters.length}`);
                  
                  // Update the aerial panel to reflect the destroyed unit
                  setTimeout(() => {
                    updateAerialPanel();
                    console.log('Aerial panel updated after fighter destruction');
                  }, 100);
                }
              }
            }
          }, index * 300);
        });
      }
      
      // Priority 2: After fighters are dealt with, attack bombers
      setTimeout(() => {
        if (humanBombers.length > 0 && humanFighters.length === 0) {
          console.log(' AI targeting enemy bombers after achieving air superiority');
          logMessage(`${gameConfig.player2.name} (AI) targets enemy bombers after achieving air superiority`, 'aerial');
          
          aiFighters.forEach((fighter, index) => {
            setTimeout(() => {
              if (humanBombers.length > 0) {
                // Find the most dangerous enemy bomber (highest attack)
                const target = humanBombers.reduce((best, current) => 
                  current.attack > best.attack ? current : best
                );
                
                const wasDestroyed = performNewAIAerialAttack(fighter, target, 'bomber');
                
                // Remove destroyed bomber from array
                if (wasDestroyed) {
                  const targetIndex = humanBombers.indexOf(target);
                  if (targetIndex > -1) {
                    humanBombers.splice(targetIndex, 1);
                    console.log(`Removed destroyed bomber ${target.name} from humanBombers array`);
                    console.log(`Remaining human bombers: ${humanBombers.length}`);
                    
                    // Update the aerial panel to reflect the destroyed unit
                    setTimeout(() => {
                      updateAerialPanel();
                      console.log('Aerial panel updated after bomber destruction');
                    }, 100);
                  }
                }
              }
            }, index * 300);
          });
        }
      }, aiFighters.length * 300 + 500);
    }
    
    // NEW AI Aerial Attack System
    function performNewAIAerialAttack(attacker, target, targetType) {
      console.log(` NEW SYSTEM: ${attacker.name} engaging enemy ${targetType} ${target.name}`);
      
      // Apply special abilities to attacker (Air Superiority, etc.)
      let attackerAttackBonus = 0;
      if (attacker.special && attacker.special !== 'none') {
        const ability = specialAbilities[attacker.special];
        if (ability && ability.apply) {
          const abilityEffects = ability.apply(attacker, null, null);
          if (abilityEffects.attackBonus) {
            attackerAttackBonus = abilityEffects.attackBonus;
            console.log(` [AIR SUPERIORITY] ${attacker.name} gets +${attackerAttackBonus} attack bonus from Air Superiority`);
          }
        }
      }
      
      // Get actual combat values with modifiers (for aerial units, we use their base stats since they're not on the grid)
      const attackerCombatValues = { actualAttack: attacker.attack + attackerAttackBonus, actualDefense: attacker.defense };
      const targetCombatValues = { actualAttack: target.attack, actualDefense: target.defense };
      
      console.log(`Attacker stats: attack=${attackerCombatValues.actualAttack}, defense=${attackerCombatValues.actualDefense}, health=${attacker.health}`);
      console.log(`Target stats: attack=${targetCombatValues.actualAttack}, defense=${targetCombatValues.actualDefense}, health=${target.health}`);
      
      const attackRoll = Math.floor(Math.random() * 6) + 1 + attackerCombatValues.actualAttack;
      const defenseRoll = Math.floor(Math.random() * 6) + 1 + targetCombatValues.actualDefense;
      
      console.log(`Combat: ${attacker.name} (${attackRoll}) vs ${target.name} (${defenseRoll})`);
      
      if (attackRoll > defenseRoll) {
        const damage = attackRoll - defenseRoll;
        const oldHealth = target.health;
        target.health = Math.max(0, target.health - damage);
        
        console.log(`Target ${target.name} health: ${oldHealth} -> ${target.health} (damage: ${damage})`);
        
        if (target.health <= 0) {
          console.log(` NEW SYSTEM: ${attacker.name} DESTROYS enemy ${targetType} ${target.name}!`);
          logMessage(`${gameConfig.player2.name} (AI) ${attacker.name} destroys enemy ${targetType} ${target.name}!`, 'aerial');
          
          // Remove destroyed unit from gameState.aerial (for UI updates)
          const targetPlayer = target.player || 'red';
          const aerialUnits = gameState.aerial[targetPlayer];
          if (aerialUnits) {
            const targetIndex = aerialUnits.findIndex(unit => 
              unit.name === target.name && unit.type === target.type
            );
            if (targetIndex > -1) {
              aerialUnits.splice(targetIndex, 1);
              console.log(`Removed destroyed ${targetType} ${target.name} from gameState.aerial`);
            }
          }
          
          // Update air superiority status
          if (targetType === 'fighter') {
            logMessage(`${gameConfig.player2.name} (AI) gains air superiority advantage!`, 'aerial');
          }
          
          return true; // Unit was destroyed
        } else {
          console.log(` NEW SYSTEM: ${attacker.name} damages enemy ${targetType} ${target.name} (${damage} damage)`);
          logMessage(`${gameConfig.player2.name} (AI) ${attacker.name} damages enemy ${targetType} ${target.name} (${damage} damage)`, 'aerial');
          return false; // Unit was damaged but not destroyed
        }
      } else {
        console.log(` NEW SYSTEM: ${attacker.name} misses enemy ${targetType} ${target.name}`);
        logMessage(`${gameConfig.player2.name} (AI) ${attacker.name} misses enemy ${targetType} ${target.name}`, 'aerial');
        return false; // Attack missed
      }
    }
    
    // NEW AI Bomber Operations System
    function executeNewAIBomberOperations(aiBombers, humanFighters) {
      console.log('=== NEW AI BOMBER OPERATIONS SYSTEM ===');
      console.log(`AI bombers: ${aiBombers.length}, Enemy fighters remaining: ${humanFighters.length}`);
      
      if (aiBombers.length === 0) {
        console.log(' AI has no bombers available for operations');
        logMessage(`${gameConfig.player2.name} (AI) has no bombers for strategic bombing`, 'aerial');
        return;
      }
      
      // Strategic bombing: Only send bombers if we have air superiority
      if (humanFighters.length === 0) {
        console.log(' AI has air superiority - launching strategic bombing campaign');
        logMessage(`${gameConfig.player2.name} (AI) launches strategic bombing campaign with air superiority`, 'aerial');
        
        aiBombers.forEach((bomber, index) => {
          setTimeout(() => {
            // Select high-value ground target for bombing
            const groundTarget = selectGroundTargetForBomber();
            if (groundTarget) {
              performNewAIBomberStrike(bomber, groundTarget);
            } else {
              logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} has no suitable ground targets`, 'aerial');
            }
          }, index * 600);
        });
      } else {
        console.log(' AI bombers grounded due to enemy air superiority');
        logMessage(`${gameConfig.player2.name} (AI) bombers grounded - enemy air superiority prevents bombing`, 'aerial');
      }
    }
    
    // NEW AI Bomber Strike System
    function performNewAIBomberStrike(bomber, target) {
      console.log(` NEW SYSTEM: ${bomber.name} conducting bombing run on ${target.name}`);
      
      // Get actual combat values with modifiers for ground target
      const targetZone = zones.find(zone => {
        return zone.tacticalGrid && Object.values(zone.tacticalGrid).some(cell => 
          cell.unit && cell.unit.id === target.id
        );
      });
      
      let targetCombatValues = { actualAttack: target.attack, actualDefense: target.defense };
      
      if (targetZone) {
        // Find the target's position in the zone
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const cell = targetZone.tacticalGrid[pos];
          if (cell.unit && cell.unit.id === target.id) {
            targetCombatValues = getActualCombatValues(target, pos, cell);
            break;
          }
        }
      }
      
      console.log(`Bomber stats: attack=${bomber.attack}, defense=${bomber.defense}, health=${bomber.health}`);
      console.log(`Target stats: attack=${targetCombatValues.actualAttack}, defense=${targetCombatValues.actualDefense}, health=${target.health}`);
      
      const attackRoll = Math.floor(Math.random() * 6) + 1 + bomber.attack;
      const defenseRoll = Math.floor(Math.random() * 6) + 1 + targetCombatValues.actualDefense;
      
      console.log(`Bombing: ${bomber.name} (${attackRoll}) vs ${target.name} (${defenseRoll})`);
      
      if (attackRoll > defenseRoll) {
        const damage = attackRoll - defenseRoll;
        target.health = Math.max(0, target.health - damage);
        
        console.log(`Target ${target.name} health reduced to ${target.health}`);
        
        if (target.health <= 0) {
          console.log(` NEW SYSTEM: ${bomber.name} DESTROYS ${target.name}!`);
          logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} destroys ${target.name}!`, 'aerial');
          
          // Remove destroyed unit from tactical grid
          const targetZone = zones.find(zone => {
            return zone.tacticalGrid && Object.values(zone.tacticalGrid).some(cell => 
              cell.unit && cell.unit.id === target.id
            );
          });
          
          if (targetZone) {
            Object.values(targetZone.tacticalGrid).forEach(cell => {
              if (cell.unit && cell.unit.id === target.id) {
                cell.unit = null;
                console.log(`Removed destroyed unit ${target.name} from tactical grid`);
              }
            });
            
            // Remove from artillery array if it's an artillery unit
            if (target.type === 'artillery') {
              const enemyPlayer = target.player;
              if (gameState.artillery && gameState.artillery[enemyPlayer]) {
                gameState.artillery[enemyPlayer] = gameState.artillery[enemyPlayer].filter(unit => unit.id !== target.id);
                console.log(` [BOMBER FIX] Removed destroyed artillery ${target.name} from gameState.artillery[${enemyPlayer}]`);
              }
            }
            
            // Update the battlefield display
            setTimeout(() => {
              renderBattlefield();
              console.log('Battlefield updated after unit destruction');
            }, 100);
          }
        } else {
          console.log(` NEW SYSTEM: ${bomber.name} bombs ${target.name} (${damage} damage)`);
          logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} bombs ${target.name} (${damage} damage)`, 'aerial');
        }
      } else {
        console.log(` NEW SYSTEM: ${bomber.name} misses ${target.name}`);
        logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} misses ${target.name}`, 'aerial');
      }
    }
    
    function executeAIFighterCombat(aiFighters, humanFighters, humanBombers) {
      console.log('=== AI FIGHTER COMBAT - ESTABLISHING AIR SUPERIORITY ===');
      console.log(`AI fighters: ${aiFighters.length}, Enemy fighters: ${humanFighters.length}, Enemy bombers: ${humanBombers.length}`);
      console.log('AI aerial units available:', gameState.aerial[gameState.aiState.aiPlayer]);
      console.log('Human aerial units available:', gameState.aerial[gameState.aiState.aiPlayer === 'red' ? 'blue' : 'red']);
      
      // Strategic air combat: Establish air superiority first
      if (aiFighters.length > 0) {
        logMessage(`${gameConfig.player2.name} (AI) launches ${aiFighters.length} fighters to establish air superiority`, 'aerial');
        
        // Priority 1: Destroy enemy fighters first (air superiority)
        if (humanFighters.length > 0) {
          console.log(' AI prioritizing enemy fighters for air superiority');
          logMessage(`${gameConfig.player2.name} (AI) prioritizes enemy fighters for air superiority`, 'aerial');
          
          aiFighters.forEach((fighter, index) => {
            setTimeout(() => {
              if (humanFighters.length > 0) {
                // Find the most dangerous enemy fighter (highest attack)
                const target = humanFighters.reduce((best, current) => 
                  current.attack > best.attack ? current : best
                );
                const wasDestroyed = performAIAerialAttack(fighter, target, 'fighter');
                
                // Remove destroyed fighter from array
                if (wasDestroyed) {
                  const targetIndex = humanFighters.indexOf(target);
                  if (targetIndex > -1) {
                    humanFighters.splice(targetIndex, 1);
                    console.log(`Removed destroyed fighter ${target.name} from humanFighters array`);
                    console.log(`Remaining human fighters: ${humanFighters.length}`);
                  }
                }
              }
            }, index * 300); // Faster engagement
          });
        }
        
        // Priority 2: After fighters are dealt with, attack bombers
        setTimeout(() => {
          if (humanBombers.length > 0 && humanFighters.length === 0) {
            console.log(' AI targeting enemy bombers after achieving air superiority');
            logMessage(`${gameConfig.player2.name} (AI) targets enemy bombers after achieving air superiority`, 'aerial');
            
            aiFighters.forEach((fighter, index) => {
              setTimeout(() => {
                if (humanBombers.length > 0) {
                  // Find the most dangerous enemy bomber (highest attack)
                  const target = humanBombers.reduce((best, current) => 
                    current.attack > best.attack ? current : best
                  );
                  const wasDestroyed = performAIAerialAttack(fighter, target, 'bomber');
                  
                  // Remove destroyed bomber from array
                  if (wasDestroyed) {
                    const targetIndex = humanBombers.indexOf(target);
                    if (targetIndex > -1) {
                      humanBombers.splice(targetIndex, 1);
                      console.log(`Removed destroyed bomber ${target.name} from humanBombers array`);
                      console.log(`Remaining human bombers: ${humanBombers.length}`);
                    }
                  }
                }
              }, index * 300);
            });
          }
        }, aiFighters.length * 300 + 500); // Wait for fighter combat to complete
      } else {
        console.log(' AI has no fighters available for air combat');
        logMessage(`${gameConfig.player2.name} (AI) has no fighters for air superiority`, 'aerial');
      }
    }

    function executeAIBomberOperations(aiBombers, humanFighters) {
      console.log('=== AI BOMBER OPERATIONS - STRATEGIC BOMBING ===');
      console.log(`AI bombers: ${aiBombers.length}, Enemy fighters remaining: ${humanFighters.length}`);
      
      // Strategic bombing: Only send bombers if we have air superiority
      if (aiBombers.length > 0) {
        if (humanFighters.length === 0) {
          console.log(' AI has air superiority - launching strategic bombing campaign');
          logMessage(`${gameConfig.player2.name} (AI) launches strategic bombing campaign with air superiority`, 'aerial');
          
          aiBombers.forEach((bomber, index) => {
            setTimeout(() => {
              // Select high-value ground target for bombing
              const groundTarget = selectGroundTargetForBomber();
              if (groundTarget) {
                performAIBomberStrike(bomber, groundTarget);
              } else {
                logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} has no suitable ground targets`, 'aerial');
              }
            }, index * 600); // Faster bombing runs
          });
        } else if (gameState.aiState.aiFighters > humanFighters.length) {
          console.log(' AI has fighter escort - launching escorted bombing mission');
          logMessage(`${gameConfig.player2.name} (AI) launches escorted bombing mission`, 'aerial');
          
          aiBombers.forEach((bomber, index) => {
            setTimeout(() => {
              const groundTarget = selectGroundTargetForBomber();
              if (groundTarget) {
                performAIBomberStrike(bomber, groundTarget);
              }
            }, index * 800);
          });
        } else {
          console.log(' AI bombers grounded due to enemy air superiority');
          logMessage(`${gameConfig.player2.name} (AI) bombers grounded - enemy air superiority prevents bombing`, 'aerial');
        }
      } else {
        console.log(' AI has no bombers available for operations');
        logMessage(`${gameConfig.player2.name} (AI) has no bombers for strategic bombing`, 'aerial');
      }
    }

    function performAIAerialAttack(attacker, target, targetType) {
      console.log(` ${attacker.name} engaging enemy ${targetType} ${target.name}`);
      
      // Apply special abilities to attacker (Air Superiority, etc.)
      let attackerAttackBonus = 0;
      if (attacker.special && attacker.special !== 'none') {
        const ability = specialAbilities[attacker.special];
        if (ability && ability.apply) {
          const abilityEffects = ability.apply(attacker, null, null);
          if (abilityEffects.attackBonus) {
            attackerAttackBonus = abilityEffects.attackBonus;
            console.log(` [AIR SUPERIORITY] ${attacker.name} gets +${attackerAttackBonus} attack bonus from Air Superiority`);
          }
        }
      }
      
      // Get actual combat values with modifiers (for aerial units, we use their base stats since they're not on the grid)
      const attackerCombatValues = { actualAttack: attacker.attack + attackerAttackBonus, actualDefense: attacker.defense };
      const targetCombatValues = { actualAttack: target.attack, actualDefense: target.defense };
      
      console.log(`Attacker stats: attack=${attackerCombatValues.actualAttack}, defense=${attackerCombatValues.actualDefense}, health=${attacker.health}`);
      console.log(`Target stats: attack=${targetCombatValues.actualAttack}, defense=${targetCombatValues.actualDefense}, health=${target.health}`);
      
      // Ensure target has health property
      if (typeof target.health === 'undefined') {
        target.health = target.defense;
        console.log(`Initialized target ${target.name} health to ${target.health}`);
      }
      
      const attackRoll = Math.floor(Math.random() * 6) + 1 + attackerCombatValues.actualAttack;
      const defenseRoll = Math.floor(Math.random() * 6) + 1 + targetCombatValues.actualDefense;
      
      console.log(`Combat: ${attacker.name} (${attackRoll}) vs ${target.name} (${defenseRoll})`);
      
      if (attackRoll > defenseRoll) {
        const damage = attackRoll - defenseRoll;
        const oldHealth = target.health;
        target.health = Math.max(0, target.health - damage);
        
        console.log(`Target ${target.name} health: ${oldHealth} -> ${target.health} (damage: ${damage})`);
        
        if (target.health <= 0) {
          console.log(` ${attacker.name} DESTROYS enemy ${targetType} ${target.name}!`);
          logMessage(`${gameConfig.player2.name} (AI) ${attacker.name} destroys enemy ${targetType} ${target.name}!`, 'aerial');
          
          // Remove destroyed unit from aerial units array
          const targetPlayer = target.player || 'red';
          const aerialUnits = gameState.aerial[targetPlayer];
          const targetIndex = aerialUnits.findIndex(unit => unit.id === target.id);
          if (targetIndex > -1) {
            aerialUnits.splice(targetIndex, 1);
            console.log(`Removed destroyed ${targetType} ${target.name} from aerial units array`);
            console.log(`Remaining ${targetPlayer} aerial units:`, aerialUnits);
            
            // Update the aerial panel to reflect the destroyed unit
            setTimeout(() => {
              updateAerialPanel();
              console.log('Aerial panel updated after unit destruction');
            }, 100);
            
            // Force refresh the aerial panel for the target player
            if (targetPlayer === 'red') {
              const redAerialPanel = document.querySelector('.aerial-panel.red-player');
              if (redAerialPanel) {
                updateAerialPanel();
              }
            } else if (targetPlayer === 'blue') {
              const blueAerialPanel = document.querySelector('.aerial-panel.blue-player');
              if (blueAerialPanel) {
                updateAerialPanel();
              }
            }
          } else {
            console.log(` Could not find destroyed unit ${target.name} in aerial units array`);
          }
          
          // Update air superiority status
          if (targetType === 'fighter') {
            logMessage(`${gameConfig.player2.name} (AI) gains air superiority advantage!`, 'aerial');
          }
          
          return true; // Unit was destroyed
        } else {
          console.log(` ${attacker.name} damages enemy ${targetType} ${target.name} (${damage} damage)`);
          logMessage(`${gameConfig.player2.name} (AI) ${attacker.name} damages enemy ${targetType} ${target.name} (${damage} damage)`, 'aerial');
          return false; // Unit was damaged but not destroyed
        }
      } else {
        console.log(` ${attacker.name} misses enemy ${targetType} ${target.name}`);
        logMessage(`${gameConfig.player2.name} (AI) ${attacker.name} misses enemy ${targetType} ${target.name}`, 'aerial');
        return false; // Attack missed
      }
    }

    function performAIBomberStrike(bomber, target) {
      console.log(` ${bomber.name} conducting bombing run on ${target.name}`);
      
      // Get actual combat values with modifiers for ground target
      const targetZone = zones.find(zone => {
        return zone.tacticalGrid && Object.values(zone.tacticalGrid).some(cell => 
          cell.unit && cell.unit.id === target.id
        );
      });
      
      let targetCombatValues = { actualAttack: target.attack, actualDefense: target.defense };
      
      if (targetZone) {
        // Find the target's position in the zone
        for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
          const cell = targetZone.tacticalGrid[pos];
          if (cell.unit && cell.unit.id === target.id) {
            targetCombatValues = getActualCombatValues(target, pos, cell);
            break;
          }
        }
      }
      
      console.log(`Bomber stats: attack=${bomber.attack}, defense=${bomber.defense}, health=${bomber.health}`);
      console.log(`Target stats: attack=${targetCombatValues.actualAttack}, defense=${targetCombatValues.actualDefense}, health=${target.health}`);
      
      const attackRoll = Math.floor(Math.random() * 6) + 1 + bomber.attack;
      const defenseRoll = Math.floor(Math.random() * 6) + 1 + targetCombatValues.actualDefense;
      
      console.log(`Bombing: ${bomber.name} (${attackRoll}) vs ${target.name} (${defenseRoll})`);
      
      if (attackRoll > defenseRoll) {
        const damage = attackRoll - defenseRoll;
        target.health = Math.max(0, target.health - damage);
        
        console.log(`Target ${target.name} health reduced to ${target.health}`);
        
        if (target.health <= 0) {
          console.log(` ${bomber.name} DESTROYS ${target.name}!`);
          logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} destroys ${target.name}!`, 'aerial');
          
          // Remove destroyed unit from tactical grid
          const targetZone = zones.find(zone => {
            return zone.tacticalGrid && Object.values(zone.tacticalGrid).some(cell => 
              cell.unit && cell.unit.id === target.id
            );
          });
          
          if (targetZone) {
            Object.values(targetZone.tacticalGrid).forEach(cell => {
              if (cell.unit && cell.unit.id === target.id) {
                cell.unit = null;
                console.log(`Removed destroyed unit ${target.name} from tactical grid`);
              }
            });
            
            // Update the battlefield display
            setTimeout(() => {
              renderBattlefield();
              console.log('Battlefield updated after unit destruction');
            }, 100);
          }
        } else {
          console.log(` ${bomber.name} bombs ${target.name} (${damage} damage)`);
          logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} bombs ${target.name} (${damage} damage)`, 'aerial');
        }
      } else {
        console.log(` ${bomber.name} misses ${target.name}`);
        logMessage(`${gameConfig.player2.name} (AI) ${bomber.name} misses ${target.name}`, 'aerial');
      }
    }

    function selectGroundTargetForBomber() {
      // Find human units in zones for bombing
      const zonesWithHumanUnits = zones.filter(zone => {
        return zone.tacticalGrid && Object.values(zone.tacticalGrid).some(cell => 
          cell.unit && cell.unit.player === 'red'
        );
      });

      if (zonesWithHumanUnits.length === 0) return null;

      // Select zone with most human units
      const targetZone = zonesWithHumanUnits.reduce((max, zone) => {
        const humanUnitCount = Object.values(zone.tacticalGrid).filter(cell => 
          cell.unit && cell.unit.player === 'red'
        ).length;
        const maxCount = Object.values(max.tacticalGrid).filter(cell => 
          cell.unit && cell.unit.player === 'red'
        ).length;
        return humanUnitCount > maxCount ? zone : max;
      });

      // Select weakest human unit in target zone
      const humanUnits = Object.values(targetZone.tacticalGrid)
        .filter(cell => cell.unit && cell.unit.player === 'red')
        .map(cell => cell.unit)
        .sort((a, b) => a.health - b.health);

      return humanUnits[0] || null;
    }

    // AI Morale & Retreat Logic
    function executeAIMoraleAndRetreat() {
      console.log('=== AI MORALE & RETREAT ===');
      
      // Check morale for all AI units
      const aiUnits = getAllAIUnits();
      
      aiUnits.forEach(unit => {
        // Update unit morale based on health and situation
        updateUnitMorale(unit);
        
        // Check if unit should retreat
        if (shouldUnitRetreat(unit)) {
          executeUnitRetreat(unit);
        }
      });
    }

    function updateUnitMorale(unit) {
      // Initialize morale if not exists
      if (unit.morale === undefined) {
        unit.morale = 100;
      }

      // Morale factors
      const healthFactor = (unit.health / unit.maxHealth) * 50; // 0-50 points
      const supportFactor = calculateSupportFactor(unit) * 30; // 0-30 points
      const leadershipFactor = calculateLeadershipFactor(unit) * 20; // 0-20 points

      unit.morale = Math.max(0, Math.min(100, healthFactor + supportFactor + leadershipFactor));
      
      console.log(`${unit.name} morale: ${unit.morale} (health: ${healthFactor}, support: ${supportFactor}, leadership: ${leadershipFactor})`);
    }

    function calculateSupportFactor(unit) {
      // Check for nearby friendly units
      const nearbyAllies = getNearbyUnits(unit, 2, 'blue');
      return Math.min(1, nearbyAllies.length / 4); // Max 1.0 for 4+ nearby allies
    }

    function calculateLeadershipFactor(unit) {
      // Elite units provide leadership bonus
      if (unit.type === 'Elite') {
        return 1.0;
      }
      
      // Check for nearby elite units
      const nearbyElites = getNearbyUnits(unit, 2, 'blue').filter(u => u.type === 'Elite');
      return Math.min(1, nearbyElites.length / 2); // Max 1.0 for 2+ nearby elites
    }

    function shouldUnitRetreat(unit) {
      // Low morale units more likely to retreat
      if (unit.morale < 30) {
        return Math.random() < 0.7; // 70% chance
      }
      
      // Heavily damaged units
      if (unit.health < unit.maxHealth * 0.3) {
        return Math.random() < 0.5; // 50% chance
      }
      
      // Outnumbered units
      const nearbyEnemies = getNearbyUnits(unit, 2, 'red');
      const nearbyAllies = getNearbyUnits(unit, 2, 'blue');
      
      if (nearbyEnemies.length > nearbyAllies.length * 2) {
        return Math.random() < 0.6; // 60% chance when heavily outnumbered
      }
      
      return false;
    }

    function executeUnitRetreat(unit) {
      console.log(`${unit.name} is retreating due to low morale/damage`);
      
      // Find retreat position (back rows)
      const retreatPos = findRetreatPosition(unit);
      
      if (retreatPos !== null) {
        moveAIUnit(unit, retreatPos);
        logMessage(`${gameConfig.player2.name} (AI) ${unit.name} retreats to safety`, 'morale');
      } else {
        // If no retreat position, unit is destroyed
        const currentPos = unit.position;
        if (currentZoneDetail && currentZoneDetail.tacticalGrid[currentPos]) {
          currentZoneDetail.tacticalGrid[currentPos].unit = null;
        }
        logMessage(`${gameConfig.player2.name} (AI) ${unit.name} is destroyed during retreat`, 'morale');
      }
    }

    function findRetreatPosition(unit) {
      const gridSize = gameConfig.gridSize;
      const currentPos = unit.position;
      const currentRow = Math.floor(currentPos / gridSize);
      
      // Try to move to back rows
      for (let row = gridSize - 1; row >= gridSize - 3; row--) {
        for (let col = 0; col < gridSize; col++) {
          const newPos = row * gridSize + col;
          if (!currentZoneDetail.tacticalGrid[newPos].unit) {
            return newPos;
          }
        }
      }
      
      return null;
    }

    // Enhanced Strategic AI
    function executeEnhancedStrategicAI(aiDecisions) {
      console.log('=== ENHANCED STRATEGIC AI ===');
      
      // Multi-turn planning
      const strategicPlan = createMultiTurnPlan();
      
      // Terrain exploitation
      executeTerrainExploitation();
      
      // Unit specialization
      executeUnitSpecialization();
      
      // Counter-strategy adaptation
      adaptToHumanStrategy();
    }

    function createMultiTurnPlan() {
      const plan = {
        shortTerm: [], // Next 1-2 turns
        mediumTerm: [], // Next 3-5 turns
        longTerm: [] // Next 6+ turns
      };
      
      // Analyze current battlefield state
      const battlefieldState = analyzeBattlefieldState();
      
      // Plan based on current situation
      if (battlefieldState.aiAdvantage > 0.6) {
        plan.shortTerm.push('aggressive_offensive');
        plan.mediumTerm.push('consolidate_gains');
      } else if (battlefieldState.aiAdvantage < 0.4) {
        plan.shortTerm.push('defensive_consolidation');
        plan.mediumTerm.push('counter_attack_preparation');
      } else {
        plan.shortTerm.push('balanced_approach');
        plan.mediumTerm.push('strategic_positioning');
      }
      
      console.log('AI Strategic Plan:', plan);
      return plan;
    }

    function executeTerrainExploitation() {
      console.log('AI exploiting terrain advantages');
      
      // Find zones with favorable terrain
      const favorableZones = zones.filter(zone => {
        return zone.terrain === 'mountain' || zone.terrain === 'forest';
      });
      
      // Prioritize defending favorable terrain
      favorableZones.forEach(zone => {
        if (zone.control === 'blue') {
          // Strengthen defensive positions
          logMessage(`${gameConfig.player2.name} (AI) reinforcing defensive position in ${zone.terrain} terrain`, 'strategy');
        }
      });
    }

    function executeUnitSpecialization() {
      console.log('AI specializing unit roles');
      
      const aiUnits = getAllAIUnits();
      
      aiUnits.forEach(unit => {
        // Assign specialized roles based on unit type
        switch (unit.type) {
          case 'Infantry':
            unit.role = 'line_combat';
            break;
          case 'Heavy':
            unit.role = 'heavy_assault';
            break;
          case 'Scout':
            unit.role = 'reconnaissance';
            break;
          case 'Support':
            unit.role = 'support_fire';
            break;
          case 'Elite':
            unit.role = 'leadership';
            break;
          case 'Field Gun':
            unit.role = 'artillery_support';
            break;
          case 'Fighter':
            unit.role = 'air_superiority';
            break;
          case 'Bomber':
            unit.role = 'strategic_bombing';
            break;
        }
      });
    }

    function adaptToHumanStrategy() {
      console.log('AI adapting to human strategy');
      
      // Analyze human player patterns
      const humanPatterns = analyzeHumanPatterns();
      
      // Adjust AI strategy based on patterns
      if (humanPatterns.aggressive) {
        gameState.aiState.strategy = 'defensive_counter';
        logMessage(`${gameConfig.player2.name} (AI) adapting to aggressive human strategy`, 'strategy');
      } else if (humanPatterns.defensive) {
        gameState.aiState.strategy = 'aggressive_pressure';
        logMessage(`${gameConfig.player2.name} (AI) adapting to defensive human strategy`, 'strategy');
      } else {
        gameState.aiState.strategy = 'balanced_approach';
      }
    }

    // Helper functions for Phase 4
    function getAIAirUnits(unitType) {
      const aiPlayer = gameState.aiState.aiPlayer;
      const aiAerialUnits = gameState.aerial[aiPlayer] || [];
      
      console.log(`Getting AI air units for player: ${aiPlayer}`);
      console.log(`All AI aerial units:`, aiAerialUnits);
      console.log(`Looking for type: ${unitType}`);
      
      if (unitType) {
        const filteredUnits = aiAerialUnits.filter(unit => unit.type === unitType);
        console.log(`Filtered ${unitType} units:`, filteredUnits);
        return filteredUnits;
      }
      
      return aiAerialUnits;
    }

    function getHumanAirUnits(unitType) {
      const humanPlayer = gameState.aiState.aiPlayer === 'red' ? 'blue' : 'red';
      const humanAerialUnits = gameState.aerial[humanPlayer] || [];
      
      console.log(`Getting human air units for player: ${humanPlayer}`);
      console.log(`All human aerial units:`, humanAerialUnits);
      console.log(`Looking for type: ${unitType}`);
      
      if (unitType) {
        const filteredUnits = humanAerialUnits.filter(unit => unit.type === unitType);
        console.log(`Filtered ${unitType} units:`, filteredUnits);
        return filteredUnits;
      }
      
      return humanAerialUnits;
    }

    function getHumanUnitsInZone(zoneId) {
      const zone = zones.find(z => z.id === zoneId);
      if (!zone || !zone.tacticalGrid) return [];
      
      const humanUnits = [];
      
      Object.entries(zone.tacticalGrid).forEach(([pos, cell]) => {
        if (cell.unit && cell.unit.player === 'red') {
          // Check if unit should be hidden due to stealth
          const stealthAbilities = applySpecialAbilities(cell.unit, parseInt(pos), cell);
          const shouldHide = stealthAbilities.hidden;
          
          if (!shouldHide) {
            humanUnits.push(cell.unit);
          }
        }
      });
      
      return humanUnits;
    }

    function getAllAIUnits() {
      const aiUnits = [];
      
      zones.forEach(zone => {
        if (zone.tacticalGrid) {
          Object.values(zone.tacticalGrid).forEach(cell => {
            if (cell.unit && cell.unit.player === 'blue') {
              aiUnits.push(cell.unit);
            }
          });
        }
      });
      
      return aiUnits;
    }

    function getNearbyUnits(unit, range, player) {
      const nearbyUnits = [];
      const gridSize = gameConfig.gridSize;
      const unitPos = unit.position;
      const unitRow = Math.floor(unitPos / gridSize);
      const unitCol = unitPos % gridSize;
      
      for (let row = Math.max(0, unitRow - range); row <= Math.min(gridSize - 1, unitRow + range); row++) {
        for (let col = Math.max(0, unitCol - range); col <= Math.min(gridSize - 1, unitCol + range); col++) {
          const pos = row * gridSize + col;
          const cell = currentZoneDetail.tacticalGrid[pos];
          
          if (cell && cell.unit && cell.unit.player === player && cell.unit.id !== unit.id) {
            // Check if unit should be hidden due to stealth
            const stealthAbilities = applySpecialAbilities(cell.unit, pos, cell);
            const shouldHide = stealthAbilities.hidden;
            
            if (!shouldHide) {
            nearbyUnits.push(cell.unit);
            }
          }
        }
      }
      
      return nearbyUnits;
    }

    function analyzeBattlefieldState() {
      const aiUnits = getAllAIUnits();
      const humanUnits = getAllHumanUnits();
      
      const aiStrength = aiUnits.reduce((sum, unit) => sum + unit.attack + unit.defense, 0);
      const humanStrength = humanUnits.reduce((sum, unit) => sum + unit.attack + unit.defense, 0);
      
      const totalStrength = aiStrength + humanStrength;
      const aiAdvantage = totalStrength > 0 ? aiStrength / totalStrength : 0.5;
      
      return {
        aiAdvantage: aiAdvantage,
        aiStrength: aiStrength,
        humanStrength: humanStrength,
        aiUnitCount: aiUnits.length,
        humanUnitCount: humanUnits.length
      };
    }

    function getAllHumanUnits() {
      const humanUnits = [];
      
      zones.forEach(zone => {
        if (zone.tacticalGrid) {
          Object.entries(zone.tacticalGrid).forEach(([pos, cell]) => {
            if (cell.unit && cell.unit.player === 'red') {
              // Check if unit should be hidden due to stealth
              const stealthAbilities = applySpecialAbilities(cell.unit, parseInt(pos), cell);
              const shouldHide = stealthAbilities.hidden;
              
              if (!shouldHide) {
              humanUnits.push(cell.unit);
              }
            }
          });
        }
      });
      
      return humanUnits;
    }

    function analyzeHumanPatterns() {
      // Simple pattern analysis based on recent actions
      const patterns = {
        aggressive: false,
        defensive: false,
        balanced: true
      };
      
      // This would be expanded with actual pattern tracking
      // For now, return balanced pattern
      return patterns;
    }

    // ========================================
    // END PHASE 4: ADVANCED AI FEATURES
    // ========================================

    // ========================================
    // PHASE 5: MASTER AI FEATURES
    // ========================================

    // AI Learning & Adaptation System
    let aiLearningData = {
      gamesPlayed: 0,
      strategiesUsed: {},
      playerProfiles: {},
      successfulMoves: {},
      failedMoves: {},
      adaptationLevel: 0
    };

    // AI Personality System
    let aiPersonality = {
      type: 'balanced', // 'aggressive', 'defensive', 'balanced', 'deceptive'
      confidence: 0.5,
      aggression: 0.5,
      caution: 0.5,
      adaptability: 0.5,
      mood: 'neutral' // 'confident', 'cautious', 'frustrated', 'aggressive'
    };

    // Phase 5: Advanced Learning & Adaptation
    function executePhase5AI(aiDecisions) {
      console.log('=== PHASE 5: MASTER AI EXECUTION ===');
      
      // Update AI personality based on current situation
      updateAIPersonality();
      
      // Execute advanced strategic planning
      executeAdvancedStrategicPlanning(aiDecisions);
      
      // Execute psychological warfare
      executePsychologicalWarfare();
      
      // Execute precision tactics
      executePrecisionTactics(aiDecisions);
      
      // Learn from this turn
      learnFromTurn(aiDecisions);
    }

    function updateAIPersonality() {
      console.log('=== AI PERSONALITY UPDATE ===');
      
      const battlefieldState = analyzeBattlefieldState();
      const aiAdvantage = battlefieldState.aiAdvantage;
      
      // Update confidence based on advantage
      if (aiAdvantage > 0.7) {
        aiPersonality.confidence = Math.min(1.0, aiPersonality.confidence + 0.1);
        aiPersonality.mood = 'confident';
        console.log('AI becoming more confident due to advantage');
      } else if (aiAdvantage < 0.3) {
        aiPersonality.confidence = Math.max(0.0, aiPersonality.confidence - 0.1);
        aiPersonality.mood = 'cautious';
        console.log('AI becoming more cautious due to disadvantage');
      }
      
      // Update aggression based on personality type
      switch (aiPersonality.type) {
        case 'aggressive':
          aiPersonality.aggression = Math.min(1.0, aiPersonality.aggression + 0.05);
          break;
        case 'defensive':
          aiPersonality.caution = Math.min(1.0, aiPersonality.caution + 0.05);
          break;
        case 'deceptive':
          // Deceptive AI varies its behavior
          aiPersonality.aggression = 0.3 + Math.random() * 0.4;
          break;
      }
      
      // Update the personality display
      updateAIPersonalityDisplay();
      
      console.log('AI Personality:', aiPersonality);
    }

    function executeAdvancedStrategicPlanning(aiDecisions) {
      console.log('=== ADVANCED STRATEGIC PLANNING ===');
      
      // Multi-turn planning
      const strategicPlan = createAdvancedStrategicPlan();
      
      // Execute personality-based decisions
      executePersonalityBasedDecisions(aiDecisions);
      
      // Execute deception tactics
      if (aiPersonality.type === 'deceptive') {
        executeDeceptionTactics(aiDecisions);
      }
    }

    function createAdvancedStrategicPlan() {
      const plan = {
        immediate: [], // Next 1-2 turns
        shortTerm: [], // Next 3-5 turns
        mediumTerm: [], // Next 6-10 turns
        longTerm: [] // Next 10+ turns
      };
      
      const battlefieldState = analyzeBattlefieldState();
      
      // Plan based on personality and situation
      if (aiPersonality.type === 'aggressive' && aiPersonality.confidence > 0.6) {
        plan.immediate.push('all_out_offensive');
        plan.shortTerm.push('overwhelm_enemy');
        logMessage(`${gameConfig.player2.name} (AI) planning aggressive offensive`, 'strategy');
      } else if (aiPersonality.type === 'defensive' || aiPersonality.mood === 'cautious') {
        plan.immediate.push('defensive_consolidation');
        plan.shortTerm.push('counter_attack_preparation');
        logMessage(`${gameConfig.player2.name} (AI) planning defensive strategy`, 'strategy');
      } else {
        plan.immediate.push('balanced_approach');
        plan.shortTerm.push('opportunistic_offensive');
        logMessage(`${gameConfig.player2.name} (AI) planning balanced strategy`, 'strategy');
      }
      
      console.log('Advanced Strategic Plan:', plan);
      return plan;
    }

    function executePersonalityBasedDecisions(aiDecisions) {
      console.log('=== PERSONALITY-BASED DECISIONS ===');
      
      // Adjust CP allocation based on personality
      if (aiPersonality.type === 'aggressive') {
        aiDecisions.cpAllocation.attack = Math.min(aiDecisions.cpAllocation.attack + 1, 10);
        aiDecisions.cpAllocation.defense = Math.max(aiDecisions.cpAllocation.defense - 1, 0);
        logMessage(`${gameConfig.player2.name} (AI) aggressive personality increases attack allocation`, 'strategy');
      } else if (aiPersonality.type === 'defensive') {
        aiDecisions.cpAllocation.defense = Math.min(aiDecisions.cpAllocation.defense + 1, 10);
        aiDecisions.cpAllocation.attack = Math.max(aiDecisions.cpAllocation.attack - 1, 0);
        logMessage(`${gameConfig.player2.name} (AI) defensive personality increases defense allocation`, 'strategy');
      }
      
      // Adjust zone selection based on personality
      if (aiPersonality.type === 'aggressive' && aiDecisions.zonesToAttack.length > 0) {
        // Add more attack zones if aggressive
        const additionalAttackZones = selectAdditionalAttackZones();
        aiDecisions.zonesToAttack.push(...additionalAttackZones);
        logMessage(`${gameConfig.player2.name} (AI) aggressive personality selects additional attack zones`, 'strategy');
      }
    }

    function executeDeceptionTactics(aiDecisions) {
      console.log('=== DECEPTION TACTICS ===');
      
      // Create fake weaknesses
      if (Math.random() < 0.3) {
        const fakeWeakZone = selectFakeWeakZone();
        if (fakeWeakZone) {
          logMessage(`${gameConfig.player2.name} (AI) creates apparent weakness in Zone ${fakeWeakZone}`, 'strategy');
        }
      }
      
      // Baiting tactics
      if (Math.random() < 0.4) {
        const baitZone = selectBaitZone();
        if (baitZone) {
          logMessage(`${gameConfig.player2.name} (AI) sets up bait in Zone ${baitZone}`, 'strategy');
        }
      }
    }

    function executePsychologicalWarfare() {
      console.log('=== PSYCHOLOGICAL WARFARE ===');
      
      // Intimidation tactics
      if (aiPersonality.confidence > 0.7) {
        logMessage(`${gameConfig.player2.name} (AI) displays overwhelming confidence`, 'strategy');
      }
      
      // Pressure tactics
      if (aiPersonality.aggression > 0.6) {
        logMessage(`${gameConfig.player2.name} (AI) applies psychological pressure`, 'strategy');
      }
      
      // Unpredictable behavior
      if (aiPersonality.type === 'deceptive') {
        logMessage(`${gameConfig.player2.name} (AI) behaves unpredictably to confuse opponent`, 'strategy');
      }
    }

    function executePrecisionTactics(aiDecisions) {
      console.log('=== PRECISION TACTICS ===');
      
      // Perfect timing
      executePerfectTiming();
      
      // Micro-management
      executeMicroManagement();
      
      // Combined arms coordination
      executeCombinedArmsCoordination();
    }

    function executePerfectTiming() {
      console.log('AI executing perfect timing tactics');
      
      // Calculate optimal timing for each action
      const timing = calculateOptimalTiming();
      
      // Execute actions at perfect moments
      if (timing.artillery) {
        logMessage(`${gameConfig.player2.name} (AI) times artillery strike perfectly`, 'strategy');
      }
      
      if (timing.attack) {
        logMessage(`${gameConfig.player2.name} (AI) launches perfectly timed attack`, 'strategy');
      }
    }

    function executeMicroManagement() {
      console.log('AI executing micro-management');
      
      // Optimize every unit position
      const aiUnits = getAllAIUnits();
      aiUnits.forEach(unit => {
        const optimalPosition = calculateOptimalPosition(unit);
        if (optimalPosition && optimalPosition !== unit.position) {
          logMessage(`${gameConfig.player2.name} (AI) micro-manages ${unit.name} to optimal position`, 'strategy');
        }
      });
    }

    function executeCombinedArmsCoordination() {
      console.log('AI executing combined arms coordination');
      
      // Coordinate artillery with ground attacks
      if (Math.random() < 0.6) {
        logMessage(`${gameConfig.player2.name} (AI) coordinates artillery with ground assault`, 'strategy');
      }
      
      // Coordinate air support with ground operations
      if (Math.random() < 0.5) {
        logMessage(`${gameConfig.player2.name} (AI) coordinates air support with ground operations`, 'strategy');
      }
    }

    function learnFromTurn(aiDecisions) {
      console.log('=== AI LEARNING FROM TURN ===');
      
      // Record this turn's decisions
      aiLearningData.gamesPlayed++;
      
      // Learn from successful strategies
      if (aiDecisions.zonesToAttack.length > 0) {
        aiLearningData.strategiesUsed.attack = (aiLearningData.strategiesUsed.attack || 0) + 1;
      }
      
      if (aiDecisions.zonesToDefend.length > 0) {
        aiLearningData.strategiesUsed.defense = (aiLearningData.strategiesUsed.defense || 0) + 1;
      }
      
      // Adapt personality based on success
      adaptPersonalityBasedOnSuccess();
      
      console.log('AI Learning Data:', aiLearningData);
    }

    function adaptPersonalityBasedOnSuccess() {
      // Adapt based on recent performance
      if (aiLearningData.gamesPlayed > 5) {
        const attackSuccess = aiLearningData.strategiesUsed.attack || 0;
        const defenseSuccess = aiLearningData.strategiesUsed.defense || 0;
        
        if (attackSuccess > defenseSuccess) {
          aiPersonality.type = 'aggressive';
          aiPersonality.aggression = Math.min(1.0, aiPersonality.aggression + 0.1);
          console.log('AI adapting to aggressive personality due to attack success');
        } else if (defenseSuccess > attackSuccess) {
          aiPersonality.type = 'defensive';
          aiPersonality.caution = Math.min(1.0, aiPersonality.caution + 0.1);
          console.log('AI adapting to defensive personality due to defense success');
        }
      }
    }

    // Helper functions for Phase 5
    function selectAdditionalAttackZones() {
      const additionalZones = [];
      const neutralZones = zones.filter(zone => zone.control === 'neutral');
      
      // Select up to 2 additional neutral zones for attack
      neutralZones.slice(0, 2).forEach(zone => {
        additionalZones.push(zone.id);
      });
      
      return additionalZones;
    }

    function selectFakeWeakZone() {
      const aiControlledZones = zones.filter(zone => zone.control === 'blue');
      if (aiControlledZones.length > 0) {
        return aiControlledZones[Math.floor(Math.random() * aiControlledZones.length)].id;
      }
      return null;
    }

    function selectBaitZone() {
      const neutralZones = zones.filter(zone => zone.control === 'neutral');
      if (neutralZones.length > 0) {
        return neutralZones[Math.floor(Math.random() * neutralZones.length)].id;
      }
      return null;
    }

    function calculateOptimalTiming() {
      return {
        artillery: Math.random() < 0.7,
        attack: Math.random() < 0.8,
        defense: Math.random() < 0.6
      };
    }

    function calculateOptimalPosition(unit) {
      // Calculate the optimal position for a unit based on its role and situation
      const gridSize = gameConfig.gridSize;
      const currentPos = unit.position;
      const currentRow = Math.floor(currentPos / gridSize);
      
      // For now, return current position (can be enhanced with more complex logic)
      return currentPos;
    }

    // ========================================
    // END PHASE 5: MASTER AI FEATURES
    // ========================================

    function completeAITurn() {
      console.log('=== COMPLETING AI TURN ===');
      console.log('AI state before completion:', {
        aiThinking: gameState.aiState.aiThinking,
        isAITurn: gameState.aiState.isAITurn,
        currentPlayer: gameState.currentPlayer
      });
      
      try {
        gameState.aiState.aiThinking = false;
        hideAITurnIndicator();
        enablePlayerActions();
        
        console.log(' AI turn indicators and actions reset');
      } catch (error) {
        console.error(' Error resetting AI turn state:', error);
      }
      
      // End AI turn by directly switching to next player
      console.log('AI turn complete, switching to next player');
      gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
      gameState.turnCount++;
      
      // Clear zone log for new player's turn
      clearZoneLogOnNewTurn();
      
      // Update player color CSS
      console.log(' [COLOR DEBUG] Turn switch - About to call updatePlayerColorCSS');
      updatePlayerColorCSS();
      console.log(' [COLOR DEBUG] Turn switch - updatePlayerColorCSS called');
      
      // Update zone CP bonuses
      updateZoneCPBonuses();
      
      // Calculate and set CP for new player
      const newCP = calculateTurnStartCP();
      gameState.commandPoints[gameState.currentPlayer] = newCP;
      
      // Reset turn state
      gameState.selectedDice = { attack: 0, defend: 0, morale: 0 };
      gameState.diceAugmented = false;
      gameState.gamePhase = 'selection';
      
      // Reset artillery and aerial usage for the new player
      resetArtilleryUsage();
      resetAerialUsage();
      
      // Clear locked zones for new player
      gameState.lockedZones = { red: [], blue: [] };
      
      const currentPlayerName = gameState.currentPlayer === 'red' ? 
        gameConfig.player1.name : gameConfig.player2.name;
      
      // Log CP bonuses
      const contestedBonus = gameState.contestedZones[gameState.currentPlayer].length;
      const controlledBonus = gameState.controlledZones[gameState.currentPlayer].length * 2;
      
      logMessage(`Turn ${gameState.turnCount}: ${currentPlayerName}'s turn begins`, 'system');
      if (contestedBonus > 0) {
        logMessage(`${currentPlayerName} gains +${contestedBonus} CP for contesting ${contestedBonus} zone(s)`, 'system');
      }
      if (controlledBonus > 0) {
        logMessage(`${currentPlayerName} gains +${controlledBonus} CP for controlling ${controlledBonus/2} zone(s)`, 'system');
      }
      logMessage(`${currentPlayerName} starts with ${newCP} Command Points`, 'system');
      
      // Reset AI state
      gameState.aiState.isAITurn = false;
      console.log('AI turn completed - AI state reset');
      console.log('AI isAITurn:', gameState.aiState.isAITurn);
      console.log('AI aiThinking:', gameState.aiState.aiThinking);
      
      renderBattlefield();
    }
    
    // Initialize on page load
    window.addEventListener('load', function() {
      setupOpponentToggle();
      
      // Setup army name input listener
      const armyNameInput = document.getElementById('army-name');
      if (armyNameInput) {
        armyNameInput.addEventListener('input', updateSaveButton);
      }
      
      // Initialize selected armies arrays if they don't exist
      if (!gameData.selectedArmies.player1) {
        gameData.selectedArmies.player1 = [];
      }
      if (!gameData.selectedArmies.player2) {
        gameData.selectedArmies.player2 = [];
      }
      
      // Initialize default armies
      updateSelectedArmiesList('player1');
      updateSelectedArmiesList('player2');
    });

    // === Multiplayer Lobby & Socket.IO Logic ===
let socket = null;
let lobbyCode = null;
let lobbyPlayers = [];
let isReady = false;
let myPlayerId = null;

// Global multiplayer flags
let isInGameSetup = false; // ensure defined before any usage

function createLobby() {
  console.log('createLobby function called');
  const name = document.getElementById('display-name').value.trim();
  console.log('Display name:', name);
  if (!name) { alert('Enter your display name'); return; }
  
  // Set multiplayer mode to true before creating connection
  isMultiplayerMode = true;
  console.log(' Set isMultiplayerMode = true for lobby creation');
  
  console.log('Creating Socket.IO connection...');
  // Connect to current server (Render)
  socket = io();
  
  socket.on('connect', () => {
    console.log('Socket connected, emitting createLobby');
    socket.emit('createLobby', { name });
  });
  
  socket.on('connect_error', (error) => {
    console.error('Socket connection error:', error);
    alert('Connection error: ' + error.message);
  });
  
  setupSocketHandlers();
}

function joinLobby() {
  console.log('joinLobby function called');
  const code = document.getElementById('lobby-code').value.trim();
  const name = document.getElementById('display-name').value.trim();
  console.log('Lobby code:', code, 'Display name:', name);
  if (!code || !name) { alert('Enter lobby code and display name'); return; }
  
  // Set multiplayer mode to true before creating connection
  isMultiplayerMode = true;
  console.log(' Set isMultiplayerMode = true for lobby joining');
  
  console.log('Creating Socket.IO connection...');
  // Connect to current server (Render)
  socket = io();
  
  socket.on('connect', () => {
    console.log('Socket connected, emitting joinLobby');
    socket.emit('joinLobby', { lobbyCode: code, name });
  });
  
  socket.on('connect_error', (error) => {
    console.error('Socket connection error:', error);
    alert('Connection error: ' + error.message);
  });
  
  setupSocketHandlers();
}

function leaveLobby() {
  if (socket) {
    socket.emit('leaveLobby');
    socket.disconnect();
    socket = null;
  }
  lobbyCode = null;
  lobbyPlayers = [];
  isReady = false;
  myPlayerId = null;
  
  // Use enhanced UI update instead of direct style manipulation
  updateLobbyUI();
  
  // Only show multiplayer screen if we're still in multiplayer mode
  if (isMultiplayerMode) {
    showScreen('multiplayer');
  }
}

function toggleReady() {
  // Prevent lobby ready system from interfering with game setup
  if (isInGameSetup) {
    console.log(' Lobby ready system blocked - currently in game setup mode');
    return;
  }
  
  if (socket) {
    isReady = !isReady;
    socket.emit('playerReady', { ready: isReady });
    updateReadyButton();
  }
}

function updateReadyButton() {
  const btn = document.getElementById('ready-button');
  if (btn) {
    // Use enhanced UI update
    updateReadyButtonUI(isReady);
  }
}

function updateLobbyUI() {
  // Show/hide lobby sections using enhanced UI
  const lobbyActionsSection = document.getElementById('lobby-actions-section');
  const currentLobbySection = document.getElementById('current-lobby-section');
  
  if (lobbyCode) {
    // In lobby - show current lobby section
    if (lobbyActionsSection) lobbyActionsSection.style.display = 'none';
    if (currentLobbySection) currentLobbySection.style.display = 'block';
  } else {
    // Not in lobby - show lobby actions section
    if (lobbyActionsSection) lobbyActionsSection.style.display = 'block';
    if (currentLobbySection) currentLobbySection.style.display = 'none';
  }
  
  // Update lobby code
  const lobbyCodeDisplay = document.getElementById('lobby-code-display');
  if (lobbyCodeDisplay) {
    lobbyCodeDisplay.textContent = lobbyCode || '------';
  }
  
  // Update player list with enhanced UI
  updatePlayerListUI(lobbyPlayers);
  
  // Update ready button
  updateReadyButton();
  
  // Update waiting message with enhanced UI
  let message = '';
  if (lobbyPlayers.length < 2) {
    message = 'Waiting for allied forces to join the operation...';
    const readyButton = document.getElementById('ready-button');
    if (readyButton) readyButton.disabled = false;
  } else {
    const allReady = lobbyPlayers.length === 2 && lobbyPlayers.every(p => p.ready);
    message = allReady ? 'Both commanders ready! Initiating battle sequence...' : 'Waiting for both commanders to ready up...';
    const readyButton = document.getElementById('ready-button');
    if (readyButton) readyButton.disabled = false;
  }
  updateWaitingMessageUI(message);
}

function setupSocketHandlers() {
  if (!socket) return;
  console.log('Setting up socket handlers');
  
  socket.on('lobbyCreated', (lobby) => {
    console.log('lobbyCreated event received:', lobby);
    // Only navigate to multiplayer screen if we're not trying to return to main menu
    if (isMultiplayerMode) {
      lobbyCode = lobby.id;
      lobbyPlayers = lobby.players;
      myPlayerId = lobby.myId;
      isReady = false;
      updateLobbyUI();
      showScreen('multiplayer');
    }
  });
  socket.on('lobbyJoined', (lobby) => {
    console.log('lobbyJoined event received:', lobby);
    // Only navigate to multiplayer screen if we're not trying to return to main menu
    if (isMultiplayerMode) {
      lobbyCode = lobby.id;
      lobbyPlayers = lobby.players;
      myPlayerId = lobby.myId;
      isReady = false;
      updateLobbyUI();
      showScreen('multiplayer');
    }
  });
  socket.on('lobbyUpdate', (lobby) => {
    lobbyCode = lobby.id;
    lobbyPlayers = lobby.players;
    updateLobbyUI();
  });
  socket.on('playerReady', (data) => {
    // Prevent lobby ready updates when in game setup mode
    if (isInGameSetup) {
      console.log(' Lobby playerReady event blocked - currently in game setup mode');
      return;
    }
    
    lobbyPlayers = data.players;
    updateLobbyUI();
  });
  socket.on('startGame', (gameData) => {
    console.log('startGame event received:', gameData);
    
    // Prevent multiple game setup initializations
    if (isInGameSetup) {
      console.log(' startGame event blocked - already in game setup mode');
      return;
    }
    
    // Setup multiplayer game setup screen
    setupMultiplayerGameSetup(gameData);
    // Transition to multiplayer game setup screen
    showScreen('multiplayer-game-setup');
  });
  
  socket.on('playerArmySelected', (data) => {
    console.log(' ===== PLAYER ARMY SELECTED EVENT RECEIVED =====');
    console.log(' Received data:', data);
    
    // Update local army selections
    const { playerId, armyId, armySelections, action, armyData } = data;
    
          console.log(' Parsed data:');
      console.log('  - playerId:', playerId);
      console.log('  - armyId:', armyId);
      console.log('  - armySelections:', armySelections);
      console.log('  - action:', action);
      console.log('  - armyData:', armyData);
    
    // Update gameData with server data using actual player IDs
    if (armySelections) {
      const player1Id = multiplayerGameData?.players[0]?.id;
      const player2Id = multiplayerGameData?.players[1]?.id;
      
      console.log(' Player IDs:');
      console.log('  - player1Id:', player1Id);
      console.log('  - player2Id:', player2Id);
      
      // First, let's log what armies we're trying to find
      console.log(' Army IDs to find:');
      console.log('  - Player 1 armies:', armySelections.player1);
      console.log('  - Player 2 armies:', armySelections.player2);
      
      // Initialize shared armies if not exists
      if (!gameData.sharedArmies) {
        gameData.sharedArmies = {};
      }
      
      // Store shared army data if provided
      if (armyData && armyId) {
        console.log(' Storing shared army data for ID:', armyId);
        gameData.sharedArmies[armyId] = armyData;
      }
      
      if (armySelections.player1 && player1Id) {
        console.log(' Updating player1 armies:', armySelections.player1);
        gameData.selectedArmies[player1Id] = armySelections.player1.map(id => getArmyById(id));
      }
      if (armySelections.player2 && player2Id) {
        console.log(' Updating player2 armies:', armySelections.player2);
        gameData.selectedArmies[player2Id] = armySelections.player2.map(id => getArmyById(id));
      }
      
      console.log(' Updated gameData.selectedArmies:', gameData.selectedArmies);
    }
    
    // Update UI displays using the correct element IDs (mp-player1, mp-player2)
    updateSelectedArmiesListMP('mp-player1');
    updateSelectedArmiesListMP('mp-player2');
    
    console.log(' Calling updateOpponentArmiesDisplay for player:', myPlayerId);
    console.log(' Data being passed to updateOpponentArmiesDisplay:', data);
    updateOpponentArmiesDisplay(data);
    
    console.log(` Army ${action || 'added'} by ${playerId}, updated displays`);
    console.log(' ===== PLAYER ARMY SELECTED EVENT COMPLETED =====');
  });
  
  socket.on('armySelectionStatusUpdate', (data) => {
    console.log(' ===== ARMY SELECTION STATUS UPDATE =====');
    console.log(' Received data:', data);
    const { playerId, armySelected, selectionStatus } = data;
    
    if (playerId && armySelected !== undefined) {
      // Update individual player army selection status
      console.log(' Updating individual player army selection status');
      console.log('Player ID:', playerId, 'Army Selected:', armySelected);
      armySelectionStatus[playerId] = armySelected;
    } else if (selectionStatus) {
      // Update all army selection statuses - convert from player1/player2 to actual IDs
      console.log(' Updating all army selection statuses');
      console.log('Selection status from server:', selectionStatus);
      
      // Get actual player IDs from multiplayer game data
      const player1Id = multiplayerGameData?.players[0]?.id;
      const player2Id = multiplayerGameData?.players[1]?.id;
      
      // Map the selection status to actual player IDs
      armySelectionStatus = {
        [player1Id]: selectionStatus.player1 || false,
        [player2Id]: selectionStatus.player2 || false
      };
      
      console.log('Mapped to actual player IDs:', armySelectionStatus);
    }
    
    console.log(' Current armySelectionStatus:', armySelectionStatus);
    
    // Update start button if host
    if (playerRole === 'host') {
      updateStartButtonStatus();
    }
    console.log(' ===== ARMY SELECTION STATUS UPDATE COMPLETED =====');
  });
  
  socket.on('multiplayerGameStarted', (data) => {
    console.log('multiplayerGameStarted event received:', data);
    // Initialize game with multiplayer configuration
    initializeMultiplayerGame(data);
    
    // Set up real-time synchronization for multiplayer
    setupMultiplayerSync();
  });
  

  

  socket.on('lobbyError', (msg) => {
    alert(msg);
    leaveLobby();
  });
  socket.on('disconnect', () => {
    leaveLobby();
  });
  
  // Listen for player name and color updates from other players
  socket.on('playerNameColorUpdate', (data) => {
    console.log(' ===== PLAYER NAME/COLOR UPDATE RECEIVED =====');
    console.log(' Received update data:', data);
    
    const { field, value, updatedBy } = data;
    
    // Only update if the change was made by the other player
    if (updatedBy !== myPlayerId) {
      console.log(' Updating field:', field, 'to value:', value);
      
      const inputElement = document.getElementById(`mp-${field}`);
      if (inputElement) {
        inputElement.value = value;
        console.log(' Updated input element:', field);
      } else {
        console.error(' Input element not found:', field);
      }
    } else {
      console.log(' Ignoring update from self');
    }
    
    console.log(' ===== PLAYER NAME/COLOR UPDATE COMPLETED =====');
  });
}

function copyLobbyCode() {
  if (lobbyCode) {
    navigator.clipboard.writeText(lobbyCode).then(() => {
      // Enhanced visual feedback
      const copyButton = document.querySelector('.copy-button');
      const originalText = copyButton.textContent;
      copyButton.textContent = 'Copied!';
      copyButton.style.background = 'linear-gradient(135deg, rgba(20, 80, 20, 0.95) 0%, rgba(15, 60, 15, 0.98) 100%)';
      
      setTimeout(() => {
        copyButton.textContent = originalText;
        copyButton.style.background = '';
      }, 2000);
      
      console.log('Lobby code copied to clipboard:', lobbyCode);
    }).catch(() => {
      console.log('Failed to copy lobby code');
    });
  }
}

// === Enhanced Multiplayer UI Functionality ===

// Initialize enhanced multiplayer UI effects
function initializeMultiplayerUI() {
  console.log(' Initializing enhanced multiplayer UI...');
  
  // Input formatting and validation for lobby code
  const lobbyCodeInput = document.getElementById('lobby-code');
  if (lobbyCodeInput) {
    lobbyCodeInput.addEventListener('input', function(e) {
      // Format as numeric only
      let value = e.target.value.replace(/[^0-9]/g, '');
      if (value.length > 6) value = value.slice(0, 6);
      e.target.value = value;
    });
  }
  
  // Enhanced visual feedback for inputs
  const inputs = document.querySelectorAll('.form-input');
  inputs.forEach(input => {
    input.addEventListener('focus', function() {
      this.style.transform = 'translateY(-2px)';
    });
    
    input.addEventListener('blur', function() {
      this.style.transform = 'translateY(0)';
    });
  });
  
  // Button press effects
  const buttons = document.querySelectorAll('.action-button, .copy-button, .back-button');
  buttons.forEach(button => {
    button.addEventListener('mousedown', function() {
      this.style.transform = 'translateY(1px) scale(0.98)';
    });
    
    button.addEventListener('mouseup', function() {
      this.style.transform = '';
    });
    
    button.addEventListener('mouseleave', function() {
      this.style.transform = '';
    });
  });
  
  console.log(' Enhanced multiplayer UI initialized');
}

// Enhanced ready button functionality
function updateReadyButtonUI(isReady) {
  const readyButton = document.getElementById('ready-button');
  if (readyButton) {
    if (isReady) {
      readyButton.classList.add('ready-state');
      readyButton.innerHTML = '<span>Ready for Battle</span>';
    } else {
      readyButton.classList.remove('ready-state');
      readyButton.innerHTML = '<span>Ready for Battle</span>';
    }
  }
}

// Enhanced player list updates
function updatePlayerListUI(players) {
  const playerList = document.getElementById('lobby-player-list');
  if (playerList) {
    playerList.innerHTML = '';
    
    players.forEach(player => {
      const playerItem = document.createElement('li');
      playerItem.className = 'player-item';
      
      const playerName = document.createElement('span');
      playerName.className = 'player-name';
      playerName.textContent = player.name;
      
      const playerStatus = document.createElement('span');
      playerStatus.className = `player-status ${player.ready ? 'ready' : 'not-ready'}`;
      playerStatus.textContent = player.ready ? 'Ready' : 'Not Ready';
      
      playerItem.appendChild(playerName);
      playerItem.appendChild(playerStatus);
      playerList.appendChild(playerItem);
    });
  }
}

// Enhanced waiting message updates
function updateWaitingMessageUI(message) {
  const waitingMessage = document.getElementById('lobby-waiting-message');
  if (waitingMessage) {
    waitingMessage.textContent = message;
  }
}

// Initialize UI when document is ready
document.addEventListener('DOMContentLoaded', function() {
  initializeMultiplayerUI();
  initializeMultiplayerAtmosphericEffects();
});

// Initialize atmospheric effects for multiplayer screen
function initializeMultiplayerAtmosphericEffects() {
  console.log(' Initializing multiplayer atmospheric effects...');
  
  // Initialize smoke system
  const smokeSystem = document.getElementById('mpSmokeSystem');
  if (smokeSystem) {
    // Create smoke particles
    for (let i = 0; i < 15; i++) {
      setTimeout(() => {
        createMultiplayerSmokeParticle(smokeSystem);
      }, i * 200);
    }
  }
  
  console.log(' Multiplayer atmospheric effects initialized');
}

// Create individual smoke particles for multiplayer
function createMultiplayerSmokeParticle(container) {
  if (!container) {
    console.warn('createMultiplayerSmokeParticle called without container');
    return;
  }
  
  const particle = document.createElement('div');
  particle.style.cssText = `
    position: absolute;
    width: ${Math.random() * 3 + 2}px;
    height: ${Math.random() * 3 + 2}px;
    background: rgba(180, 180, 180, ${Math.random() * 0.1 + 0.05});
    border-radius: 50%;
    left: ${Math.random() * 100}%;
    bottom: -10px;
    animation: smokeRise ${Math.random() * 10 + 15}s linear infinite;
    pointer-events: none;
  `;
  
  container.appendChild(particle);
  
  // Remove particle after animation
  setTimeout(() => {
    if (particle.parentNode) {
      particle.parentNode.removeChild(particle);
    }
  }, 20000);
}

// Add smoke rise animation
const style = document.createElement('style');
style.textContent = `
  @keyframes smokeRise {
    0% {
      transform: translateY(0) scale(1);
      opacity: 0.8;
    }
    50% {
      transform: translateY(-50vh) scale(1.5);
      opacity: 0.4;
    }
    100% {
      transform: translateY(-100vh) scale(2);
      opacity: 0;
    }
  }
`;
document.head.appendChild(style);

// === Multiplayer Game Setup Logic ===
let isMultiplayerMode = false;
let playerRole = null; // 'host' or 'guest'
let multiplayerGameData = null;
let armySelectionStatus = {}; // Track army selection status for each player
// isInGameSetup is declared earlier near lobby creation functions to avoid temporal dead zone

function setupMultiplayerGameSetup(gameData) {
  console.log('Setting up multiplayer game setup:', gameData);
  isMultiplayerMode = true;
  isInGameSetup = true; // Set flag to prevent lobby ready interference
  multiplayerGameData = gameData;
  
  // Determine player role (first player in lobby is host)
  const myPlayer = gameData.players.find(p => p.id === myPlayerId);
  const isHost = gameData.players.indexOf(myPlayer) === 0;
  playerRole = isHost ? 'host' : 'guest';
  
  console.log('Player role:', playerRole, 'My player ID:', myPlayerId);
  
  // Pre-fill player names from lobby
  if (gameData.players.length >= 1) {
    document.getElementById('mp-player1-name').value = gameData.players[0].name;
  }
  if (gameData.players.length >= 2) {
    document.getElementById('mp-player2-name').value = gameData.players[1].name;
  }
  
  // Show multiplayer status
  document.getElementById('player-role-display').textContent = 
    playerRole === 'host' ? 'You are Player 1 (Host)' : 'You are Player 2 (Guest)';
  
  // Show/hide sections based on player role
  if (playerRole === 'host') {
    // Host can see game configuration and their own armies
    document.getElementById('mp-game-config-section').style.display = 'block';
    document.getElementById('mp-player1-armies-section').style.display = 'block';
    document.getElementById('mp-player2-armies-section').style.display = 'none';
    document.getElementById('mp-opponent-armies-section').style.display = 'block';
  } else {
    // Guest can only see their own armies
    document.getElementById('mp-game-config-section').style.display = 'none';
    document.getElementById('mp-player1-armies-section').style.display = 'none';
    document.getElementById('mp-player2-armies-section').style.display = 'block';
    document.getElementById('mp-opponent-armies-section').style.display = 'block';
  }
  
  // Initialize waiting messages
  updateWaitingMessages();
  
  // Update start button text
  const startBtn = document.getElementById('mp-start-game-btn');
  if (playerRole === 'host') {
    startBtn.textContent = 'Start Battle (Waiting for both players to be ready)';
    startBtn.disabled = true;
  } else {
    startBtn.textContent = 'Waiting for Host...';
    startBtn.disabled = true;
  }
  
  // Initialize army selection system
  console.log(' Initializing army selection system...');
  armySelectionStatus = { player1: false, player2: false };
  
  console.log(' Initial armySelectionStatus:', armySelectionStatus);
  
  // Request current army selection status from server
  if (socket) {
    console.log(' Requesting army selection status from server...');
    socket.emit('requestArmySelectionStatus', { lobbyCode: lobbyCode });
    
    // Notify server that we're entering game setup mode
    console.log(' Notifying server of game setup mode...');
    socket.emit('enterGameSetup', { lobbyCode: lobbyCode });
  } else {
    console.error(' No socket available for army selection status request');
  }
  
  // Initialize start button status
  console.log(' Initializing start button status...');
  if (playerRole === 'host') {
    updateStartButtonStatus();
  }
  
  // Load army options into dropdowns
  loadMultiplayerArmyOptions();
  
  // Reset the setup screen to ensure clean state
  resetMultiplayerGameSetup();

  // Initialize custom dropdowns used in multiplayer setup
  // Initialize custom dropdowns for multiplayer (reuse same initializer)
  if (typeof initializeGameSetupDropdowns === 'function') {
    console.log(' Initializing multiplayer dropdowns via initializeGameSetupDropdowns');
    initializeGameSetupDropdowns();
  }

  // Always ensure MP-specific dropdowns are initialized
  {
    console.warn(' initializeGameSetupDropdowns not available for MP - using local init');
    // Minimal local initializer for MP dropdowns
    const mpDropdowns = [
      { id: 'mpWinConditionDropdown', selectedId: 'mpWinConditionSelected', optionsId: 'mpWinConditionOptions' },
      { id: 'mpTerrainDropdown', selectedId: 'mpTerrainSelected', optionsId: 'mpTerrainOptions' },
      { id: 'mpDayNightDropdown', selectedId: 'mpDayNightSelected', optionsId: 'mpDayNightOptions' },
      { id: 'mpWeatherDropdown', selectedId: 'mpWeatherSelected', optionsId: 'mpWeatherOptions' }
    ];
    mpDropdowns.forEach(cfg => {
      const dropdown = document.getElementById(cfg.id);
      const selected = document.getElementById(cfg.selectedId);
      const options = document.getElementById(cfg.optionsId);
      if (!dropdown || !selected || !options) {
        console.error(' MP dropdown elements not found for', cfg.id);
        return;
      }
      dropdown.addEventListener('click', function(e){
        if (e.target.classList.contains('dropdown-selected') || e.target.classList.contains('dropdown-arrow')) {
          dropdown.classList.toggle('open');
          options.classList.toggle('open');
        }
      });
      options.querySelectorAll('.dropdown-option').forEach(opt => {
        opt.addEventListener('click', function(){
          options.querySelectorAll('.dropdown-option').forEach(o => o.classList.remove('selected'));
          this.classList.add('selected');
          selected.textContent = this.textContent;
          dropdown.classList.remove('open');
          options.classList.remove('open');
        });
      });
      document.addEventListener('click', function(e){
        if (!dropdown.contains(e.target)) {
          dropdown.classList.remove('open');
          options.classList.remove('open');
        }
      });
      console.log(' MP dropdown initialized (local or ensured):', cfg.id);
    });
  }

  // Initialize army custom dropdowns in MP
  (function initMpArmyDropdowns(){
    const configs = [
      { id: 'mpPlayer1ArmyDropdown', selectedId: 'mpPlayer1ArmySelected', optionsId: 'mpPlayer1ArmyOptions' },
      { id: 'mpPlayer2ArmyDropdown', selectedId: 'mpPlayer2ArmySelected', optionsId: 'mpPlayer2ArmyOptions' }
    ];
    configs.forEach(cfg => {
      const dropdown = document.getElementById(cfg.id);
      const selected = document.getElementById(cfg.selectedId);
      const options = document.getElementById(cfg.optionsId);
      if (!dropdown || !selected || !options) return;
      dropdown.addEventListener('click', function(e){
        if (e.target.classList.contains('dropdown-selected') || e.target.classList.contains('dropdown-arrow')) {
          dropdown.classList.toggle('open');
          options.classList.toggle('open');
        }
      });
      options.querySelectorAll('.dropdown-option').forEach(opt => {
        opt.addEventListener('click', function(){
          options.querySelectorAll('.dropdown-option').forEach(o => o.classList.remove('selected'));
          this.classList.add('selected');
          selected.textContent = this.textContent;
          dropdown.classList.remove('open');
          options.classList.remove('open');
        });
      });
      document.addEventListener('click', function(e){
        if (!dropdown.contains(e.target)) {
          dropdown.classList.remove('open');
          options.classList.remove('open');
        }
      });
    });
  })();
}

// Reset singleplayer build points to default values
function resetSingleplayerBuildPoints() {
  console.log(' Resetting singleplayer build points to default values...');
  
  // Reset Player 1 Build Points
  const player1BuildPoints = document.getElementById('player1-build-points');
  const player1BuildPointsDisplay = document.getElementById('player1-build-points-display');
  if (player1BuildPoints && player1BuildPointsDisplay) {
    player1BuildPoints.value = 10;
    player1BuildPointsDisplay.textContent = '10';
  }
  
  // Reset Player 2 Build Points
  const player2BuildPoints = document.getElementById('player2-build-points');
  const player2BuildPointsDisplay = document.getElementById('player2-build-points-display');
  if (player2BuildPoints && player2BuildPointsDisplay) {
    player2BuildPoints.value = 10;
    player2BuildPointsDisplay.textContent = '10';
  }
  
  console.log(' Singleplayer build points reset complete');
}

// Reset multiplayer game setup screen
function resetMultiplayerGameSetup() {
  console.log(' Resetting multiplayer game setup screen...');
  
  // Clear local army selections
  gameData.selectedArmies = { player1: [], player2: [] };
  armySelectionStatus = { player1: false, player2: false };
  
  // Clear server-side army selections
  if (socket && socket.connected && lobbyCode) {
    console.log(' Clearing server-side army selections...');
    socket.emit('clearArmySelections', { lobbyCode: lobbyCode });
  }
  
  // Reset UI displays
  updateSelectedArmiesListMP('mp-player1');
  updateSelectedArmiesListMP('mp-player2');
  
  // Clear opponent armies display directly
  const opponentDisplay = document.getElementById('mp-opponent-armies-display');
  if (opponentDisplay && multiplayerGameData) {
    const opponent = multiplayerGameData.players.find(p => p.id !== myPlayerId);
    opponentDisplay.textContent = `${opponent?.name || 'Opponent'} has not selected any armies yet...`;
  }
  
  // Reset army selection dropdowns
  const player1Select = document.getElementById('mp-player1-army-select');
  const player2Select = document.getElementById('mp-player2-army-select');
  if (player1Select) player1Select.value = '';
  if (player2Select) player2Select.value = '';
  
  // Reset multiplayer build point sliders to default values
  const mpPlayer1BuildPoints = document.getElementById('mp-player1-build-points');
  const mpPlayer1BuildPointsDisplay = document.getElementById('mp-player1-build-points-display');
  if (mpPlayer1BuildPoints && mpPlayer1BuildPointsDisplay) {
    mpPlayer1BuildPoints.value = 10;
    mpPlayer1BuildPointsDisplay.textContent = '10';
  }
  
  const mpPlayer2BuildPoints = document.getElementById('mp-player2-build-points');
  const mpPlayer2BuildPointsDisplay = document.getElementById('mp-player2-build-points-display');
  if (mpPlayer2BuildPoints && mpPlayer2BuildPointsDisplay) {
    mpPlayer2BuildPoints.value = 10;
    mpPlayer2BuildPointsDisplay.textContent = '10';
  }
  
  // Shared Build Points slider removed; no reset needed
  
  // Update start button status
  if (playerRole === 'host') {
    updateStartButtonStatus();
  }
  
  console.log(' Multiplayer game setup screen reset complete');
}

// Apply name and color input restrictions based on current player role
function applyNameColorRestrictions() {
  console.log(' Applying name and color restrictions...');
  
  // Only apply restrictions if we're on the multiplayer game setup screen
  const multiplayerGameSetupScreen = document.getElementById('multiplayer-game-setup');
  if (!multiplayerGameSetupScreen || !multiplayerGameSetupScreen.classList.contains('active')) {
    console.log(' Not on multiplayer game setup screen, skipping restrictions');
    return;
  }
  
  const currentPlayerRole = getCurrentPlayerRole();
  console.log('Current player role:', currentPlayerRole);
  
  // Find all form groups within the multiplayer game setup screen
  const allFormGroups = document.querySelectorAll('#multiplayer-game-setup .form-group');
  console.log(' Found form groups:', allFormGroups.length);
  
  let player1NameGroup, player1ColorGroup, player2NameGroup, player2ColorGroup;
  
  allFormGroups.forEach((group, index) => {
    const label = group.querySelector('label');
    if (label) {
      console.log(` Form group ${index}:`, label.textContent.trim());
      if (label.textContent.includes('Warlord 1 Name:') || label.textContent.includes('Player 1 Name:')) {
        player1NameGroup = group;
        console.log(' Found Player 1 Name group');
      } else if (label.textContent.includes('Warlord 1 Color:') || label.textContent.includes('Player 1 Color:')) {
        player1ColorGroup = group;
        console.log(' Found Player 1 Color group');
      } else if (label.textContent.includes('Warlord 2 Name:') || label.textContent.includes('Player 2 Name:')) {
        player2NameGroup = group;
        console.log(' Found Player 2 Name group');
      } else if (label.textContent.includes('Warlord 2 Color:') || label.textContent.includes('Player 2 Color:')) {
        player2ColorGroup = group;
        console.log(' Found Player 2 Color group');
      }
    }
  });
  
  console.log(' Groups found:', {
    player1NameGroup: !!player1NameGroup,
    player1ColorGroup: !!player1ColorGroup,
    player2NameGroup: !!player2NameGroup,
    player2ColorGroup: !!player2ColorGroup
  });
  
  // Reset all containers to visible first
  [player1NameGroup, player1ColorGroup, player2NameGroup, player2ColorGroup].forEach(container => {
    if (container) {
      container.style.display = 'block';
    }
  });
  
  if (currentPlayerRole === 'player1') {
    // Player 1 can only see and edit their own name and color
    console.log('Player 1: Showing Player 1 inputs, hiding Player 2 inputs');
    
    if (player1NameGroup) {
      player1NameGroup.style.display = 'block';
    }
    
    if (player1ColorGroup) {
      player1ColorGroup.style.display = 'block';
    }
    
    if (player2NameGroup) {
      player2NameGroup.style.display = 'none';
    }
    
    if (player2ColorGroup) {
      player2ColorGroup.style.display = 'none';
    }
    
  } else if (currentPlayerRole === 'player2') {
    // Player 2 can only see and edit their own name and color
    console.log('Player 2: Showing Player 2 inputs, hiding Player 1 inputs');
    
    if (player1NameGroup) {
      player1NameGroup.style.display = 'none';
    }
    
    if (player1ColorGroup) {
      player1ColorGroup.style.display = 'none';
    }
    
    if (player2NameGroup) {
      player2NameGroup.style.display = 'block';
    }
    
    if (player2ColorGroup) {
      player2ColorGroup.style.display = 'block';
    }
    
  } else {
    // Fallback: if role is not determined, show all inputs
    console.log('No player role determined, showing all inputs');
    [player1NameGroup, player1ColorGroup, player2NameGroup, player2ColorGroup].forEach(container => {
      if (container) {
        container.style.display = 'block';
      }
    });
  }
  
  console.log(' Name and color restrictions applied');
}

// Setup event listeners for name and color input changes
function setupNameColorEventListeners() {
  console.log(' Setting up name and color event listeners...');
  
  // Only setup event listeners if we're on the multiplayer game setup screen
  const multiplayerGameSetupScreen = document.getElementById('multiplayer-game-setup');
  if (!multiplayerGameSetupScreen || !multiplayerGameSetupScreen.classList.contains('active')) {
    console.log(' Not on multiplayer game setup screen, skipping event listener setup');
    return;
  }
  
  const player1NameInput = document.getElementById('mp-player1-name');
  const player1ColorInput = document.getElementById('mp-player1-color-display');
  const player2NameInput = document.getElementById('mp-player2-name');
  const player2ColorInput = document.getElementById('mp-player2-color-display');
  
  // Player 1 name change
  if (player1NameInput) {
    player1NameInput.addEventListener('input', function() {
      if (socket && socket.connected && lobbyCode) {
        socket.emit('playerNameColorUpdate', {
          lobbyCode: lobbyCode,
          playerId: myPlayerId,
          field: 'player1Name',
          value: this.value
        });
      }
    });
  }
  
  // Player 1 color change - handled by custom color picker
  // The color will be updated when the custom picker applies the color
  
  // Player 2 name change
  if (player2NameInput) {
    player2NameInput.addEventListener('input', function() {
      if (socket && socket.connected && lobbyCode) {
        socket.emit('playerNameColorUpdate', {
          lobbyCode: lobbyCode,
          playerId: myPlayerId,
          field: 'player2Name',
          value: this.value
        });
      }
    });
  }
  
  // Player 2 color change - handled by custom color picker
  // The color will be updated when the custom picker applies the color
  
  console.log(' Name and color event listeners setup complete');
  
  // Setup CP slider event listeners
  const player1CpSlider = document.getElementById('mp-player1-cp');
  const player1CpDisplay = document.getElementById('mp-player1-cp-display');
  if (player1CpSlider && player1CpDisplay) {
    player1CpSlider.addEventListener('input', function() {
      player1CpDisplay.textContent = this.value;
    });
    console.log(' Player 1 CP slider event listener setup complete');
  }
  
  const player2CpSlider = document.getElementById('mp-player2-cp');
  const player2CpDisplay = document.getElementById('mp-player2-cp-display');
  if (player2CpSlider && player2CpDisplay) {
    player2CpSlider.addEventListener('input', function() {
      player2CpDisplay.textContent = this.value;
    });
    console.log(' Player 2 CP slider event listener setup complete');
  }
  
  // Shared Build Points slider removed; using per-player build points only
  
  // Setup Player 1 Build Points slider event listener
  const player1BuildPointsSlider = document.getElementById('mp-player1-build-points');
  const player1BuildPointsDisplay = document.getElementById('mp-player1-build-points-display');
  
  if (player1BuildPointsSlider && player1BuildPointsDisplay) {
    player1BuildPointsSlider.addEventListener('input', function() {
      player1BuildPointsDisplay.textContent = this.value;
    });
    console.log(' Player 1 Build Points slider event listener setup complete');
  }
  
  // Setup Player 2 Build Points slider event listener
  const player2BuildPointsSlider = document.getElementById('mp-player2-build-points');
  const player2BuildPointsDisplay = document.getElementById('mp-player2-build-points-display');
  
  if (player2BuildPointsSlider && player2BuildPointsDisplay) {
    player2BuildPointsSlider.addEventListener('input', function() {
      player2BuildPointsDisplay.textContent = this.value;
    });
    console.log(' Player 2 Build Points slider event listener setup complete');
  }
}

// Listen for player name and color updates from other players
// This will be set up in setupSocketHandlers() when socket is available

// Load army options into multiplayer dropdowns
function loadMultiplayerArmyOptions() {
  console.log('Loading army options for multiplayer...');
  console.log('gameData.savedArmies:', gameData.savedArmies);
  console.log('gameData.customUnits:', gameData.customUnits);
  
  // Get all available armies
  const availableArmies = [];
  
  // Add default army
  const defaultArmy = {
    id: 'default',
    name: 'Default Army',
    units: [...defaultUnits, ...gameData.customUnits]
  };
  availableArmies.push(defaultArmy);
  console.log('Default army:', defaultArmy);
  
  // Add custom armies
  if (gameData.savedArmies && gameData.savedArmies.length > 0) {
    gameData.savedArmies.forEach(army => {
      console.log('Adding custom army:', army);
      availableArmies.push(army);
    });
  }
  
  console.log('Available armies:', availableArmies);
  
  // Populate custom dropdowns for MP armies
  const p1Options = document.getElementById('mpPlayer1ArmyOptions');
  const p2Options = document.getElementById('mpPlayer2ArmyOptions');
  if (p1Options) {
    p1Options.innerHTML = '';
    const base = document.createElement('div');
    base.className = 'dropdown-option';
    base.dataset.value = '';
    base.textContent = 'Select Legion Type';
    p1Options.appendChild(base);
    availableArmies.forEach(army => {
      const opt = document.createElement('div');
      opt.className = 'dropdown-option';
      opt.dataset.value = army.id;
      opt.textContent = army.name;
      p1Options.appendChild(opt);
    });
    // default select base
    base.classList.add('selected');
    const p1Sel = document.getElementById('mpPlayer1ArmySelected');
    if (p1Sel) p1Sel.textContent = 'Select Legion Type';
  }
  if (p2Options) {
    p2Options.innerHTML = '';
    const base = document.createElement('div');
    base.className = 'dropdown-option';
    base.dataset.value = '';
    base.textContent = 'Select Legion Type';
    p2Options.appendChild(base);
    availableArmies.forEach(army => {
      const opt = document.createElement('div');
      opt.className = 'dropdown-option';
      opt.dataset.value = army.id;
      opt.textContent = army.name;
      p2Options.appendChild(opt);
    });
    base.classList.add('selected');
    const p2Sel = document.getElementById('mpPlayer2ArmySelected');
    if (p2Sel) p2Sel.textContent = 'Select Legion Type';
  }
}

// Army Selection System - Track when players have selected their armies
function updateArmySelectionStatus(playerId, armySelected) {
  console.log(' ===== ARMY SELECTION STATUS UPDATE =====');
  console.log(' Current state:');
  console.log('  - isMultiplayerMode:', isMultiplayerMode);
  console.log('  - socket exists:', !!socket);
  console.log('  - lobbyCode:', lobbyCode);
  console.log('  - playerId:', playerId);
  console.log('  - armySelected:', armySelected);
  console.log('  - armySelectionStatus (BEFORE):', armySelectionStatus);
  
  if (!isMultiplayerMode || !socket) {
    console.error(' Cannot update army selection - missing requirements');
    return;
  }
  
  // Update local army selection status
  armySelectionStatus[playerId] = armySelected;
  
  // Emit army selection status to server
  const selectionData = {
    lobbyCode: lobbyCode,
    playerId: playerId,
    armySelected: armySelected
  };
  console.log(' Emitting armySelectionStatus to server:', selectionData);
  socket.emit('armySelectionStatus', selectionData);
  
  // Update start button if host
  if (playerRole === 'host') {
    updateStartButtonStatus();
  }
  
  console.log(' ===== ARMY SELECTION STATUS UPDATE COMPLETED =====');
  console.log(' Final state:');
  console.log('  - armySelectionStatus (AFTER):', armySelectionStatus);
}

// Update start button based on army selection status
function updateStartButtonStatus() {
  console.log(' ===== UPDATE START BUTTON STATUS =====');
  const startBtn = document.getElementById('mp-start-game-btn');
  
  if (!startBtn) {
    console.error(' Start button not found!');
    return;
  }
  
  // Get the actual player IDs from the lobby
  const player1Id = multiplayerGameData?.players[0]?.id;
  const player2Id = multiplayerGameData?.players[1]?.id;
  
  console.log(' Player IDs from multiplayer game data:');
  console.log('  - Player 1 ID:', player1Id);
  console.log('  - Player 2 ID:', player2Id);
  console.log('  - Current armySelectionStatus:', armySelectionStatus);
  
  const player1Selected = armySelectionStatus[player1Id] || false;
  const player2Selected = armySelectionStatus[player2Id] || false;
  const bothSelected = player1Selected && player2Selected;
  
  console.log(' Army selection status:');
  console.log('  - Player 1 selected:', player1Selected);
  console.log('  - Player 2 selected:', player2Selected);
  console.log('  - Both selected:', bothSelected);
  
  if (bothSelected) {
    startBtn.textContent = 'Start Battle';
    startBtn.disabled = false;
    console.log(' Start button enabled');
  } else {
    startBtn.textContent = 'Start Battle (Waiting for both players to select armies)';
    startBtn.disabled = true;
    console.log(' Start button disabled');
  }
  
  console.log(' ===== UPDATE START BUTTON STATUS COMPLETED =====');
}

function startMultiplayerGame() {
  if (!isMultiplayerMode || !socket) return;
  
      // Collect game configuration
  const player1Id = multiplayerGameData?.players[0]?.id;
  const player2Id = multiplayerGameData?.players[1]?.id;
  
    const gameConfig = {
    player1: {
      name: document.getElementById('mp-player1-name').value,
      color: document.getElementById('mp-player1-color-display').style.getPropertyValue('--color-value') || '#DC143C',
      armies: gameData.selectedArmies[player1Id] || []
    },
    player2: {
      name: document.getElementById('mp-player2-name').value,
      color: document.getElementById('mp-player2-color-display').style.getPropertyValue('--color-value') || '#4169E1',
      armies: gameData.selectedArmies[player2Id] || []
    },
      gameSettings: {
      zoneCount: parseInt(document.getElementById('mp-zone-count').value),
      gridSize: parseInt(document.querySelector('#mp-game-config-section .grid-size-btn.active').dataset.size),
      winCondition: (function(){
        const opt = document.querySelector('#mpWinConditionOptions .dropdown-option.selected');
        return opt ? opt.dataset.value : 'dominance';
      })(),
      terrainType: (function(){
        const opt = document.querySelector('#mpTerrainOptions .dropdown-option.selected');
        return opt ? opt.dataset.value : 'random';
      })(),
      dayNightCycle: (function(){
        const opt = document.querySelector('#mpDayNightOptions .dropdown-option.selected') || document.querySelector('#dayNightOptions .dropdown-option.selected');
        return opt ? opt.dataset.value : 'day';
      })(),
      weatherType: (function(){
        const opt = document.querySelector('#mpWeatherOptions .dropdown-option.selected') || document.querySelector('#weatherOptions .dropdown-option.selected');
        return opt ? opt.dataset.value : 'clear';
      })(),
      player1CP: parseInt(document.getElementById('mp-player1-cp').value),
      player2CP: parseInt(document.getElementById('mp-player2-cp').value),
      player1BuildPoints: parseInt(document.getElementById('mp-player1-build-points').value),
      player2BuildPoints: parseInt(document.getElementById('mp-player2-build-points').value)
    }
  };
  
  console.log('Starting multiplayer game with config:', gameConfig);
  
  // Emit game start to server
  socket.emit('startMultiplayerGame', {
    lobbyCode: lobbyCode,
    gameConfig: gameConfig
  });
  
  // Transition to game screen
  showScreen('game');
}

// Handle army selection for multiplayer
function addArmyToPlayerMultiplayer(playerId) {
  // Map player1/player2 to actual player IDs
  let actualPlayerId = playerId;
  if (playerId === 'player1') {
    actualPlayerId = multiplayerGameData?.players[0]?.id;
  } else if (playerId === 'player2') {
    actualPlayerId = multiplayerGameData?.players[1]?.id;
  }
  
  const armySelect = document.getElementById(`mp-${playerId}-army-select`);
  // Support both native selects and custom dropdowns
  let selectedArmyId = '';
  if (armySelect) {
    selectedArmyId = armySelect.value;
  } else {
    const dropdownId = playerId === 'player1' ? 'mpPlayer1ArmyOptions' : 'mpPlayer2ArmyOptions';
    const selectedOpt = document.querySelector(`#${dropdownId} .dropdown-option.selected`);
    selectedArmyId = selectedOpt ? selectedOpt.dataset.value : '';
  }
  
  if (!selectedArmyId) {
    alert('Please select an army first');
    return;
  }
  
  // Add army to player's selection
  if (!gameData.selectedArmies[actualPlayerId]) {
    gameData.selectedArmies[actualPlayerId] = [];
  }
  
  // Check if player already has 5 armies
  if (gameData.selectedArmies[actualPlayerId].length >= 5) {
    alert('You can only select up to 5 armies');
    return;
  }
  
  // Check if army is already selected (check by army ID, not army object)
  console.log('Checking if army already selected:', selectedArmyId);
  console.log('Current armies for player', actualPlayerId, ':', gameData.selectedArmies[actualPlayerId]);
  
  const alreadySelected = gameData.selectedArmies[actualPlayerId].some(army => String(army.id) === String(selectedArmyId));
  if (alreadySelected) {
    alert('Army already selected');
    return;
  }
  
  // Add the army
  const armyToAdd = getArmyById(selectedArmyId);
  if (armyToAdd) {
    gameData.selectedArmies[actualPlayerId].push(armyToAdd);
    updateSelectedArmiesListMP(`mp-${playerId}`);
    
    // Notify server about army selection
    if (socket && isMultiplayerMode) {
      socket.emit('playerArmySelected', {
        lobbyCode: lobbyCode,
        playerId: myPlayerId,
        armyId: selectedArmyId,
        armyData: armyToAdd // Include the full army data
      });
      
      // Update army selection status (player has selected at least one army)
      updateArmySelectionStatus(myPlayerId, true);
    }
  }
  
  armySelect.value = '';
}

// Update selected armies list for multiplayer (with mp- prefix)
function updateSelectedArmiesListMP(playerId) {
  const container = document.getElementById(`${playerId}-selected-armies`);
  if (!container) {
    console.log('Container not found for:', playerId);
    return;
  }
  
  // Extract the actual player ID (remove mp- prefix)
  let actualPlayerId = playerId.replace('mp-', '');
  
  // Map player1/player2 to actual player IDs
  if (actualPlayerId === 'player1') {
    actualPlayerId = multiplayerGameData?.players[0]?.id;
  } else if (actualPlayerId === 'player2') {
    actualPlayerId = multiplayerGameData?.players[1]?.id;
  }
  
  const selectedArmies = gameData.selectedArmies[actualPlayerId];
  
  if (!selectedArmies || selectedArmies.length === 0) {
    container.innerHTML = '<div class="no-armies-message">No armies selected. Click "Add Army" to select armies for battle.</div>';
    return;
  }
  
  container.innerHTML = '';
  
  selectedArmies.forEach(army => {
    const armyDiv = document.createElement('div');
    armyDiv.className = 'selected-army-item';
    
    // Calculate army composition
    const unitTypes = {};
    if (army.units && army.units.length > 0) {
      army.units.forEach(unit => {
        unitTypes[unit.type] = (unitTypes[unit.type] || 0) + 1;
      });
    }
    
    const compositionText = Object.entries(unitTypes)
      .map(([type, count]) => `${count} ${formatUnitType(type)}`)
      .join(', ');
    
    armyDiv.innerHTML = `
      <div class="selected-army-info">
        <div class="selected-army-name">${army.name}</div>
        <div class="selected-army-composition">${army.units ? army.units.length : 0} units: ${compositionText || 'Default units'}</div>
      </div>
      <button class="small-button delete" onclick="removeArmyFromPlayerMP('${actualPlayerId}', '${army.id}')">Remove</button>
    `;
    
    container.appendChild(armyDiv);
  });
  
  // Add army limit indicator
  const limitDiv = document.createElement('div');
  limitDiv.className = 'army-limit-indicator';
  limitDiv.textContent = `${selectedArmies.length}/5 armies selected`;
  container.appendChild(limitDiv);
}

// Remove army from player (multiplayer version)
function removeArmyFromPlayerMP(playerId, armyId) {
  // Determine if playerId is already an actual player ID or needs mapping
  let actualPlayerId = playerId;
  let displayPlayerId = playerId;
  
  // Check if this is an actual player ID (socket ID) or needs mapping
  const player1Id = multiplayerGameData?.players[0]?.id;
  const player2Id = multiplayerGameData?.players[1]?.id;
  
  if (playerId === player1Id) {
    // It's already an actual player ID, use it directly
    actualPlayerId = playerId;
    displayPlayerId = 'player1';
  } else if (playerId === player2Id) {
    // It's already an actual player ID, use it directly
    actualPlayerId = playerId;
    displayPlayerId = 'player2';
  } else if (playerId === 'player1') {
    // It's a display ID, map to actual ID
    actualPlayerId = player1Id;
    displayPlayerId = 'player1';
  } else if (playerId === 'player2') {
    // It's a display ID, map to actual ID
    actualPlayerId = player2Id;
    displayPlayerId = 'player2';
  }
  
  console.log(' Removing army:', { playerId, actualPlayerId, displayPlayerId, armyId });
  
  if (!gameData.selectedArmies[actualPlayerId]) {
    console.log(' No armies found for player:', actualPlayerId);
    return;
  }
  
  const beforeCount = gameData.selectedArmies[actualPlayerId].length;
  gameData.selectedArmies[actualPlayerId] = gameData.selectedArmies[actualPlayerId].filter(army => String(army.id) !== String(armyId));
  const afterCount = gameData.selectedArmies[actualPlayerId].length;
  
  console.log(' Army removal result:', { beforeCount, afterCount, armyId });
  
  // Update the display using the display player ID
  updateSelectedArmiesListMP(`mp-${displayPlayerId}`);
  
  // Check if player has any armies left after removal
  const hasArmiesLeft = gameData.selectedArmies[actualPlayerId].length > 0;
  
  // Notify server about army removal to update opponent's display and status
  if (isMultiplayerMode && socket) {
    console.log(' Army removed, checking if player has armies left:', hasArmiesLeft);
    
    // Notify server about army removal to update opponent's display
    console.log(' Notifying server about army removal for opponent display update');
    const removeData = {
      lobbyCode: lobbyCode,
      playerId: actualPlayerId, // Use the actual player ID, not myPlayerId
      armyId: armyId,
      action: 'remove' // Indicate this is a removal action
    };
    console.log(' Sending remove data to server:', removeData);
    socket.emit('playerArmySelected', removeData);
  }
}

// Helper function to get army by ID (implement based on your army data)
function getArmyById(armyId) {
  console.log('Getting army by ID:', armyId, 'Type:', typeof armyId);
  console.log('Available custom armies:', gameData.savedArmies);
  
  // Check for default army
  if (armyId === 'default') {
    const defaultArmy = {
      id: 'default',
      name: 'Default Army',
      units: [...defaultUnits, ...gameData.customUnits]
    };
    console.log('Returning default army:', defaultArmy);
    return defaultArmy;
  }
  
  // Check custom armies
  if (gameData.savedArmies && gameData.savedArmies.length > 0) {
    console.log(' Searching for army with ID:', armyId);
    console.log(' Available army IDs:', gameData.savedArmies.map(a => a.id));
    
    gameData.savedArmies.forEach((army, index) => {
      console.log(` Army ${index}: ID=${army.id} (${typeof army.id}), Name=${army.name}`);
    });
    
    // Try both string and number comparison
    let customArmy = gameData.savedArmies.find(army => army.id === armyId);
    if (!customArmy) {
      customArmy = gameData.savedArmies.find(army => army.id == armyId); // Loose comparison
    }
    if (!customArmy) {
      customArmy = gameData.savedArmies.find(army => String(army.id) === String(armyId)); // String comparison
    }
    
    if (customArmy) {
      console.log(' Found custom army:', customArmy);
      // Validate unit structure
      if (customArmy.units && customArmy.units.length > 0) {
        customArmy.units.forEach((unit, index) => {
          console.log(`Unit ${index}:`, unit);
          if (!unit.attack || !unit.defense || !unit.morale) {
            console.warn(` Unit ${index} missing required properties:`, unit);
          }
        });
      }
      return customArmy;
    }
  }
  
  console.log(' Army not found in local savedArmies, checking shared armies...');
  
  // Check if we have shared army data from other players
  if (gameData.sharedArmies && gameData.sharedArmies[armyId]) {
    console.log(' Found army in shared armies:', gameData.sharedArmies[armyId]);
    return gameData.sharedArmies[armyId];
  }
  
  // Fallback to default army if not found
  console.log('Army not found, returning default army');
  return {
    id: 'default',
    name: 'Default Army',
    units: [...defaultUnits, ...gameData.customUnits]
  };
}





// ===== UNIT TESTS FOR ARMY SELECTION SYSTEM =====
function runArmySelectionTests() {
  console.log(' ===== RUNNING ARMY SELECTION SYSTEM TESTS =====');
  
  // Test 1: Check if we're in multiplayer mode
  console.log('\n Test 1: Multiplayer Mode Check');
  console.log('isMultiplayerMode:', isMultiplayerMode);
  console.log('Result:', isMultiplayerMode ? ' PASS' : ' FAIL');
  
  // Test 2: Check socket connection
  console.log('\n Test 2: Socket Connection Check');
  console.log('Socket exists:', !!socket);
  console.log('Socket connected:', socket?.connected);
  console.log('Result:', socket?.connected ? ' PASS' : ' FAIL');
  
  // Test 3: Check lobby data
  console.log('\n Test 3: Lobby Data Check');
  console.log('lobbyCode:', lobbyCode);
  console.log('myPlayerId:', myPlayerId);
  console.log('Result:', lobbyCode && myPlayerId ? ' PASS' : ' FAIL');
  
  // Test 4: Check army selection variables
  console.log('\n Test 4: Army Selection Variables Check');
  console.log('armySelectionStatus:', armySelectionStatus);
  console.log('playerRole:', playerRole);
  console.log('Result:', typeof armySelectionStatus === 'object' ? ' PASS' : ' FAIL');
  
  // Test 5: Check UI elements
  console.log('\n Test 5: UI Elements Check');
  const startBtn = document.getElementById('mp-start-game-btn');
  
  console.log('Start button found:', !!startBtn);
  console.log('Result:', startBtn ? ' PASS' : ' FAIL');
  
  // Test 6: Check current button state
  console.log('\n Test 6: Button State Check');
  if (startBtn) {
    console.log('Start button text:', startBtn.textContent);
    console.log('Start button disabled:', startBtn.disabled);
    console.log('Result:  PASS (Button state logged)');
  } else {
    console.log('Result:  FAIL (No start button found)');
  }
  
  // Test 7: Check if we're on the right screen
  console.log('\n Test 7: Screen Check');
  const gameSetupScreen = document.getElementById('multiplayer-game-setup');
  const isOnGameSetupScreen = gameSetupScreen && gameSetupScreen.classList.contains('active');
  console.log('On game setup screen:', isOnGameSetupScreen);
  console.log('Result:', isOnGameSetupScreen ? ' PASS' : ' FAIL');
  
  // Test 8: Simulate army selection (without actually selecting)
  console.log('\n Test 8: Army Selection Simulation');
  console.log('Current armySelectionStatus:', armySelectionStatus);
  console.log('Would update to:', { ...armySelectionStatus, [myPlayerId]: true });
  console.log('Would emit data:', {
    lobbyCode: lobbyCode,
    playerId: myPlayerId,
    armySelected: true
  });
  console.log('Result:  PASS (Simulation completed)');
  
  console.log('\n ===== ARMY SELECTION SYSTEM TESTS COMPLETED =====');
  console.log('\n To run these tests again, call: runArmySelectionTests()');
  console.log(' To manually test army selection, call: testArmySelection()');
  console.log(' To manually test army removal, call: testArmyRemoval()');
  console.log(' To manually trigger start button click, call: testStartButtonClick()');
  console.log(' To test if function exists, call: testFunctionExists()');
}

function testFunctionExists() {
  console.log(' ===== TESTING FUNCTION EXISTENCE =====');
  console.log('updateArmySelectionStatus function type:', typeof updateArmySelectionStatus);
  console.log('updateArmySelectionStatus function:', updateArmySelectionStatus);
  console.log('updateStartButtonStatus function type:', typeof updateStartButtonStatus);
  console.log('updateStartButtonStatus function:', updateStartButtonStatus);
  console.log('toggleReady function type:', typeof toggleReady);
  console.log('toggleReady function:', toggleReady);
  
  if (typeof updateArmySelectionStatus === 'function') {
    console.log(' updateArmySelectionStatus function exists and is callable');
  } else {
    console.error(' updateArmySelectionStatus function does not exist or is not callable');
  }
}

function testArmyRemoval() {
  console.log(' ===== TESTING ARMY REMOVAL =====');
  console.log('This will simulate removing an army and check if army selection status updates!');
  
  const beforeState = {
    armySelectionStatus: { ...armySelectionStatus },
    buttonText: document.getElementById('mp-start-game-btn')?.textContent,
    buttonDisabled: document.getElementById('mp-start-game-btn')?.disabled,
    currentArmies: gameData.selectedArmies[myPlayerId]?.length || 0
  };
  
  console.log(' Before army removal:', beforeState);
  
  // Simulate removing an army (if the player has any)
  if (gameData.selectedArmies[myPlayerId] && gameData.selectedArmies[myPlayerId].length > 0) {
    const armyToRemove = gameData.selectedArmies[myPlayerId][0];
    console.log(' Removing army:', armyToRemove);
    removeArmyFromPlayerMP(myPlayerId, armyToRemove.id);
  } else {
    console.log(' No armies to remove, simulating army removal logic');
    // Simulate the logic without actually removing
    const hasArmiesLeft = false;
    updateArmySelectionStatus(myPlayerId, hasArmiesLeft);
  }
  
  // Wait a moment then check the after state
  setTimeout(() => {
    const afterState = {
      armySelectionStatus: { ...armySelectionStatus },
      buttonText: document.getElementById('mp-start-game-btn')?.textContent,
      buttonDisabled: document.getElementById('mp-start-game-btn')?.disabled,
      currentArmies: gameData.selectedArmies[myPlayerId]?.length || 0
    };
    
    console.log(' After army removal:', afterState);
    console.log(' Army removal test completed!');
  }, 100);
}

function testStartButtonClick() {
  console.log(' ===== TESTING START BUTTON CLICK =====');
  
    const startBtn = document.getElementById('mp-start-game-btn');
  if (startBtn) {
    console.log(' Found start button, clicking it...');
    console.log(' Button onclick attribute:', startBtn.getAttribute('onclick'));
    console.log(' startMultiplayerGame function exists:', typeof startMultiplayerGame);
    
    // Test if we can call the function directly
    console.log(' Testing direct function call...');
    try {
      startMultiplayerGame();
      console.log(' Direct function call successful');
    } catch (error) {
      console.error(' Direct function call failed:', error);
    }
    
    // Now try the button click
    console.log(' Now trying button click...');
    startBtn.click();
    } else {
    console.error(' Start button not found!');
  }
}

function testArmySelection() {
  console.log(' ===== TESTING ARMY SELECTION =====');
  console.log('This will actually update the army selection status!');
  
  const beforeState = {
    armySelectionStatus: { ...armySelectionStatus },
    buttonText: document.getElementById('mp-start-game-btn')?.textContent,
    buttonDisabled: document.getElementById('mp-start-game-btn')?.disabled
  };
  
  console.log(' Before army selection:', beforeState);
  
  // Call the actual army selection function
  updateArmySelectionStatus(myPlayerId, true);
  
  // Wait a moment then check the after state
  setTimeout(() => {
    const afterState = {
      armySelectionStatus: { ...armySelectionStatus },
      buttonText: document.getElementById('mp-start-game-btn')?.textContent,
      buttonDisabled: document.getElementById('mp-start-game-btn')?.disabled
    };
    
    console.log(' After army selection:', afterState);
    console.log(' Army selection test completed!');
  }, 100);
}

// Update opponent armies display
function updateOpponentArmiesDisplay(data) {
  console.log(' ===== UPDATE OPPONENT ARMIES DISPLAY =====');
  console.log(' Received data:', data);
  
  const opponentDisplay = document.getElementById('mp-opponent-armies-display');
  if (!opponentDisplay) {
    console.error(' Opponent display element not found!');
    return;
  }
  console.log(' Found opponent display element');
  
  const { armySelections } = data;
  console.log(' Extracted armySelections:', armySelections);
  console.log(' armySelections type:', typeof armySelections);
  console.log(' armySelections keys:', Object.keys(armySelections || {}));
  
  if (!armySelections) {
    console.error(' No armySelections in data!');
    return;
  }
  console.log(' Army selections from server:', armySelections);
  
  // Determine which player is the opponent based on current player role
  const player1Id = multiplayerGameData?.players[0]?.id;
  const player2Id = multiplayerGameData?.players[1]?.id;
  
  console.log(' Player IDs:');
  console.log('  - Player 1 ID:', player1Id);
  console.log('  - Player 2 ID:', player2Id);
  console.log('  - My Player ID:', myPlayerId);
  
  let opponentArmies = [];
  let opponentName = '';
  
  if (myPlayerId === player1Id) {
    // I'm player 1, opponent is player 2
    opponentArmies = armySelections.player2 || [];
    opponentName = multiplayerGameData?.players[1]?.name || 'Opponent';
    console.log(' I am Player 1, opponent is Player 2');
  } else if (myPlayerId === player2Id) {
    // I'm player 2, opponent is player 1
    opponentArmies = armySelections.player1 || [];
    opponentName = multiplayerGameData?.players[0]?.name || 'Opponent';
    console.log(' I am Player 2, opponent is Player 1');
  } else {
    console.error(' Could not determine my player role!');
    return;
  }
  
  console.log(' Opponent armies to display:', opponentArmies);
  console.log(' Opponent name:', opponentName);
  
  if (opponentArmies.length === 0) {
    console.log(' No armies to display, showing waiting message');
    opponentDisplay.textContent = `${opponentName} has not selected any armies yet...`;
  } else {
    console.log(' Creating army display for', opponentArmies.length, 'armies');
    // Create detailed army display with units
    let displayHTML = '';
    opponentArmies.forEach((armyId, index) => {
      console.log(` Processing army ${index + 1}:`, armyId);
      
      // Use getArmyById directly since it's working correctly
      const army = getArmyById(armyId);
      console.log(` Army data for ID ${armyId}:`, army);
      
      const armyName = army ? army.name : 'Unknown Army';
      console.log(` Army name: "${armyName}"`);
      
      let unitsText = 'Default units';
      if (army && army.units && army.units.length > 0) {
        const unitNames = army.units.map(unit => unit.name);
        unitsText = unitNames.join(', ');
        console.log(`Unit names:`, unitNames);
      }
      
      const armyHTML = `<div style="margin-bottom: 10px; padding: 8px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
        <strong>${armyName}</strong><br>
        <small>Units: ${unitsText}</small>
      </div>`;
      
      console.log(` Generated HTML for army ${index + 1}:`, armyHTML);
      displayHTML += armyHTML;
    });
    
    console.log(' Final display HTML:', displayHTML);
    console.log(' Setting innerHTML on opponent display element');
    opponentDisplay.innerHTML = displayHTML;
    console.log(' Display updated successfully');
  }
  
  console.log(' ===== UPDATE OPPONENT ARMIES DISPLAY COMPLETED =====');
}

// Update waiting messages based on current state
function updateWaitingMessages() {
  console.log(' ===== UPDATE WAITING MESSAGES =====');
  console.log(' isMultiplayerMode:', isMultiplayerMode);
  console.log(' multiplayerGameData:', multiplayerGameData);
  
  if (!isMultiplayerMode || !multiplayerGameData) {
    console.log(' Not in multiplayer mode or no game data, returning');
    return;
  }
  
  const { players } = multiplayerGameData;
  const myPlayer = players.find(p => p.id === myPlayerId);
  const isHost = players.indexOf(myPlayer) === 0;
  
  console.log(' Players:', players);
  console.log(' My player:', myPlayer);
  console.log(' Is host:', isHost);
  
  const opponentDisplay = document.getElementById('mp-opponent-armies-display');
  if (!opponentDisplay) {
    console.log(' Opponent display element not found');
    return;
  }
  console.log(' Found opponent display element');
  
  // Both players should see opponent's armies, not waiting messages
  const opponent = players.find(p => p.id !== myPlayerId);
  console.log(' Opponent:', opponent);
  
  // Get opponent's armies using actual player IDs
  const player1Id = players[0]?.id;
  const player2Id = players[1]?.id;
  const opponentArmies = (myPlayerId === player1Id) ? 
    gameData.selectedArmies[player2Id] : 
    gameData.selectedArmies[player1Id];
  
  console.log(' Opponent armies from gameData.selectedArmies:', opponentArmies);
  console.log(' gameData.selectedArmies:', gameData.selectedArmies);
  
  if (!opponentArmies || opponentArmies.length === 0) {
    console.log(' No opponent armies found, showing waiting message');
    opponentDisplay.textContent = `${opponent?.name || 'Opponent'} has not selected any armies yet...`;
  } else {
    console.log(' Creating army display for', opponentArmies.length, 'armies');
    // Create detailed army display with units
    let displayHTML = '';
    opponentArmies.forEach((army, index) => {
      console.log(` Processing army ${index + 1}:`, army);
      displayHTML += `<div style="margin-bottom: 10px; padding: 8px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">`;
      displayHTML += `<strong>${army.name}</strong><br>`;
      if (army.units && army.units.length > 0) {
        displayHTML += `<small>Units: ${army.units.map(unit => unit.name).join(', ')}</small>`;
      } else {
        displayHTML += `<small>Default units</small>`;
      }
      displayHTML += `</div>`;
    });
    console.log(' Generated HTML:', displayHTML);
    opponentDisplay.innerHTML = displayHTML;
  }
  
  console.log(' ===== UPDATE WAITING MESSAGES COMPLETED =====');
}

// Initialize multiplayer game
function initializeMultiplayerGame(data) {
  console.log('Initializing multiplayer game with data:', data);
  
  const { gameConfig, players } = data;
  // Ensure multiplayer player list is available for role/turn checks during the game
  try {
    if (players && Array.isArray(players)) {
      multiplayerGameData = { players };
      console.log('Multiplayer player list stored for role checks:', players.map(p => p.id));
    }
  } catch (e) {
    console.warn('Could not store multiplayer player list:', e);
  }
  
  // Store the server's game configuration globally so it can be used by initializeSharedMultiplayerGame
  window.multiplayerGameConfig = gameConfig;
  console.log('Stored multiplayer game config:', window.multiplayerGameConfig);
  
  // Set up game configuration
  gameConfig.player1.name = gameConfig.player1.name;
  gameConfig.player1.color = gameConfig.player1.color;
  gameConfig.player2.name = gameConfig.player2.name;
  gameConfig.player2.color = gameConfig.player2.color;
  gameConfig.opponentType = 'human'; // Always human in multiplayer
  gameConfig.zoneCount = gameConfig.gameSettings.zoneCount;
  gameConfig.winCondition = gameConfig.gameSettings.winCondition;
  gameConfig.startingCP = gameConfig.gameSettings.startingCP;
  gameConfig.terrainType = gameConfig.gameSettings.terrainType;
  gameConfig.gridSize = gameConfig.gameSettings.gridSize;
  // Ensure weather and day/night settings from host are applied
  gameConfig.dayNightCycle = gameConfig.gameSettings.dayNightCycle;
  gameConfig.weatherType = gameConfig.gameSettings.weatherType;
  
  // Set selected armies
  gameData.selectedArmies.player1 = gameConfig.player1.armies || [];
  gameData.selectedArmies.player2 = gameConfig.player2.armies || [];
  
  // Initialize shared game state for multiplayer
  initializeSharedMultiplayerGame();
  
  console.log('Multiplayer game initialized with shared battlefield');
}

// Initialize shared multiplayer game state
function initializeSharedMultiplayerGame() {
  console.log('Initializing shared multiplayer game...');
  
  // Get configuration with safe defaults
  gameConfig.player1.name = document.getElementById('mp-player1-name')?.value || 'Red Commander';
  gameConfig.player1.color = document.getElementById('mp-player1-color-display')?.style.getPropertyValue('--color-value') || '#DC143C';
  gameConfig.player1.role = 'attacker';
  gameConfig.player2.name = document.getElementById('mp-player2-name')?.value || 'Blue Commander';
  gameConfig.player2.color = document.getElementById('mp-player2-color-display')?.style.getPropertyValue('--color-value') || '#4169E1';
  gameConfig.opponentType = 'human';
  gameConfig.aiCommandPoints = 4;
  
  // Use the game settings that were passed from the server (from the host's configuration)
  // This ensures all players use the same settings that the host configured
    if (window.multiplayerGameConfig) {
    console.log('Using multiplayer game config from server:', window.multiplayerGameConfig);
    gameConfig.zoneCount = window.multiplayerGameConfig.gameSettings.zoneCount;
    gameConfig.winCondition = window.multiplayerGameConfig.gameSettings.winCondition;
    gameConfig.player1CP = window.multiplayerGameConfig.gameSettings.player1CP;
    gameConfig.player2CP = window.multiplayerGameConfig.gameSettings.player2CP;
      // Keep for backward compatibility; per-player build points are authoritative
      gameConfig.buildPoints = window.multiplayerGameConfig.gameSettings.buildPoints;
    
    // For server config, we need to set individual player build points
    // If the server has individual values, use them; otherwise split the single value
    if (window.multiplayerGameConfig.gameSettings.player1BuildPoints && window.multiplayerGameConfig.gameSettings.player2BuildPoints) {
      gameConfig.player1BuildPoints = window.multiplayerGameConfig.gameSettings.player1BuildPoints;
      gameConfig.player2BuildPoints = window.multiplayerGameConfig.gameSettings.player2BuildPoints;
    } else {
      // Fall back to same value for both players if legacy single value exists
      const serverBuildPoints = window.multiplayerGameConfig.gameSettings.buildPoints || 10;
      gameConfig.player1BuildPoints = serverBuildPoints;
      gameConfig.player2BuildPoints = serverBuildPoints;
    }
    
    // Ensure individual player build points are always set
    if (!gameConfig.player1BuildPoints) gameConfig.player1BuildPoints = 10;
    if (!gameConfig.player2BuildPoints) gameConfig.player2BuildPoints = 10;
    
    gameConfig.terrainType = window.multiplayerGameConfig.gameSettings.terrainType;
    gameConfig.gridSize = window.multiplayerGameConfig.gameSettings.gridSize;
      // Apply host-selected weather and day/night cycle
      gameConfig.dayNightCycle = window.multiplayerGameConfig.gameSettings.dayNightCycle || 'day';
      gameConfig.weatherType = window.multiplayerGameConfig.gameSettings.weatherType || 'clear';
    
    // Debug logging for server config build points
    console.log(' [BUILD POINTS DEBUG] Server config build points:');
    console.log('  - Server buildPoints:', window.multiplayerGameConfig.gameSettings.buildPoints);
    console.log('  - Server player1BuildPoints:', window.multiplayerGameConfig.gameSettings.player1BuildPoints);
    console.log('  - Server player2BuildPoints:', window.multiplayerGameConfig.gameSettings.player2BuildPoints);
    console.log('  - Final gameConfig.player1BuildPoints:', gameConfig.player1BuildPoints);
    console.log('  - Final gameConfig.player2BuildPoints:', gameConfig.player2BuildPoints);
  } else {
    // Fallback to DOM values if server config not available
    console.log('No server config available, using DOM values');
    gameConfig.zoneCount = parseInt(document.getElementById('mp-zone-count')?.value || 6);
    // Read from custom dropdowns in MP
    const mpWinOpt = document.querySelector('#mpWinConditionOptions .dropdown-option.selected');
    const mpTerrOpt = document.querySelector('#mpTerrainOptions .dropdown-option.selected');
    const mpDayOpt = document.querySelector('#mpDayNightOptions .dropdown-option.selected') || document.querySelector('#dayNightOptions .dropdown-option.selected');
    const mpWeaOpt = document.querySelector('#mpWeatherOptions .dropdown-option.selected') || document.querySelector('#weatherOptions .dropdown-option.selected');
    gameConfig.winCondition = mpWinOpt ? mpWinOpt.dataset.value : 'dominance';
    gameConfig.terrainType = mpTerrOpt ? mpTerrOpt.dataset.value : 'random';
    gameConfig.dayNightCycle = mpDayOpt ? mpDayOpt.dataset.value : 'day';
    gameConfig.weatherType = mpWeaOpt ? mpWeaOpt.dataset.value : 'clear';
    gameConfig.player1CP = parseInt(document.getElementById('mp-player1-cp')?.value || 3);
    gameConfig.player2CP = parseInt(document.getElementById('mp-player2-cp')?.value || 3);
    // Get individual player build points for multiplayer
    const mpPlayer1BuildPoints = parseInt(document.getElementById('mp-player1-build-points')?.value || 10);
    const mpPlayer2BuildPoints = parseInt(document.getElementById('mp-player2-build-points')?.value || 10);
    gameConfig.player1BuildPoints = mpPlayer1BuildPoints;
    gameConfig.player2BuildPoints = mpPlayer2BuildPoints;
    // Keep single value field in sync for any legacy code paths
    gameConfig.buildPoints = Math.max(mpPlayer1BuildPoints, mpPlayer2BuildPoints);
    
    // Debug logging for multiplayer build points
    console.log(' [BUILD POINTS DEBUG] Multiplayer build points configuration:');
    console.log('  - Player 1 Build Points:', mpPlayer1BuildPoints);
    console.log('  - Player 2 Build Points:', mpPlayer2BuildPoints);
    console.log('  - gameConfig.player1BuildPoints:', gameConfig.player1BuildPoints);
    console.log('  - gameConfig.player2BuildPoints:', gameConfig.player2BuildPoints);
    console.log('  - gameConfig.buildPoints:', gameConfig.buildPoints);
    gameConfig.gridSize = parseInt(document.querySelector('#mp-game-config-section .grid-size-btn.active')?.dataset.size || 6);
  }
  
  // Use lobby code as seed for deterministic terrain generation
  if (lobbyCode) {
    gameConfig.terrainSeed = lobbyCode;
  }
  
  // Set player 2 role as opposite of player 1
  gameConfig.player2.role = gameConfig.player1.role === 'attacker' ? 'defender' : 'attacker';
  
  // Initialize game state
  gameState = {
    currentPlayer: 'red',
    commandPoints: { 
      red: gameConfig.player1CP, 
      blue: gameConfig.player2CP
    },
    buildPoints: { 
      red: gameConfig.player1BuildPoints, 
      blue: gameConfig.player2BuildPoints
    },
    // Weather and Day/Night Cycle system (multiplayer)
    weatherSystem: {
      dayNightCycle: gameConfig.dayNightCycle || 'day',
      weatherType: gameConfig.weatherType || 'clear',
      currentWeather: 'clear', // will be set below
      turnCount: 0
    },
    selectedDice: { attack: 0, defend: 0, morale: 0 },
    turnCount: 0,
    diceAugmented: false,
    currentZone: null,
    gamePhase: 'selection',
    lockedZones: { red: [], blue: [] },
    currentZonePhase: 'defense',
    selectedUnit: null,
    deploymentMode: 'place',
    deployedUnits: { red: [], blue: [] },
    zoneRoles: {},
    unitActions: {},
    zoneNames: {},
    movementMode: {
      active: false,
      selectedUnit: null,
      movementPoints: 0,
      validPositions: []
    },
    // Multi-army system tracking
    unitDeployments: {},
    selectedArmyInZone: { red: null, blue: null },
    armySelectionMode: false,
    // Unit deployment tracking to prevent duplicates across zones
    deployedUnitInstances: {},
    // CP system tracking
    cpCosts: {
      placeUnit: 1,
      moveUnit: 1,
      attack: 1,
      artilleryAttack: 2
    },
    contestedZones: { red: [], blue: [] },
    controlledZones: { red: [], blue: [] },
    // Artillery system
    artillery: {
      red: [],
      blue: []
    },
    // Artillery selection state
    selectedArtillery: null,
    artilleryMode: false,
    // Artillery actions tracking
    artilleryActions: {},
    // Aerial combat system
    aerial: {
      red: [],
      blue: []
    },
    selectedAerial: null,
    aerialMode: false,
    aerialActions: {},
    // AI system state
    aiState: {
      isAITurn: false,
      aiPlayer: null,
      aiThinking: false,
      aiDifficulty: 4
    }
  };
  
  // Debug logging for multiplayer game state build points
  console.log(' [MULTIPLAYER GAME STATE DEBUG] Build points in game state:');
  console.log('  - gameState.buildPoints.red:', gameState.buildPoints.red);
  console.log('  - gameState.buildPoints.blue:', gameState.buildPoints.blue);
  
  // Ensure selected armies are initialized
  if (!gameData.selectedArmies.player1) {
    gameData.selectedArmies.player1 = [];
  }
  if (!gameData.selectedArmies.player2) {
    gameData.selectedArmies.player2 = [];
  }
  
  // Add default armies if none are selected
  if (gameData.selectedArmies.player1.length === 0) {
    gameData.selectedArmies.player1.push({
      id: 'default',
      name: 'Default Army',
      units: [...defaultUnits, ...gameData.customUnits]
    });
  }
  
  if (gameData.selectedArmies.player2.length === 0) {
    gameData.selectedArmies.player2.push({
      id: 'default',
      name: 'Default Army',
      units: [...defaultUnits, ...gameData.customUnits]
    });
  }
  
  // Debug: Log the selected armies to see what's available
  console.log('Player 1 selected armies:', gameData.selectedArmies.player1);
  console.log('Player 2 selected armies:', gameData.selectedArmies.player2);
  
  // Generate battlefield
  generateBattlefield();
  
  // Initialize first weather based on selected type
  if (typeof calculateWeather === 'function' && gameState.weatherSystem) {
    gameState.weatherSystem.currentWeather = calculateWeather();
    updateWeatherDisplay();
    updateGameWeatherDisplay();
  }

  // Update zone display classes
  const battlefield = document.getElementById('battlefield');
  if (battlefield) {
          battlefield.className = 'battlefield';
  }
  
  // Show game screen
  showScreen('game');
  
  // Initialize game
  renderBattlefield();
  
  // Initialize AI system
  initializeAI();
  
  // Log army selections
  const player1ArmyName = gameData.selectedArmies.player1[0]?.name || 'Default Army';
  const player2ArmyName = gameData.selectedArmies.player2[0]?.name || 'Default Army';
  
  logMessage(`${gameConfig.player1.name} (${gameConfig.player1.role.toUpperCase()}) vs ${gameConfig.player2.name} (${gameConfig.player2.role.toUpperCase()}) - Battle begins!`, 'system');
  logMessage(`${gameConfig.player1.name} selected army: ${player1ArmyName}`, 'system');
  logMessage(`${gameConfig.player2.name} selected army: ${player2ArmyName}`, 'system');
  logMessage('Select zones to attack by clicking on them', 'system');
  
  // Send initial game state to other players to ensure synchronization
  if (isMultiplayerMode && !isUpdatingFromServer) {
    setTimeout(() => {
      sendGameStateUpdate();
    }, 100);
  }
  
  // Set up periodic turn validation check for multiplayer
  if (isMultiplayerMode) {
    setInterval(() => {
      disableActionsForNonCurrentPlayer();
    }, 1000); // Check every second
  }
}

// Update multiplayer zone display
function updateMPZoneDisplay() {
  const zoneCount = document.getElementById('mp-zone-count').value;
  document.getElementById('mp-zone-display').textContent = `${zoneCount} Zones`;
}

// Update multiplayer CP display
function updateMPCPDisplay() {
  const cpValue = document.getElementById('mp-starting-cp').value;
  document.getElementById('mp-cp-display').textContent = cpValue;
}

// Setup multiplayer synchronization
function setupMultiplayerSync() {
  if (!isMultiplayerMode || !socket) return;
  
  console.log('Setting up multiplayer synchronization...');
  
  // Listen for game state updates from other players
  socket.on('gameStateUpdate', (data) => {
    console.log('Received game state update:', data);
    updateGameStateFromServer(data);
  });
  
  // Listen for battlefield updates
  socket.on('battlefieldUpdate', (data) => {
    console.log('Received battlefield update:', data);
    updateBattlefieldFromServer(data);
  });
  
  // Listen for zone battle updates
  socket.on('zoneBattleUpdate', (data) => {
    console.log('Received zone battle update:', data);
    updateZoneBattleFromServer(data);
  });
  
  // Listen for turn changes
  socket.on('turnChange', (data) => {
    console.log('Received turn change:', data);
    updateTurnFromServer(data);
  });
  
  // Listen for surrender events
  socket.on('gameSurrender', (data) => {
    console.log(' ===== RECEIVED SURRENDER EVENT =====');
    console.log(' Surrender data received:', data);
    console.log(' Current player role:', getCurrentPlayerRole());
    console.log(' Is multiplayer mode:', isMultiplayerMode);
    handleGameSurrender(data);
    console.log(' ===== SURRENDER EVENT HANDLED =====');
  });
  
  // Listen for army selections cleared events
  socket.on('armySelectionsCleared', (data) => {
    console.log(' ===== ARMY SELECTIONS CLEARED =====');
    console.log(' Army selections cleared data:', data);
    
    // Clear local army selections
    gameData.selectedArmies = { player1: [], player2: [] };
    armySelectionStatus = { player1: false, player2: false };
    
    // Reset UI displays
    updateSelectedArmiesListMP('mp-player1');
    updateSelectedArmiesListMP('mp-player2');
    
    // Clear opponent armies display directly
    const opponentDisplay = document.getElementById('mp-opponent-armies-display');
    if (opponentDisplay && multiplayerGameData) {
      const opponent = multiplayerGameData.players.find(p => p.id !== myPlayerId);
      opponentDisplay.textContent = `${opponent?.name || 'Opponent'} has not selected any armies yet...`;
    }
    
    // Reset army selection dropdowns
    const player1Select = document.getElementById('mp-player1-army-select');
    const player2Select = document.getElementById('mp-player2-army-select');
    if (player1Select) player1Select.value = '';
    if (player2Select) player2Select.value = '';
    
    // Update start button status
    if (playerRole === 'host') {
      updateStartButtonStatus();
    }
    
    console.log(' Army selections cleared and UI updated');
    console.log(' ===== ARMY SELECTIONS CLEARED COMPLETED =====');
  });

  // Listen for new game request events
  socket.on('newGameRequested', (data) => {
    console.log(' ===== NEW GAME REQUESTED =====');
    console.log(' New game requested data:', data);
    
    const { requestingPlayer, pendingRequests, totalPlayers } = data;
    
    // Only update the button for the player who didn't request yet
    // Check if the requesting player is the current player
    const isCurrentPlayerRequesting = requestingPlayer === (multiplayerGameData?.players.find(p => p.id === myPlayerId)?.name);
    
    if (pendingRequests < totalPlayers && !isCurrentPlayerRequesting) {
      console.log(' Updating button for non-requesting player');
      
      // Update the New Game button to show waiting status - try multiple selectors
      let newGameButton = document.querySelector('button[onclick="startNewGame()"]');
      if (!newGameButton) {
        // Try finding by text content
        const buttons = document.querySelectorAll('button');
        for (const button of buttons) {
          if (button.textContent.includes('New Game') || button.textContent.includes('Waiting for opponent')) {
            newGameButton = button;
            break;
          }
        }
      }
      
      if (newGameButton) {
        console.log(' Updating New Game button to show request status');
        newGameButton.textContent = `${requestingPlayer} requested New Game - Click to join`;
        newGameButton.disabled = false;
        newGameButton.style.opacity = '1.0';
        newGameButton.style.cursor = 'pointer';
        newGameButton.onclick = startNewGame; // Ensure onclick is set
      } else {
        console.warn(' Could not find New Game button to update');
      }
      
      // Show a notification message
      const notificationDiv = document.createElement('div');
      notificationDiv.id = 'new-game-notification';
      notificationDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 15px;
        border-radius: 5px;
        z-index: 1000;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        max-width: 300px;
      `;
      notificationDiv.innerHTML = `
        <strong>New Game Request</strong><br>
        ${requestingPlayer} wants to start a new game.<br>
        Click "New Game" to join them.
      `;
      
      // Remove existing notification if any
      const existingNotification = document.getElementById('new-game-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      document.body.appendChild(notificationDiv);
      
      // Auto-remove notification after 10 seconds
      setTimeout(() => {
        const notification = document.getElementById('new-game-notification');
        if (notification) {
          notification.remove();
        }
      }, 10000);
    }
    
    console.log(' New game request notification shown');
    console.log(' ===== NEW GAME REQUESTED COMPLETED =====');
  });

  // Listen for new game started events
  socket.on('newGameStarted', (data) => {
    console.log(' ===== NEW GAME STARTED =====');
    console.log(' New game started data:', data);
    
    // Hide victory overlay if it's showing
    hideVictoryOverlay();
    
    // Reset multiplayer game state but keep connection
    isInGameSetup = true;
    armySelectionStatus = { player1: false, player2: false };
    
    // Clear selected armies
    gameData.selectedArmies = { player1: [], player2: [] };
    
    // Reset game state
    gameState = {
      currentPlayer: 'red',
      commandPoints: { red: 3, blue: 3 },
      selectedDice: { attack: 0, defend: 0, morale: 0 },
      turnCount: 0,
      diceAugmented: false,
      currentZone: null,
      gamePhase: 'selection',
      lockedZones: { red: [], blue: [] },
      currentZonePhase: 'defense',
      selectedUnit: null,
      deploymentMode: 'place',
      deployedUnits: { red: [], blue: [] },
      zoneRoles: {},
      unitActions: {},
      zoneNames: {},
      movementMode: {
        active: false,
        selectedUnit: null,
        movementPoints: 0,
        validPositions: []
      },
      unitDeployments: {},
      selectedArmyInZone: {
        red: null,
        blue: null
      },
      armySelectionMode: false,
      deployedUnitInstances: {},
      artillery: { red: [], blue: [] },
      aerial: { red: [], blue: [] },
      artilleryActions: {},
      aerialActions: {},
      // AI system state
      aiState: {
        isAITurn: false,
        aiPlayer: null,
        aiThinking: false,
        aiDifficulty: 4
      },
      campaignStats: {
        red: {
          unitsDeployed: 0,
          unitsLost: 0,
          unitsLostDetails: [],
          zonesControlled: 0
        },
        blue: {
          unitsDeployed: 0,
          unitsLost: 0,
          unitsLostDetails: [],
          zonesControlled: 0
        }
      }
    };
    
    // Reset zones
    zones.forEach(zone => {
      zone.control = 'contested';
      zone.locked = false;
      for (let pos = 0; pos < gameConfig.gridSize * gameConfig.gridSize; pos++) {
        zone.tacticalGrid[pos].unit = null;
      }
    });
    
    // Reset the New Game button - try multiple selectors
    let newGameButton = document.querySelector('button[onclick="startNewGame()"]');
    if (!newGameButton) {
      // Try alternative selectors
      newGameButton = document.querySelector('button:contains("New Game")');
    }
    if (!newGameButton) {
      // Try finding by text content
      const buttons = document.querySelectorAll('button');
      for (const button of buttons) {
        if (button.textContent.includes('New Game') || button.textContent.includes('Waiting for opponent')) {
          newGameButton = button;
          break;
        }
      }
    }
    
    if (newGameButton) {
      console.log(' Resetting New Game button text and state');
      newGameButton.textContent = 'New Game';
      newGameButton.disabled = false;
      newGameButton.style.opacity = '1.0';
      newGameButton.style.cursor = 'pointer';
      newGameButton.onclick = startNewGame; // Ensure onclick is set
    } else {
      console.warn(' Could not find New Game button to reset');
    }
    
    // Remove any notification
    const notification = document.getElementById('new-game-notification');
    if (notification) {
      notification.remove();
    }
    
    // Go to multiplayer game setup screen
    showScreen('multiplayer-game-setup');
    
    // Reset the setup screen to ensure clean state
    resetMultiplayerGameSetup();
    
    console.log(' Multiplayer game setup screen loaded and reset');
    console.log(' ===== NEW GAME STARTED COMPLETED =====');
  });
  


  // Listen for victory acceptance updates
  socket.on('victoryAcceptanceUpdate', (data) => {
    console.log(' ===== VICTORY ACCEPTANCE UPDATE =====');
    console.log(' Received acceptance update:', data);
    
    const { playerId, accepted, acceptances } = data;
    
    // Update status indicators for all players
    const currentPlayerRole = getCurrentPlayerRole();
    const acceptingPlayerRole = playerId === myPlayerId ? currentPlayerRole : 
                               (currentPlayerRole === 'player1' ? 'player2' : 'player1');
    
    const statusElement = acceptingPlayerRole === 'player1' ? 'player1-status' : 'player2-status';
    
    if (accepted) {
      const statusEl = document.getElementById(statusElement);
      if (statusEl) {
        statusEl.textContent = ' Accepted';
        statusEl.className = 'status-indicator accepted';
      }
    }
    
    console.log(' ===== VICTORY ACCEPTANCE UPDATE COMPLETED =====');
  });

  // Listen for victory accepted (all players accepted)
  socket.on('victoryAccepted', (data) => {
    console.log(' ===== ALL PLAYERS ACCEPTED VICTORY =====');
    console.log(' Received victory accepted:', data);
    
    // Show the summary screen
    if (window.lastVictoryData) {
      const result = `${window.lastVictoryData.result} Wins!`;
      showSummaryScreen(result, window.lastVictoryData.endCondition);
    } else {
      showSummaryScreen('Victory!', 'Victory');
    }
    
    console.log(' ===== PROCEEDING TO SUMMARY SCREEN =====');
  });

  // Listen for game victory events
  socket.on('gameVictory', (data) => {
    console.log(' ===== GAME VICTORY RECEIVED =====');
    console.log(' Game victory data:', data);
    
    const { winner, winnerName, endCondition, gameState: serverGameState } = data;
    
    // Update local game state with server state
    if (serverGameState) {
      gameState = { ...gameState, ...serverGameState };
    }
    
    // Update zones with server state
    if (data.zones) {
      console.log(' Updating zones from server victory data');
      zones.forEach((zone, index) => {
        if (data.zones[index]) {
          zone.control = data.zones[index].control;
          zone.tacticalGrid = data.zones[index].tacticalGrid;
          console.log(` Updated zone ${zone.id} control to ${zone.control}`);
        }
      });
    } else if (serverGameState && serverGameState.zones) {
      console.log(' Updating zones from nested gameState');
      zones.forEach((zone, index) => {
        if (serverGameState.zones[index]) {
          zone.control = serverGameState.zones[index].control;
          zone.tacticalGrid = serverGameState.zones[index].tacticalGrid;
          console.log(` Updated zone ${zone.id} control to ${zone.control}`);
        }
      });
    }
    
    // Render battlefield to show final state
    renderBattlefield();
    
    // Show victory overlay for multiplayer
    const result = `${winnerName} Wins!`;
    console.log(' Showing victory overlay');
    
    const currentPlayerRole = getCurrentPlayerRole();
    const isWinner = (currentPlayerRole === 'player1' && winner === 'red') || 
                   (currentPlayerRole === 'player2' && winner === 'blue');
    
    showVictoryOverlay(isWinner, winnerName, endCondition);
    
    console.log(' ===== GAME VICTORY HANDLED =====');
  });
}



// Victory confirmation overlay functions
function showVictoryOverlay(isWinner, winnerName, endCondition) {
  const overlay = document.getElementById('victory-confirmation-overlay');
  const title = document.getElementById('victory-overlay-title');
  const message = document.getElementById('victory-overlay-message');
  const victoryBtn = document.getElementById('accept-victory-btn');
  const defeatBtn = document.getElementById('accept-defeat-btn');
  const statusIndicators = document.getElementById('player-status-indicators');
  
  if (overlay && title && message && victoryBtn && defeatBtn) {
    title.textContent = isWinner ? 'Victory Achieved!' : 'Defeat Acknowledged';
    message.textContent = isWinner 
      ? `Congratulations! You have achieved ${endCondition}! Your strategic prowess has led you to victory.`
      : `Your opponent has achieved ${endCondition}. Though defeated, your tactical skills were commendable.`;
    
    if (isWinner) {
      victoryBtn.style.display = 'inline-block';
      defeatBtn.style.display = 'none';
    } else {
      victoryBtn.style.display = 'none';
      defeatBtn.style.display = 'inline-block';
    }
    
    // Show status indicators in multiplayer
    if (isMultiplayerMode && statusIndicators) {
      statusIndicators.style.display = 'block';
      
      // Update player names
      const currentPlayerRole = getCurrentPlayerRole();
      const player1Name = currentPlayerRole === 'player1' ? gameConfig.player1.name : gameConfig.player2.name;
      const player2Name = currentPlayerRole === 'player1' ? gameConfig.player2.name : gameConfig.player1.name;
      
      const player1StatusName = document.getElementById('player1-status-name');
      const player2StatusName = document.getElementById('player2-status-name');
      
      if (player1StatusName) player1StatusName.textContent = player1Name;
      if (player2StatusName) player2StatusName.textContent = player2Name;
      
      // Reset status indicators
      const player1Status = document.getElementById('player1-status');
      const player2Status = document.getElementById('player2-status');
      
      if (player1Status) {
        player1Status.textContent = ' Waiting...';
        player1Status.className = 'status-indicator waiting';
      }
      if (player2Status) {
        player2Status.textContent = ' Waiting...';
        player2Status.className = 'status-indicator waiting';
      }
    } else if (statusIndicators) {
      statusIndicators.style.display = 'none';
    }
    
    overlay.style.display = 'flex';
  }
}

function acceptVictoryOverlay() {
  const overlay = document.getElementById('victory-confirmation-overlay');
  const button = document.getElementById('accept-victory-btn');
  
  if (button) {
    button.disabled = true;
    button.textContent = 'Accepted';
  }
  
  // Notify server in multiplayer
  if (isMultiplayerMode) {
    socket.emit('acceptVictory', {
      lobbyCode: lobbyCode,
      playerId: myPlayerId,
      accepted: true
    });
  } else {
    // In single-player, immediately go to summary
    if (overlay) {
      overlay.style.display = 'none';
    }
    showSummaryScreen();
  }
}

function acceptDefeatOverlay() {
  const overlay = document.getElementById('victory-confirmation-overlay');
  const button = document.getElementById('accept-defeat-btn');
  
  if (button) {
    button.disabled = true;
    button.textContent = 'Accepted';
  }
  
  // Notify server in multiplayer
  if (isMultiplayerMode) {
    socket.emit('acceptVictory', {
      lobbyCode: lobbyCode,
      playerId: myPlayerId,
      accepted: true
    });
  } else {
    // In single-player, immediately go to summary
    if (overlay) {
      overlay.style.display = 'none';
    }
    showSummaryScreen();
  }
}

// Function to hide victory overlay
function hideVictoryOverlay() {
  const overlay = document.getElementById('victory-confirmation-overlay');
  if (overlay) {
    overlay.style.display = 'none';
  }
  
  // Reset button states
  const victoryBtn = document.getElementById('accept-victory-btn');
  const defeatBtn = document.getElementById('accept-defeat-btn');
  
  if (victoryBtn) {
    victoryBtn.disabled = false;
    victoryBtn.textContent = 'Accept Victory';
  }
  if (defeatBtn) {
    defeatBtn.disabled = false;
    defeatBtn.textContent = 'Accept Defeat';
  }
}

// Handle game surrender from server
function handleGameSurrender(data) {
  console.log(' ===== HANDLING GAME SURRENDER =====');
  console.log(' Surrender data:', data);
  
  const { surrenderingPlayer, winner, winnerName, gameState: serverGameState } = data;
  
  // Update local game state if provided
  if (serverGameState) {
    gameState = { ...gameState, ...serverGameState };
  }
  
  // Determine the result message
  const currentPlayerRole = getCurrentPlayerRole();
  let resultMessage;
  
  if (currentPlayerRole === surrenderingPlayer) {
    resultMessage = `You surrendered. ${winnerName} wins!`;
  } else {
    resultMessage = `${winnerName} wins! Your opponent surrendered.`;
  }
  
  console.log(' Result message:', resultMessage);
  console.log(' Current player role:', currentPlayerRole);
  console.log(' Surrendering player:', surrenderingPlayer);
  
  // Show the surrender summary screen
  showSummaryScreen(resultMessage, 'Surrender');
  
  console.log(' Surrender handled successfully');
  console.log(' ===== GAME SURRENDER COMPLETED =====');
}

// Flag to prevent recursive updates (declared globally above)

// Update game state from server
function updateGameStateFromServer(data) {
  if (!isMultiplayerMode) return;
  
  isUpdatingFromServer = true;
  
  const { gameState: serverGameState, zones: serverZones } = data;
  
  // Update local game state
  if (serverGameState) {
    gameState = { ...gameState, ...serverGameState };
  }
  
  // Update zones
  if (serverZones) {
    zones = serverZones;
  }
  
  // Re-render the battlefield
  renderBattlefield();
  
  // Sync weather/day-night UI with server state
  updateWeatherDisplay();
  updateGameWeatherDisplay();
  
  // Update UI elements
  updateGameUI();
  
  // Force update turn validation
  disableActionsForNonCurrentPlayer();
  
  isUpdatingFromServer = false;
}

// Update battlefield from server
function updateBattlefieldFromServer(data) {
  if (!isMultiplayerMode) return;
  
  isUpdatingFromServer = true;
  
  const { zones: serverZones, gameState: serverGameState } = data;
  
  if (serverZones) {
    zones = serverZones;
  }
  
  if (serverGameState) {
    gameState = { ...gameState, ...serverGameState };
  }
  
  // Sync weather/day-night UI with server state
  updateWeatherDisplay();
  updateGameWeatherDisplay();
  
  renderBattlefield();
  updateGameUI();
  
  // Force update turn validation
  disableActionsForNonCurrentPlayer();
  
  isUpdatingFromServer = false;
}

  // Update zone battle from server
  function updateZoneBattleFromServer(data) {
  if (!isMultiplayerMode) return;
  
  isUpdatingFromServer = true;
  
    const { currentZoneDetail: serverZoneDetail, gameState: serverGameState } = data;
    
    if (serverZoneDetail) {
      // Update the shared current zone detail view
      currentZoneDetail = serverZoneDetail;
    }
  
  if (serverGameState) {
    gameState = { ...gameState, ...serverGameState };
  }
  
  // Sync weather/day-night UI with server state
  updateWeatherDisplay();
  updateGameWeatherDisplay();
  
  generateMiniBattlefield();
  updateGameUI();
  
  isUpdatingFromServer = false;
}

// Update turn from server
function updateTurnFromServer(data) {
  if (!isMultiplayerMode) return;
  
  isUpdatingFromServer = true;
  
  const { currentPlayer, commandPoints } = data;
  
  if (currentPlayer) {
    gameState.currentPlayer = currentPlayer;
  }
  
  if (commandPoints) {
    gameState.commandPoints = commandPoints;
  }
  
  // Ensure weather/day-night display syncs when turn changes in MP
  updateWeatherDisplay();
  updateGameWeatherDisplay();
  
  updateGameUI();
  renderBattlefield();
  
  // Force update turn validation
  disableActionsForNonCurrentPlayer();
  
  isUpdatingFromServer = false;
}

// Send game state update to server
function sendGameStateUpdate() {
  if (!isMultiplayerMode || !socket) return;
  
  const updateData = {
    lobbyCode: lobbyCode,
    gameState: gameState,
    zones: zones
  };
  
  socket.emit('gameStateUpdate', updateData);
}

// Send battlefield update to server
function sendBattlefieldUpdate() {
  if (!isMultiplayerMode || !socket) return;
  
  const updateData = {
    lobbyCode: lobbyCode,
    zones: zones,
    gameState: gameState
  };
  
  socket.emit('battlefieldUpdate', updateData);
}

// Send zone battle update to server
function sendZoneBattleUpdate() {
  if (!isMultiplayerMode || !socket) return;
  
  const updateData = {
    lobbyCode: lobbyCode,
    currentZoneDetail: currentZoneDetail,
    gameState: gameState
  };
  
  socket.emit('zoneBattleUpdate', updateData);
}

// Send turn change to server
function sendTurnChange() {
  if (!isMultiplayerMode || !socket) return;
  
  const updateData = {
    lobbyCode: lobbyCode,
    currentPlayer: gameState.currentPlayer,
    commandPoints: gameState.commandPoints
  };
  
  socket.emit('turnChange', updateData);
}



// Update game UI elements
function updateGameUI() {
  // Update command points display (top bar and zone detail)
  const topCpEl = document.getElementById('command-points');
  if (topCpEl) {
    topCpEl.textContent = gameState.commandPoints[gameState.currentPlayer];
  }
  const zoneCpEl = document.getElementById('zone-command-points');
  if (zoneCpEl) {
    zoneCpEl.textContent = gameState.commandPoints[gameState.currentPlayer];
  }
  
  // Update current player indicator
  const currentPlayerIndicator = document.getElementById('current-player');
  if (currentPlayerIndicator) {
    currentPlayerIndicator.textContent = gameState.currentPlayer === 'red' ? 
      gameConfig.player1.name : gameConfig.player2.name;
  }
  
  // Update turn counter
  const turnCounter = document.getElementById('turn-counter');
  if (turnCounter) {
    turnCounter.textContent = gameState.turnCount;
  }
  
  // Disable actions for non-current player in multiplayer
  disableActionsForNonCurrentPlayer();
}

// Get current player role in multiplayer
function getCurrentPlayerRole() {
  if (!isMultiplayerMode || !multiplayerGameData) return null;
  
  const { players } = multiplayerGameData;
  const myPlayer = players.find(p => p.id === myPlayerId);
  const isHost = players.indexOf(myPlayer) === 0;
  
  return isHost ? 'player1' : 'player2';
}

// Check if it's the current player's turn in multiplayer
function isMyTurn() {
  if (!isMultiplayerMode) return true; // In single player, always your turn
  
  const playerRole = getCurrentPlayerRole();
  if (!playerRole) return false;
  
  const currentPlayerColor = gameState.currentPlayer;
  const myColor = playerRole === 'player1' ? 'red' : 'blue';
  
  return currentPlayerColor === myColor;
}

// Disable actions for non-current player in multiplayer
function disableActionsForNonCurrentPlayer() {
  if (!isMultiplayerMode) return;
  
  const isMyTurnNow = isMyTurn();
  const battlefield = document.getElementById('battlefield');
  
  console.log('=== TURN VALIDATION ===');
  console.log('Is my turn:', isMyTurnNow);
  console.log('Current player:', gameState.currentPlayer);
  console.log('My role:', getCurrentPlayerRole());
  console.log('My color:', getCurrentPlayerRole() === 'player1' ? 'red' : 'blue');
  
  if (battlefield) {
    if (!isMyTurnNow) {
      battlefield.style.pointerEvents = 'none';
      battlefield.style.opacity = '0.7';
      battlefield.style.cursor = 'none';
      console.log('Actions DISABLED - not my turn');
      // Disable end turn button for non-current player
      const endTurnBtn = document.querySelector('button[onclick="endTurn()"]');
      if (endTurnBtn) {
        endTurnBtn.disabled = true;
        endTurnBtn.style.opacity = '0.5';
      }
    } else {
      battlefield.style.pointerEvents = 'auto';
      battlefield.style.opacity = '1';
      battlefield.style.cursor = 'none';
      console.log('Actions ENABLED - my turn');
      // Enable end turn button for current player
      const endTurnBtn = document.querySelector('button[onclick="endTurn()"]');
      if (endTurnBtn) {
        endTurnBtn.disabled = false;
        endTurnBtn.style.opacity = '1';
      }
    }
  }
  
  // Also disable zone detail actions if in zone battle
  const zoneDetailScreen = document.getElementById('zone-detail');
  if (zoneDetailScreen) {
    if (!isMyTurnNow) {
      zoneDetailScreen.style.pointerEvents = 'none';
      zoneDetailScreen.style.opacity = '0.7';
    } else {
      zoneDetailScreen.style.pointerEvents = 'auto';
      zoneDetailScreen.style.opacity = '1';
    }
  }
  }
  
  // Enhanced Settings Screen Functionality
  function initializeSettingsScreen() {
        // Custom Dropdown Implementation
    const musicDropdown = document.getElementById('musicDropdown');
    const dropdownSelected = document.getElementById('dropdownSelected');
    const dropdownOptions = document.getElementById('dropdownOptions');
    const dropdownOptionElements = document.querySelectorAll('.dropdown-option');
    
    let currentSelectedValue = 'none';
    
    // Toggle dropdown - only initialize once globally
    if (musicDropdown && dropdownSelected && dropdownOptions && !dropdownInitialized) {
      console.log(' Initializing dropdown for the first time...');
      dropdownInitialized = true;
      
      dropdownSelected.addEventListener('click', function() {
        musicDropdown.classList.toggle('open');
        dropdownOptions.classList.toggle('open');
      });
      
      // Handle option selection
      dropdownOptionElements.forEach(option => {
        option.addEventListener('click', function(e) {
          e.stopPropagation();
          
          const value = this.getAttribute('data-value');
          const text = this.textContent;
          
          // Update selected display
          dropdownSelected.textContent = text;
          currentSelectedValue = value;
          
          // Update selected state
          dropdownOptionElements.forEach(opt => opt.classList.remove('selected'));
          this.classList.add('selected');
          
          // Close dropdown
          musicDropdown.classList.remove('open');
          dropdownOptions.classList.remove('open');
          
          // Add selection effect
          dropdownSelected.style.transform = 'scale(1.02)';
          dropdownSelected.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6)';
          
          setTimeout(() => {
            dropdownSelected.style.transform = '';
            dropdownSelected.style.boxShadow = '';
          }, 200);
          
          // Start music loop with selected track
          startMusicLoop(value);
          console.log('Music changed to:', value);
        });
      });
      
      // Close dropdown when clicking outside
      document.addEventListener('click', function(e) {
        if (!musicDropdown.contains(e.target)) {
          musicDropdown.classList.remove('open');
          dropdownOptions.classList.remove('open');
        }
      });
      
      console.log(' Dropdown initialization complete');
    } else if (musicDropdown && dropdownSelected && dropdownOptions) {
      console.log(' Dropdown already initialized, ensuring functionality...');
      
      // Remove any existing event listeners to prevent duplicates
      const newDropdownSelected = dropdownSelected.cloneNode(true);
      dropdownSelected.parentNode.replaceChild(newDropdownSelected, dropdownSelected);
      
      // Re-get the elements after cloning
      const freshDropdownSelected = document.getElementById('dropdownSelected');
      const freshDropdownOptions = document.getElementById('dropdownOptions');
      const freshDropdownOptionElements = document.querySelectorAll('.dropdown-option');
      
      // Re-attach event listeners
      freshDropdownSelected.addEventListener('click', function() {
        musicDropdown.classList.toggle('open');
        freshDropdownOptions.classList.toggle('open');
      });
      
      // Re-attach option event listeners
      freshDropdownOptionElements.forEach(option => {
        option.addEventListener('click', function(e) {
          e.stopPropagation();
          
          const value = this.getAttribute('data-value');
          const text = this.textContent;
          
          // Update selected display
          freshDropdownSelected.textContent = text;
          currentSelectedValue = value;
          
          // Update selected state
          freshDropdownOptionElements.forEach(opt => opt.classList.remove('selected'));
          this.classList.add('selected');
          
          // Close dropdown
          musicDropdown.classList.remove('open');
          freshDropdownOptions.classList.remove('open');
          
          // Add selection effect
          freshDropdownSelected.style.transform = 'scale(1.02)';
          freshDropdownSelected.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.6)';
          
          setTimeout(() => {
            freshDropdownSelected.style.transform = '';
            freshDropdownSelected.style.boxShadow = '';
          }, 200);
          
          // Start music loop with selected track
          startMusicLoop(value);
          console.log('Music changed to:', value);
        });
      });
      
      console.log(' Dropdown functionality restored');
    }
    
    // Volume Control
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    
    if (volumeSlider && volumeValue) {
      // Function to update slider background
      function updateSliderBackground(slider, value) {
        const percentage = value;
        const newBackground = `linear-gradient(to right, 
            rgba(0, 0, 0, 0.9) 0%, 
            rgba(20, 0, 0, 0.8) ${percentage * 0.25}%, 
            rgba(139, 0, 0, 0.7) ${percentage * 0.5}%, 
            rgba(180, 0, 0, 0.6) ${percentage * 0.75}%,
            rgba(220, 20, 60, 0.5) ${percentage}%,
            rgba(60, 60, 60, 0.4) 100%
        )`;
        slider.style.background = newBackground;
      }
      
      // Initialize slider background
      updateSliderBackground(volumeSlider, volumeSlider.value);
      
      // Initialize music volume
      updateMusicVolume(volumeSlider.value);
      
      volumeSlider.addEventListener('input', function() {
        const value = this.value;
        volumeValue.textContent = value + '%';
        
        // Update slider background to show fill
        updateSliderBackground(this, value);
        
        // Update music volume
        updateMusicVolume(value);
        
        // Add pulsing effect on change
        volumeValue.style.transform = 'scale(1.1)';
        volumeValue.style.textShadow = '0 0 15px rgba(255, 68, 68, 0.8)';
        
        setTimeout(() => {
          volumeValue.style.textShadow = '0 0 8px rgba(255, 68, 68, 0.6)';
        }, 150);
      });
    }
    
    // Enhanced Ritual Circle Effects
    const ritualCircles = document.querySelectorAll('.ritual-circle');
    
    ritualCircles.forEach((circle, index) => {
      setInterval(() => {
        if (Math.random() < 0.2) {
          const intensity = Math.random() * 0.5 + 0.5;
          circle.style.borderColor = `rgba(${180 + intensity * 75}, 0, 0, ${0.4 + intensity * 0.4})`;
          circle.style.boxShadow = `0 0 ${20 + intensity * 30}px rgba(255, 0, 0, ${intensity * 0.6})`;
          
          setTimeout(() => {
            circle.style.borderColor = '';
            circle.style.boxShadow = '';
          }, 200 + Math.random() * 300);
        }
      }, 1000 + index * 500);
    });
    
    // Floating Sigil Interaction Effects
    const floatingSigils = document.querySelectorAll('.floating-sigil');
    
    floatingSigils.forEach((sigil, index) => {
      setInterval(() => {
        if (Math.random() < 0.25) {
          const glowIntensity = Math.random() * 0.6 + 0.4;
          sigil.style.filter = `drop-shadow(0 0 ${12 + glowIntensity * 25}px rgba(255, 0, 0, ${glowIntensity}))`;
          sigil.style.transform = `scale(${1 + glowIntensity * 0.2})`;
          
          setTimeout(() => {
            sigil.style.filter = '';
            sigil.style.transform = '';
          }, 300 + Math.random() * 200);
        }
      }, 800 + index * 600);
    });
    
    // Blood Orb Pulsing Effects
    const bloodOrbs = document.querySelectorAll('.blood-orb');
    
    bloodOrbs.forEach((orb, index) => {
      setInterval(() => {
        if (Math.random() < 0.3) {
          const pulseIntensity = Math.random() * 0.5 + 0.5;
          orb.style.transform = `scale(${1 + pulseIntensity * 0.3})`;
          orb.style.opacity = pulseIntensity;
          orb.style.filter = `blur(${1 + pulseIntensity}px)`;
          
          setTimeout(() => {
            orb.style.transform = '';
            orb.style.opacity = '';
            orb.style.filter = '';
          }, 400 + Math.random() * 300);
        }
      }, 1200 + index * 400);
    });
    
    // Settings Panel Flicker Effect
    const settingsPanel = document.querySelector('.settings-panel');
    
    if (settingsPanel) {
      setInterval(() => {
        if (Math.random() < 0.1) {
          settingsPanel.style.opacity = '0.95';
          settingsPanel.style.filter = 'brightness(1.1)';
          
          setTimeout(() => {
            settingsPanel.style.opacity = '';
            settingsPanel.style.filter = '';
          }, 50 + Math.random() * 100);
        }
      }, 500);
    }
  }
  
  // Initialize settings when the screen is shown
  document.addEventListener('DOMContentLoaded', function() {
    initializeSettingsScreen();
  });
  

  
  // Function to play music
  function playMusic(trackId) {
    // Stop current music if playing
    if (currentMusic) {
      currentMusic.pause();
      currentMusic = null;
    }
    
    // If "none" is selected, don't play anything
    if (trackId === 'none' || !musicTracks[trackId]) {
      isMusicLooping = false;
      return;
    }
    
    // Create new audio element
    currentMusic = new Audio(musicTracks[trackId]);
    currentMusic.volume = musicVolume;
    currentMusic.loop = false; // We'll handle looping manually
    
    // Set up event listener for when track ends
    currentMusic.addEventListener('ended', function() {
      if (isMusicLooping && trackId !== 'none') {
        playNextTrack();
      }
    });
    
    // Play the music
    currentMusic.play().catch(error => {
      console.error(' Error playing music:', error);
    });
  }
  
  // Function to play next track in sequence
  function playNextTrack() {
    if (!isMusicLooping) return;
    
    currentTrackIndex = (currentTrackIndex + 1) % trackOrder.length;
    const nextTrackId = trackOrder[currentTrackIndex];
    console.log(' Playing next track:', nextTrackId);
    playMusic(nextTrackId);
  }
  
  // Function to start music loop
  function startMusicLoop(trackId) {
    if (trackId === 'none') {
      isMusicLooping = false;
      return;
    }
    
    isMusicLooping = true;
    currentTrackIndex = trackOrder.indexOf(trackId);
    if (currentTrackIndex === -1) currentTrackIndex = 0;
    
    console.log(' Starting music loop from:', trackId);
    playMusic(trackId);
  }
  

  
  // Function to update music volume
  function updateMusicVolume(volume) {
    musicVolume = volume / 100; // Convert percentage to 0-1 range
    
    if (currentMusic) {
      currentMusic.volume = musicVolume;
    }
  }
  
  // Function to stop music
  function stopMusic() {
    if (currentMusic) {
      currentMusic.pause();
      currentMusic = null;
    }
  }
  
  // Global fallback function to prevent errors
  window.testVolumeSlider = function(value) {
    console.log(' Fallback testVolumeSlider called with:', value);
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    
    if (volumeSlider && volumeValue) {
      volumeSlider.value = value;
      volumeValue.textContent = value + '%';
      
      // Update background
      const percentage = value;
      volumeSlider.style.background = `linear-gradient(to right, 
          rgba(0, 0, 0, 0.9) 0%, 
          rgba(20, 0, 0, 0.8) ${percentage * 0.25}%, 
          rgba(139, 0, 0, 0.7) ${percentage * 0.5}%, 
          rgba(180, 0, 0, 0.6) ${percentage * 0.75}%,
          rgba(220, 20, 60, 0.5) ${percentage}%,
          rgba(60, 60, 60, 0.4) 100%
      )`;
      
      // Update music volume
      updateMusicVolume(value);
      
      console.log(' Fallback function completed');
    } else {
      console.error(' Volume elements not found in fallback function');
    }
  };
  
  // Custom Color Picker Implementation
  class BattleColorPicker {
    constructor() {
      this.canvas = document.getElementById('colorCanvas');
      this.ctx = this.canvas.getContext('2d');
      this.hueSlider = document.getElementById('hueSlider');
      this.hueThumb = document.getElementById('hueThumb');
      this.colorPreview = document.getElementById('colorPreview');
      this.canvasCursor = document.getElementById('canvasCursor');
      this.presetGrid = document.getElementById('presetGrid');
      
      this.currentColor = { r: 255, g: 0, b: 0 };
      this.currentHue = 0;
      this.isDragging = false;
      this.targetColorInput = null;
      
      this.initializeEventListeners();
      this.createPresetColors();
      this.drawColorCanvas();
      this.updateColorPreview();
    }
    
    initializeEventListeners() {
      // Close button
      document.getElementById('closeColorPickerBtn').addEventListener('click', () => {
        this.closeColorPicker();
      });
      
      // Action buttons
      document.getElementById('cancelColorBtn').addEventListener('click', () => {
        this.closeColorPicker();
      });
      
      document.getElementById('applyColorBtn').addEventListener('click', () => {
        this.applyColor();
      });
      
      // Canvas interactions
      this.canvas.addEventListener('mousedown', (e) => {
        this.isDragging = true;
        this.onCanvasClick(e);
      });
      
      this.canvas.addEventListener('mousemove', (e) => {
        if (this.isDragging) {
          this.onCanvasClick(e);
        }
      });
      
      document.addEventListener('mouseup', () => {
        this.isDragging = false;
      });
      
      // Hue slider interactions
      this.hueSlider.addEventListener('mousedown', (e) => this.onHueSliderClick(e));
      
      // RGB input changes
      ['redInput', 'greenInput', 'blueInput'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => this.onRGBInputChange());
      });
      
      // Removed click-outside-to-close functionality - only Cancel button closes the overlay
    }
    
    createPresetColors() {
      const presets = [
        // Battle-themed colors
        '#ff0000', '#cc0000', '#990000', '#660000',
        '#ff3333', '#ff6666', '#ff9999', '#ffcccc',
        '#ff8000', '#ff4400', '#cc3300', '#882200',
        '#ffff00', '#cccc00', '#999900', '#666600',
        '#00ff00', '#00cc00', '#009900', '#006600',
        '#0080ff', '#0066cc', '#004499', '#003366',
        '#8000ff', '#6600cc', '#440099', '#220066',
        '#ff00ff', '#cc00cc', '#990099', '#660066'
      ];
      
      presets.forEach(color => {
        const preset = document.createElement('div');
        preset.className = 'preset-color';
        preset.style.backgroundColor = color;
        preset.addEventListener('click', () => this.selectPresetColor(color, preset));
        this.presetGrid.appendChild(preset);
      });
    }
    
    onCanvasClick(e) {
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      this.selectColorFromCanvas(x, y);
      this.updateCanvasCursor(x, y);
    }
    
    onHueSliderClick(e) {
      const rect = this.hueSlider.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const hue = (y / rect.height) * 360;
      
      this.currentHue = Math.max(0, Math.min(360, hue));
      this.updateHueThumb();
      this.drawColorCanvas();
      this.updateColorFromCurrentPosition();
    }
    
    onRGBInputChange() {
      const r = Math.max(0, Math.min(255, parseInt(document.getElementById('redInput').value) || 0));
      const g = Math.max(0, Math.min(255, parseInt(document.getElementById('greenInput').value) || 0));
      const b = Math.max(0, Math.min(255, parseInt(document.getElementById('blueInput').value) || 0));
      
      this.currentColor = { r, g, b };
      this.updateColorPreview();
      this.updateHueFromRGB();
      this.updatePresetSelection();
    }
    
    selectPresetColor(hex, element) {
      this.setColorFromHex(hex);
      
      // Update preset selection visual
      document.querySelectorAll('.preset-color').forEach(preset => {
        preset.classList.remove('selected');
      });
      element.classList.add('selected');
    }
    
    setColorFromHex(hex) {
      const r = parseInt(hex.substr(1, 2), 16);
      const g = parseInt(hex.substr(3, 2), 16);
      const b = parseInt(hex.substr(5, 2), 16);
      
      this.currentColor = { r, g, b };
      this.updateHueFromRGB();
      this.updateColorPreview();
      this.updateRGBInputs();
      this.drawColorCanvas();
    }
    
    selectColorFromCanvas(x, y) {
      const imageData = this.ctx.getImageData(x, y, 1, 1);
      const data = imageData.data;
      
      this.currentColor = {
        r: data[0],
        g: data[1],
        b: data[2]
      };
      
      this.updateColorPreview();
      this.updateRGBInputs();
      this.updatePresetSelection();
    }
    
    updateColorFromCurrentPosition() {
      // Update color based on current canvas center position
      const centerX = this.canvas.width / 2;
      const centerY = this.canvas.height / 2;
      this.selectColorFromCanvas(centerX, centerY);
    }
    
    updateCanvasCursor(x, y) {
      this.canvasCursor.style.left = x + 'px';
      this.canvasCursor.style.top = y + 'px';
      this.canvasCursor.style.display = 'block';
    }
    
    updateHueThumb() {
      const position = (this.currentHue / 360) * 100;
      this.hueThumb.style.top = position + '%';
    }
    
    updateHueFromRGB() {
      const { r, g, b } = this.currentColor;
      const max = Math.max(r, g, b) / 255;
      const min = Math.min(r, g, b) / 255;
      const delta = max - min;
      
      let hue = 0;
      if (delta !== 0) {
        if (max === r / 255) {
          hue = ((g / 255 - b / 255) / delta) % 6;
        } else if (max === g / 255) {
          hue = (b / 255 - r / 255) / delta + 2;
        } else {
          hue = (r / 255 - g / 255) / delta + 4;
        }
      }
      
      this.currentHue = Math.round(hue * 60);
      if (this.currentHue < 0) this.currentHue += 360;
      
      this.updateHueThumb();
    }
    
    drawColorCanvas() {
      const width = this.canvas.width;
      const height = this.canvas.height;
      
      // Draw saturation-brightness gradient
      const hueColor = this.hslToRgb(this.currentHue / 360, 1, 0.5);
      
      // Create gradients
      const saturationGradient = this.ctx.createLinearGradient(0, 0, width, 0);
      saturationGradient.addColorStop(0, 'white');
      saturationGradient.addColorStop(1, `rgb(${hueColor.r}, ${hueColor.g}, ${hueColor.b})`);
      
      this.ctx.fillStyle = saturationGradient;
      this.ctx.fillRect(0, 0, width, height);
      
      const brightnessGradient = this.ctx.createLinearGradient(0, 0, 0, height);
      brightnessGradient.addColorStop(0, 'transparent');
      brightnessGradient.addColorStop(1, 'black');
      
      this.ctx.fillStyle = brightnessGradient;
      this.ctx.fillRect(0, 0, width, height);
    }
    
    updateColorPreview() {
      const { r, g, b } = this.currentColor;
      const color = `rgb(${r}, ${g}, ${b})`;
      this.colorPreview.style.backgroundColor = color;
    }
    
    updateRGBInputs() {
      document.getElementById('redInput').value = this.currentColor.r;
      document.getElementById('greenInput').value = this.currentColor.g;
      document.getElementById('blueInput').value = this.currentColor.b;
    }
    
    updatePresetSelection() {
      const currentHex = this.rgbToHex(this.currentColor.r, this.currentColor.g, this.currentColor.b);
      
      document.querySelectorAll('.preset-color').forEach(preset => {
        const presetHex = preset.style.backgroundColor;
        if (presetHex && this.rgbToHex(...this.getComputedRGB(presetHex)) === currentHex) {
          preset.classList.add('selected');
        } else {
          preset.classList.remove('selected');
        }
      });
    }
    
    getComputedRGB(color) {
      const div = document.createElement('div');
      div.style.color = color;
      document.body.appendChild(div);
      const computed = window.getComputedStyle(div).color;
      document.body.removeChild(div);
      
      const match = computed.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (match) {
        return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
      }
      return [0, 0, 0];
    }
    
    hslToRgb(h, s, l) {
      let r, g, b;
      
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      
      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
      };
    }
    
    rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }
    
    open(targetColorInput) {
      this.targetColorInput = targetColorInput;
      
      // Get current color from target input
      const colorDisplay = document.getElementById(targetColorInput + '-display');
      if (colorDisplay) {
        const currentColor = colorDisplay.style.getPropertyValue('--color-value') || '#ff0000';
        this.setColorFromHex(currentColor);
      }
      
      // Show overlay
      const overlay = document.getElementById('customColorPickerOverlay');
      overlay.classList.add('active');
      
      // The game's custom cursor system will handle the cursor automatically
      // No need to override it since the game uses document.body.style.cursor = 'none'
      // and has its own custom cursor element
    }
    
    closeColorPicker() {
      document.getElementById('customColorPickerOverlay').classList.remove('active');
      this.targetColorInput = null;
      
      // The game's cursor system will handle the cursor automatically
    }
    
    applyColor() {
      if (this.targetColorInput) {
        const hexColor = this.rgbToHex(this.currentColor.r, this.currentColor.g, this.currentColor.b);
        
        // Update the color display
        const colorDisplay = document.getElementById(this.targetColorInput + '-display');
        if (colorDisplay) {
          colorDisplay.style.setProperty('--color-value', hexColor);
        }
        
        // Call the original update function if it exists
        if (typeof updateColorDisplay === 'function') {
          updateColorDisplay(this.targetColorInput);
        }
        
        // Emit multiplayer event for color changes
        if (this.targetColorInput.startsWith('mp-') && socket && socket.connected && lobbyCode) {
          const field = this.targetColorInput === 'mp-player1-color' ? 'player1Color' : 'player2Color';
          socket.emit('playerNameColorUpdate', {
            lobbyCode: lobbyCode,
            playerId: myPlayerId,
            field: field,
            value: hexColor
          });
        }
        
        // Store the color globally based on the input ID
        if (this.targetColorInput === 'player1-color' || this.targetColorInput === 'mp-player1-color') {
          window.playerColors.player1 = hexColor;
        } else if (this.targetColorInput === 'player2-color' || this.targetColorInput === 'mp-player2-color') {
          window.playerColors.player2 = hexColor;
        }
        
        // Apply colors throughout the game
        console.log(' [COLOR DEBUG] About to call window.applyPlayerColors()');
        window.applyPlayerColors();
        console.log(' [COLOR DEBUG] window.applyPlayerColors() completed');
        
        console.log(' [COLOR DEBUG] Color picker applied:', hexColor, 'to', this.targetColorInput);
      }
      
      this.closeColorPicker();
    }
  }
  
  // Initialize color picker
  let battleColorPicker;
  
  // Global color storage
  window.playerColors = {
    player1: '#DC143C', // Default red
    player2: '#4169E1'  // Default blue
  };
  
  // Function to open custom color picker
  window.openCustomColorPicker = function(colorInputId) {
    if (!battleColorPicker) {
      battleColorPicker = new BattleColorPicker();
    }
    battleColorPicker.open(colorInputId);
  };
  
  // Function to get player color
  window.getPlayerColor = function(playerId) {
    return window.playerColors[playerId] || (playerId === 'player1' ? '#DC143C' : '#4169E1');
  };
  
  // Function to apply colors throughout the game
  window.applyPlayerColors = function() {
    const player1Color = window.playerColors.player1;
    const player2Color = window.playerColors.player2;
    
    console.log(' [COLOR DEBUG] applyPlayerColors called with:', { player1: player1Color, player2: player2Color });
    
    // Update CSS custom properties
    document.documentElement.style.setProperty('--player1-color', player1Color);
    document.documentElement.style.setProperty('--player2-color', player2Color);
    document.documentElement.style.setProperty('--player1-color-rgb', hexToRgb(player1Color));
    document.documentElement.style.setProperty('--player2-color-rgb', hexToRgb(player2Color));
    
    // Update color display buttons
    const player1Display = document.getElementById('player1-color-display');
    const player2Display = document.getElementById('player2-color-display');
    const mpPlayer1Display = document.getElementById('mp-player1-color-display');
    const mpPlayer2Display = document.getElementById('mp-player2-color-display');
    
    if (player1Display) player1Display.style.setProperty('--color-value', player1Color);
    if (player2Display) player2Display.style.setProperty('--color-value', player2Color);
    if (mpPlayer1Display) mpPlayer1Display.style.setProperty('--color-value', player1Color);
    if (mpPlayer2Display) mpPlayer2Display.style.setProperty('--color-value', player2Color);
    
    // Update gameConfig if it exists
    if (typeof gameConfig !== 'undefined') {
      gameConfig.player1.color = player1Color;
      gameConfig.player2.color = player2Color;
      console.log(' [COLOR DEBUG] Updated gameConfig colors');
    }
    
    // Update player color CSS if the function exists
    if (typeof updatePlayerColorCSS === 'function') {
      updatePlayerColorCSS();
      console.log(' [COLOR DEBUG] Called updatePlayerColorCSS');
    }
    
    console.log(' Applied player colors:', { player1: player1Color, player2: player2Color });
  };
  
  // Initialize colors when page loads
  document.addEventListener('DOMContentLoaded', function() {
    console.log('[COLOR SYSTEM] DOM loaded, applying player colors...');
    window.applyPlayerColors();
  });
  

  </script>
  

  
  <!-- Debug Script for Cursor Detection -->
  <script>
  document.addEventListener('mousemove', function(e) {
    const el = document.elementFromPoint(e.clientX, e.clientY);
    if (el) {
      const computedCursor = window.getComputedStyle(el).cursor;
      if (computedCursor === 'crosshair') {
        console.log('CROSSHAIR CURSOR:', el, 'Class:', el.className, 'ID:', el.id);
      }
    }
  });
  </script>
  

  
  <!-- Custom Color Picker Overlay -->
  <div class="custom-color-picker-overlay" id="customColorPickerOverlay">
    <div class="custom-color-picker-container">
      <div class="picker-header">
        <h3 class="picker-title">Select Banner Color</h3>
        <button class="close-btn" id="closeColorPickerBtn"></button>
      </div>
      
      <div class="color-selection-area">
        <div class="color-canvas-container">
          <canvas class="color-canvas" id="colorCanvas" width="300" height="200"></canvas>
          <div class="canvas-cursor" id="canvasCursor"></div>
        </div>
        
        <div class="hue-slider-container">
          <div class="hue-slider" id="hueSlider">
            <div class="slider-thumb" id="hueThumb"></div>
          </div>
          <div class="color-preview" id="colorPreview"></div>
        </div>
      </div>
      
      <div class="preset-colors">
        <div class="preset-label">Battle Presets</div>
        <div class="preset-grid" id="presetGrid">
          <!-- Preset colors will be generated by JavaScript -->
        </div>
      </div>
      
      <div class="color-inputs">
        <div class="input-group">
          <label class="input-label">Red</label>
          <input type="number" class="color-input-field" id="redInput" min="0" max="255" value="255">
        </div>
        <div class="input-group">
          <label class="input-label">Green</label>
          <input type="number" class="color-input-field" id="greenInput" min="0" max="255" value="0">
        </div>
        <div class="input-group">
          <label class="input-label">Blue</label>
          <input type="number" class="color-input-field" id="blueInput" min="0" max="255" value="0">
        </div>
      </div>
      
      <div class="action-buttons">
        <button class="picker-btn" id="cancelColorBtn">Cancel</button>
        <button class="picker-btn picker-btn-primary" id="applyColorBtn">Apply Color</button>
      </div>
    </div>
  </div>
</body>
</html>



